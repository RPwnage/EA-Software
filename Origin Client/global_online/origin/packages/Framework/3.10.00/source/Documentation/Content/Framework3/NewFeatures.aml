<?xml version="1.0" encoding="utf-8"?>
<topic id="3bf1749f-5d82-468d-86b8-a8755a81d1ba" revisionNumber="1">
  <developerConceptualDocument
    xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <autoOutline/>
      <para>Topics in this section describe new features and workflows available in Framework 3</para>
    </introduction>

    <section address="Framework3NewFeaturesAndWorkflows">
      <title>New and modified Features and Workflows</title>
      <content>
        <list class="bullet">
          <listItem>
            <para>
              <legacyBold>Parallel execution and optimization.</legacyBold>
            </para>
            <para>
              NAnt reflection engine is reworked and optimized. It is 2x times faster. In addition it is thread safe and parallel
              execution is used at all stages of nant builds and solution generation. In addition several script tasks were added
              for parallel programming of nant build scripts:
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  <codeInline>&lt;parallel.foreach&gt;</codeInline>  -  concurrently executes foreach loops
                </para>
              </listItem>
              <listItem>
                <para>
                  <codeInline>&lt;parallel.do&gt;</codeInline>  -  concurrently executes all tasks defined inside &lt;parallel.do&gt; task
                </para>
              </listItem>
              <listItem>
                <para>
                  <codeInline>&lt;namedlock&gt;</codeInline>  -  named (in process) mutex for synchronization in the XML scripts
                </para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Transitive dependencies</legacyBold>
            </para>
            <para>
              Framework now supports transitive dependencies. Any module with link step will collect all dependencies from the sub-tree of its dependents.
              Transitive propagation stops at modules with link step (exes or dlls), Utility, and Make style modules.
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Include directories are not transitively propagated. This is done to avoid bloating of include directories lists which can result in slower builds.
                  And, logically, I think that if package requires headers from another package it means direct interface dependency.
                </para>
              </listItem>
              <listItem>
                <para>
                  Transitive mode is on by default. It can be controlled by nant command line parameter <link xlink:href="3211305e-da2c-4e08-ac9f-bf09384081fc"/> . If needed we could introduce means for more granular control.
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Preprocessor definitions can be exported by a package in Initialize.xml file. Propagation rules are the same as for include directories.</legacyItalic>
                </para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Auto dependencies.</legacyBold>
            </para>
            <para>
              Auto dependencies are automatically converted to usedependencies if module is built as a static library or to builddependencies
              if module is built as a dll or executable.
            </para>
            <para>
              A lot of package build scripts are littered with conditional code to define build or use dependencies based on the module build type.
              Auto dependencies help to keep build scripts simpler and more readable.
            </para>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Identical processing for different types of builds.</legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>Module dependency constraints between packages are respected now in native nant builds the same way they were in Solution generation.</para>
              </listItem>
              <listItem>
                <para>Native nant build only builds referenced modules, not the whole package, again the same way as Visual Studio Solution builds.</para>
              </listItem>
              <listItem>
                <para>
                  Libraries defined in initialize.xml file in “xxx.libs” file set are respected by in solution generation, instead of being ignored.
                  Libraries that are linked automatically through project dependencies are automatically filtered out.
                </para>
              </listItem>
              <listItem>
                <para>There are many other fixes and improvements.</para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Package and Module dependency information is available.</legacyBold>
            </para>
            <para>
              Package/Module dependency information can be printed in text form or as a graph image using standard Framework tasks and targets.
              Framework now creates in memory a build graph that is used in build and solution generation steps.
              Graph data can be printed in text or graph image forms by standard Framework backends.
            </para>
          </listItem>
          <listItem>
            <para>
              <legacyBold>External Visual Studio Projects</legacyBold>
            </para>
            <para>
              External Visual Studio projects can be defined as a Framework <link xlink:href="6e7efae2-2b91-4be3-bade-f98dee8c2a5f">Module</link>.
            </para>
            <para>
              Solution generation targets will include external project into generated solution.
            </para>
            <alert class="note">
              <para>External Visual Studio modules currently do not work in the native nant builds.</para>
            </alert>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Remapping build output</legacyBold>
            </para>
            <para>
              Several nant properties with output directory and name mapping templates are now supported.
              Binaries (exe, dll, lib and others) and generated solution files can be renamed and placed into alternative locations.
              Framework takes care of remapping libraries and assemblies that are defined in the Initialize.xml files and are result of the build.
            </para>
            <para>
              This feature can be handy for arranging prebuilt libraries, for example.
            </para>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Multiple Log and Warnings levels.</legacyBold>
            </para>
            <para>
              There are five logging levels that can be controlled through nant <legacyItalic>–loglevel</legacyItalic> commandline switch:
            </para>
            <list class="nobullet">
              <listItem>
                <para>
                  <legacyItalic>Quiet</legacyItalic> – only errors are printed
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Minimal</legacyItalic> - only errors and warnings are printed
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Normal</legacyItalic> – errors, warnings and status
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Detailed</legacyItalic> – errors, warning, status, info information is printed
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Diagnostic</legacyItalic> -  errors, warning, status, info , and debug information is printed
                </para>
                <para></para>
              </listItem>
            </list>
            <para>
              -verbose nant commandline switch turns on Diagnostic mode.
            </para>
            <alert class="note">
              <para>
                <legacyItalic>Detailed</legacyItalic> outputs build settings and build steps without cluttering output with lots nant internal info.
                This output level is useful for debugging build related problems.
              </para>
              <para>
                <computerOutputInline>nant . . . . -loglevel:Detailed</computerOutputInline>
              </para>
            </alert>
            <para>
              There are also four warnings levels that can be controlled through nant commandline switch:
            </para>
            <list class="nobullet">
              <listItem>
                <para>
                  <legacyItalic>Quiet</legacyItalic> – no warnings are printed
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Normal</legacyItalic> – warnings about situations that could affect build outcome
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Deprecation</legacyItalic> –usage of deprecated eaconfig/nant XML syntax or tasks.
                </para>
              </listItem>
              <listItem>
                <para>
                  <legacyItalic>Advice</legacyItalic> – warnings about inconsistencies /errors in build scripts that unlikely to affect build outcome or that Framework can autocorrect.
                </para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>
              <legacyBold>Package compatibility</legacyBold>
            </para>
            <para>
              Compatibility between package versions and revisions can be declared in the Package <token>ManifestFile</token> file.
              Framework will verify that compatibility requirements are met. For more details see <link xlink:href="b206a438-d1bc-4745-8e7c-6dfce40e8f64">&lt;compatibility&gt; element</link>.
            </para>
          </listItem>
          <listItem>
            <para>
              <legacyBold>copylocal</legacyBold>
            </para>
            <para>
              <newTerm>copylocal</newTerm> flag can now be defined at individual dependency or assembly reference.
              This feature works in both Visual Studio and nant builds.
            </para>
            <para>
              <newTerm>copylocal</newTerm> also works in native code builds.
             </para>
          </listItem>
        </list>
      </content>
    </section>

    <section address="Framework3NewTargets">
      <title>New and modified Targets</title>
      <content>
        <list class="bullet">
          <listItem>
            <para>
              <legacyBold>“sln-taskdef” target.</legacyBold>
            </para>
            <para>
              To make development of the live built custom C# tasks easier Framework provides slndef target that generates Visual Studio solution
              with all tasks defined through &lt;taskdef&gt;
              with source files.  Using &lt;taskdef&gt; should also allow for easy debugging from within nant Visual Studio solution.
            </para>
          </listItem>
          <listItem>
            <para>
              <legacyBold>“buildinfo” target</legacyBold>
            </para>
            <para>
              This target results in full description of each module writen into a separate text file.
              Information includes dependencies, their types, build options, build steps, etc.
            </para>
            <para>
              Like solution generation targets <newTerm>&lt;buildinfo&gt;</newTerm> target will process all configurations
              defined by <newTerm>package.configs</newTerm> property
            </para>
          </listItem>
          <listItem>
            <para>
              <legacyBold>“report-dep-graph” target</legacyBold>
            </para>
            <para>
              Dependency graph for packages and modules can be generated directly from nant.
              There is WritePackageGraphViz task that creates input file for GraphViz.
              Since all dependency information is available in Framework now, writing tasks to output it in different formats is very easy.
            </para>
            <para>
              Here is an example of the dependency graph generated for EAThreadPackage by ‘report-dep-graph’ target:
            </para>
            <mediaLink>
              <image xlink:href="DependencyGraphSample"/>
            </mediaLink>
          </listItem>
          <listItem>
            <para>
              <legacyBold>“override” and "allowoverride" attributes in &lt;target&gt; element</legacyBold>
            </para>
            <para>
              To make target redefinitions easier new attributes  <newTerm>override</newTerm>  and <newTerm>allowoverride</newTerm> were added.
              See <link xlink:href="cdfbe5e1-f530-4559-86ee-79a0fdcea133#TargetDefinition">Target definition</link>.
            </para>
          </listItem>
        </list>
      </content>
    </section>

    <section address="Framework3NewTasksAndFunctions">
      <title>New and modified NAnt Tasks and Functions </title>
      <content>
        <list class="bullet">
          <listItem>
            <para>
              <legacyBold>
                Improved &lt;taskdef&gt; functionality
              </legacyBold>
            </para>
            <list class="bullet">
              <listItem>
                <para>
                  Assembly loading in &lt;taskdef&gt; task is now implemented in two stages: assembly file is read into in-memory byte array and file stream is closed,
                  and then Assembly object is loaded into the application from the byte array. This approach allows to avoid both locking of the assembly file at original
                  location and avoid copying assembly file into temp folder which was causing intermittent problems with Incredibuild.
                </para>
                <para>Taskdef accepts source and reference files as input and can build assembly on the fly before loading it:</para>
                <code language="xml" title=" ">

                  &lt;taskdef assembly="***.dll"&gt;
                      &lt;sources&gt;&lt;/sources&gt;
                      &lt;references&gt;&lt;/references&gt;
                  &lt;/taskdef&gt;

                </code>
                <para>
                  All assembles in the current domain are automatically referenced, there is no need to explicitly reference any NAnt assembles.
                  NAnt does the best effort to eliminate duplicate references before passing reference list to the compiler.
                </para>
                <para>
                  Compilation is done using C# Compiler object instead of invoking compiler executable.
                  It improves compilation time and helps to avoid problems on some Unix like systems where Mono compiler executables can be located at non-standard paths.
                </para>
                <para>
                  <legacyItalic>
                    We encourage to use <link xlink:href="f9f8dce9-4768-7794-2a82-e0affa1821ef">&lt;taskdef&gt;</link>
                    to build all custom tasks live and don’t store precompiled dlls or use explicit &lt;csc&gt; task invocations.
                  </legacyItalic>
                </para>
              </listItem>
            </list>
          </listItem>
          <listItem>
            <para>
              <legacyBold>
                PackageGetMasterversion(string packageName)
              </legacyBold>
            </para>
            <para>Lightweight alternative to &lt;dependent&gt; task to retrieve masterversion of a package</para>
            <code language="xml" title=" ">

              &lt;property name="version" value="@{PackageGetMasterversion('EABase')}"/&gt;
              
            </code>
          </listItem>
          <listItem>
            <para>
              <legacyBold>
                PackageGetMasterDir(string packageName), PackageGetMasterDirOrEmpty(string packageName)
              </legacyBold>
            </para>
            <para>Lightweight alternative to &lt;dependent&gt; task to retrieve package directory</para>
            <code language="xml" title=" ">

              &lt;property name="eabase.dir" value="@{PackageGetMasterDir('EABase')}"/&gt;

            </code>
          </listItem>

        </list>
      </content>
    </section>

    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
