// Copyright (C) 2001-2005 Electronic Arts
//

using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Xml.Serialization;
using System.Collections.Specialized;

using Microsoft.Win32;

using NAnt.Core;
using NAnt.Core.Attributes;
using NAnt.Core.Logging;
using NAnt.Core.Util;
using NAnt.Shared.Properties;
using NAnt.Shared.Util;

namespace EA.FrameworkTasks {
    
    /// <summary>Generates a Visual Studio project file.</summary>
    /// <remarks>
	/// <para>
	/// This task is normally not called by users.  But it is used by the eaconfig 
	/// package's 'nantvcproj' target, which was designed for user convenience.
	/// </para>
	/// <para>
	/// The .vcproj file generated by this task is for use with Visual Studio (VS) .NET. 
	/// The project is actually a "makefile project" which is a generic 
	/// Visual Studio project for launching custom build engines such as NAnt.
	/// mentioned above.
	/// </para>
	/// <para>
	/// The .vcproj properties include VS Configuration and VS platform.
	/// Each of these can be selected via drop-down boxes in VS.
	/// </para>
	/// <para>
	/// The VS Configuration box will contain all NAnt configs.
	/// </para>
	/// <para>
	/// For VS platform, the generated project .vcproj file will default to contain only Win32.
	/// User may override this default and select desired VS platforms by setting the
	/// "nant.configure.generateplatforms" property in NAnt script.
	/// </para>
	/// <br>
	/// Some example values:
	/// "Win32,Xbox,Xenon", "Win32,Xbox", or "Xbox".	
	/// </br>
	/// <para>
	/// Note: Xbox and/or Xenon platforms will be skipped if user PC lacks XDK registry info!
	/// </para>
    /// <para>
    /// Note: The Xbox 360 platform is called Xenon on VS.NET 2003 and Xbox 360 on VS.NET 2005.
    /// For consistency, ${nant.configure.generateplatforms} uses "Xenon" in both cases.
    /// </para>
    /// <para>
	/// Note: VS platform names are case sensitive (i.e. Xbox differs from xbox)
	/// Please consult VisualStudio configuration manager docs if you're in doubt and intend to add
	/// platform names beyond those aforementioned.
	/// </para>
	/// <para>
	/// WARNING:  This task will blindly create a VS Configuration/platform pair for each 
	/// possible combination of NAnt config and desired VS platform(s).
	/// </para>
	/// <br>Example 1:</br>
	/// <br>given: package NAnt configs are gc-sn-debug and gc-sn-release (Gamecube)</br>
	/// <br>given: ${nant.configure.generateplatforms} = "Win32,Xbox,Xenon"</br>
	/// <br>resulting VS combinations:</br>
	/// <br> gc-sn-debug|Win32</br>
	/// <br> gc-sn-debug|Xbox</br>
	/// <br> gc-sn-debug|Xenon</br>
	/// <br> gc-sn-release|Win32</br>
	/// <br> gc-sn-release|Xbox</br>
	/// <br> gc-sn-release|Xenon</br>
	/// <para>
	/// Since Gamecube can be built, but not debugged in VS, 
	/// any of the above 3 gc-sn-debug combinations would suffice since each would
	/// build gc-sn-debug identically using the same nant command line.  
	/// Thus, 2 gc-sn-debug combinations are redundant and can be manually
	/// removed for clarity if desired by editing the .sln file (not .vcproj)
	/// after clicking File->Save All in VS.  Likewise for
	/// gc-sn-release.
	/// </para>
	/// 
	/// <br>Example 2:</br>
	/// <br>given: package NAnt configs are xenon-vc7-debug and xenon-vc7-release</br>
	/// <br>given: ${nant.configure.generateplatforms} = "Win32,Xbox,Xenon"</br>
	/// <br>resulting VS combinations:</br>
	/// <br> xenon-vc7-debug|Win32</br>
	/// <br> xenon-vc7-debug|Xbox</br>
	/// <br> xenon-vc7-debug|Xenon</br>
	/// <br> xenon-vc7-release|Win32</br>
	/// <br> xenon-vc7-release|Xbox</br>
	/// <br> xenon-vc7-release|Xenon</br>
	/// <para>
	/// Since we can build and debug xenon projects in VS, we want to keep
	/// the xenon-vc7-debug|Xenon and xenon-vc7-release|Xenon combinations.
	/// The other combinations are not VS debuggable and can be manually
	/// removed for clarity if desired by editing the .sln file (not .vcproj)
	/// after clicking File->Save All in VS.  
	/// </para>
	/// <para>
	/// When the project is opened in Visual Studio and viewed in Visual 
	/// Studio's Solution Explorer, the entire contents of that packages 
	/// folder will be shown.  The configuration dropdown will be populated 
	/// with the names of all configuration files in that packages config 
	/// folder. Selecting a configuration from this dropdown will switch the 
	/// current configuration. The Build, Rebuild all and Clean command lines 
	/// can be viewed in the project property dialog and will change depending
	/// on which configuration is currently selected.
	/// </para>
	/// <para>
	/// If the package for which the Visual Studio project file is being 
	/// generated for, does not contain a config folder or it's config folder 
	/// is empty, then the resulting project will contain 1 configuration 
	/// called "EmptyConfig" and no configuration will be specified on it's 
	/// command lines.
	/// </para>
	/// <para>
	/// To launch and debug an application that was generated by the project, 
	/// simply launch using the standard Visual Studio keys (ie F5), and when 
	/// prompted specify the executable name. Note: Non-natively supported 
	/// platforms such as PS2 and NGC can obviously only be built but not 
	/// debugged with Visual Studio.
	/// </para>
	/// <para>
	/// The generateproject task supports filesets and it is recommended that 
	/// they be used. If no fileset is specified then the default fileset will 
	/// be used.  The default fileset contains all files in the package 
	/// excluding the build, bin and lib subfolders.  A project with a large 
	/// number of files can take a very long time to load in Visual Studio and
	/// will cause Visual Studio to appear frozen during this time.
	/// </para>
	/// <para>
	/// When using filesets, any files in the set that exist under that 
	/// package's folder will show up in the projects treeview under the 
	/// appropriate subfolders.  If a file in the set is outside of the package
	/// then it will appear under it's full path of folders in the treeview,
	/// as if it were relative to that package.
	/// </para>
	/// <para>
	/// In the resulting .vcproj file, all specified files that were found in
	/// the same location as the .build file or under one of that package's
	/// subfolders, will contain relative paths. Any files that were not in
	/// either of these two locations will be referenced with absolute paths.
	/// </para>
	/// </remarks>
    /// <include file='Examples/GenVSProj/GenVSProj.example' path='example'/>
    [TaskName("generateproject")]
    public class GenerateProjectTask : Task 
    {
        
        static readonly string ProjectExtension = ".vcproj";
        static readonly string BuildDir = "build";
        static readonly string MakeTool = "VCNMakeTool";
        static readonly string DeployToolVC7 = "XboxDeploymentTool";
        static readonly string DeployToolVC8 = "VCX360DeploymentTool";

        FileSet _fileSet = new FileSet();
        bool _useDefaultFileSet = true;
        string _packageName = null;
        string _packageDir = null;
        string _configList = null;
        PropertyDictionary _outputList = null;
		string _masterconfig = null;
		string _versioncontrol = null;
        string _dvdemulationroot = null;
        string _excludefrombuild = "true";
        string _remoteroot = null;
        string _buildfile = null;
        string _version = VisualStudioVersion.v71.ToString();
        StringCollection _platforms = new StringCollection();

        [Serializable()]
        public class PlatformElement 
        {
            public PlatformElement() {
                // used for serailization only
            }

            public PlatformElement(string name) {
                this.Name = name;
            }

            [XmlAttribute("Name")]
            public string Name;
        }

        [Serializable()]
        public class ToolElement
        {
            public ToolElement() {
                // use for serialization only
            }

            public ToolElement(string toolname, string config, string masterconfig, string outputfile, string excludefrombuild, string dvdemulationroot, string remoteroot, string buildfile)
            {   
                string execDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
                string exec = Path.Combine(execDir, "nant.exe");
                Name = toolname;

                if ( toolname.Equals(MakeTool) )
                {
                    if (masterconfig != null)
                    {
                        exec = String.Format("{0} -masterconfigfile:{1}", exec, masterconfig);
                    }
                    if (buildfile != null)
                    {
                        exec = String.Format("{0} -buildfile:{1}", exec, buildfile);
                    }
                    BuildCommandLine =      String.Format("{0} -D:config={1} {2}", exec, config, "build");
                    ReBuildCommandLine =    String.Format("{0} -D:config={1} {2}", exec, config, "clean build");
                    CleanCommandLine =      String.Format("{0} -D:config={1} {2}", exec, config, "clean");
                    Output = outputfile;
                }
                else if ( toolname.Equals(DeployToolVC7) || toolname.Equals(DeployToolVC8) )
                {
                    ExcludedFromBuild = excludefrombuild;
                    if ( dvdemulationroot != null && dvdemulationroot.Length > 0 )
                    {
                        // dvd emulation
                        DeploymentFiles = "$(RemoteRoot)=" + dvdemulationroot;
                        DeploymentType = "1";
                    }
                    else
                    {
                        // copy to hdd
                        RemoteRoot = remoteroot;
                        DeploymentType = "0";
                    }
                }
                
            }

            [XmlAttribute("Name")]
            public string Name;

            [XmlAttribute("BuildCommandLine")]
            public string BuildCommandLine;
            
            [XmlAttribute("ReBuildCommandLine")]
            public string ReBuildCommandLine;
            
            [XmlAttribute("CleanCommandLine")]
            public string CleanCommandLine;

            [XmlAttribute("Output")]
            public string Output;

            [XmlAttribute("ExcludedFromBuild")]
            public string ExcludedFromBuild;

            [XmlAttribute("RemoteRoot")]
            public string RemoteRoot;
            
            [XmlAttribute("DeploymentFiles")]
            public string DeploymentFiles;
            
            [XmlAttribute("DeploymentType")]
            public string DeploymentType;
        }

        [Serializable()]
        public class ConfigurationElement
        {
            public ConfigurationElement() {
                // used for serailization only
            }

            public ConfigurationElement(string config, string projectType, string masterconfig, string outputfile, string excludefrombuild, string dvdemulationroot, string remoteroot, string buildfile) {
                this.Name = String.Format("{0}|{1}", config, projectType);
                
                this.OutputDirectory = Path.Combine(GenerateProjectTask.BuildDir, config);
                this.IntermediateDirectory = Path.Combine(GenerateProjectTask.BuildDir, config);

                Tools.Add(new ToolElement(MakeTool, config, masterconfig, outputfile, excludefrombuild, null, null, buildfile));
                if ( projectType.Equals("Xbox 360") )
                {
                    Tools.Add(new ToolElement(DeployToolVC8, config, masterconfig, null, excludefrombuild, dvdemulationroot, remoteroot, buildfile));
                }
                else if ( projectType.Equals("Xenon") )
                {
                    // vc7
                    Tools.Add(new ToolElement(DeployToolVC7, config, masterconfig, outputfile, excludefrombuild, dvdemulationroot, remoteroot, buildfile));
                }
            }

            [XmlAttribute("Name")]
            public string Name;

            [XmlAttribute("OutputDirectory")]
            public string OutputDirectory;

            [XmlAttribute("IntermediateDirectory")]
            public string IntermediateDirectory;

            [XmlAttribute("ConfigurationType")]
            public int ConfigurationType = 0;

            [XmlElement("Tool", typeof(ToolElement))]
            public ArrayList Tools = new ArrayList();
        }

        [Serializable()]
        public class FileElement        
        {
            public FileElement() {
                // used for serailization only
            }

            public FileElement(string relativePath) {
                this.RelativePath = relativePath;
            }

            [XmlAttribute("RelativePath")]
            public string RelativePath;
        }

        [Serializable()]
        public class FilterElementList : ArrayList 
        {
            public FilterElement Find(string name) {
                foreach(FilterElement element in this) {
                    if (element.Name == name)
                        return element;
                }
                return null;
            }
        }

        [Serializable()]
        public class FilterElement
        {
            public FilterElement() {
                // used for serailization only
            }

            public FilterElement(string name) {
                this.Name = name;
            }

            [XmlAttribute("Name")]
            public string Name;

            [XmlAttribute("Filter")]
            public string Filter = "";

            [XmlElement("Filter", typeof(FilterElement))]
            public FilterElementList Filters = new FilterElementList();

            [XmlElement("File", typeof(FileElement))]
            public ArrayList Files = new ArrayList();
        }
        
        [Serializable()]
        public class FilesElement
        {
            private static readonly char[] PathSeparatorChars = new char [] {
                Path.DirectorySeparatorChar,
                PathNormalizer.AltDirectorySeparatorChar
                //Path.VolumeSeparatorChar
            };

            public FilesElement(){
                // used for serailization only
            }

            public FilesElement(FileSet fileSet) {
            
                foreach(FileItem fileItem in fileSet.FileItems) {
                    
                    string path = PathNormalizer.MakeRelative(fileItem.FileName, fileSet.BaseDirectory);

                    if (Path.IsPathRooted(path)) {
                        string msg = String.Format("Could not make '{0}' relative to '{1}'.", fileItem.FileName, fileSet.BaseDirectory);
                        throw new BuildException(msg);
                    }

                    path = PathNormalizer.Normalize(path, false);
                    string filter = Path.GetDirectoryName(path);

                    if (filter == null || filter == String.Empty) {
                        Files.Add( new FileElement(path) );
                    }
                    else {
                        string[] filters = filter.Split(PathSeparatorChars);
                        FilterElement element = FindAndCreateFilter(0, filters, this.Filters);
                        element.Files.Add( new FileElement(path) );
                    }
                }
            }

            /// <summary>
            /// Recursivly search filters for any child filters; when a filter is not found we create one 
            /// and continue the processing so as to create any of its children until we reach a leaf.
            /// </summary>
            private static FilterElement FindAndCreateFilter(int index, string[] names, FilterElementList filters) {
            
                FilterElement element = filters.Find(names[index]);
                if (element == null) {
                    element = new FilterElement(names[index]);
                    filters.Add(element);
                }

                if (index == names.Length - 1)
                    return element;

                return FindAndCreateFilter(++index, names, element.Filters);
            }

            [XmlElement("Filter", typeof(FilterElement))]
            public FilterElementList Filters = new FilterElementList();
    
            [XmlElement("File", typeof(FileElement))]
            public ArrayList Files = new ArrayList();
        }
            
        [XmlRoot("VisualStudioProject", Namespace="", IsNullable=false)]    
        public class VisualStudioProject
        {
            public VisualStudioProject() {
                // used for serailization only
            }

            public VisualStudioProject(string name, StringCollection platformArray, string[] configs, PropertyDictionary outputs, string masterconfig, string versioncontrol, FileSet fileSet, VisualStudioVersion version, string excludefrombuild, string dvdemulationroot, string remoteroot, string buildfile) {
                this.Name = name;
				this.ProjectGUID = NAnt.Core.Util.Hash.MakeGUIDfromString(name);
				this.Version = version.Version;

                string outputfile = null;
                // initialize platforms
                foreach (string platform in platformArray )
                {
                    Platforms.Add( new PlatformElement( platform ) );

                    // initialize configurations
                    foreach(string config in configs) 
                    {
                        outputfile = outputs[config];
                        if ( outputfile == null )
                            outputfile = String.Empty;
                        Configurations.Add( new ConfigurationElement(config, platform, masterconfig, outputfile, excludefrombuild, dvdemulationroot, remoteroot, buildfile) );
                    }
                }

                // initialize files element
                Files = new FilesElement(fileSet);

				// initialize version control provider
				if (versioncontrol == "Perforce")
				{
					SccProjectName = "Perforce Project";
					SccAuxPath = "";
					SccLocalPath = ".";
					SccProvider = "MSSCCI:Perforce SCM";
				}
            }

            [XmlAttribute("ProjectType")]
            public string ProjectType = "Visual C++";

            [XmlAttribute("Version")]
            public string Version;

            [XmlAttribute("Name")]
            public string Name;

			[XmlAttribute("ProjectGUID")]
			public string ProjectGUID;

			// Version control attributes aren't written out by default, but can be turned on.
			// (Booleans with the same name as a property + "Specified" are automatically recognized
			// by the XML serializer and are used to determine if an element/attribute should be
			// serialized or not)
			[XmlAttribute("SccProjectName")]
			public string SccProjectName = null;
			[XmlIgnore]
			public bool SccProjectNameSpecified = false;

			[XmlAttribute("SccAuxPath")]
			public string SccAuxPath = null;
			[XmlIgnore]
			public bool SccAuxPathSpecified = false;

			[XmlAttribute("SccLocalPath")]
			public string SccLocalPath = null;
			[XmlIgnore]
			public bool SccLocalPathSpecified = false;

			[XmlAttribute("SccProvider")]
			public string SccProvider = null;
			[XmlIgnore]
			public bool SccProviderSpecified = false;
			
			[XmlAttribute("Keyword")]
            public string Keyword = "MakeFileProj";

            [XmlArray("Platforms")]
            [XmlArrayItem("Platform", typeof(PlatformElement))]
            public ArrayList Platforms = new ArrayList();

            [XmlArray("Configurations")]
            [XmlArrayItem("Configuration", typeof(ConfigurationElement))]
            public ArrayList Configurations = new ArrayList();

            [XmlElement("Files", typeof(FilesElement))]
            public FilesElement Files;

            [XmlElement("Globals")]
            public Object Globals = new Object();

            public void Serialize(string fileName)
            {
				// if we should add version control, override
				if (SccProjectName != null)
				{
					SccProjectNameSpecified = true;
				}
				if (SccAuxPath != null)
				{
					SccAuxPathSpecified = true;
				}
				if (SccLocalPath != null)
				{
					SccLocalPathSpecified = true;
				}
				if (SccProvider != null)
				{
					SccProviderSpecified = true;
				}
				XmlSerializer serializer = new XmlSerializer(typeof(VisualStudioProject));
                FileStream fs = new FileStream(fileName, FileMode.Create);
                XmlTextWriter writer = new XmlTextWriter(fs, System.Text.Encoding.UTF8);
                writer.Formatting = Formatting.Indented;
                writer.QuoteChar = '\"';
                XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
                ns.Add("","");
                serializer.Serialize(writer, this, ns);
                writer.Close();
            }
        }

        /// <summary>
        /// The version of the visual studio project. Possible values are: '7.0', '7.1' (default) and '8.0'.
        /// </summary>
        [TaskAttribute("version")]
        [StringValidator(Trim=true)]
        public string Version {
            get { return _version; }
            set { _version = value; }
        }

        /// <summary>
        /// The set of files to add to the project. The BaseDirectory attribute of this FileSet will automatically 
        /// be set to the basedir attribute of the task. The Sort attribute of this FileSet will automatically 
        /// be set to True. All files in this FileSet must be relative to its BaseDirectory.
        /// </summary>
        [FileSet("fileset")]
        public FileSet Files 
        { 
            get { return _fileSet; }
        }
        
        /// <summary>
        /// The name of the visual studio project. Default is the value of ${package.name}.
        /// </summary>
        [TaskAttribute("name", Required=false)]
        public string PackageName 
        {
            get { 
                if (_packageName == null) {
                    _packageName = Project.Properties[PackageProperties.PackageNamePropertyName];
                }
                if (_packageName == null) {
                    throw new BuildException(String.Format("Failed to evaluate {0}", PackageProperties.PackageNamePropertyName));
                }
                return _packageName; 
            }
            set { _packageName = Project.ExpandProperties(value); }
        }

        /// <summary>
        /// The base directory of the visual studio project. Default is the value of ${package.dir}.
        /// </summary>
        [TaskAttribute("basedir", Required=false)]
        public string PackageDir 
        {
            get {
                if (_packageDir == null) {
                    _packageDir = Project.Properties[PackageProperties.PackageDirectoryPropertyName];
                }
                if (_packageDir == null) {
                    throw new BuildException(String.Format("Failed to evaluate {0}", PackageProperties.PackageDirectoryPropertyName));
                }
                return _packageDir; 
            }
            set { 
                _packageDir = Project.ExpandProperties(value); 
                _packageDir = Project.GetFullPath(_packageDir);
            }
        }

		/// <summary>
		/// Location of masterconfig.xml file.  By default this isn't specified, so NAnt looks in the
		/// same directory as the build file.
		/// </summary>
		[TaskAttribute("masterconfig", Required=false)]
		public string MasterConfig
		{
			get { return _masterconfig;  }
			set { _masterconfig = value; }
		}

		/// <summary>
		/// The version control provider to attach the VS project to (optional).  
		/// This currently only supports "Perforce", everything else will default to no SCC information.
		/// </summary>
		[TaskAttribute("versioncontrol", Required=false)]
		public string VersionControl
		{
			get { return _versioncontrol;  }
			set { _versioncontrol = value; }
		}

        /// <summary>
        /// DVD emulation root for Xenon Deployment
        /// </summary>
        [TaskAttribute("dvdemulationroot", Required=false)]
        public string DvdEmulationRoot
        {
            get { return _dvdemulationroot;  }
            set { _dvdemulationroot = value; }
        }

        /// <summary>
        /// Exclude from build. Default is true.
        /// </summary>
        [TaskAttribute("excludefrombuild", Required=false)]
        public string ExcludeFromBuild
        {
            get { return _excludefrombuild;  }
            set { _excludefrombuild = value; }
        }
        
        /// <summary>
        /// Remote root path.
        /// </summary>
        [TaskAttribute("remoteroot", Required=false)]
        public string RemoteRoot
        {
            get { return _remoteroot;  }
            set { _remoteroot = value; }
        }

        /// <summary>
        /// Nant build file for tool project.
        /// </summary>
        [TaskAttribute("buildfile", Required = false)]
        public string BuildFile
        {
            get { return _buildfile; }
            set { _buildfile = value; }
        }


		/// <summary>
        /// The list of configs (whitespace delimited). Default is the value of ${package.configs}
        /// </summary>
        /// <remarks>
        /// If no configs exists a dummy config will be created.
        /// </remarks>
        string[] ConfigList 
        {
            get {
                if (_configList == null) {
                    _configList = Project.Properties[PackageProperties.PackageConfigsPropertyName];
                }
                
                string[] configs = null;
                
                if (_configList == null || _configList == String.Empty) {
                    configs = new string[1];
                    configs[0] = GenerateProjectProperties.DefaultConfig;
                }
                else {
                    configs = _configList.Split(' ');
                }
            
                return configs;
            }
        }

        PropertyDictionary OutputList
        {
            get 
            {
                if (_outputList == null)
                {
                    _outputList = new PropertyDictionary();
                    
                    foreach (string cfg in ConfigList)
                    {
                        _outputList.Add(cfg, Project.Properties[String.Format("nant.configure.{0}.output", cfg)]);
                    }
                }
                return _outputList;
            }
        }

        /// <summary>
        /// Create a log prefix that fits within established guidelines
        /// </summary>
        public override string LogPrefix 
        {
            get {
                string prefix = "[genproj] ";
                return prefix.PadLeft(Log.IndentSize);
            }
        }

        protected override void InitializeTask(XmlNode taskNode) {
            // if no file set specified use default file set
            foreach (XmlNode node in taskNode.ChildNodes) {
                if (node.Name == "fileset") {
                    _useDefaultFileSet = false;
                    break;
                }
            }
        }

        protected override void ExecuteTask() {
            try {
                string fileName = Path.Combine(PackageDir, PackageName) + ProjectExtension;
                Log.WriteLine(LogPrefix+ "Project generated at " + UriFactory.CreateUri(fileName).ToString());
                
                if (_useDefaultFileSet) {
                    Files.Clear();
                    Files.Sort = true;
                    Files.BaseDirectory = PackageDir;
                    Files.Includes.Add(PatternFactory.Instance.CreatePattern("**", PackageDir));
                    Files.Excludes.Add(PatternFactory.Instance.CreatePattern("build\\**", PackageDir));
                    Files.Excludes.Add(PatternFactory.Instance.CreatePattern("bin\\**", PackageDir));
                    Files.Excludes.Add(PatternFactory.Instance.CreatePattern("lib\\**", PackageDir));
                }

                // the filesets basedirectory needs to be equal to the package dir
                Files.BaseDirectory = PackageDir;
                Files.Sort = true; // be nice!
                
                // use of property overrides attribute.
                if (Project.Properties.Contains(GenerateProjectProperties.VisualStudioVersion)) {
                    this.Version = Project.Properties[GenerateProjectProperties.VisualStudioVersion];
                }

                // check what platform user have specified to generate
                if (Project.Properties.Contains(GenerateProjectProperties.GeneratePlatforms))
                {
					string xboxRegKey = string.Format("{0}{1}{2}", "SOFTWARE\\Microsoft\\VisualStudio\\", this.Version, "\\VC\\VC_OBJECTS_PLATFORM_INFO\\Xbox");
					string xenonRegKey = string.Format("{0}{1}{2}", "SOFTWARE\\Microsoft\\VisualStudio\\", this.Version, "\\VC\\VC_OBJECTS_PLATFORM_INFO\\Xenon");
                    string xenonRegKey2005 = string.Format("{0}{1}{2}", "SOFTWARE\\Microsoft\\VisualStudio\\", this.Version, "\\InstalledProducts\\Xbox 360 Extensions for Visual Studio");
                    string platforms = Project.Properties[GenerateProjectProperties.GeneratePlatforms];
                    string delimStr = ";, |/\t";
                    char [] delimiter = delimStr.ToCharArray();

					string[] desiredPlatforms= platforms.Split(delimiter);					
					_platforms.Clear();
					foreach (string platform in desiredPlatforms)
					{
                        if (_version == "7.0" || _version == "7.1")
                        {
                            if (platform == "Xbox" && Registry.LocalMachine.OpenSubKey(xboxRegKey) == null)
                            {
                                Log.WriteLine(LogPrefix + "Xbox platform was skipped since XDK registry entry wasn't found.");
                                continue;							
                            }
                            if (platform == "Xenon" && Registry.LocalMachine.OpenSubKey(xenonRegKey) == null)
                            {
                                Log.WriteLine(LogPrefix + "Xenon platform was skipped since XDK registry entry wasn't found.");
                                continue;							
                            }
                        }
                        else
                        {
                            if (platform == "Xbox")
                            {
                                Log.WriteLineIf(Verbose, LogPrefix + "Xbox platform was skipped since XDK doesn't support VS.NET 2005.");
                                continue;							
                            }
                            if (platform == "Xenon" && Registry.LocalMachine.OpenSubKey(xenonRegKey2005) == null)
                            {
                                Log.WriteLineIf(Verbose, LogPrefix + "Xenon platform was skipped since XDK registry entry wasn't found.");
                                continue;							
                            }
                            // Xenon platform was renamed as Xbox360 in VS.NET 2005 onwards.
                            if (platform == "Xenon")
                            {
                                _platforms.Add("Xbox 360"); // platform variable is read-only.
                                continue;
                            }
                        }

						_platforms.Add(platform);
					}
					if (_platforms.Count < 1)
					{
						Log.WriteLineIf(Verbose, LogPrefix + "Win32 platform now used by default, since SDKs weren't detected for user platforms.");
						_platforms.Add("Win32");
					}                                     
					
				}
                else
                {
                    // by default, platform array is Win32 only
                    _platforms.Add("Win32");
                }
                
                VisualStudioProject project = new VisualStudioProject(
                    this.PackageName,
                    this._platforms,
                    this.ConfigList,
                    this.OutputList,
					this.MasterConfig,
					this.VersionControl,
					this.Files,
                    VisualStudioVersion.Parse(this.Version),
                    this.ExcludeFromBuild,
                    this.DvdEmulationRoot,
                    this.RemoteRoot,
                    this.BuildFile);

                project.Serialize(fileName);

            } catch (Exception e) {
                throw new BuildException(e.Message);
            }
        }
    }
}
