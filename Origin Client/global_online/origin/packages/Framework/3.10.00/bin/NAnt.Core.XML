<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NAnt.Core</name>
    </assembly>
    <members>
        <member name="T:NAnt.Core.ConditionalElement">
            <summary>Models a Conditional NAnt XML element in the build file.</summary>
        </member>
        <member name="T:NAnt.Core.Element">
            <summary>Models a NAnt XML element in the build file.</summary>
            <remarks>
              <para>Automatically validates attributes in the element based on Attribute settings in the derived class.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Element.Initialize(System.Xml.XmlNode)">
            <summary>Performs default initialization.</summary>
            <remarks>
              <para>Derived classes that wish to add custom initialization should override <see cref="M:NAnt.Core.Element.InitializeElement(System.Xml.XmlNode)"/>.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Element.InitializeBuildElement(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>Helper task for manual initialization of a build element.(nested into this element)</summary>
        </member>
        <member name="M:NAnt.Core.Element.InitializeElement(System.Xml.XmlNode)">
            <summary>Allows derived classes to provide extra initialization and validation not covered by the base class.</summary>
            <param name="elementNode">The xml node of the element to use for initialization.</param>
        </member>
        <member name="P:NAnt.Core.Element.Location">
            <summary><see cref="P:NAnt.Core.Element.Location"/> in the build file where the element is defined.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Project">
            <summary>The <see cref="P:NAnt.Core.Element.Project"/> this element belongs to.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Parent">
            <summary>The Parent object. This will be your parent Task, Target, or Project depeding on where the element is defined.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Properties">
            <summary>The properties local to this Element and the project.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Log">
            <summary>The Log instance associated with the project.</summary>
        </member>
        <member name="P:NAnt.Core.ConditionalElement.IfDefined">
            <summary>If true then the target will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.ConditionalElement.UnlessDefined">
            <summary>Opposite of if.  If false then the target will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.ArgumentElement.Value">
            <summary>Text value</summary>
        </member>
        <member name="P:NAnt.Core.ArgumentElement.File">
            <summary>File Path. Relative file path is combined with current project base path.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.BuildElementAttribute">
            <summary>Indicates that field should be treated as an xml element for the task.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.BuildElementAttribute.Initialize">
            <summary>Tasks which set the initialize to false are required to initialize the element themselves.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.ElementNameAttribute">
            <summary>Indicates that class should be treated as a NAnt element.</summary>
            <remarks>
            Attach this attribute to a subclass of Element to have NAnt be able
            to recognize it.  The name should be short but must not confict
            with any other element already in use.
            </remarks>
        </member>
        <member name="P:NAnt.Core.Attributes.ElementNameAttribute.Name">
            <summary>The short name of the task that appears on the xml tags in build files.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.ElementNameAttribute.Mixed">
            <summary>Task xml node may contain combination of nested elements and plain text,
            rather than only nested elements.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.FunctionClassAttribute">
            <summary>
            Indicates that class contains functions.
            </summary>
        </member>
        <member name="T:NAnt.Core.Attributes.FunctionAttribute">
            <summary>
            Indicates that method should be treated as a function.
            </summary>
        </member>
        <member name="T:NAnt.Core.Attributes.Int32ValidatorAttribute">
            <summary>Indicates that field should be able to be converted into a Int32 within the given range.</summary>
        </member>
        <member name="M:NAnt.Core.Attributes.ValidatorAttribute.Validate(System.Object@)">
            <summary>
            Validates the current object and updates it as necessary.
            </summary>
        </member>
        <member name="T:NAnt.Core.Attributes.PropertyAttribute">
            <summary>Indicates that field should be treated as a xml file set for the task.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.StringValidatorAttribute">
            <summary>Validates a string.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.ArgumentSetAttribute">
            <summary>Indicates that field should be treated as a argument set for the task.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.FileSetAttribute">
            <summary>Indicates that field should be treated as a xml file set for the task.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.OptionSetAttribute">
            <summary>Indicates that field should be treated as a xml option set for the task.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.XmlElementAttribute.Mixed">
            <summary>Task xml node may contain combination of nested elements and plain text,
            rather than only nested elements.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.BuildAttributeAttribute">
             <summary>Indicates that field should be treated as a xml attribute for the task.</summary>
             <example>
             Examples of how to specify task attributes
             <code>
             // task XmlType default is string
             [BuildAttribute("out", Required=true)]
             string _out = null; // assign default value here
            
             [BuildAttribute("optimize")]
             // during ExecuteTask you can safely use Convert.ToBoolean(_optimize)
             string _optimize = Boolean.FalseString;
            
             [BuildAttribute("warnlevel")]
             [Int32Validator(0,4)] // limit values to 0-4
             // during ExecuteTask you can safely use Convert.ToInt32(_optimize)
             string _warnlevel = "0";
            
             [FileSet("sources")]
             FileSet _sources = new FileSet();
             </code>
             NOTE: Attribute values must be of type of string if you want
             to be able to have macros.  The field stores the exact value during
             InitializeTask.  Just before ExecuteTask is called NAnt will expand
             all the macros with the current values.
             </example>
        </member>
        <member name="T:NAnt.Core.Attributes.TaskAttributeAttribute">
             <summary>Indicates that field should be treated as a xml attribute for the task.</summary>
             <example>
             Examples of how to specify task attributes
             <code>
             // task XmlType default is string
             [TaskAttribute("out", Required=true)]
             string _out = null; // assign default value here
            
             [TaskAttribute("optimize")]
             // during ExecuteTask you can safely use Convert.ToBoolean(_optimize)
             string _optimize = Boolean.FalseString;
            
             [TaskAttribute("warnlevel")]
             [Int32Validator(0,4)] // limit values to 0-4
             // during ExecuteTask you can safely use Convert.ToInt32(_optimize)
             string _warnlevel = "0";
            
             [FileSet("sources")]
             FileSet _sources = new FileSet();
             </code>
             NOTE: Attribute values must be of type of string if you want
             to be able to have macros.  The field stores the exact value during
             InitializeTask.  Just before ExecuteTask is called NAnt will expand
             all the macros with the current values.
             </example>
        </member>
        <member name="T:NAnt.Core.Attributes.TaskNameAttribute">
            <summary>Indicates that class should be treated as a task.</summary>
            <remarks>
            Attach this attribute to a subclass of Task to have NAnt be able
            to recognize it.  The name should be short but must not confict
            with any other task already in use.
            </remarks>
        </member>
        <member name="P:NAnt.Core.Attributes.TaskNameAttribute.Name">
            <summary>The short name of the task that appears on the xml tags in build files.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.TaskNameAttribute.XmlSchema">
            <summary>This task xml node gets added to list of nestable elements. This bool property
            is equivalent to using XmlSchemaAttribute however using this bool is apparently faster
            than adding multiple attributes to a class</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.TaskNameAttribute.Mixed">
            <summary>Task xml node may contain combination of nested elements and plain text,
            rather than only nested elements.</summary>
        </member>
        <member name="T:NAnt.Core.BuildException">
            <summary>
            Thrown whenever an error occurs during the build.
            </summary>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs a build exception with no descriptive information.
            </summary>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.String,NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs an exception with a descriptive message.
            </summary>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.String,System.Exception,NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs an exception with a descriptive message and an
            instance of the Exception that is the cause of the current Exception.
            </summary>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.String,NAnt.Core.Location,NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs an exception with a descriptive message and location
            in the build file that caused the exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="location">Location in the build file where the exception occured.</param>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.String,NAnt.Core.Location,System.Exception,NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs an exception with the given descriptive message, the
            location in the build file and an instance of the Exception that
            is the cause of the current Exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="location">Location in the build file where the exception occured.</param>
            <param name="e">An instance of Exception that is the cause of the current Exception.</param>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.String,NAnt.Core.Location,System.Exception,System.String,NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs an exception with the given descriptive message, the
            location in the build file and an instance of the Exception that
            is the cause of the current Exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="location">Location in the build file where the exception occured.</param>
            <param name="e">An instance of Exception that is the cause of the current Exception.</param>
            <param name="type">Type of the build exception.</param>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.String,System.String,NAnt.Core.BuildException.StackTraceType)">
            <summary>
            Constructs an exception with the given descriptive message and the
            type of the exception thrown
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="type">Type of the build exception.</param>
        </member>
        <member name="M:NAnt.Core.BuildException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Initializes a new instance of the BuildException class with serialized data.</summary>
        </member>
        <member name="M:NAnt.Core.BuildException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Sets the SerializationInfo object with information about the exception.</summary>
            <param name="info">The object that holds the serialized object data. </param>
            <param name="context">The contextual information about the source or destination. </param>
            <remarks>For more information, see SerializationInfo in the Microsoft documentation.</remarks>
        </member>
        <member name="F:NAnt.Core.ContextCarryingException.CallstackImplicitNamespaces">
            List of Namespaces to be ommitted from the callstack for the sake of simplicity.
        </member>
        <member name="M:NAnt.Core.ContextCarryingException.GetSimpleTypeName(System.Type,System.Collections.Generic.List{System.String})">
            <summary>
            Returns a simplified name for a type.
            </summary>
            <param name="type">The type.</param>
            <param name="implicitNamespaces">NAnt project.</param>
            <returns>The formatted type name.</returns>
        </member>
        <member name="T:NAnt.Core.BuildExceptionStackTraceSaver">
            <summary>
            Proxy exception used to preserve stack trace of orinal BuildException. This exception should be transparent in the output.
            </summary>
        </member>
        <member name="T:NAnt.Core.ExceptionStackTraceSaver">
            <summary>
            Proxy exception used to preserve stack trace of orinal Syatem.Exception. This exception should be transparent in the output.
            </summary>
        </member>
        <member name="T:NAnt.Core.ExpressionException">
            <summary>Thrown whenever an exception is invalid.</summary>
        </member>
        <member name="T:NAnt.Core.Expression">
            <summary>
            This class implements a string expression evaluator.
            </summary>
            <remarks><![CDATA[
            Definitions:
                boolean         ::  true false 
                binary_operator ::  (C operators for LESS LESS_EQUALS GREATER GREATER_EQUALS EQUALS NOT_EQUALS AND OR: stupid X_M_L)
                unary_operator  ::  !
                parentheses:    ::  ( )
                op_char         ::  binary_operator | unary_operator | parentheses
                string          ::  '[any chars]' | 
                                    "[any chars]" | 
                                    `[any chars]` |
                                    [any string of chars that doesn't include an op_char and 
                                    doesn't begin with with a boolean.]
                                    In addition, any of the quote delimited forms can include the quote delimiter
                                    if it is escaped by a backslash '\', (e.g. "this \" has a quote")
                expression      ::  boolean |
                                    string  |
                                    ( expression ) |
                                    unary_operator expression |
                                    expression binary_operator expression
            
            Operator precedence (highest to lowest, those on same lines are equal):
                ()
                NOT
                LESS LESS_EQUALS GREATER GREATER_EQUALS
                EQUALS NOT_EQUALS
                AND
                OR  
            NOTES:
                Strings are Case Sensitive.
                An empty expression or a null expression generates an exception.                    
            ]]>
            </remarks>
            <exception cref="T:NAnt.Core.ExpressionException">Thrown when an illegal expression is input.</exception>
        </member>
        <member name="M:NAnt.Core.Expression.Evaluate(System.String)">
            <summary>Takes in a string expression, parsers and evaluates it down to a single value returned as a bool.</summary>
            <param name="expression">Input expression to evaluate.</param>
            <returns>Boolean value of the expression.</returns>
        </member>
        <member name="M:NAnt.Core.Expression.Operator.RunOperation(System.Collections.Stack)">
            <summary>
            Runs the operation popping required operands from the stack and returning the result to it.
            </summary>
            <param name="stack">Given stack for operands and result.</param>
        </member>
        <member name="P:NAnt.Core.Expression.Operator.Precedence">
            <summary>
            Precendence of the operator, with 0 being the highest.
            </summary>
        </member>
        <member name="T:NAnt.Core.Expression.Lexer">
            <summary>
            Takes an input string expression and returns a queue of string tokens representing the expression.
            </summary>
        </member>
        <member name="M:NAnt.Core.Expression.Lexer.OffsetInfo">
            <summary>
            Outputs some offset info for the exceptions.
            </summary>
            <returns>
            Formatted string that is the expression followed by another line below it which points to 
            the offset with a '^' character.
            </returns>  
        </member>
        <member name="T:NAnt.Core.FileItem">
            <summary>
            A FileItem is a fileset item after its pattern has been expanded
            </summary>
        </member>
        <member name="P:NAnt.Core.FileItem.Index">
            <summary>Internal use only for storage!</summary>
        </member>
        <member name="T:NAnt.Core.FileItemList">
            <summary>
            An array list of file items
            </summary>
        </member>
        <member name="M:NAnt.Core.FileItemList.ToStringCollection">
            <summary>Converts this array of FileItems to a StringCollection of filenames.</summary>
            <remarks>Provided as a convinience for backwards compatability and external libraries.</remarks>
        </member>
        <member name="T:NAnt.Core.FileSetItem">
            <summary>
            A FileSetItem is a fileset item before its pattern has been expanded
            </summary>
        </member>
        <member name="T:NAnt.Core.FileSetItemCollection">
            <summary>
            A collection of FileSetItems
            </summary>
        </member>
        <member name="M:NAnt.Core.FileSetItemCollection.GetMatchingItems(NAnt.Core.FileSetItemCollection,System.Boolean,System.Boolean)">
            <summary>Returns a collection of fileitems which match the set of patterns</summary>
        </member>
        <member name="T:NAnt.Core.FileSetItemCollection.FileItemContainer">
            <summary>
            A specialized container class for optimizing the storage of files.
            A hashtable of linked lists where the key is the basedirectory of the file.
            </summary>
        </member>
        <member name="M:NAnt.Core.FileSet.FindMoreRecentLastWriteTime(System.Collections.Specialized.StringCollection,System.DateTime)">
            <summary>Determines if a file has a more recent last write time than the given time.</summary>
            <param name="fileNames">A collection of filenames to check last write times against.</param>
            <param name="targetLastWriteTime">The datetime to compare against.</param>
            <returns>The name of the first file that has a last write time greater than <c>targetLastWriteTime</c>; otherwise null.</returns>
        </member>
        <member name="M:NAnt.Core.FileSet.InitializeElement(System.Xml.XmlNode)">
            <summary>Optimization. Directly intialize</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.DefaultExcludes">
            <summary>Indicates whether default excludes should be used or not.  Default "false".</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.BaseDirectory">
            <summary>The base of the directory of this file set.  Default is project base directory.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FailOnMissingFile">
            <summary>Indicates if a build error should be raised if an explictly included file does not exist.  Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FromFileSetName">
            <summary>The name of a file set to include.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.Sort">
            <summary>Sort the fileset by filename. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileItems">
            <summary>Collection of file set items that match the file set.</summary>
        </member>
        <member name="T:NAnt.Core.FileSet.FileSetElement">
            <summary>Base class for includes and excludes file set elements.</summary>
        </member>
        <member name="M:NAnt.Core.FileSet.FileSetElement.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly intialize</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.Pattern">
            <summary>The filename or pattern used for file inclusion/exclusion. Default specifies no file.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.OptionSet">
            <summary>
            The name of an optionset to associate with this set of includes or excludes.
            </summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.FromFileSetName">
            <summary>
            The name of a fileset defined by the &lt;fileset&gt; task. This fileset will be used for file inclusion/exclusion. Default is empty.
            </summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.FromFile">
            <summary>The name of a file containing a newline delimited set of files/patterns to include/exclude..</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.AsIs">
            <summary>If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.Force">
            <summary>If true the file name will be added to the file set regardless if it is already included. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.BaseDirectory">
            <summary>The base of the directory of this include pattern. 
            Default is fileset base directory. When 'basedir' is specified here it will be propagated to fileitems.
            Use this attribute to set custo basedir value which is different from the FileSet basedir, 
            In addition to evaluating patterns, basedir is used to set Link elements and file folders in Visual Studio,
            compiler resources, in CopyTask, etc.
            </summary>
        </member>
        <member name="T:NAnt.Core.FileSet.GroupElement">
            <summary>Represents groups of files in a file set.</summary>
        </member>
        <member name="M:NAnt.Core.FileSet.GroupElement.OptimizedInitializeDefaultGroup(System.Xml.XmlNode)">
            <summary>Optimization for default group. Directly intialize</summary>
        </member>
        <member name="T:NAnt.Core.FunctionClassBase">
            <summary>
            Classes which define static methods to be used as nant function must derive from this class.
            </summary>
            <remarks>
            To declare a method as available to be called from within nant you must declare a method in a class where: 
            
            	- the class derives the NAnt.FunctionClassBase abstract class
            	- the class defines a NAnt.Attributes.FunctionClassAttribute attribute
            	- the method defines a NAnt.Attributes.FunctionAttribute attribute
            	- the method is static
            	- the method returns a string
            	- the first parameter of the method is of type NAnt.Project
            	- the remaining parameters are capable of beiing converted from a string to their assigned type
            	
            Function names need not be unique. However, functions are distinguished by name and number of parameters.
            So you may not have two functions with the same name and same number of parameters. Regardless of the types.
            </remarks>
            <example>
            [FunctionClass()]
            public class NantFunctionClass
            {
            	[Function()]
            	public static string Echo(Project project, string s)
            	{
            		return s;
            	}
            	
            	[Function()]
            	public static string Add(Project project, int a, int b)
            	{
            		int sum = a + b;
            		return sum.ToString();
            	}
            }
            </example>
        </member>
        <member name="T:NAnt.Core.Functions.CharacterFunctions">
            <summary>
            Collection of character manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsDigit(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is a decimal digit.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is a decimal digit; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsDigit('5', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsNumber(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized 
            as a decimal digit or hexadecimal number.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is a decimal digit or hexadecimal number; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsNumber('9', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsWhiteSpace(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized 
            as white space.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is white space; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsWhiteSpace(' ', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsLetter(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether a character is categorized as an alphabetic letter.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is an alphabetic character; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsLetter('a', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsLetterOrDigit(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized as an 
            alphabetic character or a decimal digit.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is an alphabetic character or a decimal digit; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsLetterOrDigit('a', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharToLower(NAnt.Core.Project,System.Char)">
            <summary>
            Converts the value of a character to its lowercase equivalent.
            </summary>
            <param name="project"></param>
            <param name="c">The character.</param>
            <returns>The lowercase equivalent of c.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharToLower('A')} == a" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharToUpper(NAnt.Core.Project,System.Char)">
            <summary>
            Converts the value of a character to its uppercase equivalent.
            </summary>
            <param name="project"></param>
            <param name="c">The character.</param>
            <returns>The uppercase equivalent of c.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharToUpper('a')} == A" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsLower(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized as a lowercase letter.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is a lowercase letter; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsLower('a', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsUpper(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized as an uppercase letter.
            </summary>
            <param name="project"></param>
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is an uppercase letter; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{CharIsUpper('A', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.DateTimeFunctions">
            <summary>
            Collection of time and date manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeNow(NAnt.Core.Project)">
            <summary>
            Gets the date and time that is the current local date and time on this computer.
            </summary>
            <param name="project"></param>
            <returns>The current local date and time on this computer.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{DateTimeNow()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeUtcNow(NAnt.Core.Project)">
            <summary>
            Gets the date and time that is the current local date and time on this computer expressed as coordinated universal time (UTC).
            </summary>
            <param name="project"></param>
            <returns>The current local date and time on this computer expressed as UTC.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{DateTimeUtcNow()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeToday(NAnt.Core.Project)">
            <summary>
            Gets the current date.
            </summary>
            <param name="project"></param>
            <returns>The current date and time with the time part set to 00:00:00.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{DateTimeToday()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeDayOfWeek(NAnt.Core.Project)">
            <summary>
            Returns the current day of the week.
            </summary>
            <param name="project"></param>
            <returns>The current day of the week.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message='@{DateTimeDayOfWeek()}' />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeCompare(NAnt.Core.Project,System.DateTime,System.DateTime)">
            <summary>
            Compares two datetime stamps.
            </summary>
            <param name="project"></param>
            <param name="t1">The first datetime stamp.</param>
            <param name="t2">The second datetime stamp.</param>
            <returns>
            	Less than zero - t1 is less than t2.  &lt;br/&gt;
            	Zero - t1 equals t2. &lt;br/&gt;
            	Greater than zero - t1 is greater than t2. &lt;br/&gt;
            </returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="file.txt" />
    <property name='t1' value="@{FileGetLastWriteTime('file.txt')}" />
    <property name='t2' value="@{FileGetLastWriteTime('file.txt')}" />
    
    <fail unless="@{DateTimeCompare('${t1}', '${t2}')} == 0" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.DirectoryFunctions">
            <summary>
            Collection of directory manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryExists(NAnt.Core.Project,System.String)">
            <summary>
            Determines whether the given path refers to an existing directory on disk.
            </summary>
            <param name="project"></param>
            <param name="path">The path to test.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir="foo" />
    <fail unless="@{DirectoryExists('foo')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryIsEmpty(NAnt.Core.Project,System.String)">
            <summary>
            Returns true if the specified directory does not contain any files or directories; otherwise false.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the directory.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir='foo' />
    <fail unless="@{DirectoryIsEmpty('foo')}" 
          message='Directory should have been empty' />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetFileCount(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns the number of files in a specified directory which match the given search pattern.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <returns>Number of files in a specified directory that match the given search pattern.</returns>
            <example>
<code>
<![CDATA[
<project>
    <delete dir="foo" failonerror="false" />
    <mkdir dir="foo" />
    <touch file="foo/bar.txt" />
    
    <fail unless="@{DirectoryGetFileCount('foo', '*.txt')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetFiles(NAnt.Core.Project,System.String,System.String,System.Char)">
            <summary>
            Returns a delimited string of file names in the given directory.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <param name="delim">The delimiter to use.</param>
            <returns>Delimited string of file names.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir="foo" />
    <touch file="foo/bar.txt" />
    <touch file="foo/baz.txt" />
    
    <eval code="@{DirectoryGetFiles('foo', '*.*', '|')}" 
          property="files" 
          type="Function" />
    
    <foreach item="String" in="${files}" property="file" delim="|">
        <fail unless="@{FileExists('${file}')}" />
    </foreach>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetDirectories(NAnt.Core.Project,System.String,System.String,System.Char)">
            <summary>
            Returns a delimited string of subdirectory names in the given directory.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <param name="delim">The delimiter to use.</param>
            <returns>Delimited string of directory names.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir="foo" />
    <mkdir dir="foo/raz" />
    <mkdir dir="foo/bar" />
    
    <eval code="@{DirectoryGetDirectories('foo', '*', '|')}" 
          property="directories" 
          type="Function" />
    
    <foreach item="String" in="${directories}" property="directory" delim="|">
        <fail unless="@{DirectoryExists('${directory}')}" />
    </foreach>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoriesGetDirectoryListHelper(System.String,System.String)">
            <summary>
            Returns a collection of directory names from an preorder traversal of the directory tree
            <returns>ArrayList of directory names: provided directory and children.</returns>
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetDirectoriesRecursive(NAnt.Core.Project,System.String,System.String,System.Char)">
            <summary>
            Returns a delimited string of recursively searched directory names from (and including) the provided path
            </summary>
            
            <param name="project">The project being built</param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <param name="delim">The delimiter to use.</param>
            <returns>Delimited string of directory names: provided directory and children.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir="foo" />
    <mkdir dir="foo/raz" />
    <mkdir dir="foo/bar" />
    <mkdir dir="foo/bar/1" />
    <mkdir dir="foo/bar/2" />
    <mkdir dir="foo/bar/3" />

    <eval code="@{DirectoryGetDirectoriesRecursive('foo', '*', '|')}" 
          property="directories" 
          type="Function" />
    
    <foreach item="String" in="${directories}" property="directory" delim="|">
        <fail unless="@{DirectoryExists('${directory}')}" />
    </foreach>
</project>
]]>
</code>
</example>        
            
            
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetLastAccessTime(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns last accessed time of specified directory as a string. The string is formated using pattern specified by user.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">format pattern.</param>
            <returns>Formated last access time of a directory specified by user.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir="foo" />
    <echo message="@{DirectoryGetLastAccessTime('foo', 'dd MMM yyyy')}"/>
    <echo message="@{DirectoryGetLastAccessTime('foo', 'yyyyMMdd')}"/>
    <echo message="@{DirectoryGetLastAccessTime('foo', 'HHmm')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetLastWriteTime(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns last write time of specified directory as a string. The string is formated using pattern specified by user.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">format pattern.</param>
            <returns>Formated last access time of a directory specified by user.</returns>
            <example>
<code>
<![CDATA[
<project>
    <mkdir dir="foo" />
    <echo message="@{DirectoryGetLastWriteTime('foo', 'dd MMM yyyy')}"/>
    <echo message="@{DirectoryGetLastWriteTime('foo', 'yyyyMMdd')}"/>
    <echo message="@{DirectoryGetLastWriteTime('foo', 'HHmm')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryMove(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Moves the whole directory. When source and dest are on the same drive it just renames dir without copying files.
            </summary>
            <param name="project"></param>
            <param name="source">The path to the source directory.</param>
            <param name="dest">The path to destination directory.</param>
            <returns>Full path to the destination directory.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.FileFunctions">
            <summary>
            Collection of file manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileExists(NAnt.Core.Project,System.String)">
            <summary>
            Determines whether the specified file exists.
            </summary>
            <param name="project"></param>
            <param name="path">The file to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <fail unless="@{FileExists('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileCheckAttributes(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Check the FileAttributes of the file on the fully qualified path against a set of FileAttributes.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the file.</param>
            <param name="attributes">The set of attributes to check. Delimited by a space.</param>
            <remarks>
            &lt;dl&gt;
            	&lt;dt&gt;List of available attributes.&lt;/dt&gt;
            	&lt;dl&gt;
            		&lt;li&gt; Archive &lt;/li&gt;
            		&lt;li&gt; Compressed &lt;/li&gt;
            		&lt;li&gt; Device &lt;/li&gt;
            		&lt;li&gt; Directory &lt;/li&gt;
            		&lt;li&gt; Encrypted &lt;/li&gt;
            		&lt;li&gt; Hidden &lt;/li&gt;
            		&lt;li&gt; Normal &lt;/li&gt;
            		&lt;li&gt; NotContentIndexed &lt;/li&gt;
            		&lt;li&gt; Offline &lt;/li&gt;
            		&lt;li&gt; ReadOnly &lt;/li&gt;
            		&lt;li&gt; ReparsePoint &lt;/li&gt;
            		&lt;li&gt; SparseFile &lt;/li&gt;
            		&lt;li&gt; System &lt;/li&gt;
            		&lt;li&gt; Temporary &lt;/li&gt;
            	&lt;/dl&gt;
            &lt;/dl&gt;
            </remarks>
            <returns>True if all specified attributes are set; otherwise false.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <attrib file='foo.txt' archive='true' />
    <fail unless="@{FileCheckAttributes('foo.txt', 'Archive')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetAttributes(NAnt.Core.Project,System.String)">
            <summary>
            Gets the FileAttributes of the file on the fully qualified path.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the file.</param>
            <remarks>
            &lt;dl&gt;
            	&lt;dt&gt;List of available attributes.&lt;/dt&gt;
            	&lt;dl&gt;
            		&lt;li&gt; Archive &lt;/li&gt;
            		&lt;li&gt; Compressed &lt;/li&gt;
            		&lt;li&gt; Device &lt;/li&gt;
            		&lt;li&gt; Directory &lt;/li&gt;
            		&lt;li&gt; Encrypted &lt;/li&gt;
            		&lt;li&gt; Hidden &lt;/li&gt;
            		&lt;li&gt; Normal &lt;/li&gt;
            		&lt;li&gt; NotContentIndexed &lt;/li&gt;
            		&lt;li&gt; Offline &lt;/li&gt;
            		&lt;li&gt; ReadOnly &lt;/li&gt;
            		&lt;li&gt; ReparsePoint &lt;/li&gt;
            		&lt;li&gt; SparseFile &lt;/li&gt;
            		&lt;li&gt; System &lt;/li&gt;
            		&lt;li&gt; Temporary &lt;/li&gt;
            	&lt;/dl&gt;
            &lt;/dl&gt;
            </remarks>
            <returns>A set of FileAttributes seperated by a space.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <attrib file='foo.txt' archive='true' />
    <fail unless="@{FileGetAttributes('foo.txt')} == Archive" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetLastAccessTime(NAnt.Core.Project,System.String)">
            <summary>
            Gets the date time stamp the specified file or directory was last accessed.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the file or directory.</param>
            <returns>The date and time that the specified file or directory was last accessed.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <echo message="@{FileGetLastAccessTime('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetLastWriteTime(NAnt.Core.Project,System.String)">
            <summary>
            Gets the date time stamp the specified file or directory was last written to.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the file or directory.</param>
            <returns>The date and time that the specified file or directory was last written to.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <echo message="@{FileGetLastWriteTime('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetCreationTime(NAnt.Core.Project,System.String)">
            <summary>
            Gets the creation date time stamp of the specified file or directory.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the file or directory.</param>
            <returns>The date and time that the specified file or directory was created.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <echo message="@{FileGetCreationTime('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetVersion(NAnt.Core.Project,System.String)">
            <summary>
            Get the version number for the specified file.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the specified file.</param>
            <returns>The version number for the specified file.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{FileGetVersion('${nant.location}\nant.exe')} == ${nant.version}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetSize(NAnt.Core.Project,System.String)">
            <summary>
            Get the size of the specified file.
            </summary>
            <param name="project"></param>
            <param name="path">The path to the specified file.</param>
            <returns>Size of the specified file in bytes.</returns>
            <example>
<code>
<![CDATA[
<project>
    <touch file="foo.txt" />
    <echo message="foo.txt is @{FileGetSize('foo.txt')} bytes"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.FileSetFunctions">
            <summary>
            Collection of file set manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetExists(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified fileset is defined.
            </summary>
            <param name="project"></param>
            <param name="filesetName">The fileset name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fileset name="f" />
    <fail unless="@{FileSetExists('f')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetCount(NAnt.Core.Project,System.String)">
            <summary>
            Gets the number of files contained in the FileSet.
            </summary>
            <param name="project"></param>
            <param name="fileSetName">The name of the FileSet.</param>
            <returns>Number of file in the fileset.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fileset name="f">
        <includes name="one.txt" asis="true" />
        <includes name="two.txt" asis="true" />
    </fileset>
    
    <fail unless="@{FileSetCount('f')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetGetItem(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Returns the specified filename at the zero-based index of the specified FileSet.
            </summary>
            <param name="project"></param>
            <param name="fileSetName">The name of the FileSet.</param>
            <param name="index">Zero-based index of the specified FileSet. Index must be non-negative and less than the size of the FileSet.</param>
            <returns>Filename at zero-based index of the FileSet. </returns>
            <example>
<code>
<![CDATA[
<project>
    <fileset name="f">
        <includes name="one.txt" asis="true" />
        <includes name="two.txt" asis="true" />
    </fileset>
    
    <fail unless="'@{FileSetGetItem('f', '0')}' == 'one.txt'" />
    <fail unless="'@{FileSetGetItem('f', '1')}' == 'two.txt'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetToString(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Converts a FileSet to a string.
            </summary>
            <param name="project"></param>
            <param name="fileSetName">The name of the FileSet.</param>
            <param name="delimiter">The delimiter used to seperate each file.</param>
            <returns>A string of delimited files.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fileset name="f">
        <includes name="one.txt" asis="true" />
        <includes name="two.txt" asis="true" />
    </fileset>
    
    <fail unless="'@{FileSetToString('f', ';')}' == 'one.txt;two.txt'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetUndefine(NAnt.Core.Project,System.String)">
            <summary>
            Undefine an existing fileset
            </summary>
            <param name="project"></param>
            <param name="filesetName">The fileset name to undefine.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fileset name="f" />
    <echo message="Fileset f exists: @{FileSetExists('f')}" />
    <echo message="Removing f: @{FileSetUndefine('f')}" />
    <fail message="f still exists" if="@{FileSetExists('f')} == True" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetGetBaseDir(NAnt.Core.Project,System.String)">
            <summary>
            Get the base directory of a fileset
            </summary>
            <param name="project"></param>
            <param name="fileSetName"></param>
            <returns>Path to the base directory</returns>
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetDefinitionToXmlString(NAnt.Core.Project,System.String)">
            <summary>
            Converts a FileSet to an XML string.
            </summary>
            <param name="project"></param>
            <param name="fileSetName">The name of the FileSet.</param>
            <returns>string containing XML desribing the fileset.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.MathFunctions">
            <summary>
            Collection of NAnt Math routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathPI(NAnt.Core.Project)">
            <summary>
            The ratio of the circumference of a circle to its diameter.
            </summary>
            <param name="project"></param>
            <returns>PI</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathPI()} == 3.1415926535897931" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathE(NAnt.Core.Project)">
            <summary>
            The natural logarithmic base.
            </summary>
            <param name="project"></param>
            <returns>E</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathE()} == 2.7182818284590451" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathLT(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is less than second.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if less than, otherwise False</returns>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathLTEQ(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is less than or equal to second.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if less than or equal, otherwise False</returns>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathGT(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is greater than second.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if greater than, otherwise False</returns>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathGTEQ(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is greater than or equal to second.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if greater than or equal, otherwise False</returns>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathEQ(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is equal to second.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if equal, otherwise False</returns>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAdd(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Add two integer numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The sum of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathAdd('1', '1')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAddf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Add two floating-point numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The sum of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathAddf('1.2', '1.2')} == 2.4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSub(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Subtract two integer numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The difference of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathSub('4', '2')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSubf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Subtract two floating-point numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The difference of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathSubf('2.0', '1.0')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathMul(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Multiply two integer numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The product of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathMul('3', '3')} == 9" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathMulf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Multiply two floating-point numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The product of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathMulf('1.2', '2.0')} == 2.4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathMod(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Computes the modulo of two numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The modulo of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathMod('24', '18')} == 6" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathModf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Computes the modulo of two numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The modulo of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathModf('24.0', '18.0')} == 6" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathDiv(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Divide two integer numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The division of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathDiv('6', '3')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathDivf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Divide two floating-point numbers.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The division of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathDivf('3.0', '2.0')} == 1.5" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAbs(NAnt.Core.Project,System.Int32)">
            <summary>
            Calculates the absolute value of a specified number.
            </summary>
            <param name="project"></param>
            <param name="a">The number.</param>
            <returns>The absolute value of a specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathAbs('-1')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAbsf(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the absolute value of a specified number.
            </summary>
            <param name="project"></param>
            <param name="a">The number.</param>
            <returns>The absolute value of a specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathAbsf('-1.2')} == 1.2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathCeiling(NAnt.Core.Project,System.Double)">
            <summary>
            Returns the smallest whole number greater than or equal to the specified number.
            </summary>
            <param name="project"></param>
            <param name="a">The number.</param>
            <returns>The smallest whole number greater than or equal to the specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathCeiling('1.2')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathFloor(NAnt.Core.Project,System.Double)">
            <summary>
            Returns the largest whole number less than or equal to the specified number.
            </summary>
            <param name="project"></param>
            <param name="a">The number.</param>
            <returns>The largest whole number less than or equal to the specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathFloor('1.2')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathPow(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Raise the specified number to the specified power.
            </summary>
            <param name="project"></param>
            <param name="x">The number.</param>
            <param name="y">The power.</param>
            <returns>The number x raised to the power y.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathPow('2.0', '2.0')} == 4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSqrt(NAnt.Core.Project,System.Double)">
            <summary>
            Computes the square root of a specified number.
            </summary>
            <param name="project"></param>
            <param name="a">The specified number.</param>
            <returns>The square root of a specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{MathSqrt('25.0')} == 5" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathDegToRad(NAnt.Core.Project,System.Int32)">
            <summary>
            Converts an angle from degrees to radians.
            </summary>
            <param name="project"></param>
            <param name="a">The specified number of degrees.</param>
            <returns>The degree of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <property name='pi' value='@{MathPI()}' />
    <property name='rad' value='@{MathDivf("${pi}", "180")}' />
    <property name='deg' value='@{MathMulf("90", "${rad}")}' />
    
    <echo message="@{MathDegToRad('90')} == ${deg}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSin(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the sine of the specified angle.
            </summary>
            <param name="project"></param>
            <param name="a">The specified angle in radians.</param>
            <returns>The sine of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <property name="deg" value="@{MathDegToRad('90')}" />
    <fail unless="@{MathSin('${deg}')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathCos(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the cosine of the specified angle.
            </summary>
            <param name="project"></param>
            <param name="a">The specified angle in radians.</param>
            <returns>The cosine of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <property name="deg" value="@{MathDegToRad('90')}" />
    <fail unless="@{MathCos('${deg}')} == 6.1230317691118863E-17" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathTan(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the tangent of the specified angle.
            </summary>
            <param name="project"></param>
            <param name="a">The specified angle in radians.</param>
            <returns>The tangent of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <property name="deg" value="@{MathDegToRad('180')}" />
    <fail unless="@{MathTan('${deg}')} == -1.2246063538223773E-16" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathChangePrecision(NAnt.Core.Project,System.Double,System.Int32)">
            <summary>
            Changes the precision of a specified floating-point number.
            </summary>
            <param name="project"></param>
            <param name="a">The specified floating-point number.</param>
            <param name="precision">The new precision.</param>
            <returns>The value of a using the specified precision.</returns>
            <remarks>By default NAnt math functions return doubles using full precision (17 bits). Typically only 
            15 bits are needed.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <eval code="@{MathSubf('2.2', '1.2')}" property='p' type='Function'/>
    <fail unless='${p} == 1.0000000000000002' />

    <eval code="@{MathChangePrecision('${p}', '15')}" property='p' type='Function'/>
    <fail unless='${p} == 1' />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.NAntFunctions">
            <summary>
            Collection of NAnt Project routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.NAntFunctions.NAntIsParallel(NAnt.Core.Project)">
            <summary>
            Tests whether Framework (NAnt) is runnting in parallel mode .
            </summary>
            <param name="project"></param>
            <returns>Returns true if Framework is in paralel mode (default).</returns>
            <remarks>Parallel mode can be switched off bynant command line parameter -noparallel.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.NAntFunctions.GetLogFilePaths(NAnt.Core.Project)">
            <summary>
            Gets log file name paths.
            </summary>
            <param name="project"></param>
            <returns>Returns new line separated list of log file names or an empty string when log is not redirected to a file</returns>
        </member>
        <member name="T:NAnt.Core.Functions.OptionSetFunctions">
            <summary>
            Option set manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetGetValue(NAnt.Core.Project,System.String,System.String)">
            <summary>Get the value of an option in a named optionset.</summary>
            <param name="project"/>
            <param name="optionSetName">The name of the optionset to get from.</param>
            <param name="optionName">The name of the option to get.</param>
            <returns>The value of the option or an empty string if no option defined.</returns>
            <example>
<code>
<![CDATA[
<project>
    <optionset name='optset'>
        <option name='opt' value='1' />
    </optionset>
    
    <fail unless="@{OptionSetGetValue('optset', 'opt')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetExists(NAnt.Core.Project,System.String)">
            <summary>Check if the specified optionset is defined.</summary>
            <param name="project"/>
            <param name="optionSetName">The name of the optionset.</param>
            <returns>True if the option set is defined, otherwise False.</returns>returns&gt;
            <example>
<code>
<![CDATA[
<project>
    <optionset name='optset' />

    <fail unless="@{OptionSetExists('optset')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetOptionExists(NAnt.Core.Project,System.String,System.String)">
            <summary>Check if the specified option is defined within the specified optionset.</summary>
            <param name="project"/>
            <param name="optionSetName">The name of the optionset.</param>
            <param name="optionName">The name of the option.</param>
            <returns>True if the option is defined, otherwise False.</returns>returns&gt;
            <example>
<code>
<![CDATA[
<project>
    <optionset name='optset'>
        <option name='opt' value='1' />
    </optionset>
    
    <fail unless="@{OptionSetOptionExists('optset', 'opt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetUndefine(NAnt.Core.Project,System.String)">
            <summary>
            Undefine the specified optionset.
            </summary>
            <param name="project"></param>
            <param name="optionSetName">The optionset name to undefine.</param>
            <returns>True if the optionset was undefined properly, otherwise False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <optionset name='optset' />
    <eval code="@{OptionSetUndefine('optset')}" type="Function" />
    <fail if="@{OptionSetExists('optset')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetOptionUndefine(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Undefine the specified optionset option.
            </summary>
            <param name="project"></param>
            <param name="optionSetName">The name of the optionset.</param>
            <param name="optionName">The name of the option to undefine.</param>
            <returns>True if the optionset option was undefined properly, otherwise False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <optionset name='optset'>
        <option name='opt' value='1' />
    </optionset>
    
    <eval code="@{OptionSetOptionUndefine('optset', 'opt')}" type="Function" />
    
    <fail if="@{OptionSetOptionExists('optset', 'opt')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetToString(NAnt.Core.Project,System.String)">
            <summary>
            Output option set to string
            </summary>
            <param name="project"></param>
            <param name="optionSetName">The optionset name.</param>
            <returns>string with optionset content.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.PackageFunctions">
            <summary>
            Collection of NAnt Project routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.PackageGetMasterversion(NAnt.Core.Project,System.String)">
            <summary>
            Returns package masterversion declared in masterconfig file. This function does not perform dependent task.
            </summary>
            <param name="project"></param>
            <returns>masterversion string.</returns>
            <remarks>Throws error if package is not not declared in masterconfig file.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.PackageGetMasterDir(NAnt.Core.Project,System.String)">
            <summary>
            Returns package master release directory.
            </summary>
            <param name="project"></param>
            <returns>package directory string.</returns>
            <remarks>Throws error if package is not not declared in masterconfig file or is not installed.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.PackageGetMasterDirOrEmpty(NAnt.Core.Project,System.String)">
            <summary>
            Returns package master release directory.
            </summary>
            <param name="project"></param>
            <returns>package directory string.</returns>
            <remarks>returns empty string if package is not not declared in masterconfig file or is not installed.</remarks>
        </member>
        <member name="T:NAnt.Core.Functions.PathFunctions">
            <summary>
            Collection of path manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFullPath(NAnt.Core.Project,System.String)">
            <summary>
            Returns the complete path.
            </summary>
            <param name="project"></param>
            <param name="path">The relateive path to convert.</param>
            <returns>Complete path with drive letter (if applicable).</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathGetFullPath('.')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFileSystemFileName(NAnt.Core.Project,System.String)">
            <summary>
            Return the true/real filename stored in the file system. If file doesn't exist, it will
            just return the path passed in.
            </summary>
            <param name="project"></param>
            <param name="path">full path or path that specify a file</param>
            <returns>if file exist, return the actual filename stored in the file system, else return the path passed in.</returns>
            <example>
<code>
<![CDATA[
<project>
    <property name="FileName" value="@{PathGetTempPath()}Mixed Case.txt"/>
    <touch file="${FileName}"/>
    <property name="DOSPath" value="@{PathGetFileSystemFileName('@{PathGetTempPath()}MIXEDC~1.TXT')}"/>
    <fail 
        unless="'@{PathGetFileName(${DOSPath})}' == '@{PathGetFileName(${FileName})}'"
        message="'@{PathGetFileName(${DOSPath})}' does not match case of '@{PathGetFileName(${FileName})}'."
        />
    <delete file="${FileName}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToUnix(NAnt.Core.Project,System.String)">
            <summary>
            Returns the path with backward slashes '\' converted to forward slashes '/'.
            </summary>
            <param name="project"></param>
            <param name="path">The path string from which to convert.</param>
            <returns>Path with backward slashes converted to forward slashes.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathToUnix('c:\windows')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToCygwin(NAnt.Core.Project,System.String)">
            <summary>
            Returns the path with drive letter and semicolon are substituted to cygwin notation,
            backward slashes '\' converted to forward slashes '/'.
            </summary>
            <param name="project"></param>
            <param name="path">The path string from which to convert.</param>
            <returns>cygwin path.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathToUnix('c:\windows')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToWindows(NAnt.Core.Project,System.String)">
            <summary>
            Returns the string with forward slashes '/' converted to backward slashes '\'.
            </summary>
            <param name="project"></param>
            <param name="path">The path string from which to convert.</param>
            <returns>Path with forward slashes converted to backward slashes.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathToWindows('/usr/linux')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetDirectoryName(NAnt.Core.Project,System.String)">
            <summary>
            Returns the directory name for the specified path string.
            </summary>
            <param name="project"></param>
            <param name="path">The path of a file or directory.</param>
            <returns>Directory name of the specified path string.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathGetDirectoryName('packages\build')} == 'packages'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetRelativePath(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Relative path.
            </summary>
            <param name="project"></param>
            <param name="path">The path of a file or directory.</param>
            /// <param name="basepath">Base path used to compute relative path.</param>
            <returns>Relative path or ful;l path when computing relative path is not possible.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFileName(NAnt.Core.Project,System.String)">
            <summary>
            Returns the file name and extension of the specified path string.
            </summary>
            <param name="project"></param>
            <param name="path">The path string from which to obtain the file name and extension.</param>
            <returns>File name and extension of the specified path string.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathGetFileName('packages\nant.exe')} == 'nant.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetExtension(NAnt.Core.Project,System.String)">
            <summary>
            Returns the extension of the specified path string.
            </summary>
            <param name="project"></param>
            <param name="path">The path string from which to get the extension.</param>
            <returns>Extension of the specified path string.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathGetExtension('nant.exe')} == '.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFileNameWithoutExtension(NAnt.Core.Project,System.String)">
            <summary>
            Returns the file name of the specified path string without the extension.
            </summary>
            <param name="project"></param>
            <param name="path">The path of the file.</param>
            <returns>File name of the specified path string without the extension.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathGetFileNameWithoutExtension('nant.exe')} == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathChangeExtension(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Changes the extension of the specified path.
            </summary>
            <param name="project"></param>
            <param name="path">The specified path.</param>
            <param name="extension">The new extension.</param>
            <returns>The specified path with a different extension.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathChangeExtension('nant.exe', 'cfg')} == 'nant.cfg'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathCombine(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Combine two specified paths.
            </summary>
            <param name="project"></param>
            <param name="path1">The first specified path.</param>
            <param name="path2">The second specified path.</param>
            <returns>A new path containing the combination of the two specified paths.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathCombine('packages', 'nant')} == 'packages\nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetPathRoot(NAnt.Core.Project,System.String)">
            <summary>
            Returns the root directory of the specified path.
            </summary>
            <param name="project"></param>
            <param name="path">The specified path.</param>
            <returns>The root directory of the specified path.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathGetPathRoot('d:\packages')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetTempFileName(NAnt.Core.Project)">
            <summary>
            Returns a unique temporary file name which is created as an empty file on disk.
            </summary>
            <param name="project"></param>
            <returns>The name of a temporary file which has been created on disk.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathGetTempFileName()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetTempPath(NAnt.Core.Project)">
            <summary>
            Returns the path to the systems temp folder.
            </summary>
            <param name="project"></param>
            <returns>The path to the systems temp folder.</returns>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{PathGetTempPath()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathHasExtension(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified path has a filename extension.
            </summary>
            <param name="project"></param>
            <param name="path">The specified path.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathHasExtension('nant.exe')}" />
    <fail if="@{PathHasExtension('nant')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathIsPathRooted(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified path contains absolute or relative path information.
            </summary>
            <param name="project"></param>
            <param name="path">The specified path.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{PathIsPathRooted('d:\nant.exe')}" />
    <fail if="@{PathIsPathRooted('nant.exe')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathVerifyValid(System.String,System.String)">
            <summary>
            Verifies that path does not contain invalid characters.
            </summary>
            <param name="path">The specified path.</param>
            <param name="parameterName">Name of the path variable to pass to exception.</param>
            Throws InvalidArgument exception if path is invalid
        </member>
        <member name="T:NAnt.Core.Functions.PlatformFunctions">
            <summary>
            Collection of string manipulation routines. 
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformIsUnix(NAnt.Core.Project)">
            <summary>
            Returns 'true' if the current platform is Linux.
            </summary>
            <param name="project"></param>
            <returns>'true' if the current platform is Linux, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformIsWindows(NAnt.Core.Project)">
            <summary>
            Returns 'true' if the current platform is Windows.
            </summary>
            <param name="project"></param>
            <returns>'true' if the current platform is Windows, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformIsOSX(NAnt.Core.Project)">
            <summary>
            Returns 'true' if the current platform is OSX.
            </summary>
            <param name="project"></param>
            <returns>'true' if the current platform is Windows, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformPlatform(NAnt.Core.Project)">
            <summary>
            Returns the Operating System we are running on.
            </summary>
            <returns>name of the platform. Supported values are: Windows, Unix, OSX, Xbox, Unknown. </returns>
        </member>
        <member name="T:NAnt.Core.Functions.ProjectFunctions">
            <summary>
            Collection of NAnt Project routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetLastError(NAnt.Core.Project)">
            <summary>
            Returns the previous build exception message.
            </summary>
            <param name="project"></param>
            <returns>The previous build exception message that was thrown.</returns>
            <remarks>If no error message exists an empty string is returned.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{ProjectGetLastError()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetLastInnerError(NAnt.Core.Project)">
            <summary>
            Returns the previous inner build exception message.
            </summary>
            <param name="project"></param>
            <returns>The previous inner build exception message that was thrown.</returns>
            <remarks>If no error message exists an empty string is returned.</remarks>
            <example>
<code>
<![CDATA[
<project>
    <echo message="@{ProjectGetLastInnerError()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetName(NAnt.Core.Project)">
            <summary>
            Gets the name of the project.
            </summary>
            <param name="project"></param>
            <returns>The project name or empty string if none exists.</returns>
            <example>
<code>
<![CDATA[
<project name='test'>
    <fail unless="'@{ProjectGetName()}' == 'test'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetDefaultTarget(NAnt.Core.Project)">
            <summary>
            Gets the name of the default target.
            </summary>
            <param name="project"></param>
            <returns>The name of the default target or empty string if none exists.</returns>
            <example>
<code>
<![CDATA[
<project default='build'>
    <target name='build'>
        <fail unless="'@{ProjectGetDefaultTarget()}' == 'build'" />
    </target>
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.PropertyFunctions">
            <summary>
            Collection of property manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyExists(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified property is defined.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <property name="p" value="1" />
    <fail unless="@{PropertyExists('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyTrue(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified property value is true. 
            If property does not exist, an Exception will be thrown.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <property name="p" value="true" />
    <fail unless="@{PropertyTrue('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyExpand(NAnt.Core.Project,System.String)">
            <summary>
            Expand the specified property.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to expand.</param>
            <returns>The value of the specified property. If the property does not exits a BuildException is thrown.</returns>
            <example>
<code>
<![CDATA[
<project>
    <property name="p" value="1" />
    <fail unless="@{PropertyExpand('p')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyUndefine(NAnt.Core.Project,System.String)">
            <summary>
            Undefine the specified property.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to undefine.</param>
            <returns>True if the property was undefined properly, otherwise False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <property name="p" value="1" />

    <eval code="@{PropertyUndefine('p')}" type='Function' />
    <fail if="@{PropertyExists('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.IsPropertyGlobal(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified property is defined as global property in masterconfig.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <property name="p" value="1" />
    <fail unless="@{IsPropertyGlobal('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.GetPropertyOrDefault(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns property value or default value if property does not exist.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to check.</param>
            <param name="defaultVal">default value.</param>
            <returns>property value.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.StringFunctions">
            <summary>
            Collection of string manipulation routines. 
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrLen(NAnt.Core.Project,System.String)">
            <summary>
            Gets the number of characters in a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to count.</param>
            <returns>The number of characters in the specified string.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrLen('nant.exe')} == 8" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrEndsWith(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Determines whether the end of a string matches a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to search.</param>
            <param name="strB">The string to match.</param>
            <returns>True if the specified string strA ends with the specified string strB.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrEndsWith('nant.exe', '.exe')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrStartsWith(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Determines whether the start of a string matches a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to search.</param>
            <param name="strB">The string to match.</param>
            <returns>True if the specified string, strA, starts with the specified string, strB.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrStartsWith('nant.exe', 'nant')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrCompare(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified strings.
            </summary>
            <param name="project"></param>
            <param name="strA">The first String.</param>
            <param name="strB">The second String.</param>
            <returns>
            	Less than zero - strA is less than strB. &lt;br/&gt;
            	Zero - strA is equal to strB. &lt;br/&gt;
            	Greater than zero - strA is greater than strB. &lt;br/&gt;
            </returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrCompare('nant', 'nant')} == 0" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrCompareVersions(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified version strings.  Version strings should be numbers 
            separated by any non digit separator. Separators are used in comparison as well.
            Dot separator will take a presedence over dash separator. 
            Numbers are always considered newer than letters, version strings that are starting with "dev" or "work" are considered a special case, dev and work takes presedence over numbers
            
            For example, versions will be sorted this way in descending order:
            test-09
            test-8-1
            test-8.1-alpha
            test-8.1
            test-8       
            Work and dev will be newer than numeric versions, but only if package name is not included:
            dev
            1.01.00
            This function assumes that separators used in both version strings are the same.
            
            </summary>
            <param name="project"></param>
            <param name="strA">The first version String.</param>
            <param name="strB">The second version String.</param>
            <returns>
            	Less than zero - strA is less than strB. &lt;br/&gt;
            	Zero - strA is equal to strB. &lt;br/&gt;
            	Greater than zero - strA is greater than strB. &lt;br/&gt;
                Comparison algorithm takes into account version formatting, rather than doing simple lexicographical comparison.
            </returns>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.ValueAt(System.String,System.Int32)">
            <summary>
            Helper function for StrCompareVersions. Returns character value at position pos, 
            or '\0' if index is outside the string
            </summary>
            <param name="str"> string</param>
            <param name="pos">position in the string</param>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrLastIndexOf(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Reports the index position of the last occurrence of a string within a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to search.</param>
            <param name="strB">The string to seek.</param>
            <returns>The last index position of string strB in string strA if found; otherwise -1 if not found.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrLastIndexOf('nant.exe.config', '.')} == 8" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrIndexOf(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Reports the index of the first occurrence of a string in a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to search.</param>
            <param name="strB">The string to seek.</param>
            <returns>The index position of string strB in string strA if found; otherwise -1 if not found.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrIndexOf('nant.exe', '.')} == 4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrContains(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Reports if strA contains strB.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to search.</param>
            <param name="strB">The string to seek.</param>
            <returns>true if strB is found in  string strA; otherwise false if not found.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrRemove(NAnt.Core.Project,System.String,System.Int32,System.Int32)">
            <summary>
            Deletes a specified number of characters from the specified string beginning at a specified position.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <param name="startIndex">The position in the string to begin deleting characters.</param>
            <param name="count">The number of characters to delete.</param>
            <returns>A string having count characters removed from strA starting at startIndex.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrRemove('nant.exe', '4', '1')}' == 'nantexe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrReplace(NAnt.Core.Project,System.String,System.String,System.String)">
            <summary>
            Replaces all occurrences of a string in a string, with another string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <param name="oldValue">The string to be replaced.</param>
            <param name="newValue">The string to replace all occurrences of oldValue.</param>
            <returns>A string having every occurrence of oldValue in strA replaced with newValue.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrReplace('nant.exe', '.exe', '.config')}' == 'nant.config'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrInsert(NAnt.Core.Project,System.String,System.Int32,System.String)">
            <summary>
            Inserts a string at a specified index position in a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to insert into.</param>
            <param name="startIndex">The index position of the insertion.</param>
            <param name="value">The string to insert.</param>
            <returns>A string equivalent to strA but with value inserted at position startIndex.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrInsert('.exe', '0', 'nant')}' == 'nant.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrSubstring(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Retrieves a substring from a string. The substring starts at a specified character position.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <param name="startIndex">The starting character position of a substring in this instance.</param>
            <returns>A substring of strA starting at startIndex.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrSubstring('nant.exe', '4')}' == '.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrSubstring(NAnt.Core.Project,System.String,System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from a string.
            The substring starts at a specified character position and has a specified length.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <param name="startIndex">The index of the start of the substring.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>A substring of strA starting at startIndex and with a specified length.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrSubstring('nant.exe', '0', '4')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrConcat(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Concatenates two strings.
            </summary>
            <param name="project"></param>
            <param name="strA">The first string.</param>
            <param name="strB">The second string.</param>
            <returns>The concatenation of strA and strB.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrConcat('nant', '.exe')}' == 'nant.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrPadLeft(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Right-aligns the characters a string, padding with spaces on the left for a total length.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to pad.</param>
            <param name="totalWidth">
            The number of characters in the resulting string, equal to the number of original characters plus 
            any additional padding characters.
            </param>
            <returns>
            A string that is equivalent to strA, but right-aligned and padded on the left with as many 
            spaces as needed to create a length of totalWidth. 
            If totalWidth is less than the length of strA, a string that is identical to strA is returned.
            </returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrPadLeft('nant', '8')}' == '    nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrPadRight(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Left-aligns the characters in a string, padding with spaces on the left for a total length.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to pad.</param>
            <param name="totalWidth">
            The number of characters in the resulting string, equal to the number of original characters plus 
            any additional padding characters.
            </param>
            <returns>
            A string that is equivalent to strA, but left-aligned and padded on the right with as many 
            spaces as needed to create a length of totalWidth. 
            If totalWidth is less than the length of strA, a string that is identical to strA is returned.
            </returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrPadRight('nant', '8')}' == 'nant    '" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrTrim(NAnt.Core.Project,System.String)">
            <summary>
            Removes all occurrences of white space characters from the beginning and end of a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string to trim.</param>
            <returns>A string equivalent to strA after white space characters are removed.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrTrim('  nant  ')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrToUpper(NAnt.Core.Project,System.String)">
            <summary>
            Returns a copy of strA in uppercase.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <returns>A string in uppercase.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrToUpper('nant')}' == 'NANT'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrToLower(NAnt.Core.Project,System.String)">
            <summary>
            Returns a copy of strA in lowercase.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <returns>A string in lowercase.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrToLower('NANT')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrEcho(NAnt.Core.Project,System.String)">
            <summary>
            Echo a string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <returns>The string.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="'@{StrEcho('nant')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrIsEmpty(NAnt.Core.Project,System.String)">
            <summary>
            Returns true if the specified string is the Empty string.
            </summary>
            <param name="project"></param>
            <param name="strA">The string.</param>
            <returns>True of False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <fail unless="@{StrIsEmpty('')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.TargetFunctions">
            <summary>
            Collection of target manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.TargetFunctions.TargetExists(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified target exists.
            </summary>
            <param name="project"></param>
            <param name="targetName">The target name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project>
    <target name='build' />
    <fail unless="@{TargetExists('build')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.ICachedWriter.Append(NAnt.Core.ICachedWriter)">
            <summary>
            Appends content of another writer to this one.
            </summary>
        </member>
        <member name="M:NAnt.Core.ICachedWriter.Flush">
            <summary>
            Write memory content to the file. If file exist and content did not change leave file intact.
            </summary>
        </member>
        <member name="P:NAnt.Core.Logging.Log.IndentSize">
            <summary>Gets or sets the number of spaces in an indent.  Default is four.</summary>
        </member>
        <member name="P:NAnt.Core.Logging.Log.IndentLevel">
            <summary>Gets or sets the indent level.  Default is zero.</summary>
        </member>
        <member name="T:NAnt.Core.ObjectDictionary">
            <summary>
            Provides a dictionary of named option sets.  This is used by NAnt and the
            <see cref="T:NAnt.Core.Tasks.OptionSetTask"/> to create named option sets.
            </summary>
        </member>
        <member name="T:NAnt.Core.OptionSetDictionary">
            <summary>
            Provides a dictionary of named option sets.  This is used by NAnt and the
            <see cref="T:NAnt.Core.Tasks.OptionSetTask"/> to create named option sets.
            </summary>
        </member>
        <member name="T:NAnt.Core.OptionDictionary">
            <summary>
            Provides a dictionary of options.  An <see cref="T:NAnt.Core.OptionSet"/> contains
            a dictionary of named string options.
            </summary>
        </member>
        <member name="T:NAnt.Core.OptionSet">
            <summary>Manages a set of options as a name/value collection.</summary>
        </member>
        <member name="M:NAnt.Core.OptionSet.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly intialize</summary>
        </member>
        <member name="M:NAnt.Core.OptionSet.InitializeElement(System.Xml.XmlNode)">
            <summary>Add all the child option elements.</summary>
            <param name="elementNode">Xml node to initialize from.</param>
        </member>
        <member name="P:NAnt.Core.OptionSet.Options">
            <summary>The dictionary used to map option names to option values.</summary>
        </member>
        <member name="P:NAnt.Core.OptionSet.FromOptionSetName">
            <summary>The name of an option set to include.</summary>
        </member>
        <member name="P:NAnt.Core.OptionSet.Option._name">
            <summary>The name of the option.</summary>
        </member>
        <member name="P:NAnt.Core.OptionSet.Option._val">
            <summary>The value of the option. Value can be set as option element text. 
            To get current value use ${option.value} expression.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.TryGetPackage(System.String,NAnt.Core.PackageCore.Package@)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="package"></param>
            <returns></returns>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.GetAllPackages">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.Install(NAnt.Core.PackageCore.Release,System.String)">
            <summary>
            Installs required package from a Package Server or throws an exception.
            </summary>
            <param name="release">Release instance with information about package to install</param>        
            <returns>Root directory where package was installed</returns>
        </member>
        <member name="M:NAnt.Core.PackageCore.Package.#ctor(System.String)">
            <summary>
            creates a package object WITHOUT scanning and adding releases automatically.        /// </summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.Package.Tag">
            <summary>Gets or sets an object that contains data to associate with the package.</summary>
        </member>
        <member name="M:EA.PackageSystem.PackageCore.PackageInstallerReleaseCollection.Add(System.String,System.String,System.Boolean)">
            <summary>Add a release to the collection.</summary>
            <param name="name">Name of package.</param>
            <param name="version">Version of package.</param>
            <param name="addDependents">If <c>true</c> add release dependents as well, otherwise only add the release.</param>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.Packages">
            <summary>Returns a collection of packages.</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.MasterPackages">
            <summary>Returns a collection of packages.</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.Releases">
            <summary>Returns a collection of releases.</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.PackageRoots">
            <summary>
            The collection of package roots.
            </summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.ConfigPackageDir">
            <summary>
            Where is the directory containing configuration package?
            </summary>        
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.ConfigDir">
            <summary>
            Where is the directory containing the build configurations?
            </summary>        
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.ConfigPackageVersion">
            <summary>
            Config package's version (for FW2 only)
            </summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.TopLevelProjectManifest">
            <summary>
            Manifest file of the top level project
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.GetFrameworkReleaseDirectory">
            <summary>
            Returns the release directory containing the executing framework.
            This method does not add the release.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.GetFrameworkRelease">
            <summary>Returns the Framework package release we are currently running or null.
            Assumes the framework package has already been added.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.GetMasterVersion(System.String,NAnt.Core.Project)">
            <summary>
            get master version of the given package; return null if none was set
            Called by Release
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.GetMasterGroup(System.String,NAnt.Core.Project)">
            <summary>
            get group of the given package;        
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.AddPackages(NAnt.Core.PackageCore.PackageRootList.Root,NAnt.Core.Logging.Log)">
            <summary>
            Adds any package releases located in the specified package root. If a specific release 
            already exists in the map it will not be added.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.AddPackage(System.IO.DirectoryInfo,System.Int32,NAnt.Core.Logging.Log)">
            <summary>
            Adds any package releases located in the specified package folder. If a specific release 
            already exists in the map it will not be added.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.FindPackageRoot(NAnt.Core.Util.PathString,NAnt.Core.Logging.Log)">
            <summary>
            Search upwards from the specified path, until a package root, or null, is found.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.IsPackageRoot(System.IO.DirectoryInfo,NAnt.Core.Logging.Log)">
            <summary>Determines if the given directory is a package root.</summary>
            <param name="directory">The complete path to the directory to test.</param>
            <param name="log">Instance of Log</param>
            <returns>True if the directory is a package root; otherwise false.</returns>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.CompatibilityConditions">
            <summary>Returns a collection of releases.</summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.PackageMap.BuildRoot">
            <summary>
            returns the build root directory
            </summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.PackageMap.DefaultConfig">
            <summary>
            returns the configdir default build configuration
            </summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.PackageMap.ConfigPackageName">
            <summary>
            Config package's name (for FW2 only)
            </summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.PackageMap.OnDemand">
            <summary>
            Should we download missing packages from the package server on demand?
            This functionality make it harder than necessary to have a complete
            archive in source control, due to silent downloads of packages which
            haven't been checked into source control, so is turned off by default.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.ReleaseCollection.Add(NAnt.Core.PackageCore.Release)">
            <summary>Releases are stored in ascending order without duplicates.</summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.Release.GetVersion(System.IO.DirectoryInfo,System.String)">
            <summary>
            Retrieve the version of a packages based on the directory structure and name of package.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.Release.Delete">
            <summary>Deletes the package from disk and the package map.</summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.Release.Tag">
            <summary>Gets or sets an object that contains data to associate with the release.</summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.Release.MasterProperties">
            <summary>Gets list of package global properties defind in masterconfig.</summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.Release.HasManifest">
            <summary>True if the release has a valid manifest, otherwise false.</summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.Release.Utility.GetDirectorySize(System.String)">
            <summary>Get the size of a directory and it's contents in bytes.</summary>
            <param name="path">The complete path to the directory.</param>
            <returns>The size in bytes of the directory and it's contents.</returns>
        </member>
        <member name="M:NAnt.Core.PackageCore.Release.Utility.ObliterateDirectory(System.String)">
            <summary>Remove all files and directories in the given path regardless of readonly attributes.</summary>
            <param name="path">The path </param>
        </member>
        <member name="T:NAnt.Core.PackageCore.Compatibility">
            <summary>
            Class to store package compatibility.
            </summary>
            <remarks>
             <para>One declares package compatibility in the Manifest.xml file of a package. An example may look like:
              &lt;compatibility package="eacore"&gt;
              &lt;api-supported&gt;
              1.00.00
              1.00.01
              &lt;/api-supported&gt;
              &lt;binary-compatible&gt;
              1.00.01
              &lt;/binary-compatible&gt;
              &lt;dependent package="EABase"&gt;
              &lt;compatible&gt;
              2.0.4
              2.0.5
              &lt;/compatible&gt;
              &lt;incompatible version="2.0.3" message="Known bug in blah blah blah" /&gt;
              &lt;/dependent&gt;
              &lt;/compatibility&gt;
             </para>
            </remarks>
        </member>
        <member name="T:NAnt.Core.PackageCore.Compatibility.Incompatible">
            <summary>
            Class to store &lt;incompatible&gt;
            </summary>
        </member>
        <member name="T:NAnt.Core.PackageCore.Compatibility.Dependent">
            <summary>
            Class to store &lt;depenent&gt;
            </summary>
        </member>
        <member name="M:NAnt.Core.Task.Execute">
            <summary>Executes the task unless it is skipped.</summary>
        </member>
        <member name="M:NAnt.Core.Task.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes the task and checks for correctness.</summary>
        </member>
        <member name="M:NAnt.Core.Task.ExecuteTask">
            <summary>Executes the task.</summary>
        </member>
        <member name="P:NAnt.Core.Task.FailOnError">
            <summary>Determines if task failure stops the build, or is just reported. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Task.Verbose">
            <summary>Task reports detailed build log messages.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Task.IfDefined">
            <summary>If true then the task will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Task.UnlessDefined">
            <summary>Opposite of if.  If false then the task will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Task.NoPackageLog">
            <summary>Dummy atribute for bacwards compatibility.</summary>
        </member>
        <member name="P:NAnt.Core.Task.TaskSuccess">
            <summary>Returns true if the task succeded.</summary>
        </member>
        <member name="P:NAnt.Core.Task.LogPrefix">
            <summary>The prefix used when sending messages to the log.</summary>
        </member>
        <member name="M:NAnt.Core.TaskContainer.ExecuteChildTasks">
            <summary>
            Creates and Executes the embedded (child xml nodes) elements.
            </summary>
            <remarks> Skips any element defined by the host task that has an BuildElementAttribute (included filesets and special xml) defined.</remarks>
        </member>
        <member name="M:NAnt.Core.ParallelTaskContainer.ExecuteChildTasks">
            <summary>
            Creates and Executes the embedded (child xml nodes) elements.
            </summary>
            <remarks> Skips any element defined by the host task that has an BuildElementAttribute (included filesets and special xml) defined.</remarks>
        </member>
        <member name="T:NAnt.Core.PropertyElement">
            <summary>A property element is used by tasks that want to have the user enter a string 
            but not as an attribute.  Useful if the string is going to hold multiple lines.</summary>
        </member>
        <member name="T:NAnt.Core.XmlPropertyElement">
            <summary>A property element is used by tasks that want to have the user enter a string 
            but not as an attribute.  Useful if the string is going to hold multiple lines.
            Can also contain build script tasks.</summary>
        </member>
        <member name="M:NAnt.Core.Reflection.FunctionFactory.Run(System.String,System.Collections.Generic.List{System.String},NAnt.Core.Project)">
            <summary>
            Run a function given the nant function name. 
            This corresponds to the name defined in the FunctionAttribute by the static method.
            </summary>
        </member>
        <member name="M:NAnt.Core.Reflection.FunctionFactory.ScanDirectories(System.String[])">
            <summary>Scans directory list for any task assemblies and adds them to list of known functions.</summary>
            <param name="paths">The full path to the directory to scan.</param>
        </member>
        <member name="M:NAnt.Core.Reflection.FunctionFactory.AddFunctions(System.Reflection.Assembly,System.Boolean,System.Boolean)">
            <summary>Scans the given assembly for any classes derived from Function.</summary>
            <param name="assembly">The Assembly containing the new functions to be loaded.</param>
            <returns>The count of tasks found in the assembly.</returns>
        </member>
        <member name="T:NAnt.Core.Location">
            <summary>
            Stores the file name, line number and column number to record a position in a text file.
            </summary>
        </member>
        <member name="M:NAnt.Core.Location.GetLocationFromNode(System.Xml.XmlNode)">
            
             <summary>Location factory that return meaningful location from custom nodes that
             support position information.
             </summary>
            
        </member>
        <member name="M:NAnt.Core.Location.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Creates a location consisting of a file name, line number and column number.</summary>
            <remarks>fileName can be a local URI resource, e.g., file:///C:/WINDOWS/setuplog.txt</remarks>
        </member>
        <member name="M:NAnt.Core.Location.#ctor(System.String)">
            <summary>Creates a location consisting of a file name.</summary>
            <remarks>fileName can be a local URI resource, e.g., file:///C:/WINDOWS/setuplog.txt</remarks>
        </member>
        <member name="M:NAnt.Core.Location.#ctor">
            <summary>Creates an "unknown" location.</summary>
        </member>
        <member name="M:NAnt.Core.Location.ToString">
             <summary>
             Returns the file name, line number and a trailing space. An error
             message can be appended easily. For unknown locations, returns
             an empty string.
            </summary>
        </member>
        <member name="F:NAnt.Core.Project.IncludedFiles">
            <summary>The collection of File paths structures pointing to files already included in the project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.GlobalProperties">
            <summary>Global properties.</summary>
        </member>
        <member name="F:NAnt.Core.Project.GlobalNamedObjects">
            <summary>Global NamedObjects. Id's of objects that are propagated to dependents</summary>
        </member>
        <member name="F:NAnt.Core.Project.StaticNamedObjectContainer">
            <summary>Global NamedObjects. Id's of objects that are propagated to dependents</summary>
        </member>
        <member name="F:NAnt.Core.Project.BuildFileDocument">
            <summary>Returns the active build file XmlDocument.</summary>
        </member>
        <member name="F:NAnt.Core.Project.BuildFileURI">
            <summary>
            The URI form of the current Document
            </summary>
        </member>
        <member name="F:NAnt.Core.Project.ProjectName">
            <summary>The name of the project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.Verbose">
            <summary>When true tasks should output more build log messages.</summary>
        </member>
        <member name="F:NAnt.Core.Project.DefaultTargetName">
            <remarks>
              <para>Used only if BuildTargets collection is empty.</para>
            </remarks>
        </member>
        <member name="F:NAnt.Core.Project.Properties">
             <summary> The NAnt Properties.</summary>
            
             <remarks>
               <para>This is the collection of Properties that are defined by the system and property task statements.</para>
               <para>These properties can be used in expansion.</para>
             </remarks>
        </member>
        <member name="F:NAnt.Core.Project.NamedObjects">
            <summary>Collection of named objects used by this project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.NamedOptionSets">
            <summary>The named option sets in this project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.NamedFileSets">
            <summary>The named file sets in this project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.UserTasks">
            <summary>The user defined tasks included in this this project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.Targets">
            <summary>The targets defined in the this project.</summary>
        </member>
        <member name="F:NAnt.Core.Project.BuildTargetNames">
            <summary>The list of target names to built.</summary>
            <remarks>
              <para>Targets are built in the order they appear in the collection.  If the collection is empty the default target will be built.</para>
            </remarks>
        </member>
        <member name="F:NAnt.Core.Project.TraceEcho">
            <summary>When true all echo instructions will display their location.</summary>
        </member>
        <member name="F:NAnt.Core.Project.Nested">
            <summary>True if the project is nested. Default is false.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnBuildStarted(NAnt.Core.Events.ProjectEventArgs)">
            <summary>Signals that a build has started. This event is fired before any targets have started.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnBuildFinished(NAnt.Core.Events.ProjectEventArgs)">
            <summary>Signals that the last target has finished. This event will still be fired if an error occurred during the build.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnTargetStarted(NAnt.Core.Events.TargetEventArgs)">
            <summary>Signals that a target has started.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnTargetFinished(NAnt.Core.Events.TargetEventArgs)">
            <summary>Signals that a target has finished. This event will still be fired if an error occurred during the build.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnTaskStarted(NAnt.Core.Events.TaskEventArgs)">
            <summary>Signals that a task has started.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnUserTaskStarted(NAnt.Core.Events.TaskEventArgs)">
            <summary>Signals that a user task has started.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnUserTaskFinished(NAnt.Core.Events.TaskEventArgs)">
            <summary>Signals that a user task has finished. This event will still be fired if an error occurred during the build.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnTaskFinished(NAnt.Core.Events.TaskEventArgs)">
            <summary>Signals that a task has finished. This event will still be fired if an error occurred during the build.</summary>
        </member>
        <member name="M:NAnt.Core.Project.OnTaskDiscovered(System.Object,NAnt.Core.Events.TaskBuilderEventArgs)">
            <summary>Signals that a task has been found and has been added to NAnt's list of known tasks.</summary>
        </member>
        <member name="M:NAnt.Core.Project.GlobalInit">
            <summary>
            Run this once to intialize global static cache.
            </summary>
        </member>
        <member name="M:NAnt.Core.Project.#ctor(System.String,NAnt.Core.Logging.Log.LogLevel,System.Int32,NAnt.Core.Project,System.Boolean)">
            <summary>
            Constructs a new Project with the given source.
            </summary>
            <param name="source">
            <param name="logIdentLevel"></param>
            <param name="loglevel"></param>
            <param name="parentProject"></param>
            <param name="usestderr"></param>
            <para> The Source should be the full path to the build file.</para>
            <para> This can be of any form that XmlDocument.Load(string url) accepts.</para>
            </param>
            <remarks><para>If the source is a uri of form 'file:///path' then use the path part.</para></remarks>
        </member>
        <member name="M:NAnt.Core.Project.#ctor(System.Xml.XmlDocument,NAnt.Core.Logging.Log.LogLevel,System.Int32,NAnt.Core.Project,System.Boolean)">
            <summary>
            Constructs a new Project with the given build file document.
            </summary>
            <param name="doc">A XmlDocument class containing a valid NAnt build file.</param>
        </member>
        <member name="M:NAnt.Core.Project.Run">
            <summary>
            Does Execute() and wraps in error handling and time stamping.
            </summary>
            <returns>Indication of success</returns>
        </member>
        <member name="M:NAnt.Core.Project.Execute">
            <summary>Executes the default target.</summary>
            <remarks>
                <para>No top level error handling is done. Any BuildExceptions will make it out of this method.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Project.Execute(System.String,System.Boolean,System.Boolean)">
            <summary>Executes a specific target, and only that target.</summary>
            <param name="targetName">target name to execute.</param>
            <param name="failIfTargetDoesNotExist">Fail build if target does not exist</param>
            <remarks>
              <para>Only the target is executed. No global tasks are executed.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Project.IncludeBuildFileDocument(System.Xml.XmlDocument,NAnt.Core.Location)">
            <summary>This method is only meant to be used by the <see cref="T:NAnt.Core.Project"/> class and <see cref="T:NAnt.Core.Tasks.IncludeTask"/>.</summary>
            <param name="doc">Build file xml document.</param>
            <param name="location">Should only be used if XmlDocument is not sourced from a file. Otherwise null.</param>
        </member>
        <member name="M:NAnt.Core.Project.ExpandProperties(System.String)">
            <summary>
            Expands a string from known properties
            </summary>
            <param name="input">The string with replacement tokens</param>
            <returns>The expanded and replaced string</returns>
        </member>
        <member name="M:NAnt.Core.Project.CreateTask(System.Xml.XmlNode)">
            <summary>
            Creates a new Task from the given XmlNode
            </summary>
            <param name="taskNode">The task definition.</param>
            <returns>The new Task instance</returns>
        </member>
        <member name="M:NAnt.Core.Project.CreateTask(System.Xml.XmlNode,NAnt.Core.Target)">
            <summary>
            Creates a new Task from the given XmlNode within a Target
            </summary>
            <param name="taskNode">The task definition.</param>
            <param name="target">The owner Target</param>
            <returns>The new Task instance</returns>
        </member>
        <member name="M:NAnt.Core.Project.GetFullPath(System.String)">
            <summary>Combine with project's <see cref="P:NAnt.Core.Project.BaseDirectory"/> to form a full path to file or directory.</summary>
            <returns>
              <para>A rooted path.</para>
            </returns>
            <param name="path">The relative or absolute path.</param>
        </member>
        <member name="M:NAnt.Core.Project.RunTimeInit">
            <summary>
            Initializations which are only available at run time.
            </summary>
        </member>
        <member name="M:NAnt.Core.Project.ProjectFrameworkVersion">
            <summary>
            Checks Framework version for a project. Usually, checking a package's framework version could be done
            by PackageTask, but because a project may declare other tasks before or even omit the package tag,
            doing so in PackageTask is insufficient.
            </summary>
            <returns>"2" if Manifest.xml indicates frameworkVersion 2; "1" otherwise</returns>
        </member>
        <member name="P:NAnt.Core.Project.BuildFileLocalName">
            <summary>
            If the build document is not file backed then null will be returned.
            </summary>
        </member>
        <member name="P:NAnt.Core.Project.LogPrefix">
            <summary>The prefix used when sending messages to the log.</summary>
        </member>
        <member name="P:NAnt.Core.Project.LastError">
            <summary>The last error to be thrown.</summary>
        </member>
        <member name="P:NAnt.Core.Project.BaseDirectory">
            <summary>The Base Directory used for relative file references.</summary>
        </member>
        <member name="P:NAnt.Core.Project.CurrentScriptFile">
            <summary>Current script file.</summary>
        </member>
        <member name="T:NAnt.Core.LocationMap">
            <summary>Preserves compatibily with 2.05.00 version and older</summary>
        </member>
        <member name="M:NAnt.Core.Property.VerifyPropertyName(System.String)">
            <summary>Validate property name.</summary>
            <remarks>
              <para>If the property name is invalid a BuildException will be thrown.</para>
              <para>A valid property name contains any word character, '-' character, or '.' character.</para>
            </remarks>
            <param name="name">The name of the property to check.</param>
        </member>
        <member name="M:NAnt.Core.Property.GetPrefix(System.String)">
            <summary>Get the prefix of the specified property name.</summary>
            <example>package.Framework.dir => package.Framework</example>
        </member>
        <member name="M:NAnt.Core.Property.GetSuffix(System.String)">
            <summary>Get the suffix of the specified property name.</summary>
            <example>package.Framework.dir => dir</example>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.EvaluateParameter(System.String)">
            <summary>
            Property evaluator callback without deprecated functions.
            </summary>
            <param name="name">The name of the property to evaluate.</param>
            <returns>The paramters evalued value.</returns>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.EvaluateFunction(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Function evaluator callback for running functions.
            </summary>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.ExpandProperties(System.String)">
            <summary>Expands a string with macros.</summary>
            <param name="expression">The string with macros to expand.</param>
            <returns>The string with all macros expanded.</returns>
        </member>
        <member name="T:NAnt.Core.Reflection.PropertyConverter.BoolConverter">
            <summary>
            Special case booleans to handle expressions
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.AttribTask">
            <summary>Changes the file attributes of a file or set of files.</summary>
            <remarks>
              <para>The <c>attrib</c> task does not conserve prior file attributes.  Any specified file 
              attributes are set; all other attributes are switched off.</para>
            </remarks>
            <example>
<para>Set the <c>ReadOnly</c> attribute to true for the specified file.</para>
<code>
<![CDATA[
<project>
    <touch file="foo.txt"/>
    <attrib file="foo.txt" readonly="true"/>
    <fail 
        message="'foo.txt' not set to readonly."
        unless="@{FileCheckAttributes('foo.txt', 'ReadOnly')}"
        />
</project>
]]>
</code>
</example>
            <example>
<para>Clean any flags on the specified file.</para>
<code>
<![CDATA[
<project>
    <touch file="foo.txt"/>

    <!-- first let's add some attributes -->
    <attrib file="foo.txt" readonly="true" hidden="true"/>

    <!-- now let's clear them -->
    <attrib file="foo.txt" normal="true"/>
    <fail 
        message="'foo.txt' not set to readonly."
        if="@{FileCheckAttributes('foo.txt', 'ReadOnly Hidden')}"
        />
</project>
]]>
</code>
</example>
            <example>
<para>Set the normal file attributes to all executable files in the current 
directory and sub-directories.</para>
<code>
<![CDATA[
<project>
    <attrib normal="true">
        <fileset>
            <includes name="**/*.exe"/>
            <includes name="**/*.dll"/>
        </fileset>
    </attrib>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.FileName">
            <summary>The name of the file which will have its attributes set.  This is provided as an alternate to using the task's fileset.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.AttribFileSet">
            <summary>All the files in this fileset will have their file attributes set.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.ArchiveAttrib">
            <summary>Set the archive attribute.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.HiddenAttrib">
            <summary>Set the hidden attribute.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.NormalAttrib">
            <summary>Set the normal file attributes.  This attribute is valid only if used alone.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.ReadOnlyAttrib">
            <summary>Set the read only attribute.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.SystemAttrib">
            <summary>Set the system attribute.  Default is "false".</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.CallTask">
            <summary>
            Calls a NAnt target.  BEWARE default 'force' behavior differs between Framework
            1 and 2 packages.
            </summary>
            <example>
<para>Call the target "build".</para>
<code>
<![CDATA[
<project default="run">
	<target name="build">
		<echo message="Hello, Build!"/>
	</target>

	<target name="run">
		<call target="build"/>
	</target>
</project>
]]>
</code>
</example>
            <example>
<para>This shows how a project could 'compile' a debug and release build using a common compile target.</para>
<code>
<![CDATA[
<project default="build">
    <target name="compile">
      <echo message="compiling with debug = ${debug}"/>
    </target>

    <target name="build">
        <property name="debug" value="false"/>
        <call target="compile"/>
        <property name="debug" value="true"/>
        <call target="compile" force="true"/> <!-- notice the force attribute -->
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CallTask.TargetName">
            <summary>NAnt target to call.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CallTask.ForceExecute">
            <summary>Force an Execute even if the target 
            has already been executed.  Forced execution occurs on a copy of the unique
            target, since the original can only be executed once.
            Default value is false for a Framework 1 package,
            but true for a Framework 2 package.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ChooseTask">
            <summary>
            The <c>choose</c> task is used in conjuction with the <c>do</c> task to express multiple conditional 
            statements.
            </summary>
            <remarks>
              <para>
              The code of the first, and only the first, <c>do</c> task whose expression evaluates to true is executed.
              </para>
            </remarks>
            <example>
<para>If / Else conditional.</para>
<code>
<![CDATA[
<project>
    <property name='a' value='true' />

    <choose>
        <do if='${a}'>
            <echo message='a is true' />
        </do>
        <do>
            <echo message='a is false' />
        </do>
    </choose>    
</project>
]]>
</code>
</example>
            <example>
<para>If / ElseIf / Else conditional.</para>
<code>
<![CDATA[
<project>
    <property name='a' value='false' />
    <property name='b' value='true' />

    <choose>
        <do if='${a}'>
            <echo message='a is true' />
        </do>
        <do if='${b}'>
            <echo message='a is false and b is true' />
        </do>
        <do>
            <echo message='a is false and b is false' />
        </do>
    </choose>    
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.CopyTask">
            <summary>Copies a file or file set to a new location.</summary>
            <remarks>
              <para>
              By default, files are copied if the source file is newer than the destination file, or if the 
              destination file does not exist. However, you can explicitly overwrite (newer) files with the 
              <c>overwrite</c> attribute set to true.</para>
              <para>
              A file set, defining groups of files using patterns, can be copied if 
              the <c>todir</c> attribute is set.  All the files matched by the file set will be 
              copied to that directory, preserving their associated directory structure.
              Beware that <c>copy</c> handles only a single fileset, but note that
              a fileset may include another fileset.
              </para>
              <para>Any directories are created as needed by the <c>copy</c> task.</para>
            </remarks>
            <example>
<para>Copy a single file.</para>
<code>
<![CDATA[
<project>
    <echo file="source.txt">A temp file.</echo>
    <copy file="source.txt" tofile="destination.txt"/>
    <fail message="File did not copy." unless="@{FileExists('destination.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Copy a set of files to a new directory.</para>
<code>
<![CDATA[
<project>
    <!-- create some test files -->
    <touch file="a.txt"/>
    <touch file="b.txt"/>
    <touch file="c.txt"/>
    
    <!-- copy the files to new directory (directory will get created) -->
    <copy todir="sub">
        <fileset>
            <includes name="*.txt"/> 
        </fileset>
    </copy>

    <!-- make sure the files got copied -->    
    <fail unless="@{FileExists('sub/a.txt')}"/>
    <fail unless="@{FileExists('sub/b.txt')}"/>
    <fail unless="@{FileExists('sub/c.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Copy a set of files in a different basedirectory to a new directory.</para>
<code>
<![CDATA[
<project>
    <!-- create some test files -->
    <mkdir dir="source/foo"/>
    <mkdir dir="source/bar"/>
    <touch file="source/foo/a.txt"/>
    <touch file="source/bar/b.txt"/>
    <fail message="Source file not in expected location" unless="@{FileExists('source/foo/a.txt')}"/>
    
    <!-- copy the files to new directory (directory will get created) -->
    <copy todir="sub">
        <fileset basedir="source">
            <includes name="**/*.txt"/> 
        </fileset>
    </copy>

    <!-- make sure the files got copied -->    
    <fail message="Destination file not in expected location" unless="@{FileExists('sub/foo/a.txt')}"/>
    <fail message="Destination file not in expected location" unless="@{FileExists('sub/bar/b.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Test to show how specifying duplicate source files doesn't cause problems.</para>
<code>
<![CDATA[
<project>
    <echo file="source.txt">A temp file.</echo>
    <copy todir="out">
        <fileset>
            <includes name="Source.txt"/>
            <includes name="Source.txt"/>
            <includes name="*/**.txt"/>
        </fileset>
    </copy>
    <fail message="File did not copy." unless="@{FileExists('out/source.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Example of &lt;copy&gt; task with flatten set to true.</para>
<code>
<![CDATA[
<project>
    <property name="srcDir" value="${nant.location}\..\config"/>
    <echo message="Copying NAnt's config folder to temp"/>
    <mkdir dir="temp"/>
    <copy todir="temp" flatten="true">
        <fileset basedir="${srcDir}">
            <includes name="**/*.*"/>
        </fileset>
    </copy>
    <echo>Folder temp has @{DirectoryGetFileCount('temp', '*.*')} files</echo>
    <echo>Deleting temp</echo>
    <delete dir="temp" failonerror="false"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.CopyTask.DoFileOperations">
            <summary>
            Actually does the file (and possibly empty directory)
            transfers.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.SourceFile">
            <summary>The file to transfer in a single file transfer operation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.ToFile">
            <summary>The file to transfer to in a single file transfer operation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.ToDirectory">
            <summary>The directory to transfer to, when transfering a file set.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.Overwrite">
            <summary>Overwrite existing files even if the destination files are newer. Defaults is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.Clobber">
            <summary>Allow hidden and read-only files to be overwritten if appropriate (i.e. if source is newer or overwrite is set to true). Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.MaintainAttributes">
            <summary>Maintain file attributes of overwritten files. By default and if destination file does not exist file attributes are caried over from source file. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.Flatten">
            <summary>Flatten directory structure when transfering a file set. All files are placed in the <i>todir</i>, without duplicating the directory structure.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.RetryCount">
            <summary>Number of times to retry the copy operation if copy fails.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.RetryDelay">
            <summary>Length of time in milliseconds between retry attempts.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.HardLink">
            <summary>Tries to create a hard link to the source file rather than copying the entire contents of the file.
            If unable to create a hard link it simply copies the file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.CopyFileSet">
            <summary>The (single) file set to be copied.  
            Note the todir attribute must be set, and that a fileset 
            may include another fileset.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.RunTask">
            <summary>
            Executes a task created by &lt;createtask&gt;. 
            </summary>
            <remarks>
            
            <para>Use &lt;createtask&gt; to create a new 'task' that is made of Nant 
            script.  Then use the &lt;task&gt; task to call that task with the required parameters.</para>
            
            <para>Each parameter may be either an attribute (eg. Message in example below) or a nested text element
            (eg. DefList in example below) that allows multiple lines of text.  Multiple lines may be needed for certain task elements like
            &lt;includedirs&gt;, &lt;usingdirs&gt;, and &lt;defines&gt; in &lt;cc&gt;.	</para>
            </remarks>
            <example>
<para>Test to show how to use &lt;createtask&gt; and &lt;task&gt;.</para>
<code>
<![CDATA[
<!-- testtask.build -->
<project>
	<property name="propdefs">
	DEFINE1
	DEFINE2
	</property>
	
    <createtask name="TestTask">
        <parameters>
            <option name="Message" value="Required"/>
            <option name="DefList" value="Required"/>
        </parameters>
        <code>
            <echo message="${TestTask.Message}"/>
		    <dependent name="VisualStudio"/>
			<cc >
				<defines>
				TEST_DEF
				${TestTask.DefList}
				</defines>
				<sources>
					<includes name="test.cpp"/>
				</sources>
			</cc>
        </code>
    </createtask>

    <foreach item="OptionSet" in="Task.TestTask.Parameters" property="parameter">
        <echo message="${parameter.name} = ${parameter.value}"/>
    </foreach>

    <echo message="${Task.TestTask.Code}"/>

    <task name="TestTask" Message="@{DateTimeToday()}">
		<DefList>
		TEST_DEFINITION
		TEST_DEFINE
		${propdefs}
		</DefList>
	</task>
   
</project>
]]>
</code>

<code file="Manifest.xml">
<![CDATA[
<!-- manifest.xml -->
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>

<code file="masterconfig.xml">
<![CDATA[
<!-- masterconfig.xml -->
<project>
	<masterversions>
		<package name="VisualStudio" version="7.1.1-5"/>
		<package name="Framework" version="dev"/>
	</masterversions>
	<config package="Framework" default="win-release"/>
</project>
]]>
</code>

<code file="test.cpp">
<![CDATA[
//test.cpp
#ifndef TEST_DEFINE
#error TEST_DEFINE not defined
#endif
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.RunTask.TaskName">
            <summary>The name of the task being declared.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RunTask.ParameterValues">
            <summary>
            The parameters to be passed to &lt;createtask&gt;
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.CreateTaskTask">
            <summary>Create a task that is made of Nant script and can be used by &lt;task&gt;. <b>This task is a Framework 2
            feature.</b>
            </summary>
            <remarks>
            
            <para>Use the &lt;createtask&gt; to create a new 'task' that is made of Nant 
            script.  Then use the &lt;task&gt; task to call that task with the required parameters.</para>
            
            <para>The following unique properties will be created, for use by &lt;task&gt;:</para>
            <list type="bullet">
            <item><b>Task.{name}</b></item>
            <item><b>Task.{name}.Code</b></item>
            </list>
            The following named optionset will be created, for use by &lt;task&gt;:
            <list type="bullet">
            <item><b>Task.{name}.Parameters</b></item>
            </list>
            </remarks>
            <example>
                <code>
            &lt;createtask name="BasicTask"&gt;
               &lt;parameters&gt;
                   &lt;option name="DummyParam" value="Required"/&gt;
                   &lt;option name="Indentation"/&gt;
               &lt;/parameters&gt;
               &lt;code&gt;
                   &lt;echo message="${BasicTask.Indentation}Start BasicTask."/&gt;
                   &lt;echo message="${BasicTask.Indentation}    DummyParam value = ${BasicTask.DummyParam}"/&gt;
                   &lt;echo message="${BasicTask.Indentation}Finished BasicTask."/&gt;
               &lt;/code&gt;
            &lt;/createtask&gt;
                </code>
            </example>
            <example>
<para>Test to show how to use &lt;createtask&gt; and &lt;task&gt;.</para>
<code>
<![CDATA[
<!-- testtask.build -->
<project>
	<property name="propdefs">
	DEFINE1
	DEFINE2
	</property>
	
    <createtask name="TestTask">
        <parameters>
            <option name="Message" value="Required"/>
            <option name="DefList" value="Required"/>
        </parameters>
        <code>
            <echo message="${TestTask.Message}"/>
		    <dependent name="VisualStudio"/>
			<cc >
				<defines>
				TEST_DEF
				${TestTask.DefList}
				</defines>
				<sources>
					<includes name="test.cpp"/>
				</sources>
			</cc>
        </code>
    </createtask>

    <foreach item="OptionSet" in="Task.TestTask.Parameters" property="parameter">
        <echo message="${parameter.name} = ${parameter.value}"/>
    </foreach>

    <echo message="${Task.TestTask.Code}"/>

    <task name="TestTask" Message="@{DateTimeToday()}">
		<DefList>
		TEST_DEFINITION
		TEST_DEFINE
		${propdefs}
		</DefList>
	</task>
   
</project>
]]>
</code>

<code file="Manifest.xml">
<![CDATA[
<!-- manifest.xml -->
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>

<code file="masterconfig.xml">
<![CDATA[
<!-- masterconfig.xml -->
<project>
	<masterversions>
		<package name="VisualStudio" version="7.1.1-5"/>
		<package name="Framework" version="dev"/>
	</masterversions>
	<config package="Framework" default="win-release"/>
</project>
]]>
</code>

<code file="test.cpp">
<![CDATA[
//test.cpp
#ifndef TEST_DEFINE
#error TEST_DEFINE not defined
#endif
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.TaskName">
            <summary>The name of the task being declared.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.Overload">
            <summary>Overload existing definition.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.Parameters">
            <summary>The set of task parameters.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.Code">
            <summary>
            The Nant script this task is made out from
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DeleteTask">
            <summary>Deletes a file, file set or directory.</summary>
            <remarks>
              <para>Deletes either a single file, all files in a specified directory and its sub-directories, or a set of files specified by one or more file sets.</para>
              <note>If the file attribute is set then the file set contents will be ignored.  To delete the files in the file set, omit the file attribute in the delete element.</note>
              <note>All items specified including read-only files and directories are 
              deleted.  If an item cannot be deleted because of some other reason 
              the task will fail if "failonmissing" is true.</note>
            </remarks>
            <example>
<para>Delete a single file.  If the file does not exist the task does nothing.</para>
<code>
<![CDATA[
<project>
    <touch file="foo.txt"/>
    <delete file="foo.txt"/>
    <fail if="@{FileExists('foo.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Delete a directory and the contents within.  If the directory does not 
exist the task will fail.</para>
<code>
<![CDATA[
<project>
    <mkdir dir="c:\bar69"/>
    <touch file="c:\bar69\one.txt"/>
    <touch file="c:\bar69\two.txt"/>
    <delete dir="c:\bar69" failonmissing="true"/>
    <fail if="@{DirectoryExists('c:\bar69')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Delete a set of files.</para>
<code>
<![CDATA[
<project>
    <touch file="apple.txt"/>
    <touch file="banana.txt"/>
    <touch file="carot.bin"/>
    <delete>
        <fileset>
            <includes name="*.txt"/>
        </fileset>
    </delete>
    <fail if="@{FileExists('apple.txt')}"/>
    <fail unless="@{FileExists('carot.bin')}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.DeleteTask.SetAllFileAttributesToNormal(System.String)">
            <summary>For each file and directory in the given path set the file attributes to Normal.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.FileName">
            <summary>The file to delete. Applies only to the single file delete operation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.DirectoryName">
            <summary>The directory to delete.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.FailOnMissing">
            <summary>If true the task will fail if a file or directory specified is not present.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.Quiet">
            <summary>If true then be quiet - don't report on the deletes. Default is false</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.DeleteFileSet">
            <summary>All the files in the file set will be deleted.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DependsTask">
            <summary>Performs a generic dependency check.</summary>
            <remarks>
            <para>When properly used, this task sets the specified property to true if any file in the <c>inputs</c> is newer than any
            file in the <c>outputs</c> fileset.</para>
            <para>
            Proper usage requires that at least one file needs to be present in the inputs fileset, as well as the outputs fileset.  
            </para>
            <para>
            If either fileset is empty, the property will be set to true.
            Note that a fileset can be empty if it includes a nonexistent file(name) "asis" 
            (by setting the attribute asis="true").
            Since the asis attribute is false by default, it's impossible to create
            a fileset that includes a nonexistent file without overriding asis.
            </para>
            <para>
            Additionally, if any file included in the outputs fileset does not exist, the 
            property will be set to true.</para>
            </remarks>
            <example>
<para>Shows how to setup basic dependency checking for any task.  
Notice the use of the <see cref="T:NAnt.Core.Tasks.TouchTask"/> to create a persistent file.  
This is useful if you are doing recursive builds.  
Remember to create the -start file at the start of your build using 
another <see cref="T:NAnt.Core.Tasks.TouchTask"/> instance.  
Note that if the depends task was not used, the core-build target would keep 
getting called because of the recursive nature of the build.</para>
<code file="fruit.build">
<![CDATA[
<project default="build">
    <touch file="start"/>

    <target name="build" depends="apple banana">
        <fail unless="@{FileExists('apple')}"/>
        <fail unless="@{FileExists('banana')}"/>
    </target>

    <target name="apple">
        <nant buildfile="core.xml" target="apple-build"/>
    </target>

    <target name="banana">
        <nant buildfile="core.xml" target="banana-build"/>
    </target>
</project>
]]>
</code>
<para>Where <c>core.xml</c> contains:</para>
<code file="core.xml">
<![CDATA[
<project>
    <target name="core">
        <depends property="needs-building">
            <inputs>
                <includes name="start"/>
            </inputs>
            <outputs>
                <includes name="core-built"/>
            </outputs>
        </depends>
        <nant 
            if="${needs-building}" 
            buildfile="core.xml" target="core-build"
            />
        <touch file="core-built"/>
    </target>

    <target name="apple-build" depends="core">
        <echo message="Building apple"/>
        <touch file="apple"/>
    </target>

    <target name="banana-build" depends="core">
        <echo message="Building banana"/>
        <touch file="banana"/>
    </target>

    <target name="core-build">
        <echo message="Building core"/>
        <touch file="core"/>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.DependsTask.TaskNeedsRunning">
            <summary>Determine if the task needs to run.</summary>
            <returns><c>true</c> if we should run the program (dependents missing or not up to date), otherwise <c>false</c>.</returns>
        </member>
        <member name="P:NAnt.Core.Tasks.DependsTask.PropertyName">
            <summary>The property name to set to hold the result of the dependency check.  The value in 
            this property after the task has run successfully will be either <c>true</c> or 
            <c>false</c>.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DependsTask.Inputs">
            <summary>Set of input files to check against.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DependsTask.Outputs">
            <summary>Set of output files to check against.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DoOnce">
            <summary>Container task. Executes nested elements once for a given unique key and a context.</summary>
            <remarks>
            do.once task is thread safe.
            This task acts within single nant process. It can not cross nant process boundary.
            </remarks>
            <example>
               &lt;do.once key="package.TestPackage.echo_message" context="global"&gt;
                &lt;do if="${config-system}==pc"/&gt;
                     &lt;Generate-PC-Code/&gt;
                &lt;/do&gt;
             &lt;/do.once&gt;
            </example>
        </member>
        <member name="P:NAnt.Core.Tasks.DoOnce.Key">
            <summary>Unique key string. When using global context make sure that key string does 
            not collide with keys that may be defined in other packages. 
            Using "package.[package name]." prefix is a good way to ensure unique values.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DoOnce.Context">
            <summary>
            Context for the key. Context can be either <b>global</b> or <b>project</b>. Default value is <b>global</b>.
            <list type="bullet">
            <item><b>global</b> context means that for each unique key task is executed once in nant process.</item>
            <item><b>project</b> context means that for each unique key task is executed once for each package.</item>
            </list>
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DoOnce.IsBlocking">
            <summary>
            Defines behavior when several instances of do.once task with the same key are invoked simultaneously.
            <list type="bullet">
            <item><b>blocking=false</b> (default) - One instance will execute nested elements, other instances will return immediately without waiting.</item>
            <item><b>blocking=false</b> - One instance will execute nested elements, other instances will wait for the first instance to complete and
            then return without executing nested elements.</item>
            </list>
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DoTask">
            <summary>Allows wrapping of a group of tasks to be executed based on a conditional.</summary>
            <remarks>
            <para>Use the do task in conjunction with the if and unless attributes to execute a series
            of tasks based on the condition.</para>
            <para>Another use for the task is when you want to execute a task only if a property is
            defined.  Normally nant will try to expand the property at the same time performing
            the if/unless condition check.</para>
            </remarks>
            <example>
<para>Simple example of wrapping a series of tasks with a single condition.</para>
<code>
<![CDATA[
<project>
    <do if="true">
        <echo message="Hello, World!"/>
        <echo message="Goodbye, Cruel World!"/>
    </do>
</project>
]]>
</code>
</example>
            <example>
<para>Shows how to execute a task that takes a property but only if that property is defined.</para>
<code>
<![CDATA[
<project>
    <property name="foo" value="bar"/>
    <do if="@{PropertyExists('foo')}">
        <echo message="${foo}"/>
    </do>
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.EchoTask">
            <summary>Writes a message to the build log.</summary>
            <remarks>
              <para>A copy of the message will be sent to every defined
            build log and logger on the system.  Property references in the message will be expanded.</para>
            </remarks>
            <example>
<para>Writes message to build log.</para>
<code>
<![CDATA[
<project>
    <echo message="Hello, World!"/>
</project>
]]>
</code>
</example>
            <example>
<para>Writes message with expanded macro to build log using the implicit text element.</para>
<code>
<![CDATA[
<project>
    <echo>Base build directory = ${nant.project.basedir}</echo>
</project>
]]>
</code>
</example>
            <example>
<para>Writes messages to a named file, instead of the build log.</para>
<para>Remember that the <c>append</c> attribute defaults to <i>false</i>, 
so by default echoing a message to a file will create a new instance of 
that file, destroying any previously existing version.</para>
<code>
<![CDATA[
<project>
	<echo message="Everyone Talks About Whether Nobody Does Anything" file="irony.out" />
	<echo message="On a clear disk, you can seek forever." file="irony.out" append="true" />
</project>
]]>
</code>
<para>After this build file executes, the file <c>irony.out</c> will
contain </para>
<![CDATA[
Everyone Talks About Whether Nobody Does Anything
On a clear disk, you can seek forever.
]]>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.EchoTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes the task.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.Message">
            <summary>The message to display.  For longer messages use the inner text element of the task.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.FileName">
            <summary>The name of the file to write the message to.  If empty write message to log.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.Append">
            <summary>Indicates if message should be appended to file.  Default is "false".</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.EvalTask">
            <summary>Evaluate a block of code.</summary>
            <remarks>
            The eval task will evaluate a specified block of code and optionally store the result in a property. If 
            no property name is specified the result ignored. This task is useful for running functions which do not 
            require output.
            </remarks>
            <example>
<para>Evaluate a Function.</para>
<code>
<![CDATA[
<project>
    <property name='p' />
    <eval code="@{PropertyUndefine('p')}" type="Function" />
</project>
]]>
</code>
</example>
            <example>
<para>Evaluate a Property and place the result in a property.</para>
<code>
<![CDATA[
<project>
    <property name='a' value='Hello' />
    <property name='b' value='World' />
    
    <eval property='x' code="${a}, ${b}" type="Property" />
    <echo message='${x}' />
</project>
]]>
</code>
</example>
            <example>
<para>Evaluate an Expression and place the result in a property.</para>
<code>
<![CDATA[
<project>
    <eval property='x' code="1 == 0" type="Expression" />
    <echo message='${x}' />
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.EvalTask.Code">
            <summary>The code to evaluate.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EvalTask.Type">
            <summary>The type of code to evaluate. Valid values are <c>Property</c>, <c>Function</c> and <c>Expression</c>.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EvalTask.PropertyName">
            <summary>The name of the property to place the result into. If none is specifed result is ignored.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ExecTask">
             <summary>Executes a system command.</summary>
             <remarks>
             <para>Any options in the <c>env</c> option set get added as environment variables when
             the program is run.</para>
            
             <para>You can use <![CDATA[<arg value="switch"/> or <arg file="filename.txt"/>]]> to
             specify command line options in a more manageable way. The values in these elements get
             appended to whatever value is in the commandline attribute if that attribute exists.
             File values specified using the <c>file</c> attribute get expanded to their full paths.</para>
            
             <para>The <c>inputs</c> and <c>outputs</c> file sets allow you to perform dependency checking.
             The <c>program</c> will only get executed if one of the inputs is newer than all of the
             outputs.</para>
             
             <para>After each <see cref="T:NAnt.Core.Tasks.ExecTask"/> task is completed the read-only property <c>${exec.exitcode}</c> 
             is set to the value that the process specified when it terminated. The default value is -1 and 
             is specified when the process fails to return a valid value.</para>
            
             <para>Note: By default errors will not be generated if files are missing from the output file
             set.  Normally filesets will throw a build exception if a specifically named file does not
             exist.  This behaviour is controlled by the <c>failonmissing</c> file set attribute, which
             defaults to <c>true</c>.  If set to <c>false</c>, no build exception will be thrown when a
             specifically named file is not found.</para>
            
             <para>Note: Dependency checking requires at least one file in the <c>inputs</c> fileset and one
             file in the <c>outputs</c> fileset.  If either of these filesets is empty, no dependency
             checking will be performed.</para>
             </remarks>
             <example>
<para>Run nant and display its help.</para>
<code>
<![CDATA[
<project>
    <exec program="nant" commandline="-help"/>
</project>
]]>
</code>
</example>
             <example>
<para>Use of the <c>arg</c> element and environment variables in the <c>env</c> option set.</para>
<code>
<![CDATA[
<project>
	<!-- get sys.env.PATH, among other system properties -->
	<sysinfo/>
	
    <exec program="cmd.exe">
        <args>
            <arg value="/c echo"/>
            <arg value="Hello, %MyName%!"/>
        </args>
        <env>
            <option name="MyName" value="Paul"/>
			<option name="PATH" value="${sys.env.PATH};c:\phoenix;"/>
        </env>
    </exec>
</project>
]]>
</code>
</example>
             <example>
<para>This is an example of using the <c>inputs</c> and <c>outputs</c> file sets to perform
dependency checking.  The program will be executed if the files in the inputs are newer
than the files in the outputs.  This example also shows how to redirect standard output to a file.</para>
<code>
<![CDATA[
<project>
    <touch file="in.0.txt"/>
    <touch file="in.1.txt"/>
    <exec program='cmd.exe' output="out.txt">
        <args>
            <arg value='/c echo ${exec.inputs.0} ${exec.inputs.1}'/>
        </args>
        <inputs failonmissing='false'>
            <includes name='in.*.txt'/>
        </inputs>
        <outputs>
            <includes name='out.txt' asis='true'/>
        </outputs>
    </exec>
    <fail message="out.txt file was not created" unless="@{FileExists('out.txt')}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.ExternalProgramBase">
            <summary>Provides the abstract base class for tasks that execute external applications.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.GetCommandLine">
            <summary>Get the command line arguments, separated by spaces.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.PrepareProcess(System.Diagnostics.Process@)">
            <summary>
            Sets the StartInfo Options and returns a new Process that can be run.
            </summary>
            <returns>new Process with information about programs to run, etc.</returns>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.LogStdOut(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stdout</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.LogStdErr(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stderr</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.ProgramFileName">
            <summary>Gets the application to start.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.ProgramArguments">
            <summary>Gets the command line arguments for the application.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.OutputFile">
            <summary>The file to which the standard output will be redirected.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.OutputAppend">
            <summary>True if the output file is to be appended to.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.Stdout">
            <summary>Write to standard output. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.RedirectOut">
            <summary>Redirect standard output. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.RedirectIn">
            <summary>Redirect standard input. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.CreateInWindow">
            <summary>Whether to create process in its own window. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.Quiet">
            <summary>If true standard output from the external program will not be written to log.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.ExitCode">
            <summary>Returns the exit code of the process once it has run. Default is -1.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.BaseDirectory">
            <summary>Gets the working directory for the application.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.TimeOut">
            <summary>The maximum amount of time the application is allowed to execute, expressed in milliseconds.  Defaults to no time-out.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.Args">
            <summary>Get the command line arguments for the application.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExecTask.TaskNeedsRunning">
            <summary>Determine if the task needs to run.</summary>
            <returns><c>true</c> if we should run the program (dependents missing or not up to date), otherwise <c>false</c>.</returns>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Program">
            <summary>The program to execute. Specify the fully qualified name unless the program is in the path.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Message">
            <summary>The message to display to the log.  If present then no other output will be displayed unless there is an error or the verbose attribute is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Arguments">
            <summary>The command line arguments for the program.  Consider using <c>arg</c> elements (see task description) for improved readability.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.ResponseFile">
            <summary>Use the contents of this file as input to the program.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.CommandLineTemplate">
            <summary>The template used to form the command line. Default is '%commandline% %responsefile%'.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Output">
            <summary>The file to which the standard output will be redirected. By default, the standard output is redirected to the console.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Append">
            <summary>true if the output file is to be appended to. Default = "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Stdout">
            <summary>Write to standard output. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.RedirectOut">
            <summary>Set true to redirect stdout and stderr. When set to false, this will disable options such as stdout, outputfile etc.  Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.RedirectIn">
            <summary>Set true to redirect stdin. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.CreateInWindow">
            <summary>Set true to create process in a new window.. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.WorkingDirectory">
            <summary>The directory in which the command will be executed. The workingdir will be evaluated relative to the build file's directory.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.ClearEnv">
            <summary>Set true to clear all environmental variable before executing, environmental variable specified in env OptionSet will still be added as environmental variable.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.EnvironmentVariables">
            <summary>The set of environment variables for when the program runs.
            Benefit of setting variables, like "Path", here is that it will be
            local to this program execution (i.e. global path is unaffected).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.TimeOut">
            <summary>Stop the build if the command does not finish within the specified time.  Specified in milliseconds.  Default is no time out.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Inputs">
            <summary>Program inputs.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Outputs">
            <summary>Program outputs.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.ArgSet">
            <summary>A set of command line arguments.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FailTask">
            <summary>Exit the current build.</summary>
            <remarks>
              <para>Exits the current build optionally printing additional information.</para>
            </remarks>
            <example>
<para>Will exit the current build displaying a message if the property
<c>should-fail</c> is set to true.</para>
<code>
<![CDATA[
<project>
    <property name="should-fail" value="false"/>
    <fail if="${should-fail}" message="Because 'should-fail' was true."/>

    <trycatch>
      <try>
       <fail unless="@{FileExists(${filename})}" type="FileNotFoundException" message="File ${filename} was not found."/>
       <!-- do something with the file in ${filename}-->
      </try>
      <catch exception="FileNotFoundException">
        <echo message="File ${filename} could not be properly treated because it was not found"/>
      </catch>
    </trycatch>    
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.FailTask.Type">
            <summary>Type of the exception thrown, for further exception handling.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FailTask.Message">
            <summary>A message giving further information on why the build exited.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FileSetTask">
            <summary>
            Filesets are groups of files defined by a set of patterns.
            </summary>
            <remarks>
  <para>
    Filesets are groups of files defined by a set of patterns.
    Filesets can be specified in 2 ways:  named and unnamed.
    <para></para>
    Named filesets are created by the <c>&lt;fileset&gt;</c> task, and so are defined
    at the project level.  They are a mechanism allowing multiple tasks to reference and modify the same group of files.
    This is conceptually the same as the creation of project level properties by the <c>&lt;property&gt;</c> task.
  </para>

  <para></para>
  An unnamed fileset, also known as a fileset "element", may exist for certain tasks
  other than the <c>&lt;fileset&gt;</c> task
  (e.g. "inputs" is a fileset element in the exec task).
  But an unnamed fileset is accessible only to the task that owns it.  It can't
  be accessed by an arbitrary task; a named fileset is needed for that.

  <para>Filesets are rooted at a base directory; by default, this is the directory containing the NAnt build file. Pattern matching may be used to exclude or include specific contents and children of this directory; by default, everything but CVS-specific directories and files are included in the fileset.</para>

  <para></para>
  Attributes/parameters differ between named (task) and unnamed (element) filesets.

  <para></para>
  <b>Speed tip:</b>
  <br></br>
  Avoiding directory wildcards (\** or \*\) in filesets will speed up
  NAnt.  This would entail explicit, known folder names in the fileset though.
  Also more script is needed since directory wildcards aren't used.

  <h3>Table showing which attributes/parameters are supported</h3>
  <code>
    <![CDATA[
Attribute		FileSet Task (named)	FileSet Element (unnamed)
----------------------------------------------------------------------------
name            Yes           No
append          Yes           No
failonerror     Yes           No
verbose         Yes			No
if              Yes			No
unless          Yes			No
              
defaultexcludes No			Yes
failonmissing   No			Yes
              
basedir         Yes			Yes
fromfileset     Yes			Yes
sort            Yes     Yes

]]>
  </code>

  <h3>Syntax for named filesets</h3>
  <code>
    <![CDATA[
<fileset
  name=""
  append=""
  basedir="" 
  fromfileset="" 
  sort="" 
  if=""
  unless=""
  failonerror=""
  verbose=""
  > 
</fileset>
]]>
  </code>

  <h3>Parameters for named filesets</h3>
  <para>
    See <see taskref="fileset"/>
  </para>


  <h3>Syntax for unnamed fileset element:  exec task example</h3>
  <code>
    <![CDATA[
<exec program="cmd.exe"

  <!-- inputs is a fileset element of exec task -->
  <inputs
    basedir="" 
    fromfileset="" 
    sort="" 
    defaultexcludes=""
    failonmissing=""
    > 
  /input>
</exec>
]]>
  </code>

  <h3>Parameters for unnamed fileset element</h3>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>

    <item>
      <term>basedir</term>
      <term>The base of the directory tree defining the fileset.  Default is the directory containing the build file.</term>
      <term>No</term>
    </item>
    <item>
      <term>defaultexcludes</term>
      <term>
        <para>If "false", default excludes are not used otherwise default excludes are used.  Default is "true"</para>
        <para>
          The following patterns are excluded from filesets by default:
          <list type="bullet">
            <item>**/CVS/*</item>
            <item>**/.cvsignore</item>
            <item>**/*~</item>
            <item>**/#*#</item>
            <item>**/.#*</item>
            <item>**/%*%</item>
            <item>**/SCCS</item>
            <item>**/SCCS/**</item>
            <item>**/vssver.scc</item>
          </list>
        </para>
      </term>
      <term>No</term>
    </item>
    <item>
      <term>failonmissing</term>
      <term>Indicates if a build error should be raised if an explictly included file does not exist.  Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>Name of a fileset to include.</term>
      <term>No</term>
    </item>
    <item>
      <term>sort</term>
      <term>Indicates if the fileset contents should be sorted by file name or left in the order specified.  Default is "false".</term>
      <term>No</term>
    </item>

  </list>

  <h3>Nested Elements for both named and unnamed filesets</h3>

  <h4>&lt;group&gt;</h4>
  <para>Groups help you organize related files into groups that can be conditionally included or excluded using if/unless attributes.  Note that groups can be nested.  See below for an example.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>if</term>
      <term>If true then the task will be executed; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the task will be executed; otherwise skipped.  Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>asis</term>
      <term>If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>force</term>
      <term>If true the file name will be added to the fileset regardless if it is already included. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>optionset</term>
      <term>The name of an optionset to associate with this group of files.</term>
      <term>No</term>
    </item>
  </list>

  <h4>&lt;includes&gt;</h4>
  <para>Defines a file pattern to be included in the fileset.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>name</term>
      <term>The filename or pattern used for file inclusion.  Default specifies no file.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>
        The name of a fileset defined by the <c>&lt;fileset&gt;</c> task.  This fileset will be used for file inclusion.  Default is empty.
      </term>
      <term>No</term>
    </item>
    <item>
      <term>optionset</term>
      <term>The name of an optionset to associate with this set of includes.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfile</term>
      <term>The name of a file containing a newline delimited set of files/patterns to include.</term>
      <term>No</term>
    </item>
    <item>
      <term>asis</term>
      <term>If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>force</term>
      <term>If true a the file name will be added to the fileset regardless if it is already included. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>if</term>
      <term>If true then the task will be executed; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the task will be executed; otherwise skipped. Default is "false".</term>
      <term>No</term>
    </item>
  </list>

  <h4>&lt;excludes&gt;</h4>
  <para>Defines a file pattern of files to be excluded from the fileset.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>name</term>
      <term>The patterns used for file exclusion.  Default specifies no file.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>The name of a fileset defined by the &lt;fileset&gt; task.  This fileset will be used for file exclusion.  Default is empty.</term>
      <term>No</term>
    </item>
    <item>
      <term>optionset</term>
      <term>The name of an optionset to associate with this set of excludes.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfile</term>
      <term>The name of a file containing a newline delimited set of files/patterns to exclude.</term>
      <term>No</term>
    </item>
    <item>
      <term>if</term>
      <term>If true then the task will be executed; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the task will be executed; otherwise skipped. Default is "false".</term>
      <term>No</term>
    </item>
  </list>

  <para type="point">
    <b>Note:</b> Multiple <c>includes</c> and <c>excludes</c>
    elements can be used to specify the fileset.
    The fileset will be constructed by including all the <c>includes</c> elements,
    then excluding all the <c>excludes</c> elements without considering statement order.
  </para>

  <para type="point">
    <b>Note:</b> Preceding and trailing spaces will be trimmed off from the name attribute of
    &lt;fileset&gt;.
  </para>


  <h3>Examples: named filesets</h3>
  <para>
    <b>Specifying a fileset with all the files in the base directory.</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="*.*"/> 
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset using an absolute path:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="/packages/ToUpper/2.0.0/lib/ToUpper.lib" asis='true' /> 
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset using multiple patterns:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="*.c"/> 
    <includes name="*.cpp"/> 
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset with all the files in the current folder except one:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="*.*"/> 
    <excludes name="error.log"/>
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset with groups:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <group if="${platform} == win">
        <includes name="*.*"/>
    </group>
    <excludes name="error.log"/>
</fileset>
]]>
  </code>
  <para>
    <b>
      Specifying a named fileset named <i>sourcedirs</i>:
    </b>
  </para>
  <code>
    <![CDATA[
<fileset name="sourcedirs">
    <group if="${platform} == pc-vc7">
        <includes name="sources/pc-vc7/**"/>
    </group>
    <excludes name="*~"/>
    <excludes name="*.bak"/>
</fileset>
]]>
  </code>


  <para>
    <b>Specifying a fileset from a file:</b>
  </para>
  <code>
    <![CDATA[
<project>
  <fileset name='test'>
    <includes fromfile='files.txt' />
  </fileset>

  <fail unless='@{FileSetCount("test")} == 2' 
    message='FileSet fromfile attribute failed.' />
</project>
]]>
  </code>
  <h6>files.txt for the above example:</h6>
  <code>
    <![CDATA[
01.cpp
02.cpp
]]>
  </code>


  <para>
    <b>Creates a named fileset which can be referenced by other tasks.</b>
  </para>
  <code>
    <![CDATA[
<project>
    <!-- first create some files to include in the fileset -->
    <echo file="foo.txt">foo file</echo>
    <echo file="bar.txt">bar file</echo>
    <echo file="hack.txt">hack file</echo>

    <!-- now create the fileset to include the just created files -->
    <fileset name="sources">
        <includes name="*.txt"/>
        <excludes name="hack.txt"/>
    </fileset>
</project>
]]>
  </code>


  <para>
    <b>Creates a named fileset using named groups to help organize the files a conditionally include groups of files.</b>
  </para>
  <code>
    <![CDATA[
<project>
    <!-- first create some files to include in the fileset -->
    <echo file="good.txt">A temp file</echo>
    <echo file="fast.txt">A temp file</echo>
    <echo file="hack.txt">A temp file</echo>
    
    <property name="platform" value="win"/>
    <property name="debug" value="true"/>

    <!-- now create the fileset to include the just created files -->
    <fileset name="sources">
        <!-- include these files in the 'debug' config. -->
        <group if="${platform} == win">
            <includes name="fast.txt"/>
            <!-- groups can be nested inside of each other -->
            <group if="${debug}">
                <includes name="hack.txt"/>
            </group>
        </group>
        <includes name="good.txt"/>
    </fileset>
    <fail message="fileset 'sources' should have had 3 files but instead had @{FileSetCount('sources')}." unless="@{FileSetCount('sources')} == 3"/>
</project>
]]>
  </code>

  <h2>Fileset Patterns</h2>
  <para>The patterns used for file inclusion and exclusion look like the patterns used in DOS and UNIX:</para>

  <para>
    <c>*</c> matches zero or more characters, <c>?</c> matches one character.
  </para>

  <para>
    <c>*.cs</c> matches <c>.cs</c>, <c>x.cs</c> and <c>FooBar.cs</c>, but not <c>FooBar.xml</c> (does not end with <c>.cs</c>).
  </para>

  <para>
    <c>?.cs</c>  matches <c>x.cs</c>, <c>A.cs</c>, but not <c>.cs</c> or <c>xyz.cs</c> (neither have one character before <c>.cs</c>).
  </para>

  <para>
    Combinations of <c>*</c>'s and <c>?</c>'s are allowed.
  </para>

  <para>
    Matching is done per-directory. This means that the first directory in the pattern is matched against the first directory in the path. Then the second directory in the pattern is matched against the second directory in the path, and so on. For example, when we have the pattern <c>/?abc/*/*.cs</c> and the path <c>/xabc/foobar/test.cs</c>, the first <c>?abc</c> is matched with <c>xabc</c>, then <c>*</c> is matched with <c>foobar</c>, and finally <c>*.cs</c> is matched with <c>test.cs</c>. They all match, so the path matches the pattern.
  </para>

  <para>
    To make things a bit more flexible, we add one extra feature, which makes it possible to match multiple directory levels. This can be used to match a complete directory tree, or a file anywhere in the directory tree. To do this, ** must be used as the name of a directory. When <c>**</c> is used as the name of a directory in the pattern, it matches zero or more directories.
  </para>

  <h3>Examples</h3>

  <list type="table">
    <listheader>
      <term>Pattern</term>
      <description>Match</description>
    </listheader>
    <item>
      <term>/test/**</term>
      <description>
        <para>
          Matches all files/directories under <c>/test/</c>, such as <c>/test/x.cs</c>, or <c>/test/foo/bar/xyz.html</c>, but not <c>/xyz.xml</c>.
        </para>
      </description>
    </item>
    <item>
      <term>/test/</term>
      <description>
        <para>
          Just like <c>test/**</c>.  Matches all files/directories under <c>/test/</c>, such as <c>/test/x.cs</c>, or <c>/test/foo/bar/xyz.html</c>, but not <c>/xyz.xml</c>.
        </para>
      </description>
    </item>
    <item>
      <term>**/CVS/*</term>
      <description>
        <para>Matches all files in CVS directories that can be located anywhere in the directory tree.  Matches:</para>
        <list type="bullet">
          <item>
            <c>CVS/Repository</c>
          </item>
          <item>
            <c>org/apache/CVS/Entries</c>
          </item>
          <item>
            <c>org/apache/jakarta/tools/ant/CVS/Entries</c>
          </item>
        </list>
        <para>But not:</para>
        <list type="bullet">
          <item>
            <c>org/apache/CVS/foo/bar/Entries</c>
          </item>
        </list>
        <para>
          because <c>foo/bar/</c> part does not match.
        </para>
      </description>
    </item>
    <item>
      <term>org/apache/jakarta/**</term>
      <description>
        <para>
          Matches all files in the <c>org/apache/jakarta</c> directory tree.  Matches:
        </para>
        <list type="bullet">
          <item>
            <c>org/apache/jakarta/tools/ant/docs/index.html</c>
          </item>
          <item>
            <c>org/apache/jakarta/test.xml</c>
          </item>
        </list>
        <para>But not:</para>
        <list type="bullet">
          <item>
            <c>org/apache/xyz.java</c>
          </item>
        </list>
        <para>
          because the <c>jakarta/</c> part is missing.
        </para>
      </description>
    </item>
    <item>
      <term>org/apache/**/CVS/*</term>
      <description>
        <para>Matches all files in CVS directories that are located anywhere in the directory tree under org/apache.  Matches:</para>
        <list type="bullet">
          <item>
            <c>org/apache/CVS/Entries</c>
          </item>
          <item>
            <c>org/apache/jakarta/tools/ant/CVS/Entries</c>
          </item>
        </list>
        <para>But not:</para>
        <list type="bullet">
          <item>
            <c>org/apache/CVS/foo/bar/Entries</c>
          </item>
        </list>
        <para>
          <c>foo/bar/</c> part does not match.
        </para>
      </description>
    </item>
    <item>
      <term>**/test/**</term>
      <description>
        <para>
          Matches all files that have a <c>test</c> element in their path, including <c>test</c> as a filename.
        </para>
      </description>
    </item>
  </list>
</remarks>
            
            <example>
<para>Creates a named fileset which can be referenced by other tasks.</para>
<code>
<![CDATA[
<project>
    <!-- first create some files to include in the file set -->
    <echo file="foo.txt">foo file</echo>
    <echo file="bar.txt">bar file</echo>
    <echo file="hack.txt">hack file</echo>

    <!-- now create the file set to include the just created files -->
    <fileset name="sources">
        <includes name="*.txt"/>
        <excludes name="hack.txt"/>
    </fileset>
</project>
]]>
</code>
</example>
            <example>
<para>Creates a named fileset using named groups to help organize the files a conditionally include groups of files.</para>
<code>
<![CDATA[
<project>
    <!-- first create some files to include in the file set -->
    <echo file="good.txt">A temp file</echo>
    <echo file="fast.txt">A temp file</echo>
    <echo file="hack.txt">A temp file</echo>
    
    <property name="platform" value="win"/>
    <property name="debug" value="true"/>

    <!-- now create the file set to include the just created files -->
    <fileset name="sources">
        <!-- include these files in the 'debug' config. -->
        <group if="${platform} == win">
            <includes name="fast.txt"/>
            <!-- groups can be nested inside of each other -->
            <group if="${debug}">
                <includes name="hack.txt"/>
            </group>
        </group>
        <includes name="good.txt"/>
    </fileset>
    <fail message="File set 'sources' should have had 3 files but instead had @{FileSetCount('sources')}." unless="@{FileSetCount('sources')} == 3"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.FileSetTask.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly intialize</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.FileSetName">
            <summary>Name for fileset. Preceding and trailing spaces will be trimmed off.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.Append">
            <summary>If append is true, the patterns specified by
            this task are added to the patterns contained in the
            named file set.  If append is false, the named file set contains
            the patterns specified by this task.
            Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.BaseDirectory">
            <summary>The base directory of the file set.  Default is the directory where the
            build file is located.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.FromFileSetName">
            <summary>The name of a file set to include.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.Sort">
            <summary>Sort the file set by filename. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.FailOnMissing">
            <summary>Indicates if a build error should be raised if an explictly included file does not exist.  Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyAsis">
            <summary>
            If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyOptionset">
            <summary>
            The name of an optionset to associate with this set of excludes.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyForce">
            <summary>
            If true a the file name will be added to the fileset regardless if it is already included. Default is "false".
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyDepends">
            <summary>
            <b>Invalid element in Framework</b>. Added to prevent existing scripts failing.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NAnt.Core.Tasks.FileSetTask.DummyDefaultexcludes" -->
        <!-- Badly formed XML comment ignored for member "T:NAnt.Core.Tasks.ForEachTask" -->
        <member name="P:NAnt.Core.Tasks.ForEachTask.Property">
            <summary>The property name that holds the current iterated item value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.ItemType">
            <summary>
            The type of iteration that should be done. Valid values are: 
            File, Directory, String, Line, FileSet, and OptionSet.
            When choosing the Line option, you specify a file and the task
            iterates over all the lines in the text file.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Source">
            <summary>
            The source of the iteration.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Delimiter">
            <summary>
            The deliminator string array. Default is whitespace.  
            Multiple characters are allowed.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Local">
            <summary>
            Indicates if the property that holds the iterated value is going to be defined in a local context and thus, it will be restricted to a local scope . 
            Default is false.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FuncDefTask">
            <summary>Loads functions from a specified assembly.</summary>
            <remarks>
            <para>
            NAnt can only use .NET assemblies; other types of files which
            end in .dll won't work.
            </para>
            </remarks>
            <example>
<para>Include the functions in an assembly.</para>
<code>
<![CDATA[
<project>
    <target name="init">
        <funcdef assembly="MyCustomFunctions.dll"/>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.FuncDefTask.AssemblyFileName">
            <summary>File name of the assembly containing the NAnt functions.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FuncDefTask.Override">
            <summary>
            Override function(s) with the same name.
            Default is false. When override is 'false' &lt;funcdef&gt; will fail on duplicate function names.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.IfTask">
            <summary>Checks conditional attributes.  (Deprecated)</summary>
            <remarks>
                <para>This task is deprecated.  Use the <see cref="T:NAnt.Core.Tasks.DoTask"/> with functions instead.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.IfTask.PropertyNameTrue">
            <summary>Check the property value is true.  If property does not exist a build error will occur.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.IfTask.PropertyNameExists">
            <summary>Check existance of a property.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.IfTask.TargetNameExists">
            <summary>Check existance of a target.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.IfNotTask">
            <summary>
            Opposite of if task.  (Deprecated)
            </summary>
            <remarks>
                <para>This task is deprecated.  Use the <see cref="T:NAnt.Core.Tasks.DoTask"/> with functions instead.</para>
            </remarks>
        </member>
        <member name="T:NAnt.Core.Tasks.GetTask">
            <summary>Get a particular file from a URI source.</summary>
            <remarks>
              <para>Options include verbose reporting, timestamp based fetches and controlling actions on failures.</para>
              <para>Currently, only HTTP and UNC (Windows shared directory names of the form <c>//&lt;server&gt;/&lt;directory&gt;</c>) protocols are supported. FTP support may be added when more pluggable protocols are added to the System.Net assembly.</para>
              <para>The <c>useTimeStamp</c> option enables you to control downloads so that the remote file is only fetched if newer than the local copy. If there is no local copy, the download always takes place. When a file is downloaded, the timestamp of the downloaded file is set to the remote timestamp.</para>
              <note>This timestamp facility only works on downloads using the HTTP protocol.</note>
            </remarks>
            <example>
<para>Gets the index page of the NAnt home page, and stores it in the file help/index.html.</para>
<code>
<![CDATA[
<project>
    <target name="fetch" description="Downloads the NAnt home page">
        <get src="http://nant.sourceforge.org/" dest="index.html"/>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.GetTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">Xml node used to define this task instance.</param>
        </member>
        <member name="M:NAnt.Core.Tasks.GetTask.ExecuteTask">
            <summary>This is where the work is done </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.GetTask.TouchFile(System.String,System.DateTime)">
            <summary>Set the timestamp of a named file to a specified time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.Source">
            <summary>The URL from which to retrieve a file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.Destination">
            <summary>The file where to store the retrieved file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.Proxy">
            <summary>If inside a firewall, proxy server/port information
            Format: {proxy server name}:{port number}
            Example: proxy.mycompany.com:8080 </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.ignoreErrors">
            <summary>Log errors but don't treat as fatal. ("true"/"false"). Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.useTimeStamp">
            <summary>Conditionally download a file based on the timestamp of the local copy. HTTP only. ("true"/"false"). Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.FileSet">
            <summary>FileSets are used to select files to get.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NAnt.Core.Tasks.NamedLock" -->
        <member name="P:NAnt.Core.Tasks.NamedLock.LockName">
            <summary>Unique name for the lock. All &lt;namedlock&gt; sections with same name are mutually exclusive
            Make sure that key string does not collide with names of &lt;namedlock&gt; that may be defined in other packages. 
            Using "package.[package name]." prefix is a good way to ensure unique values.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.IncludeTask">
            <summary>Include an build file.</summary>
            <remarks>
              <para>This task is used to break your build file into smaller chunks.  
              You can load a partial build file and have it included into the main 
              build file.</para>
              <note>Any global (project level) tasks in the included build file are 
              executed when this task is executed.  Tasks in target elements of the 
              included build file are only executed if that target is executed.</note>
              <note>The project element attributes in an included build
              file are ignored.</note>
              <note>If this task is used within a target, the include included file
              should not have any targets (or include files with targets).  Doing so 
              would compromise NAnt's knowledge of available targets.</note>
            </remarks>
            <example>
<para>Include the build script in the <c>other.xml</c> file.</para>
<code file="Default.build">
<![CDATA[
<project>
    <include file="Component.xml"/>
    <fail message="Included script didn't execute" unless="@{FileExists('out.txt')}"/>
</project>
]]>
</code>
<para>Where <c>Component.xml</c> contains:</para>
<code file="Component.xml">
<![CDATA[
<project>
    <echo file="out.txt" message="The component build file."/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.IncludeTask.FileName">
            <summary>Build file to include.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.IncludeTask.IgnoreMissing">
            <summary>Ignore if file does not exist</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.MailTask">
            <summary>A task to send email.</summary>
            <remarks>
            Text and text files to include in the message body may be specified as well as binary attachments.
            </remarks>
            <example>
<para>Sends an email from nant@sourceforge.net to three recipients with a subject about the 
attachments.  The body of the message will be the combined contents of body1.txt through 
body4.txt.  The body1.txt through body3.txt files will also be included as attachments.  
The message will be sent using the smtpserver.anywhere.com SMTP server.</para>
<code><![CDATA[
<project>
    <target name="sendmail" description="Send email">
        <mail 
            from="nant@sourceforge.net" 
            tolist="recipient1@sourceforge.net" 
            cclist="recipient2@sourceforge.net" 
            bcclist="recipient3@sourceforge.net" 
            subject="Msg 7: With attachments" 
            files="body1.txt,body2.txt;body3.txt,body4.txt" 
            attachments="body1.txt,body2.txt;,body3.txt" 
            mailhost="smtpserver.anywhere.com"
        />
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.MailTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">Xml node used to define this task instance.</param>
        </member>
        <member name="M:NAnt.Core.Tasks.MailTask.ExecuteTask">
            <summary>
            This is where the work is done
            </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.MailTask.ReadFile(System.String)">
            <summary>
            Reads a text file and returns the contents
            in a string
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.From">
            <summary>Email address of sender </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.ToList">
            <summary>Comma- or semicolon-separated list of recipient email addresses</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.CcList">
            <summary>Comma- or semicolon-separated list of CC: recipient email addresses </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.BccList">
            <summary> Comma- or semicolon-separated list of BCC: recipient email addresses</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Mailhost">
            <summary>Host name of mail server. Defaults to "localhost"</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Message">
            <summary>Text to send in body of email message. At least one of the fields 'files' or 'message' must be provided.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Subject">
            <summary>Text to send in subject line of email message.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Format">
            <summary>Format of the message body. Valid values are "Html" or "Text".  Defaults to "Text".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Files">
            <summary>Name(s) of text files to send as part of body of the email message. 
            Multiple file names are comma- or semicolon-separated. At least one of the fields 'files' or 'message' must be provided.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Attachments">
            <summary>Name(s) of files to send as attachments to email message.
            Multiple file names are comma- or semicolon-separated.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.MkDirTask">
            <summary>Creates a directory path.</summary>
            <remarks>
            <para>
            A directory specified with an absolute pathname will be
            created, and any parent directories in the directory path which
            do not already exist will also be created.
            </para> <para>
            A directory specified with a relative pathname will be created 
            relative to the
            location of the build file.  Any directories in the relative
            directory path which do not already exist will be created.
            </para>
            </remarks>
            <example>
<para>Create the directory "build".</para>
<code>
<![CDATA[
<project>
    <mkdir dir="build"/>
    <fail unless="@{DirectoryExists('build')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Create the directory tree "one/two/three".</para>
<code>
<![CDATA[
<project>
    <mkdir dir="one/two/three"/>
    <fail unless="@{DirectoryExists('one/two/three')}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.MkDirTask.Dir">
            <summary>The directory to create.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.MoveTask">
            <summary>Moves a file or file set to a new location.</summary>
            <remarks>
              <para>Files are only moved if the source file is newer than the destination file, or if the destination file does not exist.  This applies to files matched by a file set as well as files specified individually.</para>
              <note>You can explicitly overwrite files with the overwrite attribute.</note>
              <para>File sets are used to select groups of files to move. To use a file set, the todir attribute must be set.</para>
            </remarks>
            <example>
<para>Move a single file.</para>
<code>
<![CDATA[
<project>
    <echo file="myfile.txt" message="A file to move."/>
    <move file="myfile.txt" tofile="mytarget.txt"/>
</project>
]]>
</code>
</example>
            <example>
  <para>Move a set of files.</para>
  <code>
  <![CDATA[
  <project default="MoveFiles">
     <target name="MoveFiles">
        <mkdir dir="C:\test"/>
        <move todir="C:\test">
            <fileset basedir=".">
                <includes name="*.txt"/>
            </fileset>
        </move>
     </target>
  </project>
  ]]>
  </code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.MoveTask.DoFileOperations">
            <summary>
            Actually does the file (and possibly empty directory) moves.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.NAntTask">
            <summary>Runs NAnt on a supplied build file.</summary>
            <remarks>
                <para>This task can be used to build subprojects which have their own full build files.  See the
                <see cref="T:NAnt.Core.Tasks.DependsTask"/> for a good example on how to build sub projects only once per build.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.BuildFileName">
            <summary>The name of the *.build file to use.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.DefaultTarget">
            <summary>The target to execute.  To specify more than one target seperate targets with a space.  Targets are executed in order if possible.  Default to use target specified in the project's default attribute.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.OptionSetName">
            <summary>The name of an optionset containing a set of properties to be passed into the supplied build file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.IndentLevel">
            <summary>The log IndentLevel. Default is the current log IndentLevel + 1.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.GlobalPropertiesAction">
            <summary>
            Defines how global properties are set up in the dependent project. 
            Valid values are <b>propagate</b> and <b>initialize</b>. Default is 'propagate'.
            </summary>
            <remarks>
            <para>
            'propagate' means standard global properties propagation.
            </para>
            <para>
            when value is 'initialize' global properties in dependent project are set using values from masterconfig and nant command line
            the same way they are set at the start of nant process. Usuall used in combination with 'start-new-build'
            </para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.StartNewBuild">
            <summary>
            Start new build graph in the dependent project. Default is 'false'
            </summary>
            <remarks>
            Normally dependent project is added to the current build graph. Setting 'start-new-build' 
            to true will create new build graph in dependent project. This is useful when nant task is used to invoke separate independent build.
            </remarks>
        </member>
        <member name="T:NAnt.Core.Tasks.OptionSetTask">
            <summary>Optionset is a dictionary containing [name, value] pairs called options.</summary>
            <remarks>
  <para>
    An optionset denotes a group of options or properties.
    Optionsets can be specified in 2 ways:  named and unnamed.
  </para>
  <para></para>
  A named optionset is created by the <c>&lt;optionset&gt;</c> task, and so are defined
  at the project level.  They are a mechanism allowing multiple tasks to reference and modify the same group of options.
  This is conceptually the same as the creation of project level properties by the <c>&lt;property&gt;</c> task.

  <para></para>
  An unnamed optionset, also known as an optionset "element", may exist for certain tasks
  other than the <c>&lt;optionset&gt;</c> task
  (e.g. "env" is an optionset element in the exec task).
  But an unnamed optionset is accessible only to the task that owns it.  It can't
  be accessed by an arbitrary task; a named optionset is needed for that.

  <para></para>
  Attributes/parameters differ between named (task) and unnamed (element) optionsets.

  <h3>Table showing which attributes/parameters are supported</h3>
  <code>
    <![CDATA[
Attribute   optionset Task (named)	optionset Element (unnamed)
----------------------------------------------------------------------------
name            Yes                       No
append          Yes                       No
failonerror     Yes                       No
verbose         Yes                       No
if              Yes                       No
unless          Yes                       No
                                           
fromoptionset   Yes                       Yes

]]>
  </code>

  <h3>Syntax for named optionsets</h3>
  <code>
    <![CDATA[
<optionset
  name=""
  append=""
  fromoptionset="" 
  if=""
  unless=""
  failonerror=""
  verbose=""
  > 
</optionset>
]]>
  </code>

  <h3>Parameters for named optionsets</h3>
  <para>
    See <see taskref="optionset"/>
  </para>


  <h3>Syntax for unnamed optionset element:  exec task example</h3>
  <code>
    <![CDATA[
<exec program="cmd.exe"

  <!-- env is an optionset element of exec task -->
  <env
    fromoptionset="" 
    > 
  /env>
</exec>
]]>
  </code>

  <h3>Parameters for unnamed optionset element</h3>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>fromoptionset</term>
      <term>The name of an existing optionset to initialize from.  Default is null.</term>
      <term>No</term>
    </item>
  </list>

  <h3>Nested elements for both named and unnamed optionsets:</h3>

  <h4>&lt;option&gt;</h4>
  <para>Specifies an option in the optionset.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>if</term>
      <term>If true then the option will be added; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the option will be added; otherwise skipped.  Default is "false".</term>
      <term>No</term>
    </item>

    <item>
      <term>name</term>
      <term>The name of the option.</term>
      <term>Yes</term>
    </item>
    <item>
      <term>value</term>
      <term>
        The value of the option.  You can specify the current option value using the special <c>${option.value}</c> property.  If the option has not been defined this property will expand to an empty string.
      </term>
      <term>Yes</term>
    </item>
  </list>

  <h3>Examples of named optionsets:</h3>
  <para>Specify an optionset with 2 options.</para>
  <code>
    <![CDATA[
<project>
    <optionset name="DefaultSettings">
        <option name="foo" value="bar"/>
        <option name="nant" value="rules"/>
    </optionset>
</project>
]]>
  </code>
  <para>Specifies an optionset based on an exsting optionset and then changes the value of the second option.  Also shows how to get the value from an optionset using a function.</para>
  <code>
    <![CDATA[
<project>
    <optionset name="DefaultSettings">
        <option name="foo" value="bar"/>
        <option name="nant" value="rules"/>
    </optionset>
    <optionset name="Settings" fromoptionset="DefaultSettings">
        <option name="nant" value="${option.value} the world"/>
    </optionset>
    <echo message="nant @{OptionSetGetValue('Settings', 'nant')}"/>
</project>
]]>
  </code>
  <code>
    <![CDATA[
<project>
    <optionset name="settings">
        <option name="clean" value="exclude" />
    </optionset>

    <optionset name="defaults">
        <option name="build" value="include" />
        <option name="buildall" value="include" />
        <option name="clean" value="include" />
    </optionset>

    <echo message="settings (before):" />
    <foreach item="OptionSet" in="settings" property="option">
        <echo message="'${option.name} = '${option.value}'" />
    </foreach>
    <echo message="" />

    <!-- <optionset> used ${option.value} internally, which conflicts with the option property in <foreach> -->
    <foreach item="OptionSet" in="defaults" property="option">
        <do unless="@{OptionSetOptionExists('settings', '${option.name}')}">
            <echo message="   appending: '${option.name} = '${option.value}'" />
            <optionset name="settings" append="true">
                <option name="${option.name}" value="${option.value}" />
            </optionset>
        </do>
    </foreach>
    <echo message="" />

    <echo message="settings (after):" />
    <foreach item="OptionSet" in="settings" property="option">
        <echo message="'${option.name} = '${option.value}'" />
    </foreach>
</project>
]]>
  </code>
</remarks>
            <example>
<para>Creates a named option set which can be used by other tasks.</para>
<code>
<![CDATA[
<project>
    <optionset name="SharedLibrary">
        <option name="cc.options" value="-c -nologo"/>
        <option name="cc.program=" value="cl.exe"/>
    </optionset>
    <foreach item="OptionSet" in="SharedLibrary" property="option">
        <echo message="${option.name} = ${option.value}"/>
    </foreach>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.OptionSetTask.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly intialize</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.OptionSetTask.OptionSetName">
            <summary>The name of the option set.</summary>        
        </member>
        <member name="P:NAnt.Core.Tasks.OptionSetTask.Append">
            <summary>If append is true, the options specified by
            this option set task are added to the options contained in the
            named option set.  Options that already exist are replaced.
            If append is false, the named option set contains the options 
            specified by this option set task.
            Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.OptionSetTask.FromOptionSetName">
            <summary>The name of a file set to include.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ParallelDoTask">
            <summary>Executes nested tasks in parallel. Only immediate nested tasks are executed in parallel.
            <para>
              <b>NOTE.</b> Make sure there are no race conditions, properties with same names, etc each group.
            </para>
            <para>
              <b>NOTE.</b> local properties are local to each thread. Normal nant properties are shared between threads.
            </para>
            </summary>
            <example>
<para>Load Nant scripts in parallel.</para>
  <code>
<![CDATA[
<project>
  <parallel.do>
    <include file="file1.xml" />
    <include file="file2.xml" />
  </parallel.do>
</project>
]]>
</code>
</example>
            <example>
  <para>Executes three groups of tasks in parallel.</para>
  <code>
<![CDATA[
<project>
  <parallel.do>
     <do>
         <echo>Started test1.exe</echo>
         <exec program="test1.exe"/>
         <echo>Finished test1.exe</echo>
     </do>
     <do>
         <echo>Started test2.exe</echo>
         <exec program="test2.exe"/>
         <echo>Finished test2.exe</echo>
     </do>
     <do>
         <echo>Started test3.exe</echo>
         <exec program="test3.exe"/>
         <echo>Finished test32.exe</echo>
     </do>
  </parallel.do>
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.ParallelForEachTask">
            <summary>Iterates over a set of items in parallel. Similar to &lt;foreach&gt; task.</summary>
            
            <remarks>
              <para>Can iterate over files in directory, lines in a file, etc.</para>
              <para>
              The <c>property</c> value is set for each item in turn as the <c>foreach</c> task 
              iterates over the given set of items. Any previously existing value in <c>property</c> 
              is stored before the block of tasks specified in the <c>foreach</c> task are invoked, 
              and restored when the block of tasks completes. 
              </para>
              <para>This storage ensures that the <c>property</c> will have the same value it had 
              before the <c>foreach</c> task was invoked once the <c>foreach</c> task completes.
              </para>
              <para>
              Valid foreach items are "File", "Folder", "Directory", "String", "Line", "FileSet",
              and "OptionSet".
              </para>
              <para>
              File - return each file name in an iterated directory<br/>
              Folder - return each folder in an iterated directory<br/>
              Directory - return each directory in an iterated directory<br/>
              String - return each splitted string from a long string with user speicified delimiter in delim.<br/>
              Line - return each line in a text file.<br/>
              FileSet - return each file name in a FileSet.<br/>
              OptionSet - return each option in an OptionSet.<br/>
              </para>
              <para>
              NOTE: When iterating over strings and lines extra leading and trailing whitespace
              characters will be trimmed and blank lines will be ignored.
              </para>
              <para>
              NOTE: When iterating over option sets the property name specified is used for a
              property prefix to the actual option name and values.  The name of option is available
              in the <c>&lt;property&gt;.name</c> property, the value in the <c>&lt;property&gt;.value</c>
              property.
              </para>
            </remarks>
            <example>
  <para>Loops over the files in C:\</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="File" in="c:\" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loop over all *.txt files in C:\</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="File" in="c:\*.txt" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Iterates over the directories in the current directory.</para>
  <code>
<![CDATA[
<project default="doloop">
    <target name="doloop">
        <foreach item="Directory" in="." property="path">
            <echo message="path='${path}' name='@{PathGetFileName('${path}')}"/>
        </foreach>
    </target>    
</project>
]]>
  </code>
</example>
            <example>
  <para>Iterate over all pc-* directories in the current directory.</para>
  <code>
<![CDATA[
<project default="doloop">
    <target name="doloop">
        <foreach item="Directory" in="pc-*" property="path">
            <echo message="${path}"/>
        </foreach>
    </target>    
</project>
]]>
  </code>
</example>
            <example>
  <para>Loops over a list</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="String" in="1 2 3" delim=" " property="count">
                <echo message="${count}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loops over a fileset</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <fileset name="myfileset">
            <includes name="*" />
        </fileset>
        <target name="doloop">
            <foreach item="FileSet" in="myfileset" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>    
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loops over a optionset</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <optionset name="SharedLibrary">
            <option name="cc.options" value="-c -nologo"/>
            <option name="cc.program=" value="cl.exe"/>
        </optionset>
        <target name="doloop">
            <foreach item="OptionSet" in="SharedLibrary" property="option">
                <echo message="${option.name} = ${option.value}"/>
            </foreach>
        </target>    
    </project>
    ]]>
  </code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.Property">
            <summary>The property name that holds the current iterated item value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.ItemType">
            <summary>
            The type of iteration that should be done. Valid values are: 
            File, Directory, String, Line, FileSet, and OptionSet.
            When choosing the Line option, you specify a file and the task
            iterates over all the lines in the text file.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.Source">
            <summary>
            The source of the iteration.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.Delimiter">
            <summary>
            The deliminator string array. Default is whitespace.  
            Multiple characters are allowed.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.PropertyTask">
            <summary>Sets a property in the current project.</summary>
            <remarks>
              <para>NAnt uses a number of predefined properties that start with nant.* or [taskname].*.  In general you should place properties into a namespace such as global.* or ProjectName.*.</para>
              <para>If the property name is invalid a build error will occur.</para>
              <para>The following regular expression is used to test for valid properties: <c>^([\w-\.]+)$</c>.  In English this means only A-Z, a-z, 0-9, '_', '-', and '.' characters are allowed.  The leading character should be a letter for readability.</para>
              <para>The task declares the <c>${property.value}</c> property within the task itself.  The <c>${property.value}</c> property is equal to the previous value of the property if already defined, otherwise it is equal to an empty string.  By using the <c>${property.value}</c> property, user can easily insert/append to an existing property.</para>
            </remarks>
            <example>
<para>Define a <c>debug</c> property with the value <c>true</c> and use the 
user-defined <c>debug</c> property.</para>
<code>
<![CDATA[
<project>
    <property name="debug" value="true"/>
    <property name="trace" value="${debug}"/>
    <fail unless="${trace} == ${debug}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Define a <c>copyright</c> property using a nested property.</para>
<code>
<![CDATA[
<project>
    <property name="copyright">Copyright (C) 2003 Gerry Shaw</property>
    <fail if="@{StrIndexOf('${copyright}', '2003')} == -1"/>
</project>
]]>
</code>
</example>
            <example>
<para>Shows how to use the <c>${property.value}</c> to append to a property.</para>
<code>
<![CDATA[
<project>
    <property name="test">bar;${property.value}</property>
    <property name="test" value="foo;${property.value}"/>
    <fail unless="${test} == foo;bar;"/>
</project>
]]>
</code>
</example>
            <example>
<para>Shows how to use the <c>fromfile</c> attribute to read from a file into a property.</para>
<code>
<![CDATA[
<project>
    <echo file="test.txt">Hello World!</echo>
    <property name="test" fromfile="test.txt" />
    <fail unless="'${test}' == 'Hello World!'"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.PropertyTask.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly intialize</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.PropertyTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">Xml node used to define this task instance.</param>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.PropertyName">
            <summary>The name of the property to set.</summary>        
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.Value">
            <summary>The value of the property. If not specified, the default will be no value.</summary>        
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.FileName">
            <summary>The path to a file from which content is read into the property value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.ReadOnly">
            <summary>Indicates if the property should be read-only.  Read only properties can never be changed.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.Deferred">
            <summary>Indicates if the property's value will expand encapsulated properties' value at definition time or at use time. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.Local">
            <summary>Indicates if the property is going to be defined in a local context and thus, it will be restricted to a local scope. Default is false.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.RecordTask">
            <summary>A task that records the build's output to a property.</summary>
            <remarks>
            This task allows you to record the build's output, or parts of it to 
            a named property.  Using the <see cref="T:NAnt.Core.Tasks.EchoTask"/> task you can output 
            the property to a file.
            </remarks>
            <example>
<para>Simple example recording build log to a named property.</para>
<code>
<![CDATA[
<project>
    <record property="log">
        <echo message="This gets saved in the log property"/>
    </record>
    <fail 
        unless="@{StrIndexOf('${log}', 'This gets saved in the log property')} != 0" 
        message="Log wasn't saved: ${log}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.RecordTask.PropertyName">
            <summary>Name of the property to record output.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RecordTask.Silent">
            <summary>If set to true, no other output except of property is produced. Console or other logs are suppressed</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.StringLogger">
            <summary>Implementation of LogListener that writes information to a string.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ScriptTask">
             <summary>Executes the code contained within the task.</summary>
             <remarks>
            
             <para>The <c>script</c> element must contain a single <c>code</c> element, which in turn
             contains the script code.</para>
             <para>A static entry point named <c>ScriptMain</c> is required.   It must have a single
             <see cref="T:NAnt.Core.Project"/> parameter.</para>
            
             <para>The following namespaces are loaded by default:</para>
             <list type="bullet">
                 <item>System</item>
                 <item>System.Collections</item>
                 <item>System.Collections.Specialized</item>
                 <item>System.IO</item>
                 <item>System.Text</item>
                 <item>System.Text.RegularExpressions</item>
                 <item>NAnt.Core</item>
             </list>
             The <b>&lt;imports&gt;</b> element can be used to import more namespaces; see example below.
             You may need to add <c>&lt;references&gt;</c> to load assemblies containing those namespaces.
             </remarks>
             <example>
<para>Run a C# script that sets a nant property that can be used by the rest of the build. Show examples of using 
the mainclass attribute and import sub-element.</para>
<code>
&lt;project&gt;
    &lt;script language="C#" mainclass="Scriptlet"&gt;
        &lt;code&gt;&lt;![CDATA[
            // If you specify the class name using the mainclass attribute, you can 
            // use it like a normal class, with data members, constructors, and so on.
            Project _project;
			
            public Scriptlet(Project project)
            {
                _project = project;
            }
			
            void Run()
            {
                _project.Properties.Add("foo", "bar");
                // Example of using System.Data.DataTable
                DataTable dt = new DataTable("Table1");
                Log("dt.TableName=" + dt.TableName);
                // Since &lt;, '&amp;', and '&gt;' are reserved characters in XML, 
                // it'll be an error to use them without the containing CDATA element.
                if (1 &lt; 2 &amp;&amp; 1 &gt; 0)
                   Log("1 &lt; 2 &amp;&amp; 1 &gt; 0");
            }
			
            void Log(string msg)
            {
                NAnt.Core.Logging.Log.WriteLine(msg);
            }
            
            public static void ScriptMain(Project project) {
                Scriptlet script = new Scriptlet(project);
                script.Run();
            }
        ]]&gt;&lt;/code&gt;
        &lt;references basedir="C:\WINDOWS\Microsoft.NET\Framework\v1.1.4322"&gt;
            &lt;!-- extra assemblies to use --&gt;
            &lt;includes name="System.Data.dll"/&gt;
        &lt;/references&gt;
        &lt;imports&gt;
            &lt;!-- Extra namespaces to use --&gt;
            &lt;import name="System.Data"/&gt;
        &lt;/imports&gt;
    &lt;/script&gt;
    &lt;fail message="Property foo not set correctly." unless="${foo} == bar"/&gt; 
&lt;/project&gt;
</code>
</example>
             <example>
<para>Run a VB.NET script that sets a nant property that can be used by the rest of the build.</para>
<code>
&lt;project&gt;
    &lt;script language="VB"&gt;
        &lt;code&gt;&lt;![CDATA[
            Public Shared Sub ScriptMain(ByVal project AS Project)
                project.Properties.Add("foo", "bar")
            End Sub
        ]]&gt;&lt;/code&gt;
    &lt;/script&gt;
    &lt;fail message="Property foo not set correctly." unless="${foo} == bar"/&gt; 
&lt;/project&gt;
</code>
</example>
             <example>
<para>Shows how to manipulate properties inside a script.</para>
<code>
&lt;project&gt;
    &lt;!-- script that adds a property (normally use the &lt;property/&gt; task)  --&gt;
    &lt;script language="C#"&gt;
        &lt;code&gt;&lt;![CDATA[
            public static void ScriptMain(Project project) {
                project.Properties["filename"] = "test.txt";
            }
        ]]&gt;&lt;/code&gt;
    &lt;/script&gt;

    &lt;!-- use the property added in the script inside some tasks --&gt;
    &lt;echo message="creating ${filename}"/&gt;
    &lt;touch file="${filename}"/&gt;

    &lt;!-- script that gets a property value to do something with it --&gt;
    &lt;script language="C#"&gt;
        &lt;code&gt;&lt;![CDATA[
            public static void ScriptMain(Project project) {
                string fileName = project.GetFullPath(project.GetPropertyValue("filename"));
                if (!File.Exists(fileName)) {
                    string msg = String.Format("File '{0}' should exist.", fileName);
                    throw new BuildException(msg);
                }
                File.Delete(fileName);
            }
        ]]&gt;&lt;/code&gt;
    &lt;/script&gt;
&lt;/project&gt;
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Language">
            <summary>The language of the script block (C# or VB).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.References">
            <summary>Required assembly references to link with.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Code">
            <summary>The script to execute. It's required that the script be put in a CDATA element. This is
            because the potential use of XML reserved characters in the script. See example below.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Imports">
            <summary>Namespaces to import.</summary>
            <remarks>
            This causes a subtle problem in Element.ProcessBuildElement(3):
            Element childElement = (Element)propertyInfo.GetValue(this, null);
            This line expects the property is derived from Element.
            So comment out following property
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.MainClass">
            <summary>The name of the main class containing the static <c>ScriptMain</c> entry point.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Compile">
            <summary>The flag of compiling code into a saved assembly or not. The default value is false. Given the file
            containing the &lt;script&gt; is named package.build, the assembly will be named package.build.dll</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.SleepTask">
            <summary>
            A task for sleeping a specified period of time, useful when a build or deployment process
            requires an interval between tasks. If none of the time attributes are specified then the task sleeps for 0 millseconds.
            </summary>
            <example>
<para>Sleep 123 milliseconds.</para>
<code>
<![CDATA[
<project default="SleepForAWhile">
    <target name="SleepForAWhile">
        <sleep milliseconds="123" />
    </target>
</project>
]]>
</code>
</example>
            <example>
<para>Sleep 1 hour, 2 minutes, 3 seconds and 4 milliseconds.</para>
<code>
<![CDATA[
<project>
    <target name="SleepForAWhile">
        <sleep hours="1" minutes="2" seconds="3" milliseconds="4" />
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.SleepTask.GetSleepTime">
            <summary>Return time to sleep.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.SleepTask.DoSleep(System.Int32)">
            <summary>Sleep the specified number of milliseconds.</summary>
            <param name="millis">Milliseconds to sleep.</param>
        </member>
        <member name="M:NAnt.Core.Tasks.SleepTask.InitializeTask(System.Xml.XmlNode)">
            <summary>
             Verify parameters.
            </summary>
            <param name="taskNode"> taskNode used to define this task instance </param>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Hours">
            <summary>Hours to add to the sleep time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Minutes">
            <summary>Minutes to add to the sleep time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Seconds">
            <summary>Seconds to add to the sleep time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Milliseconds">
            <summary>Milliseconds to add to the sleep time.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.StartTask">
            <summary>Launches an application or document.</summary>
            <remarks>
              The main purpose of this class is to open documents, web pages and launch GUI apps.  
              If you want to capture the output of a program use the <see cref="T:NAnt.Core.Tasks.ExecTask"/>.
            </remarks>
            <example>
            <para>Open a document:</para>
            <code>
            <![CDATA[
            <project>
                <start filename='file.txt' />
            </project>
            ]]>
            </code> 
            </example>
            <example>
            <para>Open a web page:</para>
            <code>
            <![CDATA[
            <project>
                <start filename='iexplore.exe'>
                    <args>
                        <arg value='www' />
                    </args>
                </start>
            </project>
            ]]>
            </code> 
            </example>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.FileName">
            <summary>The program or document to run.  Can be a program, document or URL.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.WorkingDirectory">
            <summary>The working directory to start the program from.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.Kill">
            <summary>If true the process will be killed right after being started.  Used by automated tests.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.ArgSet">
            <summary>The set of command line arguments.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.ClearEnv">
            <summary>Set true to clear all environmental variable before executing, environmental variable specified in env OptionSet will still be added as environmental variable.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.EnvironmentVariables">
            <summary>The set of environment variables for when the program runs.
            Benefit of setting variables, like "Path", here is that it will be
            local to this program execution (i.e. global path is unaffected).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.UseShell">
            <summary>Start process in a separate shell. Default is true. 
            NOTE. When useshell is set to true environment variables are not passed to the new process.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.StyleTask">
            <summary>
            Process a document with XSLT.
            This is useful for building views of XML based documentation, or in generating code.
            </summary>
            <example>
<para>Create a report in HTML.</para>
<code>
<![CDATA[
<project>
    <target name="DoXslt">
        <style style="mytest.xsl" in="data.xml"/>	
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.StyleTask.InitializeTask(System.Xml.XmlNode)">
            <param name="taskNode"> taskNode used to define this task instance </param>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.BaseDir">
            <summary>Where to find the source XML file, default is the project's basedir.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.DestDir">
            <summary>Directory in which to store the results. The default is the current directory.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.Extension">
            <summary>Desired file extension to be used for the targets. The default is "html".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.StyleSheet">
            <summary>Name of the stylesheet to use - given either relative to the project's basedir or as an absolute path.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.SrcFile">
            <summary>Specifies a single XML document to be styled. Should be used with the <c>out</c> attribute.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.OutputFile">
            <summary>Specifies the output name for the styled result from the in attribute. The default is the name specified by the in attribute but with an .html extension.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.SysInfoTask">
            <summary>Set properties with system information.</summary>
            <remarks>
              <para>Sets a number of properties with information about the system environment.  The intent of this task is for nightly build logs to have a record of the system information that the build was performed on.</para>
              <list type="table">
                <listheader><term>Property</term>      <description>Value</description></listheader>
                <item><term>sys.clr.version</term>     <description>Common Language Runtime version number.</description></item>
                <item><term>sys.env.*</term>           <description>Environment variables, stored both in upper case or their original case.(e.g., sys.env.Path or sys.env.PATH).</description></item>
                <item><term>sys.os.folder.system</term><description>The System directory.</description></item>
                <item><term>sys.os.folder.temp</term>  <description>The temporary directory.</description></item>
                <item><term>sys.os.platform</term>     <description>Operating system platform ID.</description></item>
                <item><term>sys.os.version</term>      <description>Operating system version.</description></item>
                <item><term>sys.os</term>              <description>Operating system version string.</description></item>
              </list>
            </remarks>
            <example>
<para>Register the properties with the default property prefix.</para>
<code>
<![CDATA[
<project>
    <sysinfo/>
    <echo message="Your operating system is: ${sys.os}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Register the properties without a prefix.</para>
<code>
<![CDATA[
<project>
    <sysinfo prefix=""/>
    <echo message="Your operating system is: ${os}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Register properties and display the values set.</para>
<code>
<![CDATA[
<project>
    <sysinfo verbose="true"/>
</project>
]]>
</code>
</example>
            <example>
<para>Register properties and display the values set.</para>
<code>
<![CDATA[
<project default="build">
	<target name="build">
		<sysinfo/>
		<echo message="sys.env.windir == ${sys.env.windir}"/>
		<echo message="sys.env.windir == ${sys.env.WINDIR}"/>
	</target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.SysInfoTask.Prefix">
            <summary>The string to prefix the property names with.  Default is "sys."</summary>
        </member>
        <member name="M:NAnt.Core.Target.#ctor(NAnt.Core.Target)">
            <summary>Copy constructor.</summary>
            <param name="t">The target to copy values from.</param>
        </member>
        <member name="M:NAnt.Core.Target.Execute(NAnt.Core.Project)">
            <summary>Executes dependent targets first, then the target.</summary>
        </member>
        <member name="M:NAnt.Core.Target.System#ICloneable#Clone">
            <summary>
            Creates a deep copy by calling Copy().
            </summary>
            <returns></returns>
        </member>
        <member name="M:NAnt.Core.Target.Copy">
            <summary>
            Creates a new (deep) copy.
            </summary>
            <returns>A copy with the _hasExecuted set to false. This allows the new Target to be Executed.</returns>
        </member>
        <member name="M:NAnt.Core.Target.EnumerateTasks">
            <summary>The list of tasks within this target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Name">
            <summary>The name of the target.</summary>
            <remarks>
              <para>Hides <see cref="P:NAnt.Core.Element.Name"/> to have <c>Target</c> return the name of target, not the name of Xml element - which would always be <c>target</c>.</para>
              <para>Note: Properties are not allowed in the name.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Target.IfDefined">
            <summary>If true then the target will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Target.UnlessDefined">
            <summary>Opposite of if.  If false then the target will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Target.Description">
            <summary>The Target description.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Style">
            <summary>Framework 2 packages only: Style can be 'use', 'build', or 'clean'.  Default value is either 'use' or inherited from parent target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.DependencyList">
            <summary>A space seperated list of target names that this target depends on.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Hidden">
            <summary>Prevents the target from being listed in the projecthelp. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Override">
            <summary>Override target with the same name if it already exists.</summary>
        </member>
        <member name="P:NAnt.Core.Target.AllowOverride">
            <summary>Override target with the same name if it already exists.</summary>
        </member>
        <member name="P:NAnt.Core.Target.BaseDirectory">
            <summary>The base directory to use when executing tasks in this target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.HasExecuted">
            <summary>Indicates if the target has been executed.</summary>
            <remarks>
              <para>Targets that have been executed will not execute a second time.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Target.Dependencies">
            <summary>A collection of target names that must be executed before this target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.TargetNode">
            <summary>The xml used to initialize this Target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.LogPrefix">
            <summary>The prefix used when sending messages to the log.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TargetTask">
            <summary>
            Create a dynamic target. 
            </summary>
            <remarks>
            <para>With Framework 1.x, you can declare &lt;taget&gt; within a &lt;project&gt;, but not within any
            task. Moreover, the target name can't be variable. But with TargetTask, you can declare a target with variable
            name, or within any task that supports probing. You declare a dynamic target, and call it usnig &lt;call&gt;.
            </para>
            </remarks>
            <example>
<para>Test to show how to use &lt;target&gt; task.</para>
<code>
<![CDATA[
<project>
    <property name="prop" value="val"/>
    <do if="@{PropertyExists('prop')}">
        <!-- 
        Target conditional depends on defition of prop
        If you run command: nant conditional, you'll see conditional executed after some targets.
        Reasons:
        1. When the build runs, do is executed, hence is conditional
        2. When conditional runs, it adds a target named conditional to the target list
        3. Then the build runs the foreach, hence executing its targets
        4. And finally, the build runs conditional as the given target.
        -->
        <target name="conditional">
            <echo message="In target ${target.name}"/>
        </target>
    </do>

    <optionset name="myOptSet">
        <option name="option1" value="1"/>
        <option name="option2" value="2"/>
    </optionset>
    
    <foreach item="OptionSet" in="myOptSet" property="option" verbose="true">
        <target name="looped" hidden="true">
            <echo message="In target ${target.name}: ${option.name}=${option.value}"/>
        </target>
        <!-- Without call, looped won't be executed in the loop -->
        <call target="looped"/>
        
        <property name="targetName" value="var${option.value}"/>
        <!-- Define a target with variable name -->
        <target name="${targetName}">
            <echo message="In target ${target.name}"/>
        </target>
        <call target="${targetName}"/>
    </foreach>
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.TargetName">
            <summary>The name of the target.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.DependencyList">
            <summary>A space seperated list of target names that this target depends on.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Description">
            <summary>The Target description.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.IfDefined">
            <summary>If true then the target will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Hidden">
            <summary>Prevents the target from being listed in the projecthelp. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Override">
            <summary>
            Override target with the same name if it already exists. Default is 'false'. 
            Depends on the 'allowoverride' seeting in target it tries to override.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.AllowOverride">
            <summary>Defines whether target can be overriden by other target with same name. Default is 'false'</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Style">
            <summary>Style can be 'use', 'build', or 'clean'.   See 'Auto Build Clean' 
            page in the Reference/NAnt/Fundamentals section of the help doc for details.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.UnlessDefined">
            <summary>Opposite of if.  If false then the target will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TaskDefTask">
            <summary>Loads tasks from a specified assembly. When source files are provided as input assembly is built first.</summary>
            <remarks>
            <para>All assemblies already loaded in the nant Application Domain are automatically added as references when assembly is built from sources.</para>
            <para>
            Task defintions are propagated to dependent packages like global properies.
            </para>
            <para>
            NAnt by default will scan any assemblies ending in *Task.dll in the 
            same directory as NAnt.  You can use this task to include assemblies 
            in different locations or which use a different file
            convention.  (Some .NET assemblies end will end in .net
            instead of .dll)
            </para>
            <para>
            NAnt can only use .NET assemblies; other types of files which
            end in .dll won't work.
            </para>
            </remarks>
            <example>
<para>Include the tasks in an assembly.</para>
<code>
<![CDATA[
<project>
    <target name="init">
        <taskdef assembly="MyCustomTasks.dll"/>
    </target>
</project>
]]>
</code>
</example>
            <!-- Failed to insert some or all of included XML --><include file="Examples/TaskDef/TaskDefBuild.example" path="example"/>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.AssemblyFileName">
            <summary>File name of the assembly containing the NAnt task.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:NAnt.Core.Tasks.TaskDefTask.Override" -->
        <member name="P:NAnt.Core.Tasks.TaskDefTask.Sources">
            <summary>If defined, Tasks dll will be built using these source files.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.References">
            <summary>Reference assembles. NAll assemblies already loaded in the nant Application Domain are automatically added as references.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.DebugBuild">
            <summary>Generate debug info. Default is "true"</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.Compiler">
            <summary>
            Version of .Net compiler to use when building tasks. Format is: 'v3.5', or 'v4.0', or 'v4.5', ... . Default is "v4.0"
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskBuildAndDefTask.ReferenceConfigAssembly">
            <summary>
            This attribute is deprecated, for backwars compatibility only.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TouchTask">
            <summary>
            Touch a file and/or fileset(s); corresponds to the Unix
            <i>touch</i> command.
            </summary>
            <remarks>If the file exists, <c>touch</c> changes the <i>last access</i> and <i>last write</i> timestamps to the current time.  If no file of that name exists, <c>touch</c> will create an empty file with that name, and set the <i>create</i>, <i>last access</i> and <i>last write</i> timestamps to the current time.
            </remarks>
            <example>
<para>Touch a file using the current time.  If the file does not exist it will be created..</para>
<code>
<![CDATA[
<project>
    <touch file="foo.txt"/>
</project>
]]>
</code>
</example>
            <example>
<para>Touch all executable files in the current directory and its subdirectories.</para>
<code>
<![CDATA[
<project>
    <touch>
        <fileset>
            <includes name="**/*.exe"/>
            <includes name="**/*.dll"/>
        </fileset>
    </touch>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.TouchTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">Xml node used to define this task instance.</param>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.FileName">
            <summary>Assembly Filename (required unless a fileset is specified).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.Millis">
            <summary>
            Specifies the new modification time of the file in milliseconds since midnight Jan 1 1970.
            The FAT32 file system has limitations on the date value it can hold. The smallest is 
            <code>"12/30/1979 11:59:59 PM"</code>, and largest is <code>"12/30/2107, 11:59:58 PM"</code>.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.Datetime">
            <summary>Specifies the new modification time of the file in the format MM/DD/YYYY HH:MM AM_or_PM.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.TouchFileSet">
            <summary>Fileset to use instead of single file.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TryCatchTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in try/catch/finally clauses. <b>This task is a Framework 2 
            feature.</b>
            </summary>
            <remarks>
            It uses format similar to Ant's: <a href="http://ant-contrib.sourceforge.net/tasks/trycatch.html">http://ant-contrib.sourceforge.net/tasks/trycatch.html</a>. It's a simple implementation of try/catch/finally/throw
            common in languages like C++ and C#.
            <para>
            A build exception will be thrown if:
            <list type="number">
            <item>&lt;trycatch&gt; doesn't have one &lt;try&gt;</item>
            <item>&lt;trycatch&gt; has more than one &lt;finally&gt;</item>
            <item>&lt;trycatch&gt; has tags other than &lt;try&gt;, &lt;catch&gt;, and &lt;finally&gt;</item>
            <item>&lt;catch&gt; and &lt;finally&gt; are both missing</item>
            <item>&lt;catch&gt; is ahead of &lt;try&gt;</item>
            <item>&lt;finally&gt; is ahead of &lt;try&gt; or &lt;catch&gt;</item>
            <item>&lt;throw&gt; appears in &lt;try&gt; or &lt;finally&gt;</item>
            </list>
            </para>
            <para>trycatch won't handle the above exception. Instead, it'll rethrow it, halting the build process,
            and allow you to correct the error. But for other exceptions, it'll catch them if it has a &lt;catch&gt;.
            </para>
            <para>
            When an exception is caught, &lt;trycatch&gt; will store the exception message in property 
            <i>trycatch.error</i> of the project, and remove the message when it goes out of the scope. It'll 
            rethrow the exception at the end of execution if &lt;catch&gt; has &lt;throw&gt;. As usual, tasks
            remained in &lt;catch&gt; will be ignored.
            </para>
            <para>
            &lt;trycatch&gt; can be nested within &lt;try&gt;, &lt;catch&gt;, and &lt;finally&gt;.
            </para>
            </remarks>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.TryTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in a try clause. <b>This task can appear only inside trycatch task.</b>
            </summary>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.CatchTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in a catch clause. <b>This task can appear only inside trycatch task.</b>
            </summary>
            <remarks>Also allows rethrowing a caught exception.</remarks>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CatchTask.Exception">
            <summary>The type of the exception that is meant tob e catched.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FinallyTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in a finally clause. <b>This task can appear only inside trycatch task.</b>
            </summary>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.ThrowTask">
            <summary>
            Rethrows a caught exception. <b>This task can appear only inside catch task.</b>
            </summary>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.TStampTask">
            <summary>Sets properties with the current date and time.</summary>
            <remarks>
              <para>By default <c>tstamp</c> displays the current date and time and sets the following properties:</para>
              <list type="bullet">
                <item><description><c>tstamp.date</c> to yyyyMMdd</description></item>
                <item><description><c>tstamp.time</c> to HHmm</description></item>
                <item><description><c>tstamp.now</c> using the default DateTime.ToString() method</description></item>
              </list>
              <para>To set an additional property with a custom date/time use the property and pattern attributes.  To set a number of additional properties all with the exact same date and time use the formatter nested element (see example).</para>
              <para>The date and time string displayed by the tstamp task uses the computer's default long date and time string format.  You might consider setting these to the <a href="http://www.cl.cam.ac.uk/~mgk25/iso-time.html">ISO 8601 standard for date and time notation</a>.</para>
            </remarks>
            <example>
<para>Set the build.date property.</para>
<code>
<![CDATA[
<project default="DoStamp">
    <target name="DoStamp">
        <tstamp property="build.date" pattern="yyyyMMdd" verbose="true"/>
    </target>
</project>
]]>
</code>
</example>
            <example>
<para>Set a number of properties for Ant like compatibility.</para>
<code>
<![CDATA[
<project default="DoStamp">
    <target name="DoStamp">
        <tstamp verbose="true">
            <formatter property="TODAY" pattern="dd MMM yyyy"/>
            <formatter property="DSTAMP" pattern="yyyyMMdd"/>
            <formatter property="TSTAMP" pattern="HHmm"/>
        </tstamp>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.Property">
            <summary>The property to receive the date/time string in the given pattern.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.Pattern">
            <summary>The date/time pattern to be used.</summary>
            <remarks>
              <para>The following table lists the standard format characters for each standard pattern. The format characters are case-sensitive; for example, 'g' and 'G' represent slightly different patterns.</para>
              <list type="table">
                <listheader>
                  <description>Format Character</description>
                  <description>Description Example Format Pattern (en-US)</description>
                </listheader>
                <item><description>d</description><description>MM/dd/yyyy</description></item>
                <item><description>D</description><description>dddd, dd MMMM yyyy</description></item>
                <item><description>f</description><description>dddd, dd MMMM yyyy HH:mm</description></item>
                <item><description>F</description><description>dddd, dd MMMM yyyy HH:mm:ss</description></item>
                <item><description>g</description><description>MM/dd/yyyy HH:mm</description></item>
                <item><description>G</description><description>MM/dd/yyyy HH:mm:ss</description></item>
                <item><description>m, M</description><description>MMMM dd</description></item>
                <item><description>r, R</description><description>ddd, dd MMM yyyy HH':'mm':'ss 'GMT'</description></item>
                <item><description>s</description><description>yyyy'-'MM'-'dd'T'HH':'mm':'ss</description></item>
                <item><description>t</description><description>HH:mm</description></item>
                <item><description>T</description><description>HH:mm:ss</description></item>
                <item><description>u</description><description>yyyy'-'MM'-'dd HH':'mm':'ss'Z'</description></item>
                <item><description>U</description><description>dddd, dd MMMM yyyy HH:mm:ss</description></item>
                <item><description>y, Y</description><description>yyyy MMMM</description></item>
              </list>
              <para>The following table lists the patterns that can be combined to construct custom patterns. The patterns are case-sensitive; for example, "MM" is recognized, but "mm" is not. If the custom pattern contains white-space characters or characters enclosed in single quotation marks, the output string will also contain those characters. Characters not defined as part of a format pattern or as format characters are reproduced literally.</para>
              <list type="table">
                <listheader>
                  <description>Format</description>
                  <description>Pattern Description</description>
                </listheader>
                <item><description>d</description><description>The day of the month. Single-digit days will not have a leading zero.</description></item>
                <item><description>dd</description><description>The day of the month. Single-digit days will have a leading zero.</description></item>
                <item><description>ddd</description><description>The abbreviated name of the day of the week.</description></item>
                <item><description>dddd</description><description>The full name of the day of the week.</description></item>
                <item><description>M</description><description>The numeric month. Single-digit months will not have a leading zero.</description></item>
                <item><description>MM</description><description>The numeric month. Single-digit months will have a leading zero.</description></item>
                <item><description>MMM</description><description>The abbreviated name of the month.</description></item>
                <item><description>MMMM</description><description>The full name of the month.</description></item>
                <item><description>y</description><description>The year without the century. If the year without the century is less than 10, the year is displayed with no leading zero.</description></item>
                <item><description>yy</description><description>The year without the century. If the year without the century is less than 10, the year is displayed with a leading zero.</description></item>
                <item><description>yyyy</description><description>The year in four digits, including the century.</description></item>
                <item><description>gg</description><description>The period or era. This pattern is ignored if the date to be formatted does not have an associated period or era string.</description></item>
                <item><description>h</description><description>The hour in a 12-hour clock. Single-digit hours will not have a leading zero.</description></item>
                <item><description>hh</description><description>The hour in a 12-hour clock. Single-digit hours will have a leading zero.</description></item>
                <item><description>H</description><description>The hour in a 24-hour clock. Single-digit hours will not have a leading zero.</description></item>
                <item><description>HH</description><description>The hour in a 24-hour clock. Single-digit hours will have a leading zero.</description></item>
                <item><description>m</description><description>The minute. Single-digit minutes will not have a leading zero.</description></item>
                <item><description>mm</description><description>The minute. Single-digit minutes will have a leading zero.</description></item>
                <item><description>s</description><description>The second. Single-digit seconds will not have a leading zero.</description></item>
                <item><description>ss</description><description>The second. Single-digit seconds will have a leading zero.</description></item>
                <item><description>f</description><description>The fraction of a second in single-digit precision. The remaining digits are truncated.</description></item>
                <item><description>ff</description><description>The fraction of a second in double-digit precision. The remaining digits are truncated.</description></item>
                <item><description>fff</description><description>The fraction of a second in three-digit precision. The remaining digits are truncated.</description></item>
                <item><description>ffff</description><description>The fraction of a second in four-digit precision. The remaining digits are truncated.</description></item>
                <item><description>fffff</description><description>The fraction of a second in five-digit precision. The remaining digits are truncated. </description></item>
                <item><description>ffffff</description><description>The fraction of a second in six-digit precision. The remaining digits are truncated. </description></item>
                <item><description>fffffff</description><description>The fraction of a second in seven-digit precision. The remaining digits are truncated. </description></item>
                <item><description>t</description><description>The first character in the AM/PM designator.</description></item>
                <item><description>tt</description><description>The AM/PM designator. </description></item>
                <item><description>z</description><description>The time zone offset ("+" or "-" followed by the hour only). Single-digit hours will not have a leading zero. For example, Pacific Standard Time is "-8".</description></item>
                <item><description>zz</description><description>The time zone offset ("+" or "-" followed by the hour only). Single-digit hours will have a leading zero. For example, Pacific Standard Time is "-08".</description></item>
                <item><description>zzz</description><description>The full time zone offset ("+" or "-" followed by the hour and minutes). Single-digit hours and minutes will have leading zeros. For example, Pacific Standard Time is "-08:00".</description></item>
                <item><description>:</description><description>The default time separator.</description></item>
                <item><description>/</description><description>The default date separator.</description></item>
                <item><description>\ c</description><description>Pattern Where c is any character. Displays the character literally. To display the backslash character, use "\\". </description></item>
              </list>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.PrintTime">
            <summary>Print time stamp into the output, default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.FormatterElement.Property">
            <summary>The property to set.</summary>       
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.FormatterElement.Pattern">
            <summary>The string pattern to use to format the property.</summary>       
        </member>
        <member name="T:NAnt.Core.Tasks.WarnTask">
            <summary>Display a warning message in the the current build.</summary>
            <remarks>
              <para>Displays a warning message and location in the build file then continues with the build.</para>
            </remarks>
            <example>
<para>Display a message to a log with the current position in the build</para>
<code file="simple.build">
<![CDATA[
<project>
    <warn message="This warning is on line four."/>
</project>
]]></code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.WarnTask.Message">
            <summary>The warning message to display.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.WhileTask">
            <summary>Allows wrapping of a group of tasks to be repeatedly executed based on a conditional.</summary>
            <example>
<para>Uses a while statement to loop over a series of numbers.</para>
<code>
<![CDATA[
<project>
    <property name='x' value='0' />
    <while condition='${x} lte 1'>
        <eval type='Function' code="@{MathAdd('${x}', '1')}" property='x' />
    </while>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.WhileTask.Condition">
            <summary>The expression used to test for termination criteria.</summary>
        </member>
        <member name="M:NAnt.Core.Util.BuildFile.GetBuildFileName(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Gets the file name for the build file in the specified directory.
            </summary>
            <param name="directory">The directory to look for a build file.  When in doubt use Environment.CurrentDirectory for directory.</param>
            <param name="customSearchPattern">Look for a build file with this pattern or name.  If null look for a file that matches the default build pattern (*.build).</param>
            <param name="appendDefaultExtensions">Even if custom pattern provided, make sure to add default extentions for pattern search.</param>
            <param name="findInParent">Whether or not to search the parent directories for a build file.</param>
            <returns>The path to the build file or <c>null</c> if no build file could be found.</returns>
        </member>
        <member name="M:NAnt.Core.Util.CheckDependency.ReadDependencyFile">
            <summary>Reads list of files from dependency file</summary>
            <returns>A sorted List containing all files listed in the dependency file</returns>
        </member>
        <member name="M:NAnt.Core.Util.CheckDependency.WriteDependencyFile(System.IO.TextWriter,System.Collections.Generic.List{NAnt.Core.Util.PathString})">
            <summary>Writes list of files to a dependency file</summary>
        </member>
        <member name="M:NAnt.Core.Util.CheckDependency.InputDependencyListChanged(System.Collections.Generic.List{NAnt.Core.Util.PathString},System.Collections.Generic.List{NAnt.Core.Util.PathString})">
            <summary>Determine if the current and previous list of input files differ</summary>
            <returns><c>true</c> if the lists are not identical</returns>
        </member>
        <member name="M:NAnt.Core.Util.Hash.MakeGUIDfromString(System.String)">
            <summary>
            Calculate a hash for the argument and return it as a 16 byte GUID-format string
            </summary>
        </member>
        <member name="M:NAnt.Core.Util.Hash.BytesToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the bytes in a buffer to a hex representation
            </summary>
        </member>
        <member name="M:NAnt.Core.Util.Program.LogStdOut(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stdout</summary>
        </member>
        <member name="M:NAnt.Core.Util.Program.LogStdErr(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stderr</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.RelativePath(NAnt.Core.Util.PathString,NAnt.Core.Util.PathString,System.Boolean,System.Boolean)">
            <summary>Takes two paths and returns a relative path from the source path to the destination path.</summary>
            <param name="srcPath">The source path.</param>
            <param name="dstPath">The destination path.</param>
            <param name="failOnError">Whether this function should throw an exception if an error occurs.</param>
            <param name="addDot">Whether to add a dot, represting the current directory, to the beginning of the relative path.</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.RelativePath(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>Takes two paths and returns a relative path from the source path to the destination path.</summary>
            <param name="srcPath">The source path.</param>
            <param name="dstPath">The destination path.</param>
            <param name="failOnError">Whether this function should throw an exception if an error occurs.</param>
            <param name="addDot">Whether to add a dot, represting the current directory, to the beginning of the relative path.</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.GetDriveLetter(System.String)">
            <summary>Return the drive letter as string</summary>
            <param name="path">The path whose drive letter we are interested in.</param>
            <returns>The drive letter as a string, or null if no drive letter can be determined.</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsPathInBuildRoot(NAnt.Core.Project,System.String)">
            <summary>Checks whether a path is a subdirectory of a projects build root directory.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsPathInDirectory(System.String,System.String)">
            <summary>Checks whether the given path is equal to or a sub directory of the given directory.</summary>
            <param name="path">The path that is tested to see if it is within the directory.</param>
            <param name="dir">The directory that is tested to see if it contains the path.</param>
            <returns>Return true if the path is within the directory and false otherwise.</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsValidPathString(System.String)">
            <summary>Checks if a string is a valid path string, ie. contains no invalid symbols.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.CreateHardLink(System.String,System.String,System.IntPtr)">
            <returns>returns true of success or false otherwise</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.link(System.String,System.String)">
            <returns>returns 0 if successful or -1 if failure</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.CreateHardLink(System.String,System.String)">
            <summary>
            Copies a file but creates a hard link at the destination instead of copying the entire contents of the file.
            </summary>
            <param name="dst">The path to the destination file.</param>
            <param name="src">The path to the source file being copied.</param>
            <returns>Whether or not the operation was successful.</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.DeleteDirectory(System.String,System.Boolean,System.Boolean)">
            <summary>
            Deletes a directory with all content. File attributes are reset to normal before delete.
            </summary>
            <param name="path">The path to the directory</param>
            <param name="verify">Verify that directory does not exist after delete and throw exceptioon otherwise.</param>
            <param name="failOnError">Fail in the case of error if true, otherwise ignore errors</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.SetAllFileAttributesToNormal(System.String)">
            <summary>For each file and directory in the given path set the file attributes to Normal.</summary>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.IsExplicitPattern(System.String)">
            <summary>Check if the specified pattern does not contain any wildcards.</summary>
            <returns>True if the pattern does not contain any wildcards, otherwise false.</returns>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.IsImplicitPattern(System.String)">
            <summary>Check if the specified pattern contains any wildcards.</summary>
            <returns>True if the pattern contains any wildcards, otherwise false.</returns>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.ConvertPattern(System.String,System.String@)">
            <summary>Adds regular expressions for any non-explicit (ie, uses wildcards) nant patterns.</summary>
            <param name="nantPattern">The NAnt pattern to convert.  Absolute or relative paths.</param>
            <param name="absoluteFileName">Absolute pattern will return file name here.</param>
            <returns>The resulting regular expression. Absolute canonical path.</returns>
            <remarks>
            	<para>Only nant patterns that contain a wildcard character as converted to regular expressions.
            	Explicit patterns are expected to be handled using absoluteFileName.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.IsPathInPatternSet(System.String,NAnt.Core.Util.Pattern.RegexPattern,System.Boolean,System.Collections.Generic.List{NAnt.Core.Util.Pattern.RegexPattern},System.Collections.Specialized.StringCollection)">
            <summary>Verifies that a path matches the regex pattern.
            More efficient implementation, to be used when caller knows
            if the volume is case sensitive.</summary>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.ToRegex(System.String,System.Boolean)">
            <summary>Converts NAnt search pattern to a regular expression. Use cached version or compile and cache</summary>
            <param name="pattern">input pattern string</param>
            <param name="caseSensitive">Is volume case sensitive</param>
            <returns>Compiler Regular expresssion</returns>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.ToRegexPatternOpt(System.String)">
            <summary>Converts NAnt search pattern to a regular expression pattern</summary>
            <param name="nantPattern">Search pattern relative to the search directory</param>
            <returns>Regular expresssion (absolute path) for searching matching file/directory names</returns>
        </member>
        <member name="M:NAnt.Core.Util.ExplictPattern.ConvertPattern(System.String,System.String@)">
            <summary>Adds regular expressions for any non-explicit (ie, uses wildcards) nant patterns.</summary>
            <param name="nantPattern">The NAnt pattern to convert.  Absolute or relative paths.</param>
            <param name="absoluteFileName">Absolute pattern will return file name here.</param>
            <returns>The resulting regular expression. Absolute canonical path.</returns>
            <remarks>
            	<para>Only nant patterns that contain a wildcard character as converted to regular expressions.
            	Explicit patterns are expected to be handled using absoluteFileName.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Util.ImplicitPattern.ScanDirectoryOpt(System.String,NAnt.Core.Util.Pattern.RegexPattern,System.Collections.Generic.List{NAnt.Core.Util.Pattern.RegexPattern},System.Collections.Specialized.StringCollection,System.Collections.Generic.List{System.String})">
            <summary>Searches a directory recursively for files and directories matching the search criteria</summary>
            <param name="directoryPath">Directory in which to search (absolute canonical path)</param>
            <param name="regexPattern">Regular expression to match</param>
            <param name="excludePatterns">List of regular expression patterns to exclude</param>
            <param name="excludeFileNames">List of explicit file names to exclude</param>
            <param name="matchingFiles"></param>
        </member>
        <member name="M:NAnt.Core.Util.ImplicitPattern.ConvertPattern(System.String,System.String@)">
            <summary>Adds regular expressions for any non-explicit (ie, uses wildcards) nant patterns.</summary>
            <param name="nantPattern">The NAnt pattern to convert.  Absolute or relative paths.</param>
            <param name="absoluteFileName">Absolute pattern will return file name here.</param>
            <returns>The resulting regular expression. Absolute canonical path.</returns>
            <remarks>
            	<para>Only nant patterns that contain a wildcard character as converted to regular expressions.
            	Explicit patterns are expected to be handled using absoluteFileName.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Util.ImplicitPattern.ParseSearchDirectoryAndPatternOpt(System.String,System.String@,System.Boolean@,System.String@)">
            <summary>Given a NAnt search pattern returns a search directory and an regex search pattern.</summary>
            <param name="originalNAntPattern">NAnt searh pattern (relative to the Basedirectory OR absolute, relative paths refering to parent directories ( ../ ) also supported)</param>
            <param name="searchDirectory">Out. Absolute canonical path to the directory to be searched</param>
            <param name="recursive">Out. Indicates whether directory should be parsed recursively</param>
            <param name="regexPattern">Out. Regex search pattern (absolute canonical path)</param>        
        </member>
        <member name="T:NAnt.Core.Util.PatternFactory">
            <summary>singleton class for creating patterns</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String)">
            <summary>Creates a pattern with asis bit set to true and default basedir.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String,System.Boolean)">
            <summary>Creates a pattern with default basedir.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String,System.String)">
            <summary>Creates a pattern with asis bit set to false.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String,System.String,System.Boolean)">
            <summary>Creates a pattern.</summary>
        </member>
        <member name="T:NAnt.Core.Util.ProcessRunner">
             <remarks>
             Launches a process and maintains two threads for reading from the processes stdout and stderr.
             Uses the process watcher instance to maintain a list of process ids. Useful for cleaning up processes
             when terminating.
             When an instance of a process runner goes out of scope the process will be automatically destroyed along
             with any child processes it launched.
             </remarks>
             <example>
            		Process p = new Process;  // prepare a process
            		ProcessRunner run = new ProcessRunner(p); // attach process to process runner
            
            		run.ProcessEvent += new EventHandler; // handle process events
            		run.StdOutputEvent += new EventHandler; // handle output events
            
            		try
            		{
            			timeout = run.Start()
            
            			if ( timeout )
            				// report any errors
            		}
            		catch( e )
            			// report any errors
            
            		// when process runner leaves scope prcoess and child procs will be destroyed
             </example>
        </member>
        <member name="T:NAnt.Core.Util.PropertyStack">
             <summary>
             Use a stack for defining properties so that properties can be defined recusively within build tasks.
             This class works by storing previous values of properties and restoring them when they are removed.
             </summary>
             <code>
            		new stack('myprop')
            		stack.Add('val')			// myprop == val1
            		
            			stack.Add('val2')		// myprop == val2
            			stack.Remove			// myprop == val1
            
            		stack.Remove				// myprop = undef
            </code>
        </member>
        <member name="M:NAnt.Core.Util.PropertyStack.#ctor(System.String)">
            <summary>
            Construct a PropertyStack
            </summary>
            <param name="name">The name of the property.</param>
        </member>
        <member name="M:NAnt.Core.Util.PropertyStack.Push(NAnt.Core.Project,System.String)">
            <summary>
            Adds a project property.  
            If one already exists it will be stored to be restored later when the new 
            one is removed.
            </summary>
        </member>
        <member name="M:NAnt.Core.Util.PropertyStack.Pop(NAnt.Core.Project)">
            <summary>
            Removes a project property.  
            If one previously existed it will be restored.
            </summary>
        </member>
        <member name="M:NAnt.Core.StringExtensions.ValueAt(System.String,System.Int32)">
            Helper function for StrCompareVersions. Returns character value at position pos, 
            or '\0' if index is outside the string
            <param name="str"> string</param>
            <param name="pos">position in the string</param>        
        </member>
        <member name="M:NAnt.Core.Util.StringUtil.ValueAt(System.String,System.Int32)">
            Helper function for StrCompareVersions. Returns character value at position pos, 
            or '\0' if index is outside the string
            <param name="str"> string</param>
            <param name="pos">position in the string</param>        
        </member>
        <member name="M:NAnt.Core.Reflection.TaskFactory.ScanDirectories(System.String[])">
            <summary>Scans the directorylist for any task assemblies and adds them to list of known tasks.</summary>
            <param name="paths">The full path to the directory to scan.</param>
        </member>
        <member name="M:NAnt.Core.Reflection.TaskFactory.CreateTask(System.Xml.XmlNode,NAnt.Core.Project)">
            <summary> Creates a new Task instance for the given xml and project.</summary>
            <param name="taskNode">The XML to initialize the task with.</param>
            <param name="project">The Project that the Task belongs to.</param>
            <returns>The Task instance.</returns>
        </member>
        <member name="M:NAnt.Core.Reflection.TaskFactory.CreateTask(System.String,NAnt.Core.Project)">
            <summary> Creates a new Task instance for the given task name and project.</summary>
            <param name="taskName">The task name to initialize the task with.</param>
            <param name="project">The Project that the Task belongs to.</param>
            <returns>The Task instance, or null if not found.</returns>
        </member>
        <member name="M:NAnt.Core.Reflection.TaskFactory.OnTaskDiscovered(NAnt.Core.Events.TaskBuilderEventArgs)">
            <summary>Signals that a task has been found and has been added to NAnt's list of known tasks.</summary>
        </member>
        <member name="M:NAnt.Core.StringParser.ExpandString(System.String,NAnt.Core.StringParser.PropertyEvaluator,NAnt.Core.StringParser.FunctionEvaluator)">
            <summary>
            Expands properties and functions within a string.
            </summary>
            <remarks>
              <para>Can handle nested expressions like ${${a}}.</para>
              <para>Cannot use '${' in expressions without invoking expansion.</para>
            </remarks>
            <param name="expression">The string to expand.</param>
            <param name="evaluateProperty">The delegate function to call when a property needs evaluating.</param>
            <param name="evaluateFunction">The delegate function to call when a function needs evaluating.</param>
        </member>
        <member name="M:NAnt.Core.StringParser.ParseProperty(System.String,System.Int32@,NAnt.Core.StringParser.PropertyEvaluator,NAnt.Core.StringParser.FunctionEvaluator)">
            <summary>
            Returns the expansion of a property within a string.
            </summary>
            <remarks>
              <para>Can handle nested expressions like ${${a}}.</para>
              <para>Cannot use '${' in expressions without invoking expansion.</para>
            </remarks>
            <param name="expression">The expresion to expand.</param>
            <param name="offset">The offset in the expression of the property to expand.</param>
            <param name="evaluateProperty">The delegate function to call when a property needs evaluating.</param>
            <param name="evaluateFunction">The delegate function to call when a function needs evaluating.</param>
        </member>
        <member name="M:NAnt.Core.StringParser.ParseFunction(System.String,System.Int32@,NAnt.Core.StringParser.PropertyEvaluator,NAnt.Core.StringParser.FunctionEvaluator)">
            <summary>
            Returns the expansion of a function within a string.
            </summary>
            <param name="expression">The expresion to expand.</param>
            <param name="offset">The offset in the expression of the property to expand.</param>
            <param name="evaluateProperty">The delegate function to call when a property needs evaluating.</param>
            <param name="evaluateFunction">The delegate function to call when a function needs evaluating.</param>
        </member>
        <member name="T:NAnt.Core.Util.PathNormalizer">
            <summary>Helper class for normalizing paths so they can be compared.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathNormalizer.Normalize(System.String,System.Boolean)">
            <summary>Converts a path so that it can be compared against another path.</summary>
            <remarks>
              <para>For some unknown reason using the DirectoryInfo and FileInfo classes to get the full name
              of a file or directory does not return a full path that can be always be compared.  Often the
              drive letter or directory seperators are wrong.  If you want to determine if a path starts
              with another path first normalize the paths with this method and then use the 
              "String.StartsWith" method.
            </para>
            </remarks>
            <example>
            string path1 = PathNormalizer.Normalize(path1);
            string path2 = PathNormalizer.Normalize(path2);
            if (path1.StartsWith(path2) {
                string dir = path1.Substring(path2.Length);
            }
            </example>
        </member>
        <member name="T:NAnt.Core.Util.ThreadRunner">
            <summary>
            </summary>
        </member>
        <member name="T:NAnt.Core.Util.UriFactory">
            <summary>Helper class for creating valid uris.</summary>
        </member>
        <member name="M:NAnt.Core.Util.UriFactory.CreateUri(System.Uri)">
            <remarks>
            The basic idea of this method is to remove the scheme from the file name before
            passing it to the Uri constructor. Thus, the constructor will treat the constructor
            as a file and not a uri, given us the result we desire.
            
            The build file needs to contain a '#' in the filename for the test below. 
            I cant add this test to perfoce because it wont accept filenames with '#'.
            </remarks>
            <example>
            <project>
            <fail 
                message='Uri class returned invalid result for buildfile path.'
                if='@{StrIndexOf("${nant.project.buildfile}", "Bug.#653.build")} == -1' />
            </project>
            </example>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetChildElementsByName(System.Xml.XmlNode,System.String)">
            <summary>Loops through immediate child elements and returns all children that matches the given name</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetChildElementByName(System.Xml.XmlNode,System.String)">
            <summary>Loops through immediate child elements and returns the first that matches the given name</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetChildElementByNameAndAttribute(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>Loops through immediate child elements and returns the first that match the given name 
            and has the given attribute</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetOrAddElement(System.Xml.XmlDocument,System.String,System.String)">
            <summary>Gets a child element or adds it if missing. If no namepsace is provided it will
            only search immediate child nodes.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetOrAddElement(System.Xml.XmlNode,System.String,System.String)">
            <summary>Searches immediate child elements for one with the given name and adds it if not found.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetOrAddElementWithAttributes(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>Searches immediate child elements for one with the given name and attribute and adds it if not found</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.SetAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>Sets an attribute value of a node, or adds a new attribute if an attribute
            by the given name does not exist.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.SetAttributeIfMissing(System.Xml.XmlNode,System.String,System.String)">
            <summary>Sets the value of a node's attribute only if the attribute's value
            is equal to null.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>Returns the value of an attribute, or a provided default value if either the
            node or attribute are null.</summary>
        </member>
        <member name="M:NAnt.Core.Writers.CachedWriter.Flush">
            <summary>
            Write memory content to the file. If file exist and content did not change leave file intact.
            </summary>
        </member>
        <member name="T:NAnt.Shared.Properties.PackageProperties">
            <summary>
            PackageTask properties.
            </summary>
        </member>
    </members>
</doc>
