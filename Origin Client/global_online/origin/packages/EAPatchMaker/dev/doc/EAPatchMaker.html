<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<title>EAPatchMaker</title>
<style type="text/css">
<!--
.grayed {	color: #666666
}
.smallTable {	font-size: 9pt;
	font-family: Arial, Helvetica, sans-serif;
}
.superscript {	position: relative; 
	top: -0.5em; 
	font-size: 80%; 
}
.DownplayedText {color: #999999}
.NotableComments {color: #006600}
.HighlightedText {color: #0066FF}
.code-example {	display: block;
	background-color: #e0e0f0;
	margin-left: 3em;
	margin-right: 3em;
	margin-top: 1em;
	margin-bottom: 1em;
	padding: 8px;
	border: solid 2px #a0a0d0;
	font-family: monospace;
	font-size: 9pt;
	white-space: pre;
}
.highlighted {color: #990000}
.faq-answer {    	display: block;
    	margin: 4pt 1em 0.5em 1em;
}
-->
</style>
</head>

<body>
<h1>EAPatchMaker </h1>
<p>EAPatchMaker is a utility (and linkable library) for generating EAPatch patches. As input it takes a source directory path and a .eaPatchImpl file, and as output it generates an output directory with patch files. Those patch files can be later used by the EAPatchClient on another computer to efficiently recreate the source directory on that computer. Through the .eaPatchImpl file you can specify file filters which cause EAPatchMaker to exclude or include selected files and subdirectories from the source path. There are a number of other options as well, most of which are documented below. </p>
<p>When EAPatchMaker generates a patch, it doesn't merely copy the patch files to a destination directory and call it done. EAPatch is a differential patching system in which the client can smartly download only the files it needs from the server and only portions of those files as needed. The generated patch data has additional information in it which allows this to occur. </p>
<p>See the <a href="http://eaos.rws.ad.ea.com:8080/@md=d&c=And@//EAOS/EAPatch/DL/EAPatchClient/dev/doc/EAPatchClient.html#PatchingProcess">EAPatchClient documentation</a> for info about how patching works and what its life cycle is. </p>
<h2>Minimal .eaPatchImpl</h2>
<p>EAPatchMaker works by you supplying it a starter .eaPatchImpl file (which is XML). It generates a patch from that which includes an expanded .eaPatchImpl file. There are only a few required fields in the .eaPatchImpl file, though you can fill in some of additional fields if they are useful to you. The minimum fields are:</p>
<ul>
  <li>PatchInfoURL</li>
  <li>PatchId</li>
  <li>PatchImplURL</li>
  <li>IgnoreFileArray or UsedFileArray (can use both). </li>
</ul>
<h2>Example patch </h2>
<p>Here we describe a  simple example patch.We have the following input directory, and we will be creating a patch out of File A.txt and File B.txt. This example is just two files, but entire directory trees can be included as well. </p>
<blockquote>
  <p><img src="images/Example1.0.png" width="209" height="115" /></p>
</blockquote>
<p>The .eaPatchImpl file looks like the following. Note that we set the patch to include files of type *.txt. There can be multiple UsedFileArray lines, as well as IgnoredFileArray lines: </p>
<blockquote>
  <pre><span class="highlighted">&lt;PatchImpl&gt;</span>
   <span class="highlighted">&lt;PatchInfoURL&gt;</span>Example1.eaPatchInfo<span class="highlighted">&lt;/PatchInfoURL&gt;</span>
   <span class="highlighted">&lt;PatchId&gt;</span>Example1<span class="highlighted">&lt;/PatchId&gt;</span>
   <span class="highlighted">&lt;PatchImplURL L=&quot;*_*&quot;&gt;</span>Example1.eaPatchImpl<span class="highlighted">&lt;/PatchImplURL&gt;</span>
   <span class="highlighted">&lt;UsedFileArray&gt;</span>*.txt<span class="highlighted">&lt;/UsedFileArray&gt;</span>
<span class="highlighted">&lt;/PatchImpl&gt;</span>
</pre>
</blockquote>
<p>We execute this:</p>
<pre class="code-example">EAPatchMaker.exe -inputDir:&quot;C:\examples\example 1&quot; -outputDir:&quot;C:\examples\example 1 output&quot;</pre>
<p>And the following is created: </p>
<blockquote>
  <p><img src="images/Example1.1.png" width="216" height="197" /></p>
</blockquote>
<p>The created directory can now be hosted on a web server, and an EAPatchCient instance can refer to it. Make sure that the web server directory root is specified in such a way as the PatchImplURL refers to the right location. </p>
<h2>Testing your patch</h2>
<p>  It's important that you test your resulting patch, especially if you changed the file filters from the last time you built a patch like this. </p>
<p>This is primarily because mis-implemented file filters can potentially result in deleted files and directories that you didn't intend during patch application. This probably won't be an issue if your filter consists of a simple UsedFileArray that simply names individual files. See the <a href="#filefilters">file filters</a> section of this doc for more on this. However, an example of something to beware of is that the *.txt filter given in the simple example above will replace <em>all</em> *.txt files present in the directory to be patched with File A.txt and File B.txt, and if you still want to use *.txt then you need to add an IgnoredFileArray filter to save File C.txt from being deleted during patching. </p>
<h2>Optimization</h2>
<p>It turns out that EAPatchMaker can tune the generated patch data in a way that minimizes the required download volume. If you can provide a &quot;previous&quot; directory to go along with your input directory, EAPatchMaker can analyze the two, with the assumption that when most users apply the patch to their data, the data being patched looks like this previous directory. EAPatch maker tunes the generated output to work best (maximize speed/minimize download volume) with the case of patching the previous directory to the input directory. </p>
<p>It's OK if not all users' data to be patched looks like the previous data. And it's OK if only some of the files specified in -previousDir aren't really what's expected. And it's OK if the previous dir isn't complete.</p>
<p>To use this optimization, specif the -previousDir argument to EAPatchMaker, like so:</p>
<pre class="code-example">EAPatchMaker.exe -inputDir:C:\test\Patch1 -outputDir:C:\test\Patch1Output<span class="highlighted"> -previousDir:C:\test\Patch1Prev -optimize:enabled</span></pre>
<h2><a name="filefilters" id="filefilters"></a>File filters</h2>
<p>In your .eaPatchImpl file you can specify file filters which define the files that constitute your patch. These are specified by the IgnoredFileArray and UsedFileArray settings. </p>
<p><em>It is important to understand that the application of a patch causes a directory image to be replaced with a new directory image. This means that files in the old directory image may be deleted because they are not in the new directory image.</em> This is a useful feature, but it can possibly surprise you if you aren't aware of it. You can use the IgnoredFileArray and UsedFileArray settings to control which files are affected, and they are what we describe here. </p>
<h3>IgnoredFileArray</h3>
<p>IgnoredFileArray entries in the .eaPatchImpl file describe files that are ignored while making a patch and applying a patch. They are treated as if they don't exist, both when making a patch and when applying the patch. Thus the ignored file settings constitute a file blacklisting (as opposed to whitelisting). For example: </p>
<pre class="code-example">&lt;IgnoredFileArray flags="CaseFold UnixPath"&gt;GameData/Plugins/*&lt;/IgnoredFileArray&gt;
&lt;IgnoredFileArray flags="CaseFold UnixPath"&gt;UserData/*&lt;/IgnoredFileArray&gt;</pre>

<p>When EAPatchMaker encounters the GameData/Plugins/  and  UserData/ folders while building a patch, it ignores them and doesn't read their contents. Upon building the patch, EAPatchClient will leave these directories alone on the patched system. You can use IgnoredFileArray and UsedFileArray (below) together in a .eaPatchImpl file. </p>
<h3>UsedFileArray</h3>
<p>UsedFileArray is the opposite of IgnoredFileArray; it specifies a file whitelisting. For example:</p>
<p>entries in the .eaPatchImpl file describe files that are ignored while making a patch and applying a patch. They are treated as if they don't exist, both when making a patch and when applying the patch. For example: </p>
<pre class="code-example">&lt;UsedFileArray flags="CaseFold UnixPath"&gt;*.big&lt;/UsedFileArray&gt;
&lt;UsedFileArray flags="CaseFold UnixPath"&gt;Audio/*.snd&lt;/UsedFileArray&gt;</pre>
<p>The above say that all .big files in the directory tree, including subdirectories, are part of the patch image, as well as all .snd files in the Audio directory. If you want the *.big to refer to only .big files in the base directory and not subdirectories, you would add Pathname to the UsedFileArrayFlags. Alternatively you can use IgnoredFileArray to ignore subdirectories. </p>
<h3>flags</h3>
<p>The flags use fnmatch syntax, similar to that described at http://linux.die.net/man/3/fnmatch, with the following specifications:</p>
<h2></h2>
<blockquote>
  <table border="1">
    <tr>
      <th>flag</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td>None</td>
      <td>No flags. The filter spec is taken literally. </td>
    </tr>
    <tr>
      <td>Pathname</td>
      <td>Wildcard chars don't can't see past directory separator chars.</td>
    </tr>
    <tr>
      <td>NoEscape</td>
      <td>Escape sequences (e.g. '\t') are not recognized. <br />
      Escape sequences are only ever recognized with Unix-style paths and not DOS-style paths that use '\' chars. 
      It's as if this flag is always active when DOS paths are in use.</td>
    </tr>
    <tr>
      <td>Period</td>
      <td>A leading '.' is matched only explicitly and not by * or ?.</td>
    </tr>
    <tr>
      <td>PrefixDir</td>
      <td>Directory path text that precedes the string can match the pattern.</td>
    </tr>
    <tr>
      <td>CaseFold</td>
      <td>Act case-insensitively.</td>
    </tr>
    <tr>
      <td>DosPath</td>
      <td>Force the path to be interpreted as a DOS path (e.g. '\') instead of native path. If you use this then you would make the file array paths use \ </td>
    </tr>
    <tr>
      <td>UnixPath </td>
      <td>Force the path to be interpreted as a Unix path (e.g. '/') instead of native path. If you use this then you would make the file array paths use / </td>
    </tr>
  </table>
</blockquote>
<h3>Examples</h3>
<p>We use UnixPath in most cases below because that's what you usually want to use, as it makes your file filters more portable. You could alternatively use DosPath and always use \ chars in your filters and have the same portable effect (i.e. your filters would work on Unix-like systems). </p>
<blockquote>
  <pre>Pattern               File path           Flags                 Match Result<br />--------------------------------------------------------------------------------------<br />&quot;&quot;,                   &quot;blah.txt&quot;,         0,                    false<br />&quot;blah.txt&quot;            &quot;blah.txt&quot;          0                     true  <br />&quot;*.big&quot;               &quot;/abc/file.big&quot;     UnixPath              true<br />&quot;*.big&quot;               &quot;/abc/file.big&quot;     UnixPath Pathname     false
&quot;a/b/c&quot;               &quot;a/b/c&quot;             UnixPath              true  <br />&quot;a/b/c&quot;               &quot;a/b/c&quot;             UnixPath Pathname     true <br />&quot;a/b/c&quot;               &quot;a/_/c&quot;             UnixPath              false <br />&quot;a/b/c&quot;               &quot;A/B/C&quot;             UnixPath              false <br />&quot;a/b/c&quot;               &quot;A/B/C&quot;             UnixPath CaseFold     true  <br />&quot;a/b/?&quot;               &quot;a/b/c&quot;             UnixPath              true  <br />&quot;a/b/?&quot;               &quot;a/b/&quot;              UnixPath              false <br />&quot;*&quot;                   &quot;a/b/c&quot;             UnixPath              true  <br />&quot;**&quot;                  &quot;a/b/c&quot;             UnixPath              true  <br />&quot;???&quot;                 &quot;ab&quot;                0                     false <br />&quot;???&quot;                 &quot;abc&quot;               0                     true  <br />&quot;a/b/c/*.?[ab]&quot;       &quot;a/b/c/d.qa&quot;        UnixPath              true  <br />&quot;a/b/c/*.?[ab]&quot;       &quot;a/b/c/d.qq&quot;        UnixPath              false <br />&quot;a/*/*/d&quot;             &quot;a/bbbb/c/d&quot;        UnixPath              true  <br />&quot;a/*/*/d&quot;             &quot;a/bbbb/c/d&quot;        UnixPath Pathname     true  <br />&quot;/abc/def.txt&quot;        &quot;/abc/def.txt&quot;      UnixPath              true  <br />&quot;/abc/def.txt&quot;        &quot;/abc/Xef.txt&quot;      UnixPath              false 
</pre>
</blockquote>
<h3>Mixing IgnoredFileArray and UsedFileArray</h3>
<p>What happens if you use both IgnoredFileArray and UsedFileArray in a .eaPatchImpl file? The short answer is that UsedFileArray takes precedence, but here's a &quot;truth table&quot; which presents all combinations of matching a file path against an Ignored and Used file spec:</p>
<blockquote>
  <table border="1">
    <tr>
      <th>&nbsp;</th>
      <th>Ignored unspecified </th>
      <th>Ignored match </th>
      <th>Ignored unmatched</th>
    </tr>
    <tr>
      <th>Used unspecified </th>
      <td><div align="center"></div></td>
      <td><div align="center"></div></td>
      <td><div align="center">Match</div></td>
    </tr>
    <tr>
      <th>Used match </th>
      <td><div align="center">Match</div></td>
      <td><div align="center">Match</div></td>
      <td><div align="center">Match</div></td>
    </tr>
    <tr>
      <th>Used unmatched</th>
      <td><div align="center"></div></td>
      <td><div align="center"></div></td>
      <td><div align="center"></div></td>
    </tr>
  </table>
</blockquote>
<p>In the table above, Match means that the file is part of the patch. For example: </p>
<ul>
  <li>If we have a Ignored filter of *.txt and a Used filter of File*.txt, then FileA.txt would be considered a Match for the path (center cell above), but DataA.txt would not (bottom-center cell above). </li>
  <li>If Ignored filter is *.txt and there is no Used filter, then DataA.txt would not be considered part of the path (top-center cell above), but Audio.big would (top-right cell above). </li>
  <li>If we specified neither an Ignored or Used filter, then all files in the directory tree are ignored (upper-left cell above). You might want to do this if your patch was not a file patch at all but rather a patch that executed a script (which you can also specify in the .eaPatchImpl file). </li>
  <li>If you want to patch just a single file called GameData.big and ignore all others, then you would just make a single Used entry for &quot;GameData.big&quot; and the left-center Match cell above would apply. </li>
</ul>
<h2>Command line arguments</h2>
<blockquote>
<table border="1">
  <tr>
    <th>Format</th>
    <th>Required?</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>-help / -h / -?</td>
    <td>&nbsp;</td>
    <td>Displays this usage information</td>
  </tr>
  <tr>
    <td>-v:&lt;value&gt; / -verbosity:&lt;value&gt;</td>
    <td>&nbsp;</td>
    <td>Default is 1. 0 = error output only, 1 = low output, 2 = full output.</td>
  </tr>
  <tr>
    <td>-wait / -w</td>
    <td>&nbsp;</td>
    <td>Waits for user confirmation before app exit.</td>
  </tr>
  <tr>
    <td>-inputDir:&lt;dir path&gt;</td>
    <td>Required</td>
    <td>Sets the directory the patch is made from.</td>
  </tr>
  <tr>
    <td>-outputDir:&lt;dir path&gt;</td>
    <td>Required</td>
    <td>Sets the directory the patch is written to.</td>
  </tr>
  <tr>
    <td>-previousDir:&lt;dir path&gt;</td>
    <td>Possibly</td>
    <td>Optional; required if -optimize is used. Specifies a directory with typical pre-patch contents.</td>
  </tr>
  <tr>
    <td>-patchImplPath:&lt;.eaPatchImpl path&gt;</td>
    <td>Possibly</td>
    <td>Optional; required if the .eaPatchImpl file isn't in the root of the inputDir. Specifies the patch definition.</td>
  </tr>
  <tr>
    <td>validatePatchImpl:enabled|disabled</td>
    <td>&nbsp;</td>
    <td>Optional. Default is disabled. When enabled, the user is required to supply a valid .eaPatchImpl file.</td>
  </tr>
  <tr>
    <td>-clearOutputDir:enabled|disabled</td>
    <td>&nbsp;</td>
    <td>Optional. Default is enabled. When enabled, any contents of the output directory are deleted.</td>
  </tr>
  <tr>
    <td>-errorCleanup:enabled|disabled</td>
    <td>&nbsp;</td>
    <td>Optional. Default is enabled. When enabled, upon an error the output directory and any contents are deleted.</td>
  </tr>
  <tr>
    <td>-optimize:enabled|disabled</td>
    <td>&nbsp;</td>
    <td>Optional. Default is enabled, which may be slow. If you specify this then you must specify -previousDir.</td>
  </tr>
  <tr>
    <td>-maxFileCount:&lt;count&gt;</td>
    <td>&nbsp;</td>
    <td>Optional. Default value is 100000. Used for sanity checking.</td>
  </tr>
</table>
</blockquote>
<h2>Additional example usage</h2>
<pre class="code-example">EAPatchMaker -inputDir:C:\NewData -outputDir:C:\Patch01 -patchImplPath:C:\Patch01.eaPatchImpl</pre>
<pre class="code-example">EAPatchMaker -inputDir:C:\GameApp\NewData -outputDir:C:\GameApp\Patch01 -maxFileCount:2000000 -w</pre>
<pre class="code-example">EAPatchMaker -previousDir:C:\PrevData -inputDir:C:\NewData -outputDir:C:\PatchData -optimize:enabled</pre>
<h2>EAPatchImpl (.eaPatchImpl) file format</h2>
<pre>&lt;PatchImpl&gt;
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, required</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">URL to the .eaPatchInfo file associated with this PatchInfo.
         This doesn't need to be filled in by the person who creates this patch. 
         It's filled in at runtime from the actual URL location the file came from.
         This URL can also be server-relative and thus not have the http://&lt;server&gt;:&lt;port&gt; 
         portion present, as it will be assumed to be the default patch server set 
         at runtime by the application. If the URL doesn't begin with http[s]:// then
         it is assuemed to be relative. You can't just use (e.g.) patch.ea.com/Madden_2014/TeamUpdates/en_us/Patch.eaPatchImpl
         Paths are expected to be in a form compatible with paths used as HTML links,
         which means, for example, that special characters need to be escaped, etc.

         Example:
            &lt;PatchInfoURL&gt;http://patch.ea.com/Madden_2014/TeamUpdates/Patch1.eaPatchInfo&lt;/PatchInfoURL&gt;
         Example (server-relative):
            &lt;PatchInfoURL&gt;Madden_2014/TeamUpdates/Patch1.eaPatchInfo&lt;/PatchInfoURL&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;PatchInfoURL&gt;&lt;/PatchInfoURL&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, required</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Unique string, like a GUID. This is not meant to be read by users; mPatchName is 
         the user-readable name of the patch. The format of the id is application-specific.

         Example:
            &lt;PatchId&gt;1234-3e21-4352-3893&lt;/PatchId&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;PatchId&gt;&lt;/PatchId&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Indicates whether the patch is a fix, add-on, etc. Case-insensitive.
         The valid string options are application-specific, but the term "patch" is 
         reserved to mean non-optional content. Other strings like "plug-in" are possible.

         Example:
            &lt;PatchClass&gt;patch&lt;/PatchClass&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;PatchClass&gt;&lt;/PatchClass&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: bool, optional </span><span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">True if the patch is required in order to further run the application.

         Example:
            &lt;Required&gt;true&lt;/Required&gt;</span>
   <span class="DownplayedText"> --&gt;</span>
    &lt;Required&gt;&lt;/Required&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: LocalizedString, required</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">URL for the patch implementation itself. May get redirected by the server.
         This URL can also be server-relative and thus not have the http://&lt;server&gt;:&lt;port&gt; 
         portion present, as it will be assumed to be the default patch server set 
         at runtime by the application. If the URL doesn't begin with http[s]:// then
         it is assuemed to be relative. You can't just use (e.g.) patch.ea.com/Madden_2014/TeamUpdates/en_us/Patch.eaPatchImpl
         Paths are expected to be in a form compatible with paths used as HTML links,
         which means, for example, that special characters need to be escaped, etc.

         Example (demonstrates a patch that works for all locales):
            &lt;PatchImplURL L="*_*"&gt;http://patch.ea.com/Madden_2014/TeamUpdates/Patch.eaPatchImpl&lt;/PatchImplURL&gt;
         Example (server-relative):
            &lt;PatchImplURL L="*_*"&gt;Madden_2014/TeamUpdates/Patch.eaPatchImpl&lt;/PatchImplURL&gt;
         Example:
            &lt;PatchImplURL L="en_us"&gt;http://patch.ea.com/Madden_2014/TeamUpdates/en_us/Patch.eaPatchImpl&lt;/PatchImplURL&gt;
            &lt;PatchImplURL L="de_de"&gt;http://patch.ea.com/Madden_2014/TeamUpdates/de_de/Patch.eaPatchImpl&lt;/PatchImplURL&gt;
         Example (demonstrates a patch that works for any language used in the country of germany):
            &lt;PatchImplURL L="*_de"&gt;http://patch.ea.com/Madden_2014/TeamUpdates/de/Patch.eaPatchImpl&lt;/PatchImplURL&gt;
</span><span class="DownplayedText">--&gt;</span>
    &lt;PatchImplURL L="en_us"&gt;&lt;/PatchImplURL&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Entitlement ids, defined by the people who tie SKUs and users to downloadable entitlements. </span><span class="DownplayedText">--&gt;</span><span class="HighlightedText">
    </span><span class="DownplayedText">&lt;!--</span><span class="HighlightedText"> Identifies the patch for the purpose of entitlements (rights to use it).
         The format of this is application dependent and can be any kind of string 
         the application may find useful for matching patches.

         Example (showing two ContentIds this patch is valid for):
            &lt;ContentIdArray&gt;12345&lt;/ContentIdArray&gt;
            &lt;ContentIdArray&gt;67890&lt;/ContentIdArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;ContentIdArray&gt;&lt;/ContentIdArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">List of SKUs which this patch is valid for.
         The format of this is application dependent and can be any kind of string the
         application may find useful for matching patches.

         Example (showing two SKUs this patch is valid for):
            &lt;SKUIdArray&gt;12345&lt;/SKUIdArray&gt;
            &lt;SKUIdArray&gt;abcde&lt;/SKUIdArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;SKUIdArray&gt;&lt;/SKUIdArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: LocalizedString, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Human readable brief patch name (title). Must be localized Unicode text only, and not HTML, RTF, DOC, etc.

         Example:
            &lt;LocalizedString L="en_us"&gt;Team Updates&lt;/LocalizedString&gt;
            &lt;LocalizedString L="de_de"&gt;Team Aktuelles&lt;/LocalizedString&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;PatchName L="en_us"&gt;&lt;/PatchName&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: LocalizedString, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Human readable patch description. May be Unicode text, HTML (beginning with &lt;!DOCTYPE html ..&gt;),  
         or may be a URL to an HTML page (beginning with "http" or "https"). Your app should have an 
         embedded HTML display (e.g. EAWebKit) in order to display this HTML content.
         The format of the URL doesn't matter to the patching app.

         Example:
            &lt;PatchDescription L="en_us"&gt;Team Updates (can be a paragraph of text)&lt;/PatchDescription&gt;
            &lt;PatchDescription L="de_de"&gt;Team Aktuelles (can be a paragraph of text)&lt;/PatchDescription&gt;
         Example:
            &lt;PatchDescription L="en_us"&gt;&lt;!DOCTYPE html&gt;&lt;HTML&gt; Team Updates... &lt;/HTML&gt;&lt;/PatchDescription&gt;
            &lt;PatchDescription L="de_de"&gt;&lt;!DOCTYPE html&gt;&lt;HTML&gt; Team Aktuelles... &lt;/HTML&gt;&lt;/PatchDescription&gt;
         Example:
            &lt;PatchDescription L="en_us"&gt;http://patch.ea.com/Madden_2014/TeamUpdates/en_us/PatchDescription.html&lt;/PatchDescription&gt;
            &lt;PatchDescription L="de_de"&gt;http://patch.ea.com/Madden_2014/TeamUpdates/de_de/PatchDescription.html&lt;/PatchDescription&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;PatchDescription L="en_us"&gt;&lt;/PatchDescription&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: LocalizedString, optional</span><span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Optional EULA (End User License Agreement) that the user of the patch must agree
         to before installing the patch.

         Example:
            &lt;PatchEULA L="en_us"&gt;You agree to the terms of this software...&lt;/PatchEULA&gt;</span>
    --&gt;
    &lt;PatchEULA L="en_us"&gt;&lt;/PatchEULA&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Name of application which this patch applies to. The client app may wish to 
         test against this to validate that the patch belongs to it. This is not a 
         localized string, as it's not meant to be shown to users.

         Example:
            &lt;AppId&gt;Madden Football 2014&lt;/AppId&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;AppId&gt;&lt;/AppId&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">OSs which this patch applies to.
         Options include "*" "Win32" "Win64" "XBox 360" "PS3" "Wii" "WiiU" plus future platform names.

         Example (demonstrates that both Win32 and Win64 are supported):
            &lt;OSNameArray&gt;Win32&lt;/OSNameArray&gt;
            &lt;OSNameArray&gt;Win64&lt;/OSNameArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;OSIdArray&gt;*&lt;/OSIdArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray</span><span class="HighlightedText">, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Minimum OS versions needed to be able to download and use the patch. 
         Synchronized with mOSIdArray. </span>
    <span class="DownplayedText">--&gt;</span>
    &lt;MinOSVersionArray&gt;&lt;/MinOSVersionArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, optional </span><span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Date in an ISO 8601 format: "yyyy-MM-dd hh:mm:ss GMT", such as 
         "1994-11-06 08:49:37 GMT" for November 6, 1994. 

         Example:
            &lt;ReleaseDate&gt;2014-6-28 08:49:00 GMT&lt;/ReleaseDate&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;ReleaseDate&gt;&lt;/ReleaseDate&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: LocalizedString, optional </span><span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">List of supported locales. GetString returns NULL if the locale isn't 
         supported returns a non-NULL empty string if supported. 

         Example demonstrating that this patch supports the following two languages:
            &lt;LocaleSupport L="en_us"&gt;(any text here is currently ignored)&lt;/LocaleSupport&gt;
            &lt;LocaleSupport L="de_de"&gt;&lt;/LocaleSupport&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;LocaleSupport L="*_*"&gt;&lt;/LocaleSupport&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">List of patches which this patch supercedes, and thus aren't necessary 
         if you install this patch. This section may be absent if there are no 
         patches this patches supercedes.</span>

        <span class="HighlightedText"> Example:
            &lt;SupercedentPatchIdArray&gt;5556-3e21-4352-4321&lt;/SupercedentPatchIdArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;SupercedentPatchIdArray&gt;&lt;/SupercedentPatchIdArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray, optional </span><span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">List of patches (PatchIds) which supercede this patch. This section
         may be absent if there are no superceding patches.

         Example:
            &lt;SupercedingPatchIdArray&gt;1234-3e21-4352-3893&lt;/SupercedingPatchIdArray&gt;
            &lt;SupercedingPatchIdArray&gt;2345-3893-1234-2654&lt;/SupercedingPatchIdArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;SupercedingPatchIdArray&gt;&lt;/SupercedingPatchIdArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: StringArray, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">List of patches which this patch depends on being installed before 
         this one can be installed. This section may be absent if there are no dependent patches.

         Example:
            &lt;DependentPatchIdArray&gt;2222-1212-5454-6868&lt;/DependentPatchIdArray&gt;
            &lt;DependentPatchIdArray&gt;3333-1212-5454-5656&lt;/DependentPatchIdArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;DependentPatchIdArray&gt;&lt;/DependentPatchIdArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Where the patch goes. The format of this string is platform and 
         possibly application-specific. You can use either kind of directory
         separator (/ or \) and it will be converted to the platform type 
         at runtime. Normally this is a relative path, and thus doesn't begin
         with a leading '/' char (as that would refer to a full path). Be relative
         we mean relative to the base runtime data directory specified by the app.
         This can also be empty, which indicates that the patch occurs in the 
         base data directory.

         Example:
            &lt;PatchBaseDirectory&gt;GameData/Updates/&lt;/PatchBaseDirectory&gt;
         Example:
            &lt;PatchBaseDirectory&gt;&lt;/PatchBaseDirectory&gt;</span>
   <span class="DownplayedText"> --&gt;</span>
    &lt;PatchBaseDirectory&gt;&lt;/PatchBaseDirectory&gt;


    <span class="DownplayedText">&lt;!-- </span><span class="HighlightedText">Type: String, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Optional arbitrary information the user might want to associate with the patch.

         Example:
            &lt;UserInfo&gt;Four score and seven years ago today...&lt;/UserInfo&gt;
         Example:
            &lt;UserInfo&gt;&lt;/UserInfo&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;UserInfo&gt;&lt;/UserInfo&gt;


    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span><span class="HighlightedText"> Optional checksum/hash the user might want to associate with the patch. May have a 
         different meaning than any kind of hash we use elsewhere within this library.

         Example:
            &lt;UserChecksum&gt;3e4a286d929216da&lt;/UserChecksum&gt;
         Example:
            &lt;UserChecksum&gt;235,334,991,14,225&lt;/UserChecksum&gt;
         Example:
            &lt;UserChecksum&gt;&lt;/UserChecksum&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;UserInfo&gt;&lt;/UserInfo&gt;


    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: uint64_t: 64 bit non-negative integer, without commas, decimal or hex (beginning with 0x), optional</span><span class="DownplayedText"> --&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">The sum of the file sizes that an installed version of this patch uses. 
         Doesn't include ignored directories includes just the files in the patch. 
         This value is filled in by the Patch Maker.

         Example:
            &lt;FinalFileSizeUsage&gt;34895342&lt;/FinalFileSizeUsage&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;FinalFileSizeUsage&gt;&lt;/FinalFileSizeUsage&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: uint64_t: 64 bit non-negative integer, without commas, decimal or hex (beginning with 0x), optional</span> <span class="DownplayedText">--&gt;</span>
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">The amount of disk space an installed version of this patch uses. 
         Doesn't include ignored directories includes just the files in the patch. 
         This is usually a value a little greater than the sum of the file sizes, 
         due to things like file system sector sizes. This value is filled in by 
         the Patch Maker, though it can be overridden by a user edit afterwards.

         Example:
            &lt;FinalDiskSpaceUsage&gt;28489024&lt;/FinalDiskSpaceUsage&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;FinalDiskSpaceUsage&gt;&lt;/FinalDiskSpaceUsage&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: uint64_t: 64 bit non-negative integer, without commas, decimal or hex (beginning with 0x), optional</span> --&gt;
    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">The max amount of disk space the patch requires to have as part of its 
         download and install. This is &gt; mFinalDiskSpaceUsage, as in the simplest 
         case it could need a full patch image plus intermediate files created 
         by the build process. This value is filled in by the Patch Maker, though it
         can be overridden by a user edit afterwards.

         Example:
            &lt;IntermediateDiskSpaceUsage&gt;3728489025&lt;/IntermediateDiskSpaceUsage&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;IntermediateDiskSpaceUsage&gt;&lt;/IntermediateDiskSpaceUsage&gt;


    <span class="DownplayedText">&lt;!-- </span><span class="HighlightedText">Type: String, optional
         Script to run before installing the patch. May be a URL to a Lua script 
         instead of a script itself. See the EAPatch documentation for what the
         Lua script can do.
         This field may be omitted.</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;PreRunScript&gt;&lt;/PreRunScript&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: String, optional 
         Script to run after installing the patch. May be a URL to a Lua script 
         instead of a script itself. See the EAPatch documentation for what the
         Lua script can do.
         This field may be omitted.</span>
    <span class="DownplayedText">--&gt; </span>
    &lt;PostRunScript&gt;&lt;/PostRunScript&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: FileFilterArray, required (need to specify at least one of IgnoredFileArray and UsedFileArray) 
         Array of files to ignore, specified by wild-card-like filters. The files may be in subdirectories or in the root. 
         Subdirectories can be specified with wildcards as per the FnMatch function:
         http://linux.die.net/man/3/fnmatch. Options include:
            Pathname   - Wildcard don't can't see past directory separator chars.
            NoEscape   - Escape sequences (e.g. '\t') are not recognized. Escape sequences are only ever recognized with Unix-style paths and not DOS-style paths that use '\' chars. It's as if this flag is always active when DOS paths are in use.
            Period     - A leading '.' is matched only explicitly and not by * or ?.
            LeadingDir - Match a leading directory and allow ignoring after it.
            PrefixDir  - Directory path text that precedes the string can match the pattern.
            CaseFold   - Act case-insensitively.
            DosPath    - Force the path to be interpreted as a DOS path (e.g. '\') instead of native path.
            UnixPath   - Force the path to be interpreted as a Unix path (e.g. '/') instead of native path.
         The flags field may be empty, but must be present.
         See the example below for the syntax of the flags and path specification.
         This field may be omitted.
         FnMatch example behavior:
            Pattern               String              Flags                           Result
            _________________________________________________________________________________
            ""                    ""                  0                               true  
            "blah.txt",           "",                 0,                              false
            "*",                  "",                 0,                              true
            "",                   "blah.txt",         0,                              false
            "blah.txt"            "blah.txt"          0                               true  
            "a/b/c"               "a/b/c"             kFNMUnixPath                    true  
            "a/b/c"               "a/b/c"             kFNMUnixPath | kFNMPathname     true  
            "a\\b\\c"             "a\\b\\c"           kFNMDosPath                     true  
            "a\\b\\c"             "a\\b\\c"           kFNMDosPath | kFNMPathname      true  
            "a/b/c"               "a/_/c"             kFNMUnixPath                    false 
            "a/b/c"               "A/B/C"             kFNMUnixPath                    false 
            "a/b/c"               "A/B/C"             kFNMUnixPath | kFNMCaseFold     true  
            "a/b/?"               "a/b/c"             kFNMUnixPath                    true  
            "a/b/?"               "a/b/"              kFNMUnixPath                    false 
            "a\\b\\?"             "a\\b\\"            kFNMDosPath                     false 
            "*"                   "a/b/c"             kFNMUnixPath                    true  
            "*"                   "a\\b\\c"           kFNMDosPath                     true  
            "**"                  "a/b/c"             kFNMUnixPath                    true  
            "**"                  "a\\b\\c"           kFNMDosPath                     true  
            "???"                 "ab"                0                               false 
            "???"                 "abc"               0                               true  
            "a/b/c/*.?[ab]"       "a/b/c/d.qa"        kFNMUnixPath                    true  
            "a\\b\\c\\*.?[ab]"    "a\\b\\c\\d.qa"     kFNMDosPath                     true  
            "a/b/c/*.?[ab]"       "a/b/c/d.qq"        kFNMUnixPath                    false 
            "a\\b\\c\\*.?[ab]"    "a\\b\\c\\d.qq"     kFNMDosPath                     false 
            "a/*/*/d"             "a/bbbb/c/d"        kFNMUnixPath                    true  
            "a\\*\\*\\d"          "a\\bbbb\\c\\d"     kFNMDosPath                     true  
            "a/*/*/d"             "a/bbbb/c/d"        kFNMUnixPath | kFNMPathname     true  
            "a\\*\\*\\d"          "a\\bbbb\\c\\d"     kFNMDosPath | kFNMPathname      true  
            "/abc/def.txt"        "/abc/def.txt"      kFNMUnixPath                    true  
            "C:\\abc\\def.txt"    "C:\\abc\\def.txt"  kFNMDosPath                     true  
            "/abc/def.txt"        "/abc/Xef.txt"      kFNMUnixPath                    false 
            "C:\\abc\\def.txt"    "C:\\abc\\Xef.txt"  kFNMDosPath                     false
         Example usage:
            &lt;IgnoredFileArray flags="CaseFold UnixPath"&gt;GameData/AddOnData/*&lt;/IgnoredFileArray&gt;
            &lt;IgnoredFileArray flags="CaseFold UnixPath"&gt;GameData/Language.dat/&lt;/IgnoredFileArray&gt;
            &lt;IgnoredFileArray flags="CaseFold UnixPath"&gt;GameData/Locale*.dat&lt;/IgnoredFileArray&gt;</span>
    <span class="DownplayedText">--&gt;</span>
    &lt;IgnoredFileArray&gt;&lt;/IgnoredFileArray&gt;

    <span class="DownplayedText">&lt;!--</span> <span class="HighlightedText">Type: FileFilterArray, required (need to specify at least one of IgnoredFileArray and UsedFileArray) 
         This is similar to IgnoredFileArray except it defines a whitelist instead of a blacklist.</span>
         <span class="HighlightedText">If you want to have a patch which is just one or more files, you can just list them here. </span><span class="DownplayedText">--&gt;</span>
    &lt;UsedFileArray&gt;&lt;/UsedFileArray&gt;

&lt;/PatchImpl&gt;
</pre>
<h2><a name="EAPatchDir" id="EAPatchDir"></a>EAPatchDir (.eaPatchDir) file format</h2>
<p>EAPatchDir (.eaPatchDir) files are files that describe an available set of patches. An EAPatchDir file is simply a text file listing URLs for EAPatchInfo (.eaPatchInfo) files. Thus an EAPatchDir file is much like a restaurant menu which lists the available dishes. Note that a .eaPatchInfo file is a small XML file which describes the patch briefly, enough to present a user interface to an application user. The actual patch implementation is described in the .eaPatchImpl file. </p>
<p>EAPatchMaker doesn't generate .eaPatchDir files. They are optional and could be needed only if you want to present a menu of patches to a user to select from. The format of the file is described via an example of the file:</p>
<blockquote>
  <pre class="HighlightedText"># Example.eaPatchDir
# 
# This is a text file which simply lists URLs for available patches.
# Lines beginning with # are ignored, as are empty lines.
# The application may examine the list of patches and further reduce the 
# set of available patches based on information within the patch info file.
# In the example below, there is a separate directory for each .eapatchInfo
# file, but all .eaPatchInfo files could be in the same directory. However,
# the patch implementations themselves (.eaPatchImpl, etc.) still would 
# need to be in separate directories. The names of the .eaPatchInfo files
# are arbitrary and don't have to be the same as the directory they are 
# in, though it's easiest to understand if that's so and the .eaPatchImpl
# files are also named the same.
#
# Both absolute and relative URLs are supported. In the case of relative URLs
# the system assumes that the http://&lt;server&gt;/ part is just the same as whatever 
# server the .eaPatchDir came from.
# 
# Paths are expected to be in a form compatible with paths used as HTML links,
# which means, for example, that special characters need to be escaped, etc.

http://patch.ea.com:1234/Basebrawl_2014/Patch1/Patch1.eaPatchInfo
http://patch.ea.com:1234/Basebrawl_2014/Patch2/Patch2.eaPatchInfo
http://patch.ea.com:1234/Basebrawl_2014/Patch3/Patch3.eaPatchInfo
http://patch.ea.com:1234/Basebrawl_2014/Patch4/Patch4.eaPatchInfo
Basebrawl_2014/Patch5/Patch5.eaPatchInfo
Basebrawl_2014/Patch6/Patch6.eaPatchInf</pre>
</blockquote>
<h2></h2>
<hr />
<p>&nbsp;</p>
</body>
</html>
