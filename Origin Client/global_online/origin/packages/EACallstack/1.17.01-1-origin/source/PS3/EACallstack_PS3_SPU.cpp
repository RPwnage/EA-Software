///////////////////////////////////////////////////////////////////////////////
// EACallstack_PS3_SPU.cpp
//
// Copyright (c) 2003-2005 Electronic Arts Inc.
// Created by Paul Pedriana
///////////////////////////////////////////////////////////////////////////////


#include <EABase/eabase.h>

#if defined(EA_PLATFORM_PS3_SPU)

#include <EACallstack/EACallstack.h>
#include <EACallstack/Context.h>
#include EA_ASSERT_HEADER


namespace EA
{
namespace Callstack
{


EACALLSTACK_API void InitCallstack()
{
    // Nothing needed.
}


EACALLSTACK_API void ShutdownCallstack()
{
    // Nothing needed.
}



struct SPUStackFrame
{
    const SPUStackFrame* pNext;
    uint32_t             availableStackSize;
    uint32_t             unused1;
    uint32_t             unused2;
    const char*          pReturnAddress;
} __attribute__((aligned(16)));


// Declare a global register variable for the current compilation unit. This allows us 
// to use the given register safely within the compilation unit. You can see what this 
// is about at:
//     http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Global-Reg-Vars.html#Global-Reg-Vars
// This is not portable to SNC. It's probably best to use __builtin_frame_address() in SNC.
#if defined(__SNC__)
    #define spRegister ((SPUStackFrame*)__builtin_frame_address())
    #define lrRegister ((char*)__builtin_return_address())
#else
    register SPUStackFrame* spRegister __asm__("$sp");  // sp is the same as r1.word[0]. 
    register char*          lrRegister __asm__("$lr");  // lr is the same as r0.word[0].
#endif



///////////////////////////////////////////////////////////////////////////////
// GetCallstack
//
// Note that in optimized builds some functions may not have a stack frame.
// This is typically so when the function has no local variables or has local
// variables which can be somehow 'optimized away' by the optimizer.
//
// We have the following snippet which deals with the case of relocatable code.
// It works by loading the link-time-specified address of the label "1:" into 
// linkTimeAddress via the ila instruction (1f means label 1, forward).
// This is the link-time address because the asm generated by the compiler is 
// simply executing what was generated at compile-time. It wouldn't be safe if 
// you tried to jump to that value, since the code might have been relocated.
// Then it loads the actual runtime address into the actualAddress variable 
// via the brsl (branch-relative) instruction which simply branches to the next 
// instruction and stores the the address of that instruction into actualAddress. 
// If the code has been relocated upon load then relocationDistances will be non-zero. 
// If you want to represent the addresses in their original link-time form then you 
// need to subtract relocationDistance from all values.
//
//    uint32_t linkTimeAddress, actualAddress, relocationDistance;
//    __asm__ ("ila %0,1f\n\tbrsl\t%1,1f\n1:" : "=r" (linkTimeAddress), "=r" (actualAddress));
//    relocationDistance = actualAddress - linkTimeAddress;
//
// In our case here, we report the link-time addresses, as the user usually 
// wants to look these up in a symbol reader. 
//
// This function is about 270 bytes in size in a debug build and 170 in an optimized build.
// 
// If the pContext argument is non-NULL, then it must refer to a currently valid 
// stack context. If pContext is non-NULL, then if its context or the current context
// has been relocated then the resulting addresses may be an an incorrect offset.
//
EACALLSTACK_API size_t GetCallstack(void* pAddressArray[], size_t nAddressArrayCapacity, const CallstackContext* pContext)
{
    size_t nEntryIndex = 0;
    const SPUStackFrame* pFrame = (pContext ? (const SPUStackFrame*)pContext->mGPR1 : spRegister);
    const char* pReturnAddress = (pContext ? (const char*)pContext->mGPR0 : lrRegister);

    uint32_t linkTimeAddress, actualAddress, relocationDistance;
    __asm__ ("ila %0,1f\n\tbrsl\t%1,1f\n1:" : "=r" (linkTimeAddress), "=r" (actualAddress));
    relocationDistance = actualAddress - linkTimeAddress;

    for(pFrame = pFrame->pNext;
        pFrame && (pFrame <= (SPUStackFrame*)0x0003fff0) && (nEntryIndex < (nAddressArrayCapacity - 2)); 
        pFrame = pFrame->pNext, pReturnAddress = pFrame->pReturnAddress)
    {
        // The call address is often a single 32 bit instruction prior to the return address.
        // Sometimes it is more instructions prior; uncommonly it can be instructions later.
        pAddressArray[nEntryIndex++] = const_cast<char*>((pReturnAddress - 4) - relocationDistance);
    }

    pAddressArray[nEntryIndex++] = (void*)relocationDistance; // We store the relocation distance as the last entry, so the user can reference it if needed.
    pAddressArray[nEntryIndex]   = 0;

    return nEntryIndex;
}


///////////////////////////////////////////////////////////////////////////////
// GetCallstackContext
//
EACALLSTACK_API bool GetCallstackContext(CallstackContext& context, intptr_t /*threadId*/)
{
    return GetCallstackContext(context, NULL); // There can only be the current thread. It may be useful to see that threadId matches the current thread.
}


///////////////////////////////////////////////////////////////////////////////
// GetCallstackContextSysThreadId
//
EACALLSTACK_API bool GetCallstackContextSysThreadId(CallstackContext& context, intptr_t threadId)
{
    return GetCallstackContext(context, threadId);
}


///////////////////////////////////////////////////////////////////////////////
// GetCallstackContext
//
EACALLSTACK_API void GetCallstackContext(CallstackContext& context, const Context* pContext)
{
    if(pContext)
    {
        context.mGPR0 = pContext->mGpr[0].mWord[0];
        context.mGPR1 = pContext->mGpr[1].mWord[0];
    }
    else
    {
        register uint32_t* pReturnAddress asm("$lr");  // lr is the same as r0.word[0]
        register uint32_t* pFrame asm("$sp");          // sp is the same as r1.word[0]

        union P32_U32 { void* pVoid; uint32_t* p32; uint32_t u32; };
        P32_U32 addr  = { pReturnAddress };
        P32_U32 frame = { pFrame };

        context.mGPR0 = addr.u32;
        context.mGPR1 = frame.u32;
    }
}


///////////////////////////////////////////////////////////////////////////////
// GetModuleFromAddress
//
EACALLSTACK_API size_t GetModuleFromAddress(const void* /*address*/, char* pModuleName, size_t /*moduleNameCapacity*/)
{
    pModuleName[0] = 0;
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
// GetModuleHandleFromAddress
//
EACALLSTACK_API ModuleHandle GetModuleHandleFromAddress(const void* /*pAddress*/)
{
    return 0;
}


} // namespace Callstack
} // namespace EA


#endif // compile guard

