--- a/include/EAIO/EAIniFile.h	2012-11-06 22:51:01.000000000 -0800
+++ b/include/EAIO/EAIniFile.h	2012-11-06 22:51:01.000000000 -0800
@@ -230,6 +230,7 @@
             virtual bool LoadSectionNames(int nAccessFlags);
             virtual bool GetFileLine8To8(String8& sLine);
             virtual bool GetFileLine16To16(StringW& sLine);
+            virtual bool GetFileLine16To32(StringW& sLine);
             virtual bool GetFileLine(StringW& sLine);
             virtual bool ConvertAndWriteStream(const wchar_t* pchar, size_t size);
             virtual int  ReadEntry(const wchar_t* pSection, const wchar_t* pKey, wchar_t* pValue, size_t nValueLength);
--- a/source/EAIniFile.cpp	2012-11-06 22:51:01.000000000 -0800
+++ b/source/EAIniFile.cpp	2012-11-06 22:51:01.000000000 -0800
@@ -18,6 +18,7 @@
 #include <EAStdC/EAString.h>
 #include <EAStdC/EASprintf.h>
 #include <EAStdC/EAScanf.h>
+#include <EAStdC/EAEndian.h>
 #include <EASTL/list.h>
 #include <EASTL/vector.h>
 #include <EASTL/fixed_string.h>
@@ -1370,7 +1371,13 @@
     sLine.clear();
     
     if(GetCharacterSize(mnEncodingSrc) == 2)
-        return GetFileLine16To16(sLine);
+    {
+        if (sizeof(wchar_t) == 2)
+            return GetFileLine16To16(sLine);
+        
+        else
+            return GetFileLine16To32(sLine);
+    }
 
     String8 sLine8;
 
@@ -1549,6 +1556,88 @@
     return bResult;
 }
 
+///////////////////////////////////////////////////////////////////////////////
+// GetFileLine16To32
+//
+// Reads 16 bit text into a 32 bit UTF16 string.
+//
+bool IniFile::GetFileLine16To32(StringW& sLine)
+{
+    using namespace EA::IO;
+    using namespace IFLocal;
+    typedef char16_t cType;
+    
+    bool            bResult             = false;
+    IO::off_type    nCurrentPosition    = mpStream->GetPosition();
+    bool            bEOLFound           = false;
+    const size_type kBufferLength       = 64 * sizeof(cType); // A reasonable chunk size for an .ini file line. The final line may end up being longer.
+    const size_type kBufferSize         = kBufferLength * sizeof(cType);
+    cType           buffer[kBufferLength];
+    bool            requiresSwizzle     = mnEncodingSrc != GetLocalUCS2Encoding();
+    
+    sLine.clear();
+    memset(buffer, 0, sizeof(buffer));
+    
+    while(!bEOLFound)
+    {
+        const size_type nBytesRead = mpStream->Read(&buffer, kBufferSize);
+        
+        if((nBytesRead == 0) || (nBytesRead == kSizeTypeError)) // If we are at the end of the file or there is an error...
+            break;
+        
+        bResult = true; // If we have successfully read anything, then the return value is going to be true.
+        
+        // Search for EOL in this chunk. EOL means any of 0x0d or 0x0a. We are trying to be somewhat platform-independent here.
+        IO::off_type pos;
+        
+        for(pos = 0; pos < (IO::off_type)nBytesRead; pos++)
+        {
+            cType c = buffer[pos];
+            if (requiresSwizzle)
+                c = (cType)EA::StdC::Swizzle((uint16_t)c);
+            
+            if((c == 0x0d) || (c == 0x0a)) // If the character is one of the newline characters...
+            {
+                bool  bEOFFound = false;
+                
+                bEOLFound = true;
+                
+                // Now seek to the beginning of the next (non-empty) line.
+                // With some deftness, this code below can be made to work without using the stream as much.
+                mpStream->SetPosition(nCurrentPosition + (pos * sizeof(c))); // We need to seek here because our initial read was to the end of 'buffer'.
+                do{
+                    if(mpStream->Read(&c, sizeof(c)) != sizeof(c))
+                        bEOFFound = true;
+
+                    if (requiresSwizzle)
+                        c = (cType)EA::StdC::Swizzle((uint16_t)c);
+                    
+                } while(!bEOFFound && ((c == 0x0d) || (c == 0x0a)));
+                
+                if(!bEOFFound)
+                    mpStream->SetPosition(-(IO::off_type)sizeof(c), IO::kPositionTypeCurrent); // Seek back by one character, since we we'll need that last one next round.
+                break;
+            }
+        }
+        
+        // Convert 16-but buffer to sLine (32), making sure to swizzle the data as necessary
+        if (requiresSwizzle)
+        {
+            for (IO::off_type i = 0; i < pos; ++i)
+                sLine += (StringW::value_type)EA::StdC::Swizzle((uint16_t)buffer[i]);
+        }
+        
+        else
+        {
+            for (IO::off_type i = 0; i < pos; ++i)
+                sLine += buffer[i];
+        }
+        
+        nCurrentPosition = mpStream->GetPosition();
+    }
+    
+    return bResult;
+}
 
 bool IniFile::SectionExists(const wchar_t* pSection)
 {
