///////////////////////////////////////////////////////////////////////////////
// ExceptionHandler.h
// 
// Copyright (c) 2005, Electronic Arts. All Rights Reserved.
// Written and maintained by Vasyl Tsvirkunov and Paul Pedriana.
//
// Exception handling and reporting facilities.
///////////////////////////////////////////////////////////////////////////////


#ifndef EXCEPTIONHANDLER_EXCEPTIONHANDLER_H
#define EXCEPTIONHANDLER_EXCEPTIONHANDLER_H


#include <EABase/eabase.h>
#include <ExceptionHandler/internal/Config.h>
#include <ExceptionHandler/ReportWriter.h>
#include <EASTL/fixed_list.h>
#include <EASTL/fixed_string.h>
#include <EASTL/core_allocator_adapter.h>
#include <eathread/eathread.h>
#include <eathread/eathread_thread.h>
#include <EAIO/EAFileBase.h>
#include <EACallstack/Context.h>
#include <stdio.h>


namespace EA
{
    namespace Debug
    {
        // Forward declarations
        class ExceptionHandlerClient;
        class ExceptionHandler;
        class ReportWriter;


        /// String
        /// A generic string type.
        typedef eastl::fixed_string<char, 512, true, EA::Allocator::EASTLICoreAllocator> String;


        /// ExceptionType
        ///
        /// These are generic exception types. Individual CPUs will usually have addition
        /// exception types, but usually have some form of the generic ones here. When you 
        /// are looking at an exception report, its exception type or code information will
        /// usually be defined in the platform-specific type and not one of the generic 
        /// types here unless specifically documented otherwise. This enumeration remains
        /// useful for the CreateException function, which itself is mostly a testing function.
        ///
        enum ExceptionType
        {
            kExceptionTypeNone,
            kExceptionTypeAccessViolation,      /// Read or write to inaccessable memory.
            kExceptionTypeIllegalInstruction,   /// Illegal opcode.
            kExceptionTypeDivideByZero,         /// Integer divide by zero.
            kExceptionTypeStackOverflow,        /// Stack ran out of space, often due to infinite recursion.
            kExceptionTypeStackCorruption,      /// Stack frame was corrupted.
            kExceptionTypeAlignment,            /// Misaligned read or write.
            kExceptionTypeFPU,                  /// Floating point / VPU exception.
            kExceptionTypeTrap,                 /// System/OS trap (system call).
            kExceptionTypeOther                 /// CPU-specific.
        };


        /// CreateException
        ///
        /// Creates an exception of the given type.
        /// If the ExceptionHandler argument is non-NULL, the exception is 
        /// explicitly set to be handled by the given ExceptionHandler.
        ///
        void CreateException(ExceptionType exceptionType, ExceptionHandler* pExceptionHandler = NULL);


        /// UserFunction
        /// This is a function type used for RunTrapped. It has been superceded by 
        /// the EAThread-style function types but remains for compatibility.
        typedef void (*UserFunction)(void*);


        /// ExceptionHandler
        /// 
        /// App-accessible ExceptionHandler class. Create an instance of this class
        /// in your main thread to start exception handling. See also notes for
        /// RunTrapped function in this class.
        /// This class is actually a proxy for platform-specific implementation.
        class ExceptionHandler
        {
        public:
            /// enum ReportTypeMask
            /// Defines flags of what kinds of reports are written in response to an exception.
            enum ReportTypeMask
            {
                kReportTypeNone           = 0x00000000,     // No reports of any type.
                kReportTypeException      = 0x00000001,     // Exception report generated by ReportWriter.
                kReportTypeMinidump       = 0x00000002,     // Microsoft minidump. This type has no applicability to non-Microsoft platforms.
                kReportTypeAll            = 0xffffffff 
            };

            /// enum ReportFieldMask
            /// Bitfield to control output of individual sections of exception report.
            /// Used by EnableReportField. Most clients will leave it at default (all
            /// fields enabled).
            enum ReportFieldMask
            {
                kReportFieldNone          = 0x00000000,
                kReportFieldHeader        = 0x00000001,
                kReportFieldCallStack     = 0x00000002,
                kReportFieldRegisters     = 0x00000004,
                kReportFieldLoadedModules = 0x00000008,
                kReportFieldExtraData     = 0x00000010,
                kReportFieldMemoryDumps   = 0x00000020,
                kReportFieldOpenFiles     = 0x00000040,
                kReportFieldProcessList   = 0x00000080,
                kReportFieldAll           = 0xffffffff
            };

            /// enum EventId
            /// All possible client notification IDs
            enum EventId
            {
                kExceptionHandlingBegin,
                kExceptionHandlingEnd,
                kExceptionHandlingEnabled,
                kExceptionHandlingDisabled,
                kReadyForExtraData,
                kExtraDataDone
            };


            /// Mode
            enum Mode
            {
                kModeSignalHandling,    /// Refers to Posix/Unix sigint handling.
                kModeCPP,               /// Refers to C++ try/catch. Some compilers (e.g. VC++) provide some amount of support for handling processor exceptions via C++ handling. Compiler support varies and there are often options to control how an individual compiler supports it.
                kModeStackBased,        /// Refers to OS-provided handling where you handle exceptions like C++ try/catch but at the OS API level. This is only supported by Microsoft (__try/__catch) as of this writing.
                kModeVectored,          /// Refers to OS-provided handling where your handler is in a separate thread listening for events. e.g. Windows structured exception handling, Apple mach-level exception hanlding, Sony PS3 exception handling, Ninteno exception handling.
                kModeDefault            /// Refers to the most practical for the current platform and build type.
            };
            
            /// enum Action
            /// Defines what we should do after we catch an exception.
            /// Some of these actions may not be possible with all platforms.
            /// For example, kActionContinue is not possible on the PS3 platform,
            /// due to the way it does exception handling via callback instead of try/catch.
            enum Action
            {
                kActionContinue,    /// Continue execution from the point of the catch.
                kActionTerminate,   /// Terminate execution at the point of the catch.
                kActionThrow,       /// Propogate the exception so another handler can catch it.
                kActionDefault      /// Whatever is appropriate for the given platform and mode. For kModeCPP default is to continue. For kModeVectored on platforms that don't support recovering from threads, default is kActionTerminate.
            };

            /// kDefaultTerminationReturnValue
            /// The value that is returned by default to the operating system when the 
            /// exception handler terminates the application.
            static const int kDefaultTerminationReturnValue = -1;

        public:
            /// ExceptionHandler
            /// Class constructor
            ExceptionHandler();

            /// ~ExceptionHandler
            /// Class destructor
            virtual ~ExceptionHandler();

            /// IsValid
            /// Returns true if exception handler is properly constructed
            /// Checks if the exception handler is properly formed. It is possible for
            /// this function to return false if a platform does not have exception
            /// handler implemented -- it is not fatal, just means that exception
            /// handling is not being done.
            virtual bool IsValid() const;

            /// Allows you to set a memory allocator for use by ExceptionHandler.
            /// Due to the fact that the global heap may be in an unstable state during a crash (it may have crashed itelf), 
            /// allocators set here ideally should be separated from the main heap. ExceptionHandler itself does not use
            /// this allocator (as it doesn't allocate memory), though it passes it down to the ReportWriter that it uses, 
            /// which itself may use it.
            virtual EA::Allocator::ICoreAllocator* GetAllocator() const;
            virtual void SetAllocator(EA::Allocator::ICoreAllocator* pCoreAllocator);

            /// SetMode
            /// Sets how exception handling is implemented, as some platforms have multiple
            /// options for this (e.g. Apple sigint and mach, and Microsoft structured and vectored).
            /// SetMode be called as part of setup before SetEnabled and RunTrapped is called.
            /// Currently only one mode can be active at a time. However, until some day that
            /// multi-mode support is available, you can use two ExceptionHandler instances
            /// to enable the usage of multiple modes.
            virtual bool SetMode(Mode mode);

            /// SetEnabled
            /// Enable or disable exception handling. This function controls exception
            /// handling by both UnhandledExceptionHandler and trapped execution.
            /// The exception handler cannot be disabled if there is function running
            /// trapped. If you are running the app under a debugger then you probably
            /// want to SetEnabled(false) in order to let the debugger handle exceptions.
            /// We provide a static IsDebuggerPresent() function to test for this.
            /// If you want to set a custom mode via SetMode, it must be called before
            /// calling SetEnabled.
            virtual bool SetEnabled(bool state);

            /// IsEnabled
            /// Returns true if exception handling is enabled
            /// Check if exception handling is enabled. Return true if it is, false if
            /// if it is not or the handler is not valid.
            virtual bool IsEnabled() const;

            /// SetBuildDescription
            /// Stores a string used to describe the current build. This string is printed
            /// at the top of exception reports so that the reports can be distinguished.
            /// The contents pointed to by the input string pointer are copied to an 
            /// internal buffer. The build description is expected -- but not strictly
            /// required -- to be in the same format as exception report line output. 
            /// That is, it is expected to have a 'type: value\n'format per line.
            /// The build description can contain multiple lines, as it is merely echoed
            /// to the report file when the file is written.
            virtual void SetBuildDescription(const char* pBuildDescription);

            /// GetBuildDescription
            /// Returns the build description set by SetBuildDescription. The returned 
            /// pointer will not be the same pointer as passed to SetBuildDescription.
            virtual const char* GetBuildDescription() const;

            /// SetAction
            /// Controls what happens after the exception has been caught. 
            /// The default action if SetAction is not called is kActionDefault.
            virtual void SetAction(Action action, int returnValue = kDefaultTerminationReturnValue);

            /// GetAction
            /// Returns the Action information which controls what happens after 
            /// an exception has been caught.
            virtual Action GetAction(int* pReturnValue = NULL) const;

            // Deprecated, present for temporary backwards compatibility:
            virtual void SetTerminateOnException(bool state);
            virtual bool GetTerminateOnException() const;

            /// SetReportFileName
            /// Lets you specify the file name or file path for the generation of the next
            /// exception report. If a minidump is generated then it will be of the same name 
            /// as this file name/path but with .mdmp as a file name extension instead.
            /// Example usage (file name):
            ///     exceptionHandler.SetReportFileName("MyReportFileName.txt");
            /// Example usage (file path):
            ///     exceptionHandler.SetReportFileName("/a/b/MyReportFileName.txt");
            virtual void SetReportFileName(const char8_t* pReportFileName);
            virtual void SetReportFileName(const char16_t* pReportFileName);

            /// SetReportDirectory
            /// The string pointed to by pReportDirectory is copied to an internal buffer.
            /// The default path directory is an empty string. The directory path is 
            /// not expected to have a trailing path separator.
            /// You don't need to call this function if you call SetReportFileName with
            /// a file path as opposed to a file name.
            /// Example usage:
            ///     exceptionHandler.SetReportDirectory("/a/b/");
            virtual void SetReportDirectory(const char8_t* pReportDirectory);
            virtual void SetReportDirectory(const char16_t* pReportDirectory);

            /// GetReportDirectory
            /// Returns a pointer to a path directory.
            /// The default path directory is an empty string.
            /// The returned directory will either be empty or will have a trailing 
            /// path separator appended, even if the user called SetReportDirectory without one.
            virtual const char16_t* GetReportDirectory() const;
            
            /// GetCurrentReportFilePath
            /// Gets the file path to the most recently generated exception report.
            /// The return value is the required strlen of the output buffer.
            /// Returns 0 if reportType is invalid or if there is no current path.
            virtual size_t GetCurrentReportFilePath(char* buffer, size_t capacity, ReportTypeMask reportType = kReportTypeException);

            /// GenerateReportFilePath
            /// Generates the standard report path for the given report type. 
            /// The return value is the required strlen of the output buffer.
            /// This is used prior to creating an exception report file for the purposes of 
            /// picking a name for the file. This used to be named GetReportFilePath.
            virtual size_t GenerateReportFilePath(char* buffer, size_t capacity, ReportTypeMask reportType = kReportTypeException);

            /// RemoveReportFile
            /// Deletes a report file from disk.
            /// This is useful for the case that it's been generated and you have uploaded it or otherwise
            /// don't need it any more. 
            /// Example usage:
            ///     eh.RemoveReportFile(ExceptionHandler::kReportTypeException | ExceptionHandler::kReportTypeMinidump);
            virtual bool RemoveReportFile(int reportTypeFlags);

            /// GetReportWriter
            /// Example usage:
            ///     pExceptionHandler->GetReportWriter()->SetOption(ReportWriter::kOptionReportUserName, 1);
            virtual ReportWriter* GetReportWriter() const;

            /// SetReportWriter
            virtual void SetReportWriter(ReportWriter* pReportWriter);

            // Temporary backward compatbility. The fTrapped name is deprecated.
            typedef UserFunction fTrapped;

            /// RunTrapped
            /// Returns true if an exception was caught during trapped function execution.
            /// Executes function while handling exceptions. This is a preferred way to
            /// deal with exceptions. While just keeping instance of the ExceptionHandler
            /// will work on some platforms (Win32 with SEH) it may be unavailable on
            /// others. RunTrapped is always available. It also allows the client app
            /// to gracefully deal with exceptions: potentially unsafe code should be
            /// running in trapped section and cleanup or restart actions should be taken
            /// if RunTrapped return true.
            /// Note that if exception handler is not valid this will still execute the
            /// trapped function but no exceptions will be handled.
            /// In 'vectored' exception handling modes (kModeVectored, kModeSignalHandling)
            /// you don't need to call RunTrapped but can just start executing code after
            /// calling SetEnabled(true)
            virtual bool RunTrapped(UserFunction userFunction, void* pContext);

            /// EAThread-based RunTrapped
            ///
            /// This allows you to automatically route all threads created by EAThread through
            /// an exception handler. Some platforms (e.g. Microsoft console platforms) require 
            /// you to do this because they don't support the concept of a global exception handler.
            /// Other platforms (e.g. Unix, Apple, Sony, Nintendo), don't require you to use this
            /// because exception handling is done via a global handler that's always active.
            ///
            /// Example usage:
            ///    // Define one or more of your own thread functions as usual.
            ///    static intptr_t SomeThreadFunction(void* pContext)
            ///        { return 0; }
            ///    
            ///    // You need define only one such function as this:
            ///    static intptr_t RunFunction(EA::Thread::RunnableFunction runnableFunction, void* pContext)
            ///        { return EA::Debug::GetDefaultExceptionHandler()->RunTrapped(runnableFunction, pContext); }
            ///    
            ///    // Code executed once on startup.
            ///    ExceptionHandler eh;                                                   // This needs to be exist for the duration of the program.
            ///    EA::Debug::SetDefaultExceptionHandler(&eh);                            // We call SetDefaultExceptionHandler so that RunFunction above can grab it via GetDafaultExceptionHandler. You don't necessarily need to do this in your case.
            ///    EA::Thread::Thread::SetGlobalRunnableFunctionUserWrapper(RunFunction); // Call this once on startup.
            ///    
            ///    // Create and user your Thread objects as usual. However, thread execution will be routed through the 
            ///    // ExceptionHandler due to the registered RunFunction above. Note that the following code is disconnected
            ///    // from the code above and any code in the app that creates threads will automatically inherit the above
            ///    // exception handling.
            ///    EA::Thread::Thread thread;
            ///    intptr_t           threadReturnValue;
            ///    thread.Begin(SomeThreadFunction, pSomeUserContext, NULL);              // If an exception is caught then the ExceptionHandler would have handled it. On some platforms the application is 
            ///    thread.WaitForEnd(EA::Thread::kTimeoutNone, &threadReturnValue);       // terminated and so WaitForEnd would never return. The RegisterClient API lets you listen for caught exceptions.
            ///    
            virtual intptr_t RunTrapped(EA::Thread::RunnableFunction runnableFunction, void* pContext);
            virtual intptr_t RunTrapped(EA::Thread::IRunnable* pRunnableClass, void* pContext);

            /// ExceptionInfo
            /// This is a base class for platform-specific exception information. In each platform-specific
            /// exception handler class there will be a subclass of this which provides extended information.
            /// You can static-cast ExceptionInfo to the platform-specific class.
            struct ExceptionInfo
            {
                tm                      mTime;                          /// Time of the exception.
                void*                   mCallstack[24];                 /// Callstack of the exception generating thread. The first entry is the most recent entry in the stack, where the exception occurred.
                size_t                  mCallstackEntryCount;           /// Count of valid entries in mCallstack.
                EA::Thread::ThreadId    mThreadId;                      /// This is the ThreadId the exception occurred in.
                EA::Thread::SysThreadId mSysThreadId;                   /// This is the SysThreadId the exception occurred in.
                char                    mThreadName[24];                /// The name the user assigned to the thread with the exception.
                void*                   mpExceptionInstructionAddress;  /// The address (program counter) of the instruction where the exception occurred.
                void*                   mpExceptionMemoryAddress;       /// The memory location at which a memory fault occurred (if applicable). For example, if the exception is for reading an invalid pointer, this holds that pointer.
                EA::Callstack::Context  mContext;                       /// The CPU context at the time of the exception.
                String                  mExceptionDescription;          /// String description of the exception (e.g. "invalid memory read from 0x0034a248")
                // See the platform-specific subclass for extended details.

                ExceptionInfo();
            };

            /// GetExceptionInfo
            /// You can static-cast ExceptionInfo to the platform-specific class.
            /// This is a new function which now replaces some other functions here.
            /// This function is guaranteed to return valid data only when called from a 
            /// registered client exception notification.
            const ExceptionInfo* GetExceptionInfo() const;

            // Deprecated functions. use GetExceptionInfo instead.
                size_t GetExceptionCallstack(void* pCallstackArray, size_t capacity) const;
                const EA::Callstack::Context* GetExceptionContext() const;
                EA::Thread::ThreadId GetExceptionThreadId(EA::Thread::SysThreadId& sysThreadId, char* threadName, size_t threadNameCapacity) const;
                void* GetPlatformExceptionInfo();
            // End deprecated functions.

            /// EnableReportTypes
            /// Controls which type of reports are generated.
            virtual void EnableReportTypes(int reportTypes);

            /// GetReportTypes
            virtual int GetReportTypes() const;

            /// EnableReportFields
            /// Controls which parts of the exception report are being written to the file.
            virtual void EnableReportFields(int reportFields);

            /// GetReportFields
            virtual int GetReportFields() const;

            /// GetCallstackFlags
            /// Returns the flags set by SetCallstackFlags, or the default.
            virtual int GetCallstackFlags() const;

            /// SetCallstackFlags
            /// Specifies what kind of callstack information to report, if kReportFieldCallStack is 
            /// enabled (e.g. via EnableReportFields). 
            /// Default is EA::Callstack::kARTFlagFileLine | kARTFlagFunctionOffset | kARTFlagAddress
            /// You may want to disable one or more of these if your exceptions are such that they
            /// corrupt your code or heap, and instead analyze the callstack information outside of the application.
            virtual void SetCallstackFlags(int addressRepTypeFlags);

            /// GetMiniDumpFlags
            virtual int GetMiniDumpFlags() const;

            /// SetMiniDumpFlags
            /// Specifies the set of flags to pass to the minidump generator.
            /// Default is 0 (none / normal).
            /// The interpretation of these flags is handler/platform-specific.
            virtual void SetMiniDumpFlags(int miniDumpFlags);

            // Minidump reading functionality. This is used for reading minidump data in 
            // a way that avoids allocating a memory buffer. This may be called only after 
            // the minidump was successfully written. 
            // Example usage:
            //     ExceptionHandler eh;
            //     char buffer[2048];
            //     FILE fp;
            //     . . .
            //     if(eh.ReadMinidumpBegin()) {
            //         ssize_t size;
            //         while((size = (ssize_t)eh.ReadMinidumpPart(buffer, 2048)) > 0)
            //             fwrite(fp, buffer, size, 1);
            //     }
            virtual bool    ReadMinidumpBegin();                           // Returns true if successful.
            virtual size_t  ReadMinidumpPart(char* buffer, size_t size);   // Returns (ssize_t)-1 upon error, 0 if no more to read, else the number of bytes read. Call this repeatedly until it returns -1 or 0.
            virtual void    ReadMinidumpEnd();                             // This must always be called if ReadMinidumpBegin returned true.

            /// SimulateExceptionHandling
            /// exceptionType is one of enum ExceptionType or some non-enumerated custom type.
            virtual void SimulateExceptionHandling(int exceptionType);

            /// WriteExceptionReport
            /// Generic function for writing exception reports.
            virtual void WriteExceptionReport();

            /// RegisterClient
            /// Register or unregister an exception client. Clients receive notifications about
            /// beginning and end of exception handling and also get a chance to add extra
            /// information to the exception report. Multiple clients can register simultaneously.
            /// The last registered client will be the first notified (LIFO).
            virtual void RegisterClient(ExceptionHandlerClient* pClient, bool bRegister);

            /// NotifyClients
            /// Sends notification to all clients via function call. The most recently registered
            /// client will be notified first and the first registered client will be notified last.
            virtual void NotifyClients(EventId eventId);

            /// GetPlatformHandler
            /// Converts the platform handler to the appropriate type. 
            /// It is assumed that the user knows what the appropriate casts are.
            /// Example usage:
            ///     ExceptionHandlerWin32* pEHWin32 = pEH->GetPlatformHandler<ExceptionHandlerWin32*>();
            template <typename U>
            U GetPlatformHandler()
                { return static_cast<U>(mpPlatformHandler); }

            /// IsDebuggerPresent
            /// Tells if a debugger appears to be present while this app is running.
            static bool IsDebuggerPresent();

            /// Sets up mpPlatformHandler to point to the platform-specific version.
            void AllocatePlatformHandler(bool allocate);

        public:
            // To do: Move this section to a private shared header or find a similar solution. It's declared public 
            // here because every possible platform-specific handler would need to access it, and the C++ language 
            // doesn't have a means for grouping access aside from manually listing each type.
            union UserFunctionUnion
            {
                EA::Debug::UserFunction      mEADebugUserFunction;
                EA::Thread::RunnableFunction mEAThreadRunnableFunction;
                EA::Thread::IRunnable*       mpEAThreadRunnableClass;
            };

            enum UserFunctionType
            {
                kEADebugUserFunction,
                kEAThreadRunnableFunction,
                kEAThreadRunnableClass
            };

            static intptr_t ExecuteUserFunction(UserFunctionUnion userFunction, UserFunctionType userFunctionType, void* pContext);
            intptr_t RunTrappedInternal(UserFunctionUnion userFunction, UserFunctionType userFunctionType, void* pContext, bool& exceptionCaught);

        protected:
            void   WriteHeader();
            void   WriteCallStack();
            void   WriteThreadList();
            void   WriteProcessList();
            void   WriteRegisters();
            void   WriteLoadedModules();
            void   WriteMemoryDumps();
            void   WriteExtraData();
            void   WriteOpenFileList();

            typedef eastl::fixed_list<ExceptionHandlerClient*, 4> HandlerList;

        protected:
            EA::Allocator::ICoreAllocator*  mpCoreAllocator;                                  //
            void*                           mpPlatformHandler;                                // static_cast at runtime to the platform-specific handler.
            ReportWriter                    mReportWriterDefault;                             // 
            ReportWriter*                   mpReportWriter;                                   // 
            int                             mReportTypes;                                     // Values of enum ReportTypeMask.
            int                             mReportFields;                                    // Values of enum ReportTypeField.
            int                             mCallstackAddressRepTypeFlags;                    // Values of enum EA::Callstack::AddressRepTypeFlag, used if mReportFields has kReportFieldCallStack.
            char                            mReportNameSpaceChar;                             // What char to use in the report file name for spaces. Defaults to ' ' but can be changed to others such as '_' or '-'.
            int                             mMiniDumpFlags;                                   // 
            bool                            mbRunningTrapped;                                 // 
            HandlerList                     mHandlerList;                                     // 
            String                          msBuildDescription;                               // User-specified arbitrary string.
            char16_t                        mpReportFileName[EA::IO::kMaxFileNameLength];     // User-specifiable file name or path to use for exception reports. Overrides mpReportDirectory when it's a path as opposed to a name.
            char16_t                        mpReportDirectory[EA::IO::kMaxDirectoryLength];   // User-specifiable directory for writing reports to.
            char                            mBaseReportName[64];                              // User-specifiable report name prefix.
            char                            mReportFilePath[EA::IO::kMaxPathLength];          // The actual report file path used to write the most recent exception report.
            FILE*                           mpFile;                                           // Used by ReadMinidumpBegin, etc.
        };



        /// ExceptionHandlerClient
        /// This is a base interface class for ExceptionHandler clients.
        /// Example usage:
        ///    class MyClient : public EA::Debug::ExceptionHandlerClient {
        ///        void Notify(EA::Debug::ExceptionHandler* pHandler, EA::Debug::ExceptionHandler::EventId id) {
        ///            if(id == EA::Debug::ExceptionHandler::kExceptionHandlingEnd)
        ///                { /* Do something */ }
        ///        }
        ///    };
        ///    
        ///    MyClient gMyClient;
        ///    pExceptionHandler->RegisterClient(&gMyClient, true);
        ///    
        class ExceptionHandlerClient
        {
        public:
            virtual ~ExceptionHandlerClient() { }

            /// Notify
            /// This function has to be implemented in clients in order to receive
            /// handler notifications.
            virtual void Notify(ExceptionHandler* pHandler, ExceptionHandler::EventId id) = 0;
        };


        /// GetDefaultExceptionHandler / SetDefaultExceptionHandler
        /// These are optional convenience functions which let you store and retrieve a application-global  
        /// pointer to an ExceptionHandler. This SetDefaultExceptionHandler does nothing but set a 
        /// global pointer; it doesn't do anything more with it such as initializing it or enabling it.
        /// These functions are not called at any time by the ExceptionHandler library itself, as they 
        /// are user functions only. These functions are not thread safe, so you must coordinate any 
        /// calls to SetDefaultExceptionHandler with different values from multiple threads.
        ExceptionHandler* GetDefaultExceptionHandler();
        void              SetDefaultExceptionHandler(ExceptionHandler* pExceptionHandler);


        // GetThreadName
        // Utility function for getting the debug name of a thread based on its thread id.
        // To do: Move this or a generic variation of it to EAThread.
        size_t GetThreadName(const EA::Thread::ThreadId& threadId, const EA::Thread::SysThreadId& sysThreadId, 
                                char* threadName, size_t threadNameCapacity);



    } // namespace Debug

} // namespace EA


#endif // Header include guard










