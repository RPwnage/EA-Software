From 6286765d11d4e19846e1d74f33f021d69a7a4209 Mon Sep 17 00:00:00 2001
From: unknown <DGog@D8757297.eac.ad.ea.com>
Date: Mon, 27 May 2013 12:15:09 -0700
Subject: [PATCH] origin_patches

---
 core/include/cryptssc2.h                  |    2 +-
 core/source/dirtysock/unix/dirtynetunix.c |    6 ++
 core/source/misc/telemetryapi.c           |   66 ++++++++++++++++++++-
 core/source/proto/protossl.c              |   87 +++++++++++++++++++++++++++++
 5 files changed, 161 insertions(+), 6 deletions(-)

diff --git a/core/include/cryptssc2.h b/core/include/cryptssc2.h
index 1dc3cd2..f08cda5 100644
--- a/core/include/cryptssc2.h
+++ b/core/include/cryptssc2.h
@@ -46,7 +46,7 @@
 
 /*** Defines ***************************************************************************/
 
-#define CRYPTSSC2_TEST (/*DIRTYCODE_DEBUG && */ TRUE)
+#define CRYPTSSC2_TEST (/*DIRTYCODE_DEBUG && */ 1) // Changing this from TRUE to 1 since qt defines TRUE as true and VS freaks out
 
 /*** Macros ****************************************************************************/
 
diff --git a/core/source/dirtysock/unix/dirtynetunix.c b/core/source/dirtysock/unix/dirtynetunix.c
index 29cd58c..a7b93b0 100644
--- a/core/source/dirtysock/unix/dirtynetunix.c
+++ b/core/source/dirtysock/unix/dirtynetunix.c
@@ -2171,6 +2171,12 @@ int32_t SocketInfo(SocketT *pSocket, int32_t iInfo, int32_t iData, void *pBuf, i
     {
         return(pSocket->iLastError);
     }
+    
+    // return the unix socket descriptor
+    if (iInfo == 'sock')
+    {
+        return(pSocket->socket);
+    }
 
     // return socket status
     if (iInfo == 'stat')
diff --git a/core/source/misc/telemetryapi.c b/core/source/misc/telemetryapi.c
index cd4ed36..7a02911 100644
--- a/core/source/misc/telemetryapi.c
+++ b/core/source/misc/telemetryapi.c
@@ -41,7 +41,7 @@
 /*** Defines ***************************************************************************/
 
 #if DIRTYCODE_DEBUG
-    #define TELEMETRY_VERBOSE                 (1)     //!< for better debugging information at the console
+    #define TELEMETRY_VERBOSE                 (1)     //!< for less debugging information at the console
 #endif
 
 //! reserved space in the send buffer for telemetry 3.0 tags
@@ -153,7 +153,7 @@
 #define TELEMETRY_ILLEGALEVENTSTRINGCHAR_REPLACEMENT  ('_')
 
 #define TELEMETRY_ANONAUTH_SECRET   ("The truth is back in style.")
-#define TELEMETRY_AUTHKEY_LEN       (256)
+#define TELEMETRY_AUTHKEY_LEN       (512)
 
 #define TELEMETRY_SUBDIR_LEN        (5)
 
@@ -197,6 +197,10 @@ struct TelemetryApiRefT
     // module memory group
     int32_t iMemGroup;      //!< module mem group id
     void *pMemGroupUserData;//!< user data associated with mem group
+    
+    // Custom IP address
+    char    strCustomIP[65];                    //!< custom IP address, typically for encrypting an IP in the server logs
+    int32_t iTruncateIP;                        //!< Boolean to indicate last octet of IP must be truncated on the server side
 
     char strAuth[TELEMETRY_AUTHKEY_LEN];      //! authorization string
     char strServerName[256];    //! server name, replaces the old server address field
@@ -928,6 +932,7 @@ char* _TelemetryApiUntruncEvents3(TelemetryApiRefT *pTelemetryRef, uint8_t bSend
 /********************************************************************************F*/
 static int32_t _TelemetryApiSendData(TelemetryApiRefT *pTelemetryRef, int32_t iMsgType)
 {
+    uint8_t bNeedAuth = FALSE;
 #if defined(DIRTYCODE_XENON)
     uint32_t intIP;
     XNADDR XnAddr;
@@ -943,10 +948,25 @@ static int32_t _TelemetryApiSendData(TelemetryApiRefT *pTelemetryRef, int32_t iM
         if(pTelemetryRef->bAnonymous) 
         {
             TagFieldSetString(pTelemetryRef->pTagString, pTelemetryRef->uTagStringSize + pTelemetryRef->uEvent3BufferSize, "ANON", pTelemetryRef->strAuth);
+            bNeedAuth = TRUE;
         } 
         else
         {
             TagFieldSetString(pTelemetryRef->pTagString, pTelemetryRef->uTagStringSize + pTelemetryRef->uEvent3BufferSize, "AUTH", pTelemetryRef->strAuth);
+             bNeedAuth = TRUE;
+        }
+
+        // Add the custom IP if necessary
+        if (bNeedAuth)
+        {
+            if (strlen(pTelemetryRef->strCustomIP) > 0)
+            {
+                TagFieldSetString(pTelemetryRef->pTagString, pTelemetryRef->uTagStringSize + pTelemetryRef->uEvent3BufferSize, "IPAD", pTelemetryRef->strCustomIP);
+            }
+            else if (pTelemetryRef->iTruncateIP > 0)// tcip and ipad cannot both be sent, IPAD superceeds TCIP
+            {
+                TagFieldSetNumber(pTelemetryRef->pTagString, pTelemetryRef->uTagStringSize + pTelemetryRef->uEvent3BufferSize, "TCIP", pTelemetryRef->iTruncateIP);
+            }
         }
 
 #if defined(DIRTYCODE_XENON)    
@@ -1885,6 +1905,9 @@ TelemetryApiRefT *TelemetryApiCreateEx(uint32_t uNumEvents, TelemetryApiBufferTy
 
         // Set the retry count to 1
         pTelemetryRef->uSubmit3MaxRetry = 1;
+        
+        pTelemetryRef->strCustomIP[0] = '\0';
+        pTelemetryRef->iTruncateIP = 0;
     }
 
     // return reference pointer
@@ -2131,7 +2154,7 @@ int32_t TelemetryApiAuthentAnonymous(TelemetryApiRefT *pTelemetryRef, const char
 int32_t TelemetryApiAuthentAnonymousEx(TelemetryApiRefT *pTelemetryRef, const char *pDestIP, int32_t iDestPort, uint32_t uLocale,
                                      const char *pDomain, uint32_t uTime, const char *pPlayerID, const char *pMAC, int64_t uNucleusPersonaID)
 {
-    char strPlayerID[64], strMAC[18], strNucleusPersonaID[32], strTmp[TELEMETRY_AUTHKEY_LEN], strDomain[TELEMETRY_MAXIMUM_ANON_DOMAIN_LEN];
+    char strPlayerID[64], strMAC[64], strNucleusPersonaID[32], strTmp[TELEMETRY_AUTHKEY_LEN], strDomain[TELEMETRY_MAXIMUM_ANON_DOMAIN_LEN];
 
     if(pDestIP == NULL || pDomain == NULL || pTelemetryRef == NULL)
     {
@@ -2169,7 +2192,7 @@ int32_t TelemetryApiAuthentAnonymousEx(TelemetryApiRefT *pTelemetryRef, const ch
 
     if(uNucleusPersonaID != 0)
     {
-        ds_snzprintf(strNucleusPersonaID,sizeof(strNucleusPersonaID),"$%016x",uNucleusPersonaID);
+        ds_snzprintf(strNucleusPersonaID,sizeof(strNucleusPersonaID),"%lld",uNucleusPersonaID);
     }
     else
     {
@@ -2880,6 +2903,8 @@ int32_t TelemetryApiStatus(TelemetryApiRefT *pTelemetryRef, int32_t iSelect, voi
             'subd' - select a subdirectory of the telemetry domain (maximum 4 chars)
             'cryp' - set whether to encrypt telemetry data
             'rtry' - set the number of automatic retries when a full telemetry 3 buffer is encountered.
+            'ipad' - set the IP address to report in telemetry logs. IP will be reported exactly as written, use pValue = NULL to reset. (maximum 64 characters)
+            'tcip' - set a flag to indicate to the server to truncate the last octet of the user's IP for data privacy reasons.
         \endverbatim
 
     \Version 04/05/2004 (jbrookes)
@@ -2891,6 +2916,7 @@ int32_t TelemetryApiControl(TelemetryApiRefT *pTelemetryRef, int32_t iKind, int3
     int32_t iReturn = 0;
     int32_t i;
     char *pSrc;
+    uint8_t ipOk = TRUE;
 
     // there's nothing we can set without a logger reference,
     //  so this is an error
@@ -3053,6 +3079,38 @@ int32_t TelemetryApiControl(TelemetryApiRefT *pTelemetryRef, int32_t iKind, int3
                 pTelemetryRef->uSubmit3MaxRetry = (uint32_t)iValue;         
             }
             break;
+        case 'ipad':
+            if (pValue != NULL)
+            {
+                // check that all characters in the IP are allowable
+                ds_strnzcpy(pTelemetryRef->strCustomIP, (char*)pValue, sizeof(pTelemetryRef->strCustomIP));
+                for (i=0; i<(int32_t)strlen((char*)pTelemetryRef->strCustomIP);++i)
+                {
+                    if (!TELEMETRY_EVENTSTRINGCHAR_VALID(((char*)pTelemetryRef->strCustomIP)[i]))
+                    {
+                        ipOk = FALSE;
+                        ((char*)pTelemetryRef->strCustomIP)[i] = TELEMETRY_ILLEGALEVENTSTRINGCHAR_REPLACEMENT;
+                    }
+                }
+
+                if (!ipOk)
+                {
+                    iReturn = -1;
+                }
+            }
+            break;
+        case 'tcip':
+            {
+                if (iValue > 0)
+                {
+                    pTelemetryRef->iTruncateIP = iValue;
+                }
+                else
+                {
+                    pTelemetryRef->iTruncateIP = 0;
+                }
+            }
+            break;
             
     }
     return(iReturn);
diff --git a/core/source/proto/protossl.c b/core/source/proto/protossl.c
index b24c808..ba0541c 100644
--- a/core/source/proto/protossl.c
+++ b/core/source/proto/protossl.c
@@ -508,6 +508,82 @@ const static uint8_t _ProtoSSL_GeoTrustServerModulus[] =
     0xaf, 0x55, 0x7a, 0x24, 0xbe, 0x8c, 0x39, 0x0d, 0x77, 0x9d, 0xde, 0x02, 0xc3, 0x0c, 0xbd, 0x1f
 };
 
+// The 2048-bit modulus for the GeoTrust SSL intermediate cert
+// Used by legacy Ebisu-related services
+const static uint8_t _ProtoSSL_GeoTrustSSLModulus[] =
+{
+    0x90, 0xb3, 0x80, 0xc1, 0xe4, 0xe5, 0x46, 0xad,
+    0x70, 0x60, 0x3d, 0xba, 0xe5, 0x14, 0xdd, 0x9e,
+    0x8a, 0x5e, 0x8b, 0x75, 0x5a, 0xe6, 0xca, 0x6d,
+    0x41, 0xa5, 0x23, 0xe8, 0x39, 0x85, 0x26, 0x7a,
+    0xa7, 0x55, 0x77, 0x9a, 0x48, 0xa1, 0x92, 0x7e,
+    0x3a, 0x1e, 0x1a, 0xf1, 0x27, 0xab, 0xa3, 0x4c,
+    0x39, 0xcc, 0xcb, 0x3d, 0x47, 0xaf, 0x81, 0xae,
+    0x16, 0x6a, 0x5c, 0x37, 0xef, 0x45, 0x41, 0xfd,
+    0xfb, 0x9a, 0x97, 0x3c, 0xa0, 0x43, 0x9d, 0xc6,
+    0xdf, 0x17, 0x21, 0xd1, 0x8a, 0xa2, 0x56, 0xc2,
+    0x03, 0x49, 0x84, 0x12, 0x81, 0x3e, 0xc9, 0x0a,
+    0x54, 0x60, 0x66, 0xb9, 0x8c, 0x54, 0xe4, 0xf9,
+    0xe6, 0xf9, 0x94, 0xf1, 0xe0, 0x5f, 0x75, 0x11,
+    0xf2, 0x29, 0xb9, 0xe4, 0x86, 0xa2, 0xb1, 0x89,
+    0xad, 0xa6, 0x1e, 0x83, 0x29, 0x63, 0xb2, 0xf0,
+    0x54, 0x1c, 0x85, 0x0b, 0x7a, 0xe7, 0xe1, 0x2e,
+    0x0d, 0xaf, 0xa4, 0xbd, 0xcd, 0xe7, 0xb1, 0x5a,
+    0xd7, 0x8c, 0x05, 0x5a, 0x0e, 0x4b, 0x73, 0x28,
+    0x8b, 0x75, 0x5d, 0x34, 0xd8, 0x77, 0x0b, 0xe1,
+    0x74, 0x62, 0xe2, 0x71, 0x30, 0x62, 0xd8, 0xbc,
+    0x8a, 0x05, 0xe5, 0x31, 0x63, 0x4a, 0x54, 0x89,
+    0x6a, 0x33, 0x78, 0xa7, 0x4e, 0x55, 0x24, 0x1d,
+    0x97, 0xef, 0x1a, 0xe4, 0x12, 0xc6, 0x0f, 0x30,
+    0x18, 0xb4, 0x34, 0x4d, 0xe1, 0xd8, 0x23, 0x3b,
+    0x21, 0x5b, 0x2d, 0x30, 0x19, 0x25, 0x0e, 0x74,
+    0xf7, 0xa4, 0x21, 0x4b, 0xa0, 0xa4, 0x20, 0xc9,
+    0x6c, 0xcd, 0x98, 0x56, 0xc0, 0xf2, 0xa8, 0x5f,
+    0x3e, 0x26, 0x75, 0xa0, 0x0d, 0xf8, 0x36, 0x88,
+    0x8a, 0x2c, 0x5a, 0x7d, 0x67, 0x30, 0xa9, 0x0f,
+    0xd1, 0x99, 0x70, 0x2e, 0x78, 0xe1, 0x51, 0x26,
+    0xaf, 0x55, 0x7a, 0x24, 0xbe, 0x8c, 0x39, 0x0d,
+    0x77, 0x9d, 0xde, 0x02, 0xc3, 0x0c, 0xbd, 0x1f,
+};
+
+// The 2048-bit modulus for the VeriSign Secure Server G3 intermediate cert
+// Used by Origin branded Ebisu services
+const static uint8_t _ProtoSSL_VeriSignSecureServerG3Modulus[] =
+{
+    0xb1, 0x87, 0x84, 0x1f, 0xc2, 0x0c, 0x45, 0xf5,
+    0xbc, 0xab, 0x25, 0x97, 0xa7, 0xad, 0xa2, 0x3e,
+    0x9c, 0xba, 0xf6, 0xc1, 0x39, 0xb8, 0x8b, 0xca,
+    0xc2, 0xac, 0x56, 0xc6, 0xe5, 0xbb, 0x65, 0x8e,
+    0x44, 0x4f, 0x4d, 0xce, 0x6f, 0xed, 0x09, 0x4a,
+    0xd4, 0xaf, 0x4e, 0x10, 0x9c, 0x68, 0x8b, 0x2e,
+    0x95, 0x7b, 0x89, 0x9b, 0x13, 0xca, 0xe2, 0x34,
+    0x34, 0xc1, 0xf3, 0x5b, 0xf3, 0x49, 0x7b, 0x62,
+    0x83, 0x48, 0x81, 0x74, 0xd1, 0x88, 0x78, 0x6c,
+    0x02, 0x53, 0xf9, 0xbc, 0x7f, 0x43, 0x26, 0x57,
+    0x58, 0x33, 0x83, 0x3b, 0x33, 0x0a, 0x17, 0xb0,
+    0xd0, 0x4e, 0x91, 0x24, 0xad, 0x86, 0x7d, 0x64,
+    0x12, 0xdc, 0x74, 0x4a, 0x34, 0xa1, 0x1d, 0x0a,
+    0xea, 0x96, 0x1d, 0x0b, 0x15, 0xfc, 0xa3, 0x4b,
+    0x3b, 0xce, 0x63, 0x88, 0xd0, 0xf8, 0x2d, 0x0c,
+    0x94, 0x86, 0x10, 0xca, 0xb6, 0x9a, 0x3d, 0xca,
+    0xeb, 0x37, 0x9c, 0x00, 0x48, 0x35, 0x86, 0x29,
+    0x50, 0x78, 0xe8, 0x45, 0x63, 0xcd, 0x19, 0x41,
+    0x4f, 0xf5, 0x95, 0xec, 0x7b, 0x98, 0xd4, 0xc4,
+    0x71, 0xb3, 0x50, 0xbe, 0x28, 0xb3, 0x8f, 0xa0,
+    0xb9, 0x53, 0x9c, 0xf5, 0xca, 0x2c, 0x23, 0xa9,
+    0xfd, 0x14, 0x06, 0xe8, 0x18, 0xb4, 0x9a, 0xe8,
+    0x3c, 0x6e, 0x81, 0xfd, 0xe4, 0xcd, 0x35, 0x36,
+    0xb3, 0x51, 0xd3, 0x69, 0xec, 0x12, 0xba, 0x56,
+    0x6e, 0x6f, 0x9b, 0x57, 0xc5, 0x8b, 0x14, 0xe7,
+    0x0e, 0xc7, 0x9c, 0xed, 0x4a, 0x54, 0x6a, 0xc9,
+    0x4d, 0xc5, 0xbf, 0x11, 0xb1, 0xae, 0x1c, 0x67,
+    0x81, 0xcb, 0x44, 0x55, 0x33, 0x99, 0x7f, 0x24,
+    0x9b, 0x3f, 0x53, 0x45, 0x7f, 0x86, 0x1a, 0xf3,
+    0x3c, 0xfa, 0x6d, 0x7f, 0x81, 0xf5, 0xb8, 0x4a,
+    0xd3, 0xf5, 0x85, 0x37, 0x1c, 0xb5, 0xa6, 0xd0,
+    0x09, 0xe4, 0x18, 0x7b, 0x38, 0x4e, 0xfa, 0x0f,
+};
+
 // only certificates from these authorities are supported
 static ProtoSSLCACertT _ProtoSSL_CACerts[] =
 {
@@ -531,6 +607,17 @@ static ProtoSSLCACertT _ProtoSSL_CACerts[] =
     { { "US", "", "", "GeoTrust, Inc.", "", "GeoTrust SSL CA" },
       256, _ProtoSSL_GeoTrustServerModulus,
       3, { 0x01, 0x00, 0x01 },
+        0, NULL, NULL, &_ProtoSSL_CACerts[5]},
+    { { "US", "", "", "GeoTrust, Inc.",
+        "", "GeoTrust SSL CA"},
+        256, _ProtoSSL_GeoTrustSSLModulus,
+        3, { 0x01, 0x00, 0x01 },
+        0, NULL, NULL, &_ProtoSSL_CACerts[6]},
+    { { "US", "", "", "VeriSign, Inc.",
+        "VeriSign Trust Network, Terms of use at https://www.verisign.com/rpa (c)10",
+        "VeriSign Class 3 Secure Server CA - G3" },
+        256, _ProtoSSL_VeriSignSecureServerG3Modulus,
+        3, { 0x01, 0x00, 0x01 },
       0, NULL, NULL, NULL},
 };
 
-- 
1.7.8.msysgit.0

