/*H********************************************************************************/
/*!
    \File lockerapi.h

    \Description
        The Locker API manages a server-based storage location similar in concept
        to a memory card.  Files may be uploaded to and downloaded from this storage
        location.

    \Notes
        None.

    \Copyright
        Copyright (c) Electronic Arts 2004. ALL RIGHTS RESERVED.

    \Version 1.0 11/24/2004 (jbrookes) first version
*/
/********************************************************************************H*/

#ifndef _lockerapi_h
#define _lockerapi_h

/*** Include files ****************************************************************/

/*** Defines **********************************************************************/

#define LOCKERAPI_FILENAME_MAXLEN       (128)       //!< max filename length
#define LOCKERAPI_FILEDESC_MAXLEN       (128)       //!< max description length
#define LOCKERAPI_FILEGAME_MAXLEN       (64)        //!< max game name length
#define LOCKERAPI_FILETYPE_MAXLEN       (16)        //!< max filetype length
#define LOCKERAPI_FILEIDNT_MAXLEN       (20)        //!< max File id length
#define LOCKERAPI_FILEDMPT_MAXLEN       (20)        //!< max length of domain partition

#define LOCKERAPI_FILEATTR_PUBLIC       (1)         //!< file is available for other users to download
#define LOCKERAPI_FILEATTR_EAFILE       (2)         //!< file was pushed by EA (not uploaded by user)

#define LOCKERAPI_FILEATTR_PC           (1<<16)     //!< file is pc compatible
#define LOCKERAPI_FILEATTR_PS3          (8<<16)     //!< file is ps3 compatible
#define LOCKERAPI_FILEATTR_XENON        (32<<16)    //!< file is xenon compatible
#define LOCKERAPI_FILEATTR_REV          (128<<16)   //!< file is Revolution compatible


#define LOCKERAPI_FILE_PERM_USER_READ (1)           //!< File is ok to read for user 
#define LOCKERAPI_FILE_PERM_USER_WRITE (2)          //!< File is ok to write for user 
#define LOCKERAPI_FILE_PERM_WORLD_READ (4)          //!< File is ok to read for everyone 
#define LOCKERAPI_FILE_PERM_WORLD_WRITE (8)          //!< File is ok to write for everyone

#define LOCKERAPI_SPOOLSIZE             (4096)      //!< size of spool buffer

#define LOCKERAPI_SORTDIR_ASCENDING     (-1)        //!< sort dir in ascending order
#define LOCKERAPI_SORTDIR_DESCENDING    (1)         //!< sort dir in descending order

#define LOCKERAPI_MAX_META_SIZE         (2*1024)    //!< max length for meta data 
#define LOCKERAPI_MAXFILES              (64)        //!< max files per directory


/*** Macros ***********************************************************************/

/*** Type Definitions *************************************************************/

//! locker sort categories
typedef enum LockerApiCategoryE
{
    LOCKERAPI_CATEGORY_NAME,        //!< sort by name
    LOCKERAPI_CATEGORY_GAME,        //!< sort by game name
    LOCKERAPI_CATEGORY_TYPE,        //!< sort by file type
    LOCKERAPI_CATEGORY_SIZE,        //!< sort by file size
    LOCKERAPI_CATEGORY_DATE,        //!< sort by file upload date
    LOCKERAPI_CATEGORY_ATTR,        //!< sort by file attributes
    LOCKERAPI_CATEGORY_PERM,        //!< sort by file permission
    LOCKERAPI_CATEGORY_IDNT,        //!< sort by file ident

    LOCKERAPI_NUMCATEGORIES         //!< number of categories
} LockerApiCategoryE;

//! lockerapi events
typedef enum LockerApiEventE
{
    LOCKERAPI_EVENT_ERROR = -1, //!< an error occurred - call GetLastError()

    LOCKERAPI_EVENT_NONE = 0,   //!< null event
    LOCKERAPI_EVENT_DIRECTORY,  //!< directory update
    LOCKERAPI_EVENT_WRITEDATA,  //!< api is ready for another data chunk
    LOCKERAPI_EVENT_READDATA,   //!< api has another data chunk ready
    LOCKERAPI_EVENT_DONE,       //!< data transfer operation is complete
    
    LOCKERAPI_NUMEVENTS         //!< number of events (not including error event)
} LockerApiEventE;

// lockerapi errors
typedef enum LockerApiErrorE
{
    /*
       Errors returned by server
    */
    LOCKERAPI_ERROR_NONE,           //!< no error

    // generic errors
    LOCKERAPI_ERROR_SERVER,         //!< an unknown server error occurred
    LOCKERAPI_ERROR_LKEYINVALID,    //!< invalid lkey

    // put errors
    LOCKERAPI_ERROR_FILEEXISTS,     //!< file already exists
    LOCKERAPI_ERROR_TOOMANYFILES,   //!< upload would exceed file quota
    LOCKERAPI_ERROR_TOOMANYBYTES,   //!< upload would exceed byte quota
    LOCKERAPI_ERROR_NAMEPROFANE,    //!< file name is profane and not allowed

    // get/update info/delete errors
    LOCKERAPI_ERROR_FILEMISSING,    //!< file missing on server
    LOCKERAPI_ERROR_NOPERMISSION,   //!< no permission to access file

    // get directory errors
    LOCKERAPI_ERROR_UNKNOWNOWNER,   //!< owner unrecognized/doesn't have a locker

    /*
       Errors generated by client
    */
    LOCKERAPI_ERROR_CLIENT = 100,  //!< an unknown client error occurred
    LOCKERAPI_ERROR_TIMEOUT        //!< server timeout
} LockerApiErrorE;

//! locker file info modifiable by client
typedef struct LockerApiFileInfoT
{
    char strName[LOCKERAPI_FILENAME_MAXLEN];    //!< name
    char strDesc[LOCKERAPI_FILEDESC_MAXLEN];    //!< description 
    char strGame[LOCKERAPI_FILEGAME_MAXLEN];    //!< name of game that uploaded file
    char strType[LOCKERAPI_FILETYPE_MAXLEN];    //!< type
    char strIdnt[LOCKERAPI_FILEIDNT_MAXLEN];    //!< the file ident for this file 
    char strDmpt[LOCKERAPI_FILEDMPT_MAXLEN];    //!< domain partition name 
    int32_t iAttr;                              //!< attributes
    int32_t iNetSize;                           //!< size in bytes of file as stored on network
    int32_t iLocSize;                           //!< size in bytes of file as stored locally
    int32_t iPermissions;                       //!< the permission associated with this file
    int32_t iVersion;                           //!< version number for the file 
} LockerApiFileInfoT;

//! a single locker file
typedef struct LockerApiFileT
{
    LockerApiFileInfoT Info;                    //!< file info
    int32_t  iDate;                             //!< upload date
    int32_t  iId;                               //!< file identifier
} LockerApiFileT;

//! a single locker
typedef struct LockerApiDirectoryT
{
    char strOwner[32];                          //!< name of directory owner
    char strGame[LOCKERAPI_FILEGAME_MAXLEN];    //!< name of game that we are logged in with
    int32_t iNumFiles;                          //!< number of files in locker
    int32_t iMaxFiles;                          //!< max number of files
    int32_t iNumBytes;                          //!< number of bytes in locker
    int32_t iMaxBytes;                          //!< maximum number of bytes available in locker
    LockerApiFileT Files[LOCKERAPI_MAXFILES];   //!< directory file list
} LockerApiDirectoryT;


//! private module state
typedef struct LockerApiRefT LockerApiRefT;

//! lockerapi event handler
typedef void (LockerApiCallbackT)(LockerApiRefT *pLockerApi, LockerApiEventE eEvent, LockerApiFileT *pFile, void *pUserData);

/*** Variables ********************************************************************/

/*** Functions ********************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

// create locker module
LockerApiRefT *LockerApiCreate(const char *pServer, LockerApiCallbackT *pCallback, void *pUserData);

// destroy locker module
void LockerApiDestroy(LockerApiRefT *pLockerApi);

// set login info
void LockerApiSetLoginInfo(LockerApiRefT *pLockerApi, const char *pLKey, const char *pPersona);

// get a user's directory based on the game (async) 
void LockerApiFetchLocker(LockerApiRefT *pLockerApi, const char *pOwner, const char *pGameName);

// get current directory
const LockerApiDirectoryT *LockerApiGetDirectory(LockerApiRefT *pLockerApi);

// sort current directory
void LockerApiSortDirectory(LockerApiRefT *pLockerApi, LockerApiCategoryE eCategory, int32_t iSortDir);

// update file attributes
void LockerApiUpdateFileInfo(LockerApiRefT *pLockerApi, int32_t iFileId, const char *pStrDesc, int32_t iAttr, int32_t iPerm, const char *pMetaData);

// start a file download (async)
void LockerApiGetFile(LockerApiRefT *pLockerApi, int32_t iFileId);

// read a chunk of data
int32_t LockerApiReadData(LockerApiRefT *pLockerApi, void *pData);

// start a file upload (async)
void LockerApiPutFile(LockerApiRefT *pLockerApi, const LockerApiFileInfoT *pFileInfo, const char *pOwner, uint32_t bOverwrite, const char *pMetaData );

// write a chunk of data
int32_t LockerApiWriteData(LockerApiRefT *pLockerApi, const void *pData);

// delete a file (async)
void LockerApiDeleteFile(LockerApiRefT *pLockerApi, int32_t iFileId);

// search based on meta data(async)
void LockerApiMetaSearch(LockerApiRefT *pLockerApi, const char *pMetaData);

// get the current search results (appears like a directory)
const LockerApiDirectoryT *LockerApiGetMetaSearch(LockerApiRefT *pLockerApi);

// abort current operation
void LockerApiAbort(LockerApiRefT *pLockerApi);

// get most recent error
LockerApiErrorE LockerApiGetLastError(LockerApiRefT *pLockerApi);

// control function
int32_t LockerApiControl(LockerApiRefT *pLockerApi, int32_t iControl, int32_t iValue, int32_t iValue2, void *pValue);

#ifdef __cplusplus
};
#endif

#endif // _lockerapi_h

