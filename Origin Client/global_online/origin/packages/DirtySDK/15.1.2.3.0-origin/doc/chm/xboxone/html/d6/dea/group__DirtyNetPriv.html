<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>DirtySock: DirtyNetPriv</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../eadp-horizontal-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">DirtySock
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d6/dea/group__DirtyNetPriv.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DirtyNetPriv<div class="ingroups"><a class="el" href="../../d7/dbb/group__DirtySock.html">DirtySock</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html">SocketPacketQueueEntryT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket packet queue entry  <a href="../../da/d17/structSocketPacketQueueEntryT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket rate estimation  <a href="../../dc/d0a/structSocketRateT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address map  <a href="../../d8/d62/structSocketAddrMapT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafe4ed7fd509c7f4474e3738d8266be80"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gafe4ed7fd509c7f4474e3738d8266be80">SocketHostnameCacheT</a></td></tr>
<tr class="memdesc:gafe4ed7fd509c7f4474e3738d8266be80"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket hostname cache  <a href="#gafe4ed7fd509c7f4474e3738d8266be80">More...</a><br/></td></tr>
<tr class="separator:gafe4ed7fd509c7f4474e3738d8266be80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d781c2bc180cfa6f1fb344fed5b8a3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga45d781c2bc180cfa6f1fb344fed5b8a3">SocketPacketQueueT</a></td></tr>
<tr class="memdesc:ga45d781c2bc180cfa6f1fb344fed5b8a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket packet queue  <a href="#ga45d781c2bc180cfa6f1fb344fed5b8a3">More...</a><br/></td></tr>
<tr class="separator:ga45d781c2bc180cfa6f1fb344fed5b8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72406569346f0037f4641707a2e4899a"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html">SocketPacketQueueEntryT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga72406569346f0037f4641707a2e4899a">SocketPacketQueueEntryT</a></td></tr>
<tr class="memdesc:ga72406569346f0037f4641707a2e4899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket packet queue entry  <a href="#ga72406569346f0037f4641707a2e4899a">More...</a><br/></td></tr>
<tr class="separator:ga72406569346f0037f4641707a2e4899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ecccc80ceaeb97ee634050a29cce07"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga49ecccc80ceaeb97ee634050a29cce07">SocketRateT</a></td></tr>
<tr class="memdesc:ga49ecccc80ceaeb97ee634050a29cce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket rate estimation  <a href="#ga49ecccc80ceaeb97ee634050a29cce07">More...</a><br/></td></tr>
<tr class="separator:ga49ecccc80ceaeb97ee634050a29cce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafae9cdf61c8faac044f11c497166bfc2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html">SocketAddrMapEntryT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gafae9cdf61c8faac044f11c497166bfc2">SocketAddrMapEntryT</a></td></tr>
<tr class="separator:gafae9cdf61c8faac044f11c497166bfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff6cedb0c2320dd3a7779b074ab39e9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga7ff6cedb0c2320dd3a7779b074ab39e9">SocketAddrMapT</a></td></tr>
<tr class="memdesc:ga7ff6cedb0c2320dd3a7779b074ab39e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">socket address map  <a href="#ga7ff6cedb0c2320dd3a7779b074ab39e9">More...</a><br/></td></tr>
<tr class="separator:ga7ff6cedb0c2320dd3a7779b074ab39e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae81ba16e71872fa5964c85ebe413a556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gae81ba16e71872fa5964c85ebe413a556">SocketHostnameCacheCreate</a> (int32_t iMemGroup, void *pMemGroupUserData)</td></tr>
<tr class="memdesc:gae81ba16e71872fa5964c85ebe413a556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create short-term hostname (DNS) cache.  <a href="#gae81ba16e71872fa5964c85ebe413a556">More...</a><br/></td></tr>
<tr class="separator:gae81ba16e71872fa5964c85ebe413a556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ad91b1fa137552f7cf6758c57a2090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga33ad91b1fa137552f7cf6758c57a2090">SocketHostnameCacheDestroy</a> (<a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *pCache)</td></tr>
<tr class="memdesc:ga33ad91b1fa137552f7cf6758c57a2090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy short-term hostname (DNS) cache.  <a href="#ga33ad91b1fa137552f7cf6758c57a2090">More...</a><br/></td></tr>
<tr class="separator:ga33ad91b1fa137552f7cf6758c57a2090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7a05e875510edfb2f87884860ba0f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga1c7a05e875510edfb2f87884860ba0f9">SocketHostnameCacheAdd</a> (<a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *pCache, const char *pStrHost, uint32_t uAddress, int32_t iVerbose)</td></tr>
<tr class="memdesc:ga1c7a05e875510edfb2f87884860ba0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add hostname and address to hostname cache.  <a href="#ga1c7a05e875510edfb2f87884860ba0f9">More...</a><br/></td></tr>
<tr class="separator:ga1c7a05e875510edfb2f87884860ba0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a7e76a3b95b30abbec8516ba143776"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga24a7e76a3b95b30abbec8516ba143776">SocketHostnameCacheGet</a> (<a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *pCache, const char *pStrHost, int32_t iVerbose)</td></tr>
<tr class="memdesc:ga24a7e76a3b95b30abbec8516ba143776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address for hostname from cache, if available. Also expires cache entry if applicable.  <a href="#ga24a7e76a3b95b30abbec8516ba143776">More...</a><br/></td></tr>
<tr class="separator:ga24a7e76a3b95b30abbec8516ba143776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae66d31ff669db27c1f9745dacefaa99c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gae66d31ff669db27c1f9745dacefaa99c">SocketHostnameCacheDel</a> (<a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *pCache, const char *pStrHost, uint32_t uAddress, int32_t iVerbose)</td></tr>
<tr class="memdesc:gae66d31ff669db27c1f9745dacefaa99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove hostname cache entry from the cache, if it exists. pStrHost is checked if non-NULL and uAddress is checked if non-zero (note that both can be checked if desired).  <a href="#gae66d31ff669db27c1f9745dacefaa99c">More...</a><br/></td></tr>
<tr class="separator:gae66d31ff669db27c1f9745dacefaa99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga776bfda2944c3874bbd820353261d8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga776bfda2944c3874bbd820353261d8e7">SocketHostnameAddRef</a> (<a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> **ppHostList, <a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> *pHost, uint8_t bUseRef)</td></tr>
<tr class="memdesc:ga776bfda2944c3874bbd820353261d8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for in-progress DNS requests we can piggyback on, instead of issuing a new request.  <a href="#ga776bfda2944c3874bbd820353261d8e7">More...</a><br/></td></tr>
<tr class="separator:ga776bfda2944c3874bbd820353261d8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddbe2014d9a68aecfbfaf13e88935174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gaddbe2014d9a68aecfbfaf13e88935174">SocketHostnameListProcess</a> (<a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> **ppHostList, int32_t iMemGroup, void *pMemGroupUserData)</td></tr>
<tr class="memdesc:gaddbe2014d9a68aecfbfaf13e88935174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process list of in-progress DNS requests, disposing of those that are completed and no longer referenced.  <a href="#gaddbe2014d9a68aecfbfaf13e88935174">More...</a><br/></td></tr>
<tr class="separator:gaddbe2014d9a68aecfbfaf13e88935174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf986d178d802f64e06f273fe8276f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga4cf986d178d802f64e06f273fe8276f3">SocketPacketQueueCreate</a> (int32_t iMaxPackets, int32_t iMemGroup, void *pMemGroupUserData)</td></tr>
<tr class="memdesc:ga4cf986d178d802f64e06f273fe8276f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a packet queue.  <a href="#ga4cf986d178d802f64e06f273fe8276f3">More...</a><br/></td></tr>
<tr class="separator:ga4cf986d178d802f64e06f273fe8276f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b0a88c2ee02c67004368132b587245"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gac6b0a88c2ee02c67004368132b587245">SocketPacketQueueDestroy</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue)</td></tr>
<tr class="memdesc:gac6b0a88c2ee02c67004368132b587245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy packet queue.  <a href="#gac6b0a88c2ee02c67004368132b587245">More...</a><br/></td></tr>
<tr class="separator:gac6b0a88c2ee02c67004368132b587245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga105cc2978f2137ee252f857c615863e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga105cc2978f2137ee252f857c615863e7">SocketPacketQueueResize</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue, int32_t iMaxPackets, int32_t iMemGroup, void *pMemGroupUserData)</td></tr>
<tr class="memdesc:ga105cc2978f2137ee252f857c615863e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a packet queue, if the max packet size is different.  <a href="#ga105cc2978f2137ee252f857c615863e7">More...</a><br/></td></tr>
<tr class="separator:ga105cc2978f2137ee252f857c615863e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed50e8a2f71866f20dcfcc7b3775ae8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga2ed50e8a2f71866f20dcfcc7b3775ae8">SocketPacketQueueControl</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue, int32_t iControl, int32_t iValue)</td></tr>
<tr class="memdesc:ga2ed50e8a2f71866f20dcfcc7b3775ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control socket packet queue options.  <a href="#ga2ed50e8a2f71866f20dcfcc7b3775ae8">More...</a><br/></td></tr>
<tr class="separator:ga2ed50e8a2f71866f20dcfcc7b3775ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c5a3f556825998102198d395025801"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga49c5a3f556825998102198d395025801">SocketPacketQueueStatus</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue, int32_t iStatus)</td></tr>
<tr class="memdesc:ga49c5a3f556825998102198d395025801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status of socket packet queue.  <a href="#ga49c5a3f556825998102198d395025801">More...</a><br/></td></tr>
<tr class="separator:ga49c5a3f556825998102198d395025801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1f26e46487e97f2c2e5c07e272ee06"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga9a1f26e46487e97f2c2e5c07e272ee06">SocketPacketQueueAdd</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue, const uint8_t *pPacketData, int32_t iPacketSize, struct sockaddr *pPacketAddr)</td></tr>
<tr class="memdesc:ga9a1f26e46487e97f2c2e5c07e272ee06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a packet to packet queue.  <a href="#ga9a1f26e46487e97f2c2e5c07e272ee06">More...</a><br/></td></tr>
<tr class="separator:ga9a1f26e46487e97f2c2e5c07e272ee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga706031a42619ce07376b1ce52735da81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html">SocketPacketQueueEntryT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga706031a42619ce07376b1ce52735da81">SocketPacketQueueAlloc</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue)</td></tr>
<tr class="memdesc:ga706031a42619ce07376b1ce52735da81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloc a packet queue entry. This is used when receiving data directly into the packet queue data buffer.  <a href="#ga706031a42619ce07376b1ce52735da81">More...</a><br/></td></tr>
<tr class="separator:ga706031a42619ce07376b1ce52735da81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1687ec08e7ba84d7bd675749eefeaebd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga1687ec08e7ba84d7bd675749eefeaebd">SocketPacketQueueRem</a> (<a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *pPacketQueue, uint8_t *pPacketData, int32_t iPacketSize, struct sockaddr *pPacketAddr)</td></tr>
<tr class="memdesc:ga1687ec08e7ba84d7bd675749eefeaebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a packet from packet queue.  <a href="#ga1687ec08e7ba84d7bd675749eefeaebd">More...</a><br/></td></tr>
<tr class="separator:ga1687ec08e7ba84d7bd675749eefeaebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097c90d4248968643521dbe71b58e5d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga097c90d4248968643521dbe71b58e5d0">SocketRateUpdate</a> (<a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a> *pRate, int32_t iData, const char *pOpName)</td></tr>
<tr class="memdesc:ga097c90d4248968643521dbe71b58e5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update socket data rate estimation.  <a href="#ga097c90d4248968643521dbe71b58e5d0">More...</a><br/></td></tr>
<tr class="separator:ga097c90d4248968643521dbe71b58e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab8211828585e467238b13839b4ae49"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga7ab8211828585e467238b13839b4ae49">SocketRateThrottle</a> (<a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a> *pRate, int32_t iSockType, int32_t iData, const char *pOpName)</td></tr>
<tr class="memdesc:ga7ab8211828585e467238b13839b4ae49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throttles data size to send or recv based on calculated data rate and configured max rate.  <a href="#ga7ab8211828585e467238b13839b4ae49">More...</a><br/></td></tr>
<tr class="separator:ga7ab8211828585e467238b13839b4ae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c11161dcf9a89a97f1213852f77ce08"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga7c11161dcf9a89a97f1213852f77ce08">SocketSendCallbackAdd</a> (<a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a> aCbList[], <a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a> *pCbEntry)</td></tr>
<tr class="memdesc:ga7c11161dcf9a89a97f1213852f77ce08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new socket send callback.  <a href="#ga7c11161dcf9a89a97f1213852f77ce08">More...</a><br/></td></tr>
<tr class="separator:ga7c11161dcf9a89a97f1213852f77ce08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0460928278b76a3227d6b5484c16a50a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga0460928278b76a3227d6b5484c16a50a">SocketSendCallbackRem</a> (<a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a> aCbList[], <a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a> *pCbEntry)</td></tr>
<tr class="memdesc:ga0460928278b76a3227d6b5484c16a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a socket send callback that was already registered.  <a href="#ga0460928278b76a3227d6b5484c16a50a">More...</a><br/></td></tr>
<tr class="separator:ga0460928278b76a3227d6b5484c16a50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9c7ffeeacd2f3ac802aeee222f4a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga6d9c7ffeeacd2f3ac802aeee222f4a29">SocketAddrMapInit</a> (<a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *pAddrMap, int32_t iMemGroup, void *pMemGroupUserData)</td></tr>
<tr class="memdesc:ga6d9c7ffeeacd2f3ac802aeee222f4a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a Socket Address Map.  <a href="#ga6d9c7ffeeacd2f3ac802aeee222f4a29">More...</a><br/></td></tr>
<tr class="separator:ga6d9c7ffeeacd2f3ac802aeee222f4a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4aba0a34349b74dda21bed17b842cfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gaa4aba0a34349b74dda21bed17b842cfb">SocketAddrMapShutdown</a> (<a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *pAddrMap)</td></tr>
<tr class="memdesc:gaa4aba0a34349b74dda21bed17b842cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up a Socket Address Map.  <a href="#gaa4aba0a34349b74dda21bed17b842cfb">More...</a><br/></td></tr>
<tr class="separator:gaa4aba0a34349b74dda21bed17b842cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaecb02edc95dae9bd2bec426e41291f"><td class="memItemLeft" align="right" valign="top">struct sockaddr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gaaaecb02edc95dae9bd2bec426e41291f">SocketAddrMapTranslate</a> (<a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *pAddrMap, struct sockaddr *pResult, const struct sockaddr *pSource, int32_t *pNameLen)</td></tr>
<tr class="memdesc:gaaaecb02edc95dae9bd2bec426e41291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate the following:  <a href="#gaaaecb02edc95dae9bd2bec426e41291f">More...</a><br/></td></tr>
<tr class="separator:gaaaecb02edc95dae9bd2bec426e41291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6b9c8c07bc4b6c765c02cfbb400b53"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga0b6b9c8c07bc4b6c765c02cfbb400b53">SocketAddrMapAddress</a> (<a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *pAddrMap, const struct sockaddr *pAddr, int32_t iAddrSize)</td></tr>
<tr class="memdesc:ga0b6b9c8c07bc4b6c765c02cfbb400b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an IPv6 address and return a virtual IPv4 address that can be used to reference it.  <a href="#ga0b6b9c8c07bc4b6c765c02cfbb400b53">More...</a><br/></td></tr>
<tr class="separator:ga0b6b9c8c07bc4b6c765c02cfbb400b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfc6499b736af597684a78a529823dc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga8bfc6499b736af597684a78a529823dc">SocketAddrRemapAddress</a> (<a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *pAddrMap, const struct sockaddr *pOldAddr, const struct sockaddr *pNewAddr, int32_t iAddrSize)</td></tr>
<tr class="memdesc:ga8bfc6499b736af597684a78a529823dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap an existing IPv6 address and return a virtual IPv4 address that can be used to reference it.  <a href="#ga8bfc6499b736af597684a78a529823dc">More...</a><br/></td></tr>
<tr class="separator:ga8bfc6499b736af597684a78a529823dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee389cd8bbfedb2895cce3db9c443870"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gaee389cd8bbfedb2895cce3db9c443870">SocketAddrUnmapAddress</a> (<a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *pAddrMap, const struct sockaddr *pAddr, int32_t iAddrSize)</td></tr>
<tr class="memdesc:gaee389cd8bbfedb2895cce3db9c443870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an address mapping from the mapping table.  <a href="#gaee389cd8bbfedb2895cce3db9c443870">More...</a><br/></td></tr>
<tr class="separator:gaee389cd8bbfedb2895cce3db9c443870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gafae9cdf61c8faac044f11c497166bfc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html">SocketAddrMapEntryT</a> <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html">SocketAddrMapEntryT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7ff6cedb0c2320dd3a7779b074ab39e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a>  <a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>socket address map </p>

</div>
</div>
<a class="anchor" id="gafe4ed7fd509c7f4474e3738d8266be80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>socket hostname cache </p>

</div>
</div>
<a class="anchor" id="ga72406569346f0037f4641707a2e4899a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html">SocketPacketQueueEntryT</a>  <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html">SocketPacketQueueEntryT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>socket packet queue entry </p>

</div>
</div>
<a class="anchor" id="ga45d781c2bc180cfa6f1fb344fed5b8a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>socket packet queue </p>

</div>
</div>
<a class="anchor" id="ga49ecccc80ceaeb97ee634050a29cce07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a>  <a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>socket rate estimation </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0b6b9c8c07bc4b6c765c02cfbb400b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketAddrMapAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *&#160;</td>
          <td class="paramname"><em>pAddrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>pAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iAddrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map an IPv6 address and return a virtual IPv4 address that can be used to reference it. </p>
<p><a class="anchor" id="SocketAddrMapAddress"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pAddrMap</td><td>- address map </td></tr>
    <tr><td class="paramname">*pAddr</td><td>- address to add to the mapping table </td></tr>
    <tr><td class="paramname">iAddrSize</td><td>- size of address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - negative=error, else virtual IPv4 address for newly mapped IPv6 address</dd></dl>
<dl class="section version"><dt>Version</dt><dd>04/17/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html#a886ddfe3ad11e7590f8517fbe800e492">SocketAddrMapEntryT::iRefCount</a>, <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html#ae5268f64575348540c6dfd31840ac197">SocketAddrMapEntryT::iVirtualAddress</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d8/d62/structSocketAddrMapT.html#acb639b85056330f190a3bdec80756e65">SocketAddrMapT::pMapEntries</a>, <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html#a4b8aa8b6883e749d5530dc16a3c90bad">SocketAddrMapEntryT::SockAddr6</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga773d4fe2add8138bcb9f78e1aad3ab5b">SockaddrIn6GetAddr4</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga6917f48e67339dc71034017d01802571">SockaddrIn6IsIPv4()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gae44a0e4570ca84fc08c4c92e1e3b96ea">SockaddrIn6IsZero()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gad8f69f633d37f50d331bf2cb7bb02468">SockaddrInGetAddr</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#ga617e9d78e74f34f0a91f17e1e7698b2a">SocketInfo()</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga2e1668db5bbe17963a6ca9128c5ec9b2">SocketAccept()</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga8bfc6499b736af597684a78a529823dc">SocketAddrRemapAddress()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#ga617e9d78e74f34f0a91f17e1e7698b2a">SocketInfo()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d9c7ffeeacd2f3ac802aeee222f4a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketAddrMapInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *&#160;</td>
          <td class="paramname"><em>pAddrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMemGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemGroupUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a Socket Address Map. </p>
<p><a class="anchor" id="SocketAddrMapInit"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pAddrMap</td><td>- address map </td></tr>
    <tr><td class="paramname">iMemGroup</td><td>- memory group </td></tr>
    <tr><td class="paramname">*pMemGroupUserData</td><td>- memory group user data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>03/03/2016 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d8/d62/structSocketAddrMapT.html#a55d2b5585d576c91442e26d4dcd3eea3">SocketAddrMapT::iMemGroup</a>, <a class="el" href="../../d8/d62/structSocketAddrMapT.html#afd6ddb161cea5caa45b1a8759c20a2f1">SocketAddrMapT::iNextVirtAddr</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, and <a class="el" href="../../d8/d62/structSocketAddrMapT.html#a9b272e75c36373912e1ccdafddda322c">SocketAddrMapT::pMemGroupUserData</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga3f7f8470f917a28402ddcc85776f4853">SocketCreate()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa4aba0a34349b74dda21bed17b842cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketAddrMapShutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *&#160;</td>
          <td class="paramname"><em>pAddrMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up a Socket Address Map. </p>
<p><a class="anchor" id="SocketAddrMapShutdown"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pAddrMap</td><td>- address map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>03/03/2016 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d5/df8/group__DirtyMem.html#ga511050f9df5c6afddcec2c1244f824a6">DirtyMemFree()</a>, <a class="el" href="../../d8/d62/structSocketAddrMapT.html#a55d2b5585d576c91442e26d4dcd3eea3">SocketAddrMapT::iMemGroup</a>, <a class="el" href="../../d8/d62/structSocketAddrMapT.html#acb639b85056330f190a3bdec80756e65">SocketAddrMapT::pMapEntries</a>, <a class="el" href="../../d8/d62/structSocketAddrMapT.html#a9b272e75c36373912e1ccdafddda322c">SocketAddrMapT::pMemGroupUserData</a>, and <a class="el" href="../../d5/df8/group__DirtyMem.html#ga4ac7e86fd1425142107bc0d2245818b6">SOCKET_MEMID</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga03e615b95b3ddadbf003e060efba573d">SocketDestroy()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaaecb02edc95dae9bd2bec426e41291f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sockaddr* SocketAddrMapTranslate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *&#160;</td>
          <td class="paramname"><em>pAddrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>pResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>pSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pNameLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate the following: </p>
<p><a class="anchor" id="SocketAddrMapTranslate"></a></p>
<pre class="fragment">- IPv4 real address to IPV4-mapped IPv6 address
- IPv4 virtual address to IPv6 address
- IPv6 address to IPv4 address
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pAddrMap</td><td>- address map </td></tr>
    <tr><td class="paramname">*pResult</td><td>- [out] storage for translated result </td></tr>
    <tr><td class="paramname">*pSource</td><td>- source address </td></tr>
    <tr><td class="paramname">*pNameLen</td><td>- [out] storage for result length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>struct sockaddr * - pointer to resulting IPv6 address</dd></dl>
<dl class="section version"><dt>Version</dt><dd>04/15/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d0/db5/group__Platform.html#ga3b5c02ec734b11a9af7b349d02cd301a">ds_memcpy_s()</a>, <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html#ae5268f64575348540c6dfd31840ac197">SocketAddrMapEntryT::iVirtualAddress</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html#a4b8aa8b6883e749d5530dc16a3c90bad">SocketAddrMapEntryT::SockAddr6</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga773d4fe2add8138bcb9f78e1aad3ab5b">SockaddrIn6GetAddr4</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga6917f48e67339dc71034017d01802571">SockaddrIn6IsIPv4()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gad8f69f633d37f50d331bf2cb7bb02468">SockaddrInGetAddr</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa7dd5250213ddc43eb7a8040fc3c21ea">SockaddrInGetPort</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gab0ff3f1e5c8b09d63df4e7af550b8345">SockaddrInit</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gac1887038d67b4655381947d4c9e83440">SockaddrInSetAddr</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga65aaa79f47586715580b4609bc8ed5d3">SockaddrInSetPort</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga3e27e543e95035e173602542ab91db23">SocketHtons()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga617e9d78e74f34f0a91f17e1e7698b2a">SocketInfo()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#ga66486652e6eb3700dd631c72b1ecccec">SocketNtohs()</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga2e1668db5bbe17963a6ca9128c5ec9b2">SocketAccept()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gabe5956df037fdfe1d2fa1bd43f54b26f">SocketBind()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gae14b1f7d6a571be831e72a0200b455ab">SocketConnect()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gad125662b93dcd796df4bb4ca5ec3b335">SocketSendto()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8bfc6499b736af597684a78a529823dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketAddrRemapAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *&#160;</td>
          <td class="paramname"><em>pAddrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>pOldAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>pNewAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iAddrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap an existing IPv6 address and return a virtual IPv4 address that can be used to reference it. </p>
<p><a class="anchor" id="SocketAddrRemapAddress"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pAddrMap</td><td>- address map </td></tr>
    <tr><td class="paramname">*pOldAddr</td><td>- address that should be in mapping table </td></tr>
    <tr><td class="paramname">*pNewAddr</td><td>- address to update to the mapping table </td></tr>
    <tr><td class="paramname">iAddrSize</td><td>- size of address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - negative=error, else virtual IPv4 address for remapped IPv6 address</dd></dl>
<dl class="section version"><dt>Version</dt><dd>12/03/2015 (amakoukji) </dd></dl>

<p>References <a class="el" href="../../db/dd9/structSocketAddrMapEntryT.html#ae5268f64575348540c6dfd31840ac197">SocketAddrMapEntryT::iVirtualAddress</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, and <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga0b6b9c8c07bc4b6c765c02cfbb400b53">SocketAddrMapAddress()</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>.</p>

</div>
</div>
<a class="anchor" id="gaee389cd8bbfedb2895cce3db9c443870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketAddrUnmapAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d62/structSocketAddrMapT.html">SocketAddrMapT</a> *&#160;</td>
          <td class="paramname"><em>pAddrMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>pAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iAddrSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an address mapping from the mapping table. </p>
<p><a class="anchor" id="SocketAddrUnmapAddress"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pAddrMap</td><td>- address map </td></tr>
    <tr><td class="paramname">*pAddr</td><td>- address to remove from the mapping table </td></tr>
    <tr><td class="paramname">iAddrSize</td><td>- size of address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - negative=error, else virtual IPv4 address for newly mapped IPv6 address</dd></dl>
<dl class="section version"><dt>Version</dt><dd>04/18/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>.</p>

</div>
</div>
<a class="anchor" id="ga776bfda2944c3874bbd820353261d8e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/ddb/structHostentT.html">HostentT</a>* SocketHostnameAddRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> **&#160;</td>
          <td class="paramname"><em>ppHostList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> *&#160;</td>
          <td class="paramname"><em>pHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bUseRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for in-progress DNS requests we can piggyback on, instead of issuing a new request. </p>
<p><a class="anchor" id="SocketHostnameAddRef"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">**ppHostList</td><td>- list of active lookups </td></tr>
    <tr><td class="paramname">*pHost</td><td>- current lookup </td></tr>
    <tr><td class="paramname">bUseRef</td><td>- force using a new entry if bUseRef=FALSE (should normally be TRUE)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> * - Pre-existing DNS request we have refcounted, or NULL</dd></dl>
<dl class="section version"><dt>Version</dt><dd>01/16/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../df/ddb/structHostentT.html#a94ba96204971d3d89d8102d2c7aa9e2e">HostentT::done</a>, <a class="el" href="../../df/ddb/structHostentT.html#a3240d1345a9c403530cb06e5902f5fc1">HostentT::name</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gafc2b9e1d269e7fa900d2a6f6420ec221">NetCritEnter()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga91fe4591a47d2c57b1d87534e989c330">NetCritLeave()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../df/ddb/structHostentT.html#acc38f6d5a95ac9903b6622ac706d039b">HostentT::pNext</a>, <a class="el" href="../../df/ddb/structHostentT.html#af5863b4cf49d3f9d5947eead36a2ef8a">HostentT::refcount</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga617e9d78e74f34f0a91f17e1e7698b2a">SocketInfo()</a>, and <a class="el" href="../../d0/db5/group__Platform.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa86e9dae07a0fbf6b94856e41b116e5d">SocketLookup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c7a05e875510edfb2f87884860ba0f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketHostnameCacheAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *&#160;</td>
          <td class="paramname"><em>pCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStrHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVerbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add hostname and address to hostname cache. </p>
<p><a class="anchor" id="SocketHostnameCacheAdd"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pCache</td><td>- hostname cache </td></tr>
    <tr><td class="paramname">*pStrHost</td><td>- hostname to add </td></tr>
    <tr><td class="paramname">uAddress</td><td>- address of hostname </td></tr>
    <tr><td class="paramname">iVerbose</td><td>- debug level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>10/09/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a89d1a2d2c409a64c304e861a88356274">SocketHostnameCacheT::CacheEntries</a>, <a class="el" href="../../d0/db5/group__Platform.html#ga879fcb2875ccc72129d6e0d692dc589f">ds_strnzcpy()</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#ae9ed9dbe0d8ee3cedf71a825e4ba84b4">SocketHostnameCacheT::iMaxEntries</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gafc2b9e1d269e7fa900d2a6f6420ec221">NetCritEnter()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga91fe4591a47d2c57b1d87534e989c330">NetCritLeave()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga24a7e76a3b95b30abbec8516ba143776">SocketHostnameCacheGet()</a>, <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a2da6c2d2ada8f1b4ede7810fb15fa4cf">SocketHostnameCacheEntryT::strDnsName</a>, <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a24ba438a90061611f3d6c4bccdee56e0">SocketHostnameCacheEntryT::uAddress</a>, and <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a92d924b1ed883b3a6d71d5c102831a17">SocketHostnameCacheEntryT::uTimer</a>.</p>

</div>
</div>
<a class="anchor" id="gae81ba16e71872fa5964c85ebe413a556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a>* SocketHostnameCacheCreate </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMemGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemGroupUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create short-term hostname (DNS) cache. </p>
<p><a class="anchor" id="SocketHostnameCacheCreate"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMemGroup</td><td>- memgroup to alloc/free with </td></tr>
    <tr><td class="paramname">*pMemGroupUserData</td><td>- memgroup user data to alloc/free with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html" title="socket hostname cache ">SocketHostnameCacheT</a> * - hostname cache or NULL on failure</dd></dl>
<dl class="section version"><dt>Version</dt><dd>10/09/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d5/df8/group__DirtyMem.html#gad7507812366b85323e61c0da17907448">DirtyMemAlloc()</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#ae9ed9dbe0d8ee3cedf71a825e4ba84b4">SocketHostnameCacheT::iMaxEntries</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a136dd4c5bfd644f631bfc65d82c21a85">SocketHostnameCacheT::iMemGroup</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a5fcdfd6aa0860938cf1fbad040176e2d">SocketHostnameCacheT::pMemGroupUserData</a>, and <a class="el" href="../../d5/df8/group__DirtyMem.html#ga4ac7e86fd1425142107bc0d2245818b6">SOCKET_MEMID</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga3f7f8470f917a28402ddcc85776f4853">SocketCreate()</a>.</p>

</div>
</div>
<a class="anchor" id="gae66d31ff669db27c1f9745dacefaa99c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketHostnameCacheDel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *&#160;</td>
          <td class="paramname"><em>pCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStrHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVerbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove hostname cache entry from the cache, if it exists. pStrHost is checked if non-NULL and uAddress is checked if non-zero (note that both can be checked if desired). </p>
<p><a class="anchor" id="SocketHostnameCacheDel"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pCache</td><td>- hostname cache </td></tr>
    <tr><td class="paramname">*pStrHost</td><td>- hostname of cache entry to delete, or NULL </td></tr>
    <tr><td class="paramname">uAddress</td><td>- address of cache entry to delete, or zero </td></tr>
    <tr><td class="paramname">iVerbose</td><td>- debug level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>09/23/2016 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a89d1a2d2c409a64c304e861a88356274">SocketHostnameCacheT::CacheEntries</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#ae9ed9dbe0d8ee3cedf71a825e4ba84b4">SocketHostnameCacheT::iMaxEntries</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gafc2b9e1d269e7fa900d2a6f6420ec221">NetCritEnter()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga91fe4591a47d2c57b1d87534e989c330">NetCritLeave()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a2da6c2d2ada8f1b4ede7810fb15fa4cf">SocketHostnameCacheEntryT::strDnsName</a>, and <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a24ba438a90061611f3d6c4bccdee56e0">SocketHostnameCacheEntryT::uAddress</a>.</p>

</div>
</div>
<a class="anchor" id="ga33ad91b1fa137552f7cf6758c57a2090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketHostnameCacheDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *&#160;</td>
          <td class="paramname"><em>pCache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy short-term hostname (DNS) cache. </p>
<p><a class="anchor" id="SocketHostnameCacheDestroy"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pCache</td><td>- hostname cache</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>10/09/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d5/df8/group__DirtyMem.html#ga511050f9df5c6afddcec2c1244f824a6">DirtyMemFree()</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a136dd4c5bfd644f631bfc65d82c21a85">SocketHostnameCacheT::iMemGroup</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a5fcdfd6aa0860938cf1fbad040176e2d">SocketHostnameCacheT::pMemGroupUserData</a>, and <a class="el" href="../../d5/df8/group__DirtyMem.html#ga4ac7e86fd1425142107bc0d2245818b6">SOCKET_MEMID</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga03e615b95b3ddadbf003e060efba573d">SocketDestroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga24a7e76a3b95b30abbec8516ba143776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SocketHostnameCacheGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/d96/structSocketHostnameCacheT.html">SocketHostnameCacheT</a> *&#160;</td>
          <td class="paramname"><em>pCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStrHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iVerbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address for hostname from cache, if available. Also expires cache entry if applicable. </p>
<p><a class="anchor" id="SocketHostnameCacheGet"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pCache</td><td>- hostname cache </td></tr>
    <tr><td class="paramname">*pStrHost</td><td>- hostname to add </td></tr>
    <tr><td class="paramname">iVerbose</td><td>- debug level</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t - address for hostname, or zero if not in cache</dd></dl>
<dl class="section version"><dt>Version</dt><dd>10/09/2013 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#a89d1a2d2c409a64c304e861a88356274">SocketHostnameCacheT::CacheEntries</a>, <a class="el" href="../../d4/df0/dirtynet_8c.html#a46220fe9a77a24b65c8b30aa381b502a">DIRTYNET_HOSTNAMECACHELIFETIME</a>, <a class="el" href="../../d7/d96/structSocketHostnameCacheT.html#ae9ed9dbe0d8ee3cedf71a825e4ba84b4">SocketHostnameCacheT::iMaxEntries</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gafc2b9e1d269e7fa900d2a6f6420ec221">NetCritEnter()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga91fe4591a47d2c57b1d87534e989c330">NetCritLeave()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga71b575a1405a86e841e47df85c805975">NetTickDiff</a>, <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a2da6c2d2ada8f1b4ede7810fb15fa4cf">SocketHostnameCacheEntryT::strDnsName</a>, <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a24ba438a90061611f3d6c4bccdee56e0">SocketHostnameCacheEntryT::uAddress</a>, and <a class="el" href="../../d9/d58/structSocketHostnameCacheEntryT.html#a92d924b1ed883b3a6d71d5c102831a17">SocketHostnameCacheEntryT::uTimer</a>.</p>

<p>Referenced by <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga1c7a05e875510edfb2f87884860ba0f9">SocketHostnameCacheAdd()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa86e9dae07a0fbf6b94856e41b116e5d">SocketLookup()</a>.</p>

</div>
</div>
<a class="anchor" id="gaddbe2014d9a68aecfbfaf13e88935174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketHostnameListProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/ddb/structHostentT.html">HostentT</a> **&#160;</td>
          <td class="paramname"><em>ppHostList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMemGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemGroupUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process list of in-progress DNS requests, disposing of those that are completed and no longer referenced. </p>
<p><a class="anchor" id="SocketHostnameListProcess"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">**ppHostList</td><td>- list of active lookups </td></tr>
    <tr><td class="paramname">iMemGroup</td><td>- memgroup hostname lookup records are allocated with </td></tr>
    <tr><td class="paramname">*pMemGroupUserData</td><td>- memgroup userdata hostname lookup records are allocated with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is called from the SocketIdle thread, which is already guarded by the global critical section. It is therefore assumed that it does not need to be explicitly guarded here.</dd></dl>
<dl class="section version"><dt>Version</dt><dd>01/16/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d5/df8/group__DirtyMem.html#ga511050f9df5c6afddcec2c1244f824a6">DirtyMemFree()</a>, <a class="el" href="../../df/ddb/structHostentT.html#acc38f6d5a95ac9903b6622ac706d039b">HostentT::pNext</a>, and <a class="el" href="../../d5/df8/group__DirtyMem.html#ga4ac7e86fd1425142107bc0d2245818b6">SOCKET_MEMID</a>.</p>

</div>
</div>
<a class="anchor" id="ga9a1f26e46487e97f2c2e5c07e272ee06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketPacketQueueAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pPacketData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iPacketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>pPacketAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a packet to packet queue. </p>
<p><a class="anchor" id="SocketPacketQueueAdd"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue to add to </td></tr>
    <tr><td class="paramname">*pPacketData</td><td>- packet data to add to queue </td></tr>
    <tr><td class="paramname">iPacketSize</td><td>- size of packet data </td></tr>
    <tr><td class="paramname">*pPacketAddr</td><td>- remote address associated with packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - zero=success, negative=failure</dd></dl>
<dl class="section version"><dt>Version</dt><dd>02/21/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#ab9c7afe0fb82bdedd0b2db734706ff74">SocketPacketQueueEntryT::aPacketData</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#ab3d3722d1e28ab9c37fd1c3bb92a9a74">SocketPacketQueueT::aPacketQueue</a>, <a class="el" href="../../d4/df0/dirtynet_8c.html#aee4a73a5ab06cf290437424d79dfb409">DIRTYNET_PACKETQUEUEDEBUG</a>, <a class="el" href="../../d0/db5/group__Platform.html#ga198c61fb97f9a8899644b55411e47a47">ds_memcpy()</a>, <a class="el" href="../../d0/db5/group__Platform.html#ga3b5c02ec734b11a9af7b349d02cd301a">ds_memcpy_s()</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af62c92f24e8f97a37fecfc60f6610f67">SocketPacketQueueT::iMaxPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adbea5144f7336e1fedb7b287a452d5d7">SocketPacketQueueT::iNumPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adcde5442c62c30359328853beb1d1cef">SocketPacketQueueT::iPacketHead</a>, <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a2bd941a1a7a336780467c7db651cb0a2">SocketPacketQueueEntryT::iPacketSize</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#acce49ca65c69801dab8dd57a69d1dd92">SocketPacketQueueT::iPacketTail</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a8088792a9c2e4db78d7c6bac51708fc0">SocketPacketQueueEntryT::PacketAddr</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga9f76b6ae4a059de8e4d92dedfb9029f4">SOCKET_MAXUDPRECV</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a4c7728e373049f12aa459cdeb2768270">SocketPacketQueueT::uPacketDrop</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#acf8f3186daae3dda9fb2fbf191098b35">SocketPacketQueueT::uPacketMax</a>, and <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a6f9e429e79d17ac2bb93d001a3eff891">SocketPacketQueueEntryT::uPacketTick</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>, and <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga105cc2978f2137ee252f857c615863e7">SocketPacketQueueResize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga706031a42619ce07376b1ce52735da81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html">SocketPacketQueueEntryT</a>* SocketPacketQueueAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloc a packet queue entry. This is used when receiving data directly into the packet queue data buffer. </p>
<p><a class="anchor" id="SocketPacketQueueAlloc"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue to alloc entry from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html" title="socket packet queue entry ">SocketPacketQueueEntryT</a> * - packet queue entry</dd></dl>
<dl class="section version"><dt>Version</dt><dd>02/24/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#ab3d3722d1e28ab9c37fd1c3bb92a9a74">SocketPacketQueueT::aPacketQueue</a>, <a class="el" href="../../d4/df0/dirtynet_8c.html#aee4a73a5ab06cf290437424d79dfb409">DIRTYNET_PACKETQUEUEDEBUG</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af62c92f24e8f97a37fecfc60f6610f67">SocketPacketQueueT::iMaxPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adbea5144f7336e1fedb7b287a452d5d7">SocketPacketQueueT::iNumPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adcde5442c62c30359328853beb1d1cef">SocketPacketQueueT::iPacketHead</a>, <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a2bd941a1a7a336780467c7db651cb0a2">SocketPacketQueueEntryT::iPacketSize</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#acce49ca65c69801dab8dd57a69d1dd92">SocketPacketQueueT::iPacketTail</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, and <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ed50e8a2f71866f20dcfcc7b3775ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketPacketQueueControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iControl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control socket packet queue options. </p>
<p><a class="anchor" id="SocketPacketQueueControl"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue control function; different selectors control different behaviors </td></tr>
    <tr><td class="paramname">iControl</td><td>- control selector </td></tr>
    <tr><td class="paramname">iValue</td><td>- selector specific</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - selector result</dd></dl>
<dl class="section note"><dt>Note</dt><dd>iControl can be one of the following:</dd></dl>
<pre class="fragment">        'pdev' - set simulated packet deviation
        'plat' - set simulated packet latency
        'plos' - set simulated packet loss</pre><dl class="section version"><dt>Version</dt><dd>10/07/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a2c863832685e439998256c8c3bb61699">SocketPacketQueueT::uDeviation</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a1637e1fa24613a66d030e0b91386d0f1">SocketPacketQueueT::uLatency</a>, and <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af43cb507fb922e8bef38fee76caa6cbf">SocketPacketQueueT::uPacketLoss</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4cf986d178d802f64e06f273fe8276f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a>* SocketPacketQueueCreate </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMaxPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMemGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemGroupUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a packet queue. </p>
<p><a class="anchor" id="SocketPacketQueueCreate"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMaxPackets</td><td>- size of queue, in packets (max 127) </td></tr>
    <tr><td class="paramname">iMemGroup</td><td>- memgroup to alloc/free with </td></tr>
    <tr><td class="paramname">*pMemGroupUserData</td><td>- memgroup user data to alloc/free with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html" title="socket packet queue ">SocketPacketQueueT</a> * - packet queue, or NULL on failure</dd></dl>
<dl class="section version"><dt>Version</dt><dd>02/21/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#ab3d3722d1e28ab9c37fd1c3bb92a9a74">SocketPacketQueueT::aPacketQueue</a>, <a class="el" href="../../d5/df8/group__DirtyMem.html#gad7507812366b85323e61c0da17907448">DirtyMemAlloc()</a>, <a class="el" href="../../d4/df0/dirtynet_8c.html#af286b901c7c417d8357ed6df488564e7">DIRTYNET_PACKETQUEUEMAX</a>, <a class="el" href="../../d0/db5/group__Platform.html#ga2f8789d2aed3bafa8f8bd3333b695fe3">DS_CLAMP</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af62c92f24e8f97a37fecfc60f6610f67">SocketPacketQueueT::iMaxPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a0f5ea27f29990b933fc855c75a04a8a1">SocketPacketQueueT::iMemGroup</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adbea5144f7336e1fedb7b287a452d5d7">SocketPacketQueueT::iNumPackets</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a3eb11e3a9d43214c927342d3e0b47f89">SocketPacketQueueT::pMemGroupUserData</a>, <a class="el" href="../../d5/df8/group__DirtyMem.html#ga4ac7e86fd1425142107bc0d2245818b6">SOCKET_MEMID</a>, and <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a230d1cfd84951fd953ae750ca9c0b6b2">SocketPacketQueueT::uLatencyTime</a>.</p>

<p>Referenced by <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga105cc2978f2137ee252f857c615863e7">SocketPacketQueueResize()</a>.</p>

</div>
</div>
<a class="anchor" id="gac6b0a88c2ee02c67004368132b587245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketPacketQueueDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy packet queue. </p>
<p><a class="anchor" id="SocketPacketQueueDestroy"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section version"><dt>Version</dt><dd>02/21/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d5/df8/group__DirtyMem.html#ga511050f9df5c6afddcec2c1244f824a6">DirtyMemFree()</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a0f5ea27f29990b933fc855c75a04a8a1">SocketPacketQueueT::iMemGroup</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a3eb11e3a9d43214c927342d3e0b47f89">SocketPacketQueueT::pMemGroupUserData</a>, and <a class="el" href="../../d5/df8/group__DirtyMem.html#ga4ac7e86fd1425142107bc0d2245818b6">SOCKET_MEMID</a>.</p>

<p>Referenced by <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga105cc2978f2137ee252f857c615863e7">SocketPacketQueueResize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1687ec08e7ba84d7bd675749eefeaebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketPacketQueueRem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pPacketData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iPacketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>pPacketAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a packet from packet queue. </p>
<p><a class="anchor" id="SocketPacketQueueRem"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue to add to </td></tr>
    <tr><td class="paramname">*pPacketData</td><td>- [out] storage for packet data </td></tr>
    <tr><td class="paramname">iPacketSize</td><td>- size of packet output data buffer </td></tr>
    <tr><td class="paramname">*pPacketAddr</td><td>- [out] storage for packet addr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - positive=size of packet, zero=no packet, negative=failure</dd></dl>
<dl class="section version"><dt>Version</dt><dd>02/21/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#ab9c7afe0fb82bdedd0b2db734706ff74">SocketPacketQueueEntryT::aPacketData</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#ab3d3722d1e28ab9c37fd1c3bb92a9a74">SocketPacketQueueT::aPacketQueue</a>, <a class="el" href="../../d4/df0/dirtynet_8c.html#aee4a73a5ab06cf290437424d79dfb409">DIRTYNET_PACKETQUEUEDEBUG</a>, <a class="el" href="../../d0/db5/group__Platform.html#ga198c61fb97f9a8899644b55411e47a47">ds_memcpy()</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a0852e08f336f5873ff840c543af9a952">SocketPacketQueueT::iDeviationTime</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af62c92f24e8f97a37fecfc60f6610f67">SocketPacketQueueT::iMaxPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adbea5144f7336e1fedb7b287a452d5d7">SocketPacketQueueT::iNumPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adcde5442c62c30359328853beb1d1cef">SocketPacketQueueT::iPacketHead</a>, <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a2bd941a1a7a336780467c7db651cb0a2">SocketPacketQueueEntryT::iPacketSize</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#acce49ca65c69801dab8dd57a69d1dd92">SocketPacketQueueT::iPacketTail</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga2668cd2ab5f5b7f258daa068eb4d799e">NetRand()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga71b575a1405a86e841e47df85c805975">NetTickDiff</a>, <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a8088792a9c2e4db78d7c6bac51708fc0">SocketPacketQueueEntryT::PacketAddr</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga6cc6e46640a49d7ca641e41ff509de68">SockaddrInSetMisc</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a2c863832685e439998256c8c3bb61699">SocketPacketQueueT::uDeviation</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a1637e1fa24613a66d030e0b91386d0f1">SocketPacketQueueT::uLatency</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a230d1cfd84951fd953ae750ca9c0b6b2">SocketPacketQueueT::uLatencyTime</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af43cb507fb922e8bef38fee76caa6cbf">SocketPacketQueueT::uPacketLoss</a>, and <a class="el" href="../../da/d17/structSocketPacketQueueEntryT.html#a6f9e429e79d17ac2bb93d001a3eff891">SocketPacketQueueEntryT::uPacketTick</a>.</p>

<p>Referenced by <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga105cc2978f2137ee252f857c615863e7">SocketPacketQueueResize()</a>.</p>

</div>
</div>
<a class="anchor" id="ga105cc2978f2137ee252f857c615863e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a>* SocketPacketQueueResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMaxPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iMemGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemGroupUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a packet queue, if the max packet size is different. </p>
<p><a class="anchor" id="SocketPacketQueueResize"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue to resize (may be null) </td></tr>
    <tr><td class="paramname">iMaxPackets</td><td>- new size of queue, in packets (max 127) </td></tr>
    <tr><td class="paramname">iMemGroup</td><td>- memgroup to alloc/free with </td></tr>
    <tr><td class="paramname">*pMemGroupUserData</td><td>- memgroup user data to alloc/free with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html" title="socket packet queue ">SocketPacketQueueT</a> * - pointer to resized packet queue</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the new max queue size is less than the number of packets in the current queue, packets will be overwritten in the usual manner (older discarded in favor of newer).</dd></dl>
<dl class="section version"><dt>Version</dt><dd>05/30/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d4/df0/dirtynet_8c.html#af286b901c7c417d8357ed6df488564e7">DIRTYNET_PACKETQUEUEMAX</a>, <a class="el" href="../../d0/db5/group__Platform.html#ga2f8789d2aed3bafa8f8bd3333b695fe3">DS_CLAMP</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af62c92f24e8f97a37fecfc60f6610f67">SocketPacketQueueT::iMaxPackets</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#ga9f76b6ae4a059de8e4d92dedfb9029f4">SOCKET_MAXUDPRECV</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga9a1f26e46487e97f2c2e5c07e272ee06">SocketPacketQueueAdd()</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga4cf986d178d802f64e06f273fe8276f3">SocketPacketQueueCreate()</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#gac6b0a88c2ee02c67004368132b587245">SocketPacketQueueDestroy()</a>, and <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga1687ec08e7ba84d7bd675749eefeaebd">SocketPacketQueueRem()</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gabe5956df037fdfe1d2fa1bd43f54b26f">SocketBind()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>.</p>

</div>
</div>
<a class="anchor" id="ga49c5a3f556825998102198d395025801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketPacketQueueStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/dc6/structSocketPacketQueueT.html">SocketPacketQueueT</a> *&#160;</td>
          <td class="paramname"><em>pPacketQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status of socket packet queue. </p>
<p><a class="anchor" id="SocketPacketQueueStatus"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pPacketQueue</td><td>- packet queue to get status of </td></tr>
    <tr><td class="paramname">iStatus</td><td>- status selector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - selector result</dd></dl>
<dl class="section note"><dt>Note</dt><dd>iStatus can be one of the following:</dd></dl>
<pre class="fragment">        'full' - TRUE if queue is full, FALSE otherwise
        'pdrp' - number of packets overwritten due to queue overflow
        'pmax' - maximum number of packets in queue (high water)
        'size' - queue size (in packets)</pre><dl class="section version"><dt>Version</dt><dd>10/20/2015 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d0/db5/group__Platform.html#gaa93f0eb578d23995850d61f7d61c55c1">FALSE</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#af62c92f24e8f97a37fecfc60f6610f67">SocketPacketQueueT::iMaxPackets</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#adbea5144f7336e1fedb7b287a452d5d7">SocketPacketQueueT::iNumPackets</a>, <a class="el" href="../../d0/db5/group__Platform.html#gaa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#a4c7728e373049f12aa459cdeb2768270">SocketPacketQueueT::uPacketDrop</a>, and <a class="el" href="../../d4/dc6/structSocketPacketQueueT.html#acf8f3186daae3dda9fb2fbf191098b35">SocketPacketQueueT::uPacketMax</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#ga617e9d78e74f34f0a91f17e1e7698b2a">SocketInfo()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gab8446942be1a8a99247103a3288f1960">SocketRecvfrom()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ab8211828585e467238b13839b4ae49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketRateThrottle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a> *&#160;</td>
          <td class="paramname"><em>pRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iSockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pOpName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throttles data size to send or recv based on calculated data rate and configured max rate. </p>
<p><a class="anchor" id="SocketRateThrottle"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pRate</td><td>- state used to calculate rate </td></tr>
    <tr><td class="paramname">iSockType</td><td>- socket type (SOCK_DGRAM, SOCK_STREAM, etc) </td></tr>
    <tr><td class="paramname">iData</td><td>- amount of data being sent/recv </td></tr>
    <tr><td class="paramname">*pOpName</td><td>- indicates send or recv (for debug use only)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - amount of data to send/recv</dd></dl>
<dl class="section version"><dt>Version</dt><dd>08/20/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../d4/df0/dirtynet_8c.html#a4ce69642e10f05f9f2f6e1d94c70912a">DIRTYNET_RATEDEBUG</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaf6e281cce23380cd22a8b3123da4d2f7">NetPrintfVerbose</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga097c90d4248968643521dbe71b58e5d0">SocketRateUpdate()</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#abbf9754ebdfa26c0c7f637a4f3646b65">SocketRateT::uMaxRate</a>, and <a class="el" href="../../dc/d0a/structSocketRateT.html#ae99627b2778f8faa6a133c5ddd6e5a7b">SocketRateT::uNextRate</a>.</p>

<p>Referenced by <a class="el" href="../../d2/da4/classHttpCallback.html#a400d0a0cef8ec894aab8e5fd05992dc4">HttpCallback::OnDataAvailable()</a>, <a class="el" href="../../d4/d9c/classSequentialStream.html#a5976f49a6edeca4ec86dadd7856bd045">SequentialStream::Read()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gab8446942be1a8a99247103a3288f1960">SocketRecvfrom()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gad125662b93dcd796df4bb4ca5ec3b335">SocketSendto()</a>.</p>

</div>
</div>
<a class="anchor" id="ga097c90d4248968643521dbe71b58e5d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketRateUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d0a/structSocketRateT.html">SocketRateT</a> *&#160;</td>
          <td class="paramname"><em>pRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pOpName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update socket data rate estimation. </p>
<p><a class="anchor" id="SocketRateUpdate"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*pRate</td><td>- state used to store rate estimation data </td></tr>
    <tr><td class="paramname">iData</td><td>- amount of data being sent/recv </td></tr>
    <tr><td class="paramname">*pOpName</td><td>- indicates send or recv (for debug use only)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Rate estimation is based on a rolling 16-deep history of ~100ms samples of data rate (the actual period may vary slightly based on update rate and tick resolution) covering a total of ~1600-1700ms. We also keep track of the rate we are called at (excluding multiple calls within the same tick) so we can estimate how much data we need to have sent by the next time we are called. This is important because we will always be shooting lower than our cap if we don't consider this factor, and the amount we are shooting lower by increases the slower the update rate.</dd></dl>
<dl class="section version"><dt>Version</dt><dd>08/20/2014 (jbrookes) </dd></dl>

<p>References <a class="el" href="../../dc/d0a/structSocketRateT.html#a6310964d3cec685e4648a47628422837">SocketRateT::aCallHist</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#a5c08d614db127e903d4c4c9cd06a0b28">SocketRateT::aDataHist</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#a08f8f187d5241fb8fb7a0bef06fef242">SocketRateT::aTickHist</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#gaa0d9caf2e46e0a1af62069c6e6c7c598">NetTick()</a>, <a class="el" href="../../d8/db9/group__DirtyLib.html#ga71b575a1405a86e841e47df85c805975">NetTickDiff</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#a8a888152c8d7bb06baf880950a50f223">SocketRateT::uCurRate</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#ad7e25e81b035053309b373ead27b8345">SocketRateT::uDataIndex</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#a24a40ae1d085aac42922b94f57d6effe">SocketRateT::uLastRateTick</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#a20e35a906aa54486ff5d8442937eba74">SocketRateT::uLastTick</a>, <a class="el" href="../../dc/d0a/structSocketRateT.html#abbf9754ebdfa26c0c7f637a4f3646b65">SocketRateT::uMaxRate</a>, and <a class="el" href="../../dc/d0a/structSocketRateT.html#ae99627b2778f8faa6a133c5ddd6e5a7b">SocketRateT::uNextRate</a>.</p>

<p>Referenced by <a class="el" href="../../d2/da4/classHttpCallback.html#a400d0a0cef8ec894aab8e5fd05992dc4">HttpCallback::OnDataAvailable()</a>, <a class="el" href="../../d4/d9c/classSequentialStream.html#a5976f49a6edeca4ec86dadd7856bd045">SequentialStream::Read()</a>, <a class="el" href="../../d6/dea/group__DirtyNetPriv.html#ga7ab8211828585e467238b13839b4ae49">SocketRateThrottle()</a>, <a class="el" href="../../d7/da6/group__DirtyNet.html#gab8446942be1a8a99247103a3288f1960">SocketRecvfrom()</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gad125662b93dcd796df4bb4ca5ec3b335">SocketSendto()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c11161dcf9a89a97f1213852f77ce08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketSendCallbackAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a>&#160;</td>
          <td class="paramname"><em>aCbEntries</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a> *&#160;</td>
          <td class="paramname"><em>pCbEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new socket send callback. </p>
<p><a class="anchor" id="SocketSendCallbackAdd"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCbEntries</td><td>- collection of callbacks to add to </td></tr>
    <tr><td class="paramname">*pCbEntry</td><td>- entry to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - zero=success; negative=failure</dd></dl>
<dl class="section version"><dt>Version</dt><dd>07/18/2014 (mclouatre) </dd></dl>

<p>References <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html#a94f440095e49c47ab293e912e21f7a8d">SocketSendCallbackEntryT::pSendCallback</a>, <a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html#ae4ead580fc04d507364fa42519e5d16d">SocketSendCallbackEntryT::pSendCallref</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gaf4cb2ad51d6264abca6fedc5593395fa">SOCKET_MAXSENDCALLBACKS</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0460928278b76a3227d6b5484c16a50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketSendCallbackRem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a>&#160;</td>
          <td class="paramname"><em>aCbEntries</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html">SocketSendCallbackEntryT</a> *&#160;</td>
          <td class="paramname"><em>pCbEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a socket send callback that was already registered. </p>
<p><a class="anchor" id="SocketSendCallbackRem"></a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCbEntries</td><td>- collection of callbacks to remove from </td></tr>
    <tr><td class="paramname">*pCbEntry</td><td>- entry to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t - zero=success; negative=failure</dd></dl>
<dl class="section version"><dt>Version</dt><dd>07/18/2014 (mclouatre) </dd></dl>

<p>References <a class="el" href="../../d8/db9/group__DirtyLib.html#ga65daf776ea13a4de6e65651254a25906">NetPrintf</a>, <a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html#a94f440095e49c47ab293e912e21f7a8d">SocketSendCallbackEntryT::pSendCallback</a>, <a class="el" href="../../df/dc5/structSocketSendCallbackEntryT.html#ae4ead580fc04d507364fa42519e5d16d">SocketSendCallbackEntryT::pSendCallref</a>, and <a class="el" href="../../d7/da6/group__DirtyNet.html#gaf4cb2ad51d6264abca6fedc5593395fa">SOCKET_MAXSENDCALLBACKS</a>.</p>

<p>Referenced by <a class="el" href="../../d7/da6/group__DirtyNet.html#gaa88f03e010fe955cf637b81bf4bbe75e">SocketControl()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<table x-use-null-cells
        style="float: alignright;
                width: 100%;
                border-spacing: 0px;"
        cellspacing=0
        width=100%>
<tr>
<td style="text-align: left;
            padding-left: 0px;
            padding-top: 0px;
            padding-right: 0px;
            padding-bottom: 0px;"
    align=left><span style="font-family: Arial, sans-serif; font-size: 8pt;">EA Digital Platform</span></td>
<td style="text-align: right;
            padding-left: 0px;
            padding-top: 0px;
            padding-right: 0px;
            padding-bottom: 0px;"
    align=right><span style="font-family: Arial, sans-serif; font-size: 8pt;">&#169;
 2014 Electronic Arts Inc.</span><br />
<span style="font-family: Arial, sans-serif; font-size: 8pt;">Generated
 on: Fri Oct 21 2016 13:34:39</span><br />
</td></tr>
</table>
