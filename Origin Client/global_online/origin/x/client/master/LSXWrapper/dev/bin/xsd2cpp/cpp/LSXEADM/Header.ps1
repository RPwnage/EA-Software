$SchemaFilename = $Generator.NamespaceToFilename($Schema.Namespace).Replace('/','.')
$SchemaFilename + ".h"
$HeaderGuard = "__" + ($Generator.NamespaceToFilename($Schema.Namespace) + ".h").Replace('.','_').Replace('/','_').ToUpper() + "__"

"#ifndef " + $HeaderGuard
"#define " + $HeaderGuard
"
// Generated By: XSD2CPP V2.0
// Author: Hans van Veenendaal
//
// !!!! This file is automatically generated please do not modify !!!!

#include <QString>
#include <string>
#include <vector>
#include <stdint.h>
#include ""../../Types.h""  // Ugly fix... Need to fix up the include paths 

"
foreach($i in $Schema.ImportedSchemas)
{
	$filename = $Generator.NamespaceToFilename($i.Namespace)
	if($filename -ne "Serialization")
	{
		"#include """ + $filename + ".h"""
	}
}
"
"
foreach($i in $Schema.ImportedSchemas)
{
	$filename = $Generator.NamespaceToFilename($i.Namespace)
	if(-not $filename.StartsWith("Serialization"))
	{
		"using namespace " + $filename.Replace(".", "::") + ";"
	}
}

# If there are simple types in this schema include them
if($Schema.SimpleTypes.Count -ne 0)
{
"
#include """ + $Generator.NameSpaceToFilename($Schema.Namespace) + "Enum.h"""
""
}

#Write out the namespace
$NamespaceParts = $SchemaFilename.Split('.')
foreach($i in $NamespaceParts)
{
	"namespace " + $i
	"{"
}
	"
		// Writing out the hashes
	"
#	foreach($i in $Schema.SimpleTypes)
#	{
#	"#define HASH_" + $i.Name + " " + $Generator.MurmurHash($i.Name) + "UL"
#	}
	foreach($i in $Schema.ComplexTypes)
	{
		if(-not $i.IsArrayContainer)
		{
			"#define HASH_" + $i.Name + " " + $Generator.MurmurHash($i.Name) + "UL"
		}
	}

"
	// Forward Declaration of types
"
foreach($i in $Schema.ComplexTypes)
{
	if(-not $i.IsArrayContainer)
	{
		"struct " + $i.Typename + ";"
	}
}
""

# Write out the structure declarations.

foreach($i in $Schema.ComplexTypes)
{
	if(-not $i.IsArrayContainer)
	{
		if($i.Documentation.Length -gt 0)
		{
			"// " + $i.Documentation
		}
		$line = "struct " + $i.Typename
		if($i.BaseType -ne $null)
		{
			$line = $line + " : public " + $i.BaseType.Typename
		}
		
		$line

		"{"
		"	" + $i.Typename + "();"
		"	void InitStruct();"
		"	const char * GetType() const { return """ + $i.Name + """;}"
		"	uint32_t GetHash() const { return HASH_" + $i.Name + ";}"
		if($i.Elements.Count -eq 1)
		{
			if($i.Elements[0].MaxOccurs -ne 1)
			{
				"	uint32_t GetCount() const { return " + $i.Elements[0].Name + ".size(); }"
				"	uint32_t GetTypeSize() const { return sizeof(" + $Generator.ConvertType($i.Elements[0].Typename) + "); }"
			}
		}

		if($i.Attributes.Count -ne 0)
		{
"

"
			foreach($a in $i.Attributes)
			{
				if($a.Documentation.Length -gt 0)
				{
					"    // " + $a.Documentation
				}
				"	" + $Generator.ConvertType($a) + " " + $a.Name + ";"
			}
		}

		if($i.Elements.Count -ne 0)		
		{
"

"
			foreach($e in $i.Elements)
			{
				if($e.Documentation.Length -gt 0)
				{
					"    // " + $e.Documentation
				}
				"	" + $Generator.ConvertType($e) + " " + $e.Name + ";"
			}
		}

		"};"
		""
	}
}









[array]::Reverse($NamespaceParts)
foreach($i in $NamespaceParts)
{
	"} // namespace " + $i
}

"
#endif // " + $HeaderGuard

