$SchemaFilename = $Generator.NamespaceToFilename($Schema.Namespace).Replace('/','.')
#The first object in the script is the file it will be saved into.
$SchemaFilename + "Reader.cpp"

"#include """ + $SchemaFilename +"Reader.h"""

"
// Generated By: XSD2CPP V2.0
// Author: Hans van Veenendaal
//
// !!!! This file is automatically generated please do not modify !!!!

#include ""ReaderCommon.h"""
foreach($i in $Schema.ImportedSchemas)
{
	$filename = $Generator.NamespaceToFilename($i.Namespace)
	if($filename -ne "Serialization")
	{
		"#include """ + $filename + "Reader.h"""
	}
}
""
foreach($i in $Schema.ImportedSchemas)
{
	$filename = $Generator.NamespaceToFilename($i.Namespace)
	if($filename -ne "Serialization")
	{
		"using namespace " + $filename.Replace(".", "::") + ";"
	}
}
""

#Write out the namespace
$NamespaceParts = $SchemaFilename.Split('.')
foreach($i in $NamespaceParts)
{
	"namespace " + $i
	"{"
}


"// Readers used to read simple types"
foreach($i in $Schema.SimpleTypes)
{
	if($i.Enumerations.Count -ne 0)
	{
		"bool Read(INodeDocument * pDoc, const char *name, " + $Generator.ConvertType($i) + " &data);"
	}
}

""
"// Readers used to read the content of a complex type"
foreach($i in $Schema.ComplexTypes)
{
	"bool Read(INodeDocument * pDoc, const char *name, " + $Generator.ConvertType($i) + " &data);"
}

""

foreach($i in $Schema.SimpleTypes)
{
	if($i.Enumerations -ne 0)
	{
		if($i.EnumValuesSet)
		{
			""
			"bool ReadAttribute(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	return ReadEnumValueAttribute(doc, name, " + $i.Name + "Strings, " + $i.Name + "_IndexToEnumMap ," + $i.Enumerations.Count + ", *(int *)&data);"
			"}"
			""
			"bool Read(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	return ReadEnumValue(doc, name, " + $i.Name + "Strings, " + $i.Name + "_IndexToEnumMap ," + $i.Enumerations.Count + ", *(int *)&data);"
			"}"
		}
		else
		{
			""
			"bool ReadAttribute(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	return ReadEnumValueAttribute(doc, name, " + $i.Name + "Strings, " + $i.Enumerations.Count + ", *(int *)&data);"
			"}"
			""
			"bool Read(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	return ReadEnumValue(doc, name, " + $i.Name + "Strings, " + $i.Enumerations.Count + ", *(int *)&data);"
			"}"
		}
	}
}


""
"// Readers used to read the content of a complex type"
foreach($i in $Schema.ComplexTypes)
{
	if(-not $i.IsArrayContainer)
	{
		"bool ReadClass(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	if (!doc)"
		"		return false;"
		""
		"	// Reset the structure to default values"
		"	data.InitStruct();"
        ""
		"	std::string name;"
		""
		$prefixDeclared = $False;

		if($i.Attributes.Count -gt 0)
		{
		"	std::string prefix = GetPrefix(doc, """ + $i.Namespace + """);"
		"	if (prefix.length() != 0)"
		"	{"
		"		prefix += "":"";"
		"	}"
		""
			$prefixDeclared = $True;
			
			foreach($a in $i.Attributes)
			{
				"	name = prefix + """ + $a.SourceName + """;"
				"	" + $Generator.GetReader($a) + "(doc, name.c_str(), data." + $a.Name +");"
			}
		}

		if(($i.BaseType -ne $null) -or ($i.Elements.Count -gt 0))
		{
		
			if($i.BaseType -ne $null)
			{
				"	ReadClass(doc, *(" + $i.BaseType.Name + " *)&data);"
				""
			}


			if($i.Elements.Count -gt 0)
			{
				foreach($e in $i.Elements)
				{
					if($e.IsArray)
					{
						$elementName = $e.Name
						if($e.TypeCT -ne $null)
						{
							$elementName = $e.TypeCT.SourceName;
						}
						"	{"
						"		std::string prefix = GetPrefix(doc, """ + $e.Namespace + """);"
						"		if(prefix.length()>0)"	
						"			name = prefix + "":" + $elementName + """; else name = """ + $elementName + """;"
						"		if(doc->EnterArray(name.c_str()))"
						"		{"
						"           if(name == doc->GetName())"
						"           {"
						"			    if(doc->FirstValue())"
						"			    {"
						"				    do"
						"				    {"
						"					    " + $Generator.ConvertContainedType($e) + " item;"
						"					    if (!" + $Generator.GetContainedTypeReader($e) + "(doc, item))"
						"						    return false;"
						""
						"					    data." + $e.Name + ".push_back(item);"
						"				    }while(doc->NextValue());"
						"			    }"
						"			    doc->LeaveArray();"
						"               doc->Parent();"
						"		    }"
						"		}"
						"		else"
						"		{"
						"			if(doc->FirstChild(name.c_str()))"
						"			{"
						"				do"
						"				{"
						"					" + $Generator.ConvertContainedType($e) + " item;"
						"					if (!" + $Generator.GetContainedTypeReader($e) + "(doc, item))"
						"						return false;"
						""
						"					data." + $e.Name + ".push_back(item);"
						"				}while(doc->NextChild(name.c_str()));"
						"			}"
						"			doc->Parent();"
						"		}"
						"	}"
					}
					else
					{
						if($prefixDeclared -eq $False)
						{
							"	std::string prefix = GetPrefix(doc, """ + $i.Namespace + """);"
							"	if (prefix.length() != 0)"
							"	{"
							"		prefix += "":"";"
							"	}"
							""
								$prefixDeclared = $True;				
						}
					
					
						"	name = prefix + """ + $e.SourceName + """;"
						"	" + $Generator.GetReader($e) + "(doc, name.c_str(), data." + $e.Name +");"
					}
				}
			}
		}
		""
		"	return true;"
		"}"
	}
	""
}

""
"// Readers used to read the complex type and its content"
foreach($i in $Schema.ComplexTypes)
{
	if(-not $i.IsArrayContainer)
	{
		"bool Read(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	return ReadClass(doc, data);"
		"}"
	}
	""
	if(-not $i.IsArrayContainer)
	{
		"bool Read(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"    bool ret = false;"
        "    if(doc->FirstChild(name))"
		"        ReadClass(doc, data);"
		"    doc->Parent();"	
		"    return ret;"
		"}"
		""
	}
	else
	{
		"bool Read(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data)"
		"{"
		foreach($e in $i.Elements)
		{
			if($e.IsArray)
			{
				$elementName = $e.Name;
				if($e.TypeCT -ne $null)
				{
					$elementName = $e.TypeCT.SourceName;
				}
				"	std::string prefix = GetPrefix(doc, """ + $e.Namespace + """);"
				"	std::string name;"
				"	if(prefix.length()>0)"	
				"		name = prefix + "":" + $elementName + """; else name = """ + $elementName + """;"
				"	if(doc->EnterArray(name.c_str()))"
				"	{"
				"		if(doc->FirstValue())"
				"		{"
				"			do"
				"			{"
				"				" + $Generator.ConvertContainedType($e) + " item;"
				"				if (!" + $Generator.GetContainedTypeReader($e) + "(doc, item))"
				"					return false;"
				""
				"				data.push_back(item);"
				"			}while(doc->NextValue());"
				"		}"
				"		doc->LeaveArray();"
				"	}"
				"	else"
				"	{"
				"		if(doc->FirstChild(name.c_str()))"
				"		{"
				"			do"
				"			{"
				"				" + $Generator.ConvertContainedType($e) + " item;"
				"				if (!" + $Generator.GetContainedTypeReader($e) + "(doc, item))"
				"					return false;"
				""
				"				data.push_back(item);"
				"			}while(doc->NextChild(name.c_str()));"
				"		}"
				"		doc->Parent();"
				"	}"
			}
		}
		"	return true;"
		"}"
		""

		"bool Read(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	if(doc->FirstChild(name))"
		"	{"
		"		Read(doc, data);"
		"	}"
		"	doc->Parent();"
		"	return true;"
		"}"
		""
	}

}




[array]::Reverse($NamespaceParts)
foreach($i in $NamespaceParts)
{
	"} // namespace " + $i
}
