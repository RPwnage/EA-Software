<xs:schema id="OriginSDK" version="9.10.1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="lsx" xmlns:tns="lsx">

  <!--**************************************************************************************
  **** This file describes the payload part of the LSX messages.
  **** Wrap with <LSX><Request recipient="Presence" id="1"> <payload Version="1"/> </Request></LSX>
  **** Wrap with <LSX><Response sender="Presence" id="1"> <payloadResponse/> </Request></LSX>
  -->

  <!-- Error return -->
  <xs:complexType name="ErrorSuccess">
    <xs:attribute name="Code" type="xs:int"/>
    <xs:attribute name="Description" type="xs:string"/>
  </xs:complexType>

  <!--EbisuErrorT EBISUSDK_API EbisuCheckPermission(EbisuUserT user, int32_t iPermission)-->

  <xs:simpleType name="PermissionType">
    <xs:restriction base="xs:int">
      <xs:enumeration id="MULTIPLAYER" value="0">
        <xs:annotation>
          <xs:documentation>This enumeration is deprecated</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="PURCHASE" value="1"/>
      <xs:enumeration id="TRIAL" value="2"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="CheckPermission" >
    <xs:annotation>
      <xs:documentation>This type is deprecated.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="PermissionId" type="tns:PermissionType" />
  </xs:complexType>

  <xs:simpleType name="GrantedType">
    <xs:restriction base="xs:int">
      <xs:enumeration id="DENIED" value="0"/>
      <xs:enumeration id="GRANTED" value="1" />
      <xs:enumeration id="FRIENDS_ONLY" value="2" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="CheckPermissionResponse">
    <xs:attribute name="Access" type="tns:GrantedType">
      <xs:annotation>
        <xs:documentation>This attribute is deprecated.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- LSX Message definition for EbisuErrorT EbisuGetProfile(int32_t iIndex, EbisuProfileT *pProfile)-->
  <xs:complexType name="GetProfile" facility="PROFILE" groups="User" >
    <xs:annotation>
      <xs:documentation>Get the users profile information.</xs:documentation>
    </xs:annotation>
    <!-- Should always be 0 -->
    <xs:attribute name="index" type="xs:int" default="0">
      <xs:annotation>
        <xs:documentation>This parameter indicates the current user index. Currently only 0 is supported.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- The LSX reply for OriginErrorT OriginGetProfile(int32_t iIndex, OriginProfileT *pProfile) -->
  <xs:complexType name="GetProfileResponse">
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="PersonaId"	type="xs:unsignedLong"/>
    <xs:attribute name="Persona" type="xs:string" />
    <xs:attribute name="AvatarId" type="xs:string" />
    <xs:attribute name="Country" type="xs:string" />
    <xs:attribute name="IsUnderAge" type="xs:boolean" />
    <xs:attribute name="IsSubscriber" type="xs:boolean" />
    <xs:attribute name="GeoCountry" type="xs:string" />
    <xs:attribute name="CommerceCountry" type="xs:string" />
    <xs:attribute name="CommerceCurrency" type="xs:string" />
  </xs:complexType>

  <xs:simpleType name="SettingType">
    <xs:restriction base="xs:int">
      <xs:enumeration id="INVALID" value="-1"/>
      <xs:enumeration id="LANGUAGE" value="0">
        <xs:annotation>
          <xs:documentation>Get the Origin Language.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="ENVIRONMENT" value="1">
        <xs:annotation>
          <xs:documentation>Get the Origin Environment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="IS_IGO_AVAILABLE" value="2">
        <xs:annotation>
          <xs:documentation>Check whether the IGO is available. Even if the IGO is enabled, it may not be available.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="IS_IGO_ENABLED" value="3">
        <xs:annotation>
          <xs:documentation>Check whether the IGO is enabled.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="IS_TELEMETRY_ENABLED" value="4">
        <xs:annotation>
          <xs:documentation>Check whether telemetry is enabled. (i.e. the user has not opted-out of telemetry)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="GetSetting" facility="SDK" groups="General">
    <xs:attribute name="SettingId" type="tns:SettingType" default="INVALID">
      <xs:annotation>
        <xs:documentation>Enumeration identifying the setting item we are reading from the client.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetSettingResponse">
    <xs:attribute name="Setting" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="GetSettings" facility="SDK" groups="General">
    <xs:annotation>
      <xs:documentation>Get all the Origin game readable settings in one call.</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="GetSettingsResponse" >
    <xs:attribute name="Language" type="xs:string" />
    <xs:attribute name="Environment" type="xs:string" />
    <xs:attribute name="IsIGOAvailable" type="xs:boolean" />
    <xs:attribute name="IsIGOEnabled" type="xs:boolean" />
    <xs:attribute name="IsTelemetryEnabled" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="GetAllGameInfo" facility="SDK" groups="General">
    <xs:annotation>
      <xs:documentation>Get all the Game Info settings in one call.</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="GetAllGameInfoResponse">
    <xs:attribute name="UpToDate" type="xs:boolean"/>
    <xs:attribute name="Languages" type="xs:string"/>
    <xs:attribute name="FreeTrial" type="xs:boolean"/>
    <xs:attribute name="FullGamePurchased" type="xs:boolean"/>
    <xs:attribute name="Expiration" type="xs:dateTime"/>
    <xs:attribute name="SystemTime" type="xs:dateTime"/>
    <xs:attribute name="HasExpiration" type="xs:boolean"/>
    <xs:attribute name="InstalledVersion" type="xs:string"/>
    <xs:attribute name="InstalledLanguage" type="xs:string"/>
    <xs:attribute name="AvailableVersion" type="xs:string"/>
    <xs:attribute name="DisplayName" type="xs:string"/>
  </xs:complexType>

  <xs:simpleType name="GameInfoType">
    <xs:restriction base="xs:int">
      <xs:enumeration id="INVALID" value="-1"/>
      <xs:enumeration id="UPTODATE" value="0">
        <xs:annotation>
          <xs:documentation>Check whether the game is up to date.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="LANGUAGES" value="1">
        <xs:annotation>
          <xs:documentation>Set of languages that the user is entitled to play the game in.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FREETRIAL" value="2">
        <xs:annotation>
          <xs:documentation>Check whether the game is a free trial.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="EXPIRATION" value="3">
        <xs:annotation>
          <xs:documentation>Check whether the game has an expiration set.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="EXPIRATION_DURATION" value="4">
        <xs:annotation>
          <xs:documentation>Returns the number of seconds remaining until expiration.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="INSTALLED_VERSION" value="5">
        <xs:annotation>
          <xs:documentation>Get the installed version of the game.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="INSTALLED_LANGUAGE" value="6">
        <xs:annotation>
          <xs:documentation>The language/locale the title is installed in.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="AVAILABLE_VERSION" value="7">
        <xs:annotation>
          <xs:documentation>Get the available version of the game.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="DISPLAY_NAME" value="8">
        <xs:annotation>
          <xs:documentation>The name of the game.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FULLGAME_PURCHASED" value="9">
        <xs:annotation>
          <xs:documentation>If this is a trial this boolean will return true when the full game is purchased.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="GetGameInfo" facility="SDK" groups="General">
    <xs:annotation>
      <xs:documentation>Get a specific game info.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="GameInfoId" type="tns:GameInfoType" default="INVALID">
      <xs:annotation>
        <xs:documentation>Enumerated value identifying the game info item we are reading from the client.</xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="GetGameInfoResponse">
    <xs:attribute name="GameInfo" type="xs:string"/>
  </xs:complexType>

  <!-- Enum specifying the IGO windows. -->
  <xs:simpleType name="IGOWindow">
    <xs:annotation>
      <xs:documentation>Defines types of In-Game Overlay windows.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:int" >
      <xs:enumeration id="LOGIN" value="1">
        <xs:annotation>
          <xs:documentation>A reference to the login in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="PROFILE" value="2">
        <xs:annotation>
          <xs:documentation>A reference to the profile in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="RECENT" value="3">
        <xs:annotation>
          <xs:documentation>A reference to the recent players in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FEEDBACK" value="4">
        <xs:annotation>
          <xs:documentation>A reference to the feedback in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FRIENDS" value="5">
        <xs:annotation>
          <xs:documentation>A reference to the friends in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FRIEND_REQUEST" value="6">
        <xs:annotation>
          <xs:documentation>A reference to the friend request in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="CHAT" value="7">
        <xs:annotation>
          <xs:documentation>A reference to the chat in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="COMPOSE_CHAT" value="8">
        <xs:annotation>
          <xs:documentation>A reference to the chat composition in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="INVITE" value="9">
        <xs:annotation>
          <xs:documentation>A reference to the achievements in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="ACHIEVEMENTS" value="10">
        <xs:annotation>
          <xs:documentation>A reference to the profile in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="STORE" value="11">
        <xs:annotation>
          <xs:documentation>A reference to the store in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="CODE_REDEMPTION" value="12">
        <xs:annotation>
          <xs:documentation>A reference to the code redemption in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="CHECKOUT" value="13">
        <xs:annotation>
          <xs:documentation>A reference to the checkout in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="BLOCKED" value="14">
        <xs:annotation>
          <xs:documentation>A reference to the blocked users in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="BROWSER" value="15">
        <xs:annotation>
          <xs:documentation>A reference to the browser in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FIND_FRIENDS" value="16">
        <xs:annotation>
          <xs:documentation>A reference to the find friends in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="CHANGE_AVATAR" value="17">
        <xs:annotation>
          <xs:documentation>A reference to the change avatar in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="GAMEDETAILS" value="18">
        <xs:annotation>
          <xs:documentation>A reference to the game details in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="BROADCAST" value="19">
        <xs:annotation>
          <xs:documentation>A reference to the broadcast in-game overlay window.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- Backend LSX message for any EbisuShowXXXXUI function, except for commerce.-->
  <xs:complexType name="ShowIGOWindow">
    <xs:sequence>
      <xs:element name="TargetId" minOccurs="0" maxOccurs="unbounded" type="xs:unsignedLong"/>
      <xs:element name="String" type="xs:string" minOccurs="0" maxOccurs="1"/>
      <xs:element name="Categories" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="MasterTitleIds" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="Offers" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>

    <xs:attribute name="UserId" type="xs:unsignedLong" use="optional"/>
    <xs:attribute name="WindowId" type="tns:IGOWindow" />
    <xs:attribute name="Show" type="xs:boolean" default="true"/>
    <xs:attribute name="Flags" type="xs:int" use="optional"/>
    <xs:attribute name="ContentId" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="ShowIGO" facility="IGO" groups="IGO">
    <xs:annotation>
      <xs:documentation>Toggles the display of the IGO. This function gives the game control over the visibility of the IGO. Similar to the user-controlled hotkey 'Ctrl+Tab or Shift+`'.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="bShow" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Indicates whether to show or hide the IGO.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="IGOUnavailable" event="true" alias="IGOUnavailableEvent" groups="Events">
    <xs:attribute name="Reason" type="xs:int"/>
  </xs:complexType>
  
  <xs:complexType name="MinimizeRequest" event="true" alias="MinimizeRequest" groups="Events">
  </xs:complexType>

  <xs:complexType name="RestoreRequest" event="true" alias="RestoreRequest" groups="Events">
  </xs:complexType>

  <xs:complexType name="GetUTCTime" facility="SDK" groups="General">
    <xs:annotation>
      <xs:documentation>Returns the server time irrespective of the Local PC's time.</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="GetUTCTimeResponse">
    <xs:attribute name="Time" type="xs:dateTime"/>
  </xs:complexType>

  <!-- 
  This will add a list of users to your recent player list. 
  EbisuErrorT EbisuAddRecentPlayers(const EbisuUserT *pUser, const EbisuUserT *pRecentList, int32 iRecentCount)
  -->

  <xs:complexType name="AddRecentPlayers" groups="Friends">
    <!--facility="RECENTPLAYER">-->
    <xs:sequence>
      <xs:element name="Player" alias="Players" type="xs:unsignedLong" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A list of UserIds of players the User is playing against.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
  </xs:complexType>

  <!--EbisuErrorT EbisuQueryFriends(const EbisuUserT *pUser, int32 *pBufLen, HANDLE *pHandle); -->
  <xs:complexType name="QueryFriends" facility="FRIENDS" groups="Friends">
    <xs:annotation>
      <xs:documentation>Queries a user's friends' information asynchronously. Begin enumerating the user's friends list, returning a collection of OriginFriendT records. No assumptions should be made on the total number of friends returned.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user. Use OriginGetDefaultUser().</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="Presence">
    <xs:restriction base="xs:int">
      <xs:enumeration id="OFFLINE" value="0">
        <xs:annotation>
          <xs:documentation>The user is currently offline.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="ONLINE" value="1">
        <xs:annotation>
          <xs:documentation>Indicator that the user is ONLINE. This is a read only setting, and cannot be set by the game.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="INGAME" value="2">
        <xs:annotation>
          <xs:documentation>When the game is started you can set this to indicate that the user is playing a game. When the game is started through Origin, Origin will set this state.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="BUSY" value="3">
        <xs:annotation>
          <xs:documentation>The user is online but busy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="IDLE" value="4">
        <xs:annotation>
          <xs:documentation>The user is online but idle (likely away).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="JOINABLE" value="5">
        <xs:annotation>
          <xs:documentation>The user is online and in a joinable game state.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="JOINABLE_INVITE_ONLY" value="6">
        <xs:annotation>
          <xs:documentation>The user is online and in a joinable but only for invited users.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="FriendState">
    <xs:restriction base="xs:int">
      <xs:enumeration id="NONE" value="0">
        <xs:annotation>
          <xs:documentation>There is no friend relation between you and this user.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="MUTUAL" value="1">
        <xs:annotation>
          <xs:documentation>You are a mutual friend to this user.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="INVITED" value="2">
        <xs:annotation>
          <xs:documentation>You invited this user to be a friend.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="DECLINED" value="3">
        <xs:annotation>
          <xs:documentation>The user declined to be your friend.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="REQUEST" value="4">
        <xs:annotation>
          <xs:documentation>The user is requesting you to be his friend.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="Friend">
    <xs:attribute name="UserId"	type="xs:unsignedLong"/>
    <xs:attribute name="PersonaId"	type="xs:unsignedLong"/>
    <xs:attribute name="Persona" type="xs:string"/>
    <xs:attribute name="AvatarId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The ImageId to the Avatar.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Group" type="xs:string">
      <xs:annotation>
        <xs:documentation>The chat group this friend belongs to.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Presence" type="tns:Presence">
      <xs:annotation>
        <xs:documentation>The rich presence description string.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="State" type="tns:FriendState">
      <xs:annotation>
        <xs:documentation>The friend's state. See ORIGIN_FRIEND_DECLINED etc.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="TitleId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The title that the user is in. </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Title" type="xs:string">
      <xs:annotation>
        <xs:documentation>The localized title string.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="MultiplayerId" type="xs:string">
      <xs:annotation>
        <xs:documentation>An id to identify games that can play together.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="RichPresence" type="xs:string">
      <xs:annotation>
        <xs:documentation>The rich presence description string.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="GamePresence" type="xs:string">
      <xs:annotation>
        <xs:documentation>A game-specific presence string.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RequestFriend" facility="XMPP" groups="Friends">
    <xs:annotation>
      <xs:documentation>Request a user to become a friend.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user. Use OriginGetDefaultUser().</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="UserToAdd" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user that is requested to be friend.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RemoveFriend" facility="XMPP" groups="Friends">
    <xs:annotation>
      <xs:documentation>Request to unfriend a user.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user that is requesting to remove the friend.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="UserToRemove" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user to be unfriended.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="AcceptFriendInvite">
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="OtherId" type="xs:unsignedLong"/>
  </xs:complexType>

  <!-- The response for EbisuErrorT EbisuQueryFriends(const EbisuUserT *pUser, int32 *pBufLen, HANDLE *pHandle); -->
  <xs:complexType name="QueryFriendsResponse" event="true" alias="FriendsEvent" groups="Events">
    <xs:sequence>
      <xs:element name="Friends" type="tns:Friend" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="User" >
    <xs:attribute name="EAID" type="xs:string" />
    <xs:attribute name="UserId" type="xs:unsignedLong" />
    <xs:attribute name="PersonaId" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="GetBlockList" facility="BLOCKED_USERS" groups="Friends"/>

  <xs:complexType name="GetBlockListResponse">
    <xs:sequence>
      <xs:element name="User" type="tns:User" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Return" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="BlockUser" facility="XMPP" groups="Friends">
    <xs:annotation>
      <xs:documentation>Blocks one user from contacting another.</xs:documentation>
    </xs:annotation>
    <xs:attribute name ="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user that is requesting to block the user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name ="UserIdToBlock" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user that is to be blocked.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="UnblockUser" facility="XMPP" groups="Friends">
    <xs:annotation>
      <xs:documentation>Removes the block that prevents on user from contacting another.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user that is requesting to un-block the user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name ="UserIdToUnblock" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The nucleus user id of the user that is to be un-blocked.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetUserProfileByEmailorEAID" facility="GET_USERID" alias="GetUserProfileByEAID" groups="Friends">
    <xs:annotation>
      <xs:documentation>Get the profile of a user based on their email or EA id.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="KeyWord" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="GetUserProfileByEmailorEAIDResponse">
    <xs:sequence>
      <xs:element name="User" type="tns:User" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Return" type="xs:string"/>
  </xs:complexType>

  <!-- Request for EbisuErrorT EbisuCheckFriends(EbisuUserT user, const EbisuUserT *pUserList, int32 iUserCount, int32 *pBufLen, HANDLE *pHandle);-->
  <xs:complexType name="QueryAreFriends" facility="FRIENDS" groups="Friends">
    <xs:annotation>
      <xs:documentation>Determines the relationship between a local user and one or more other users.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Friends" type="xs:unsignedLong" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user. Use OriginGetDefaultUser().</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="FriendStatus">
    <xs:attribute name="FriendId" type="xs:unsignedLong" />
    <xs:attribute name="State" type="tns:FriendState" />
  </xs:complexType>

  <!-- The middleware reply for the Check Friends request.-->
  <xs:complexType name="QueryAreFriendsResponse">
    <xs:sequence>
      <xs:element name="Users" type="tns:FriendStatus" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <!--int32 EbisuSubscribePresence(const EbisuUserT *pUser, const EbisuUserT *pPeerList, int32 iPeerCount) -->
  <xs:complexType name="SubscribePresence">
    <xs:sequence>
      <xs:element name="Users" type="xs:unsignedLong" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong" />
  </xs:complexType>

  <!--int32 EbisuUnsubscribePresence(const EbisuUserT *pUser, const EbisuUserT *pPeerList, int32 iPeerCount)-->
  <xs:complexType name="UnsubscribePresence">
    <xs:sequence>
      <xs:element name="Users" type="xs:unsignedLong" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
  </xs:complexType>

  <!--int32 EbisuQueryPresence(const EbisuUserT *pUser, int32 *pBufLen, HANDLE *pHandle)-->
  <xs:complexType name="QueryPresence" facility="PRESENCE" groups="Friends">
    <xs:annotation>
      <xs:documentation>Queries the current presence status for a list of friends and/or recent players.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Users" type="xs:unsignedLong" minOccurs="1" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>The list of users whose presence you want to update (e.g., friends/recent players etc.).</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user who is requesting the presence update. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!--The response for int32 EbisuQueryPresence(const EbisuUserT *pUser, int32 *pBufLen, HANDLE *pHandle)
  This is currently the friend structure, but we may change this to a lighter weight structure.-->
  <xs:complexType name="QueryPresenceResponse">
    <xs:sequence>
      <xs:element name="Friends" type="tns:Friend" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <!--int32 EbisuSetPresence(const EbisuUserT *pUser, int32 iContext, int32 iValue, const char *pCustom, const EbisuCharT *pSession)-->
  <xs:complexType name="SetPresence" facility="PRESENCE" groups="User">
    <xs:annotation>
      <xs:documentation>Sets the presence for the current user. Sets the extended presence for the game. Origin will set basic presence (which game the user is playing, if they appear idle, etc.), but this function allows the game to provide more detail. If the user is in a joinable game session, they must pass the session identifier. If not in game or not in a joinable game, the session identifier should be NULL. Note that ORIGIN_PRESENCE_OFFLINE is not a valid state and will return an error. (Any option for a user to 'hide themselves' online would be available exclusively via the Origin desktop application, not through the SDK.)</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user who is requesting a change to his or her presence. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Presence" type="tns:Presence">
      <xs:annotation>
        <xs:documentation>One of ORIGIN_PRESENCE_XXX (see enumPresence).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="RichPresence" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>Additional public presence information like: 'Playing FIFA11' (NULL=no custom presence).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="GamePresence" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>A game-specific presence string that only has meaning for the same title (NULL=no game data).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="SessionId" type="xs:string" use="optional">
      <xs:annotation>
        <xs:documentation>A session string (0=not in game session).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="SetPresenceVisibility" facility="PRESENCE" groups="User">
    <xs:annotation>
      <xs:documentation>Controls the visibility of the user. This controls the visibility of the users presence for other players. visible == true --> The users presence is visible for other users. visible == false --> The user will appear offline for other users.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user for whom you are requesting the presence visibility change for. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Visible" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>The boolean indicating whether the users presence should be visible to other players.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetPresenceVisibility" facility="PRESENCE" groups="User">
    <xs:annotation>
      <xs:documentation>Request the visibility of the user. This function queries the visibility of the users presence to other players. visible == true --> The users presence is visible for other users. visible == false --> The user will appear offline for other users.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user for whom you are requesting the presence visibility for. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetPresenceVisibilityResponse">
    <xs:attribute name="Visible" type="xs:boolean"/>
  </xs:complexType>

  <!--int32 EbisuGetPresence(const EbisuUserT *pUser, int32 *pContext, int32 *pValue, char *pCustom, int iCustom, EbisuCharT *pSession)-->
  <xs:complexType name="GetPresence" facility="PRESENCE" groups="User">
    <xs:annotation>
      <xs:documentation>Retrieves the presence for the current user. Queries the current extended presence state for the game. This returns the state previously set with OriginSetPresence for the selected user.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user whose presence you want to get. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetPresenceResponse" event="true" alias="PresenceEvent" groups="Events">
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="Presence" type="tns:Presence"/>
    <xs:attribute name="Title" type="xs:string" use="optional"/>
    <xs:attribute name="TitleId" type="xs:string" use="optional"/>
    <xs:attribute name="MultiplayerId" type="xs:string" use="optional"/>
    <xs:attribute name="RichPresence" type="xs:string" use="optional"/>
    <xs:attribute name="GamePresence" type="xs:string" use="optional"/>
    <xs:attribute name="SessionId" type="xs:string" use="optional"/>
  </xs:complexType>

  <xs:complexType name="CurrentUserPresenceEvent" event="true" groups="Events">
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="Presence" type="tns:Presence"/>
    <xs:attribute name="Title" type="xs:string" use="optional"/>
    <xs:attribute name="TitleId" type="xs:string" use="optional"/>
    <xs:attribute name="MultiplayerId" type="xs:string" use="optional"/>
    <xs:attribute name="RichPresence" type="xs:string" use="optional"/>
    <xs:attribute name="GamePresence" type="xs:string" use="optional"/>
    <xs:attribute name="SessionId" type="xs:string" use="optional"/>
  </xs:complexType>

  <xs:complexType name="QueryImage" facility="RESOURCES" groups="General">
    <xs:annotation>
      <xs:documentation>Requests an image. Most of the user identifying structures like OriginProfileT, OriginFriendT contain an ImageId. This can be used to query the cached location of the 40x40 image for that user. You can also request images for other users by constructing an imageId that has the following format: [user:12270853235] and use that to query the avatar image of the following sizes: 40x40, 208x208, 416x416. The OriginQueryImage API will return all the available cached image sizes for that particular user, and if the requested size was not available the response code will be ORIGIN_PENDING. When you receive an ORIGIN_PENDING code it will be followed up by an ORIGIN_EVENT_PROFILE event to indicate that the requested image is available. (See OriginProfileChangeT)</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ImageId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The identifier for the image belonging to game title.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Width" type="xs:int">
      <xs:annotation>
        <xs:documentation>The required width of the image.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Height" type="xs:int">
      <xs:annotation>
        <xs:documentation>The required height of the image.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Image">
    <xs:attribute name="ImageId" type="xs:string" />
    <xs:attribute name="Width" type="xs:int" />
    <xs:attribute name="Height" type="xs:int" />
    <xs:attribute name="ResourcePath" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="QueryImageResponse">
    <xs:sequence>
      <xs:element name="Images" type="tns:Image" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Result" type="xs:int" />
  </xs:complexType>


  <!--int32 EbisuSendInvite(const EbisuUserT *pUser, const EbisuUserT *pInviteList, int32 iInviteCount, char *pInviteText);-->
  <xs:complexType name="SendInvite" facility="XMPP" alias="SendGameInvite" groups="Game">
    <xs:annotation>
      <xs:documentation>Invite a list of friends to your game. This function allows the game to invite other players without needing interaction with the IGO.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Invitees" type="xs:unsignedLong" minOccurs="1" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A list of users.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Invitation" type="xs:string">
      <xs:annotation>
        <xs:documentation>A message to accompany the invitation.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:simpleType name="InviteReply">
    <xs:restriction base="xs:int">
      <xs:enumeration id="PENDING" value="0"/>
      <xs:enumeration id="ACCEPTED" value="1"/>
      <xs:enumeration id="REJECTED" value="2"/>
    </xs:restriction>
  </xs:simpleType>


  <xs:complexType name="Invite">
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="Reply" type="tns:InviteReply" />
  </xs:complexType>

  <xs:complexType name="SendInviteResponse">
    <xs:sequence>
      <xs:element name="PendingInvites" type="tns:Invite" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="GetAuthToken" facility="UTILITY" groups="General">
    <xs:annotation>
      <xs:documentation>Get a nucleus 1 compatible authtoken</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="GetAccessToken">
  </xs:complexType>

  <xs:complexType name="GetAuthCode" facility="UTILITY" groups="General">
    <xs:annotation>
      <xs:documentation>Requests an authcode from the Origin Server identifying the user. The reply will be provided through the callback function.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ClientId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The client Id the AuthCode should be generated for.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Scope" type="xs:string">
      <xs:annotation>
        <xs:documentation>[optional] Scope used to generate the authcode. This optional param is NULL if not specified and will use the default scope.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="AuthCode">
    <xs:attribute name="value" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="AuthToken">
    <xs:attribute name="value" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="GetInternetConnectedState" facility="UTILITY" groups="General">
  </xs:complexType>

  <xs:complexType name="InternetConnectedState" >
    <xs:attribute name="connected" type="xs:int"/>
  </xs:complexType>

  <xs:complexType name="SendChat">
    <xs:attribute name="ChatId" type="xs:string" />
    <xs:attribute name="Body" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="CreateChat">
    <xs:sequence>
      <xs:element name="UserIds" minOccurs="0" maxOccurs="unbounded" type="xs:unsignedLong"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="AddUserToChat">
    <xs:sequence>
      <xs:element name="UserIds" minOccurs="0" maxOccurs="unbounded" type="xs:unsignedLong"/>
    </xs:sequence>
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="JoinChat">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="LeaveChat">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="QueryChatInfo">
  </xs:complexType>

  <xs:simpleType name="ChatState">
    <xs:restriction base="xs:string">
      <xs:enumeration id="ONETOONE" value="0"/>
      <xs:enumeration id="PENDINGMUC" value="1"/>
      <xs:enumeration id="MUC" value="2"/>
      <xs:enumeration id="FINISHED" value="3"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ChatInfo">
    <xs:attribute name="ChatId" type="xs:string" />
    <xs:attribute name="State" type="tns:ChatState" />
  </xs:complexType>

  <xs:complexType name="QueryChatInfoResponse">
    <xs:sequence>
      <xs:element name="Chats" type="tns:ChatInfo" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="QueryChatUsers">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="QueryChatUsersResponse">
    <xs:sequence>
      <xs:element name="ChatUsers" type="tns:Friend" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="GoOnline" facility="SDK" groups="General">
    <xs:annotation>
      <xs:documentation>Push Origin into Online mode.</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="BroadcastStart" facility="SDK" groups="Broadcast">
    <xs:annotation>
      <xs:documentation>Start a Twitch broadcast. Calling this function will try to start a Twitch broadcast. If the credentials are not set up, it will bring up the Twitch login window.</xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <xs:complexType name="BroadcastStop" facility="SDK" groups="Broadcast">
    <xs:annotation>
      <xs:documentation>Stop a Twitch broadcast. Calling this function will try to stop a Twitch broadcast.</xs:documentation>
    </xs:annotation>
  </xs:complexType>

  <xs:complexType name="BroadcastStatus" >
    <xs:attribute name="status" type="xs:int"/>
  </xs:complexType>

  <xs:complexType name="GetBroadcastStatus" facility="SDK" groups="Broadcast">
    <xs:annotation>
      <xs:documentation>Checks the current broadcast status. This will currently only check whether the internet connection is enabled.</xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <!--****************************************  Ebisu Event messages *************************************************-->

  <xs:simpleType name="IGOState">
    <xs:restriction base="xs:int">
      <xs:enumeration id="DOWN" value="0"/>
      <xs:enumeration id="UP" value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="IGOEvent" event="true" groups="Events">
    <xs:attribute name="State" type="tns:IGOState" />
  </xs:complexType>

  <xs:simpleType name="BroadcastState">
    <xs:annotation>
      <xs:documentation>Defines the broadcast state changes.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:int">
      <xs:enumeration id="DIALOG_OPEN" value="0">
        <xs:annotation>
          <xs:documentation>This indicates the main broadcast dialog has been opened. This is the dialog shown when the user has a Twitch account associated with an Origin account. This event will get fire anytime the dialog is opened regardless of whether the user opened it via the OIG or the SDK triggers the dialog.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="DIALOG_CLOSED" value="1">
        <xs:annotation>
          <xs:documentation>This indicates the main broadcast dialog has been closed.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="ACCOUNTLINKDIALOG_OPEN" value="2">
        <xs:annotation>
          <xs:documentation>This indicates the Twitch login UI, which allows the user to associate a Twitch account with an Origin account, is open.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="ACCOUNT_DISCONNECTED" value="3">
        <xs:annotation>
          <xs:documentation>This indicates that no Twitch account is associated with the Origin account.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="STARTED" value="4">
        <xs:annotation>
          <xs:documentation>This indicates that the game has passed the ORIGIN_BROADCAST_START_PENDING state and is actively broadcasting.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="STOPPED" value="5">
        <xs:annotation>
          <xs:documentation>This indicates the game broadcast stopped.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="BLOCKED" value="6">
        <xs:annotation>
          <xs:documentation>This indicates the game broadcast cannot start because either the game is unreleased or is on the Twitch blacklist.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="START_PENDING" value="7">
        <xs:annotation>
          <xs:documentation>This indicates Twitch is in the process of starting to broadcast, but is not actively broadcasting yet.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="ERROR" value="8">
        <xs:annotation>
          <xs:documentation>This indicates there was an error while attempting to start a broadcast.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="BroadcastEvent" event="true" groups="Events">
    <xs:attribute name="State" type="tns:BroadcastState" />
  </xs:complexType>

  <xs:complexType name="MultiplayerInvite" event="true" alias="GameInviteEvent" groups="Events">
    <xs:sequence>
      <xs:element name="SessionInformation" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="multiplayerId" type="xs:string" />
    <xs:attribute name="initial" type="xs:boolean" />
    <xs:attribute name="from"	type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="MultiplayerInvitePending" event="true" alias="GameInvitePendingEvent" groups="Events">
    <xs:attribute name="MultiplayerId" type="xs:string" />
    <xs:attribute name="from" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="Login" event="true" alias="LoginEvent" groups="Events">
    <xs:attribute name="IsLoggedIn" type="xs:boolean" />
  </xs:complexType>

  <xs:simpleType name="ProfileStateChange">
    <xs:restriction base="xs:int">
      <xs:enumeration id="EAID" value="0" />
      <xs:enumeration id="AVATAR" value="1" />
      <xs:enumeration id="SUBSCRIPTION" value="2" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ProfileEvent" event="true" groups="Events">
    <xs:attribute name="Changed" type="tns:ProfileStateChange" />
    <xs:attribute name="UserId" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="PurchaseEvent" event="true" groups="Events">
    <xs:attribute name="manifest" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="ChatMessageEvent">
    <xs:attribute name="ChatId" type="xs:string" />
    <xs:attribute name="UserId" type="xs:unsignedLong" />
    <xs:attribute name="Body" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="ChatInviteEvent">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="ChatCreatedEvent">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="ChatFinishedEvent">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="ChatUpdatedEvent">
    <xs:attribute name="ChatId" type="xs:string" />
  </xs:complexType>

  <xs:simpleType name="ContentState">
    <xs:restriction base="xs:int">
      <xs:enumeration id="UNKNOWN" value="0"/>
      <xs:enumeration id="READY_TO_DOWNLOAD" value="1"/>
      <xs:enumeration id="SERVER_QUEUED" value="2"/>
      <xs:enumeration id="DOWNLOADING" value="3"/>
      <xs:enumeration id="DOWNLOAD_PAUSED" value="4"/>
      <xs:enumeration id="READY_TO_ACTIVATE" value="5"/>
      <xs:enumeration id="READY_TO_DECRYPT" value="6"/>
      <xs:enumeration id="DECRYPTING" value="7"/>
      <xs:enumeration id="READY_TO_UNPACK" value="8"/>
      <xs:enumeration id="UNPACKING" value="9"/>
      <xs:enumeration id="READY_TO_INSTALL" value="10"/>
      <xs:enumeration id="INSTALLING" value="11"/>
      <xs:enumeration id="READY_TO_PLAY" value="12"/>
      <xs:enumeration id="READY_TO_USE" value="13"/>
      <xs:enumeration id="INSTALLED" value="14"/>
      <xs:enumeration id="WAITING_TO_DOWNLOAD" value="15"/>
      <xs:enumeration id="WAITING_TO_DECRYPT" value="16"/>
      <xs:enumeration id="DOWNLOAD_EXPIRED" value="17"/>
      <xs:enumeration id="DECRYPT_EXPIRED" value="18"/>
      <xs:enumeration id="INVALID_CONTENT" value="19"/>
      <xs:enumeration id="PLAYING" value="20"/>
      <xs:enumeration id="FINALIZING_DOWNLOAD" value="21" />
      <xs:enumeration id="PREPARING_DOWNLOAD" value="22" />
      <xs:enumeration id="UPDATING" value="23" />
      <xs:enumeration id="VERIFYING" value="24" />
      <xs:enumeration id="READY_TO_UPDATE" value="25" />
      <xs:enumeration id="UPDATE_PAUSED" value="26" />
      <xs:enumeration id="DOWNLOAD_QUEUED" value="27" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="Game">
    <xs:attribute name="contentID" type="xs:string" />
    <xs:attribute name="progressValue" type="xs:float" />
    <xs:attribute name="state" type="tns:ContentState" />
    <xs:attribute name="installedVersion" type="xs:string"/>
    <xs:attribute name="availableVersion" type="xs:string"/>
    <xs:attribute name="displayName" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="CoreContentUpdated" event="true" alias="ContentEvent" groups="Events">
    <xs:sequence>
      <xs:element name="Games" type="tns:Game" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="BlockListUpdated" event="true" alias="BlockListUpdatedEvent" groups="Events">
  </xs:complexType>

  <xs:complexType name="OnlineStatusEvent" event="true" groups="Events">
    <xs:attribute name="isOnline" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="PresenceVisibilityEvent" event="true" groups="Events">
    <xs:attribute name="Visible" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="Challenge">
    <xs:attribute name="key" type="xs:string"/>
    <xs:attribute name="version" type="xs:string"/>
    <xs:attribute name="build" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="ChallengeResponse">
    <xs:sequence>
      <xs:element name="ContentId" type="xs:string"/>
      <xs:element name="Title" type="xs:string"/>
      <xs:element name="MultiplayerId" type="xs:string"/>
      <xs:element name="Language" type="xs:string"/>
      <xs:element name="Version" alias="SdkVersion" type="xs:string"/>
    </xs:sequence>
    <xs:attribute name="response" type="xs:string"/>
    <xs:attribute name="key" type="xs:string"/>
    <xs:attribute name="version" alias="ProtocolVersion" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="ChallengeAccepted">
    <xs:attribute name="response" type="xs:string"/>
  </xs:complexType>

  <xs:simpleType name="Facility">
    <xs:restriction base="xs:int">
      <xs:enumeration id="SDK" value="0" />
      <xs:enumeration id="PROFILE" value="1" />
      <xs:enumeration id="PRESENCE" value="2" />
      <xs:enumeration id="FRIENDS" value="3" />
      <xs:enumeration id="COMMERCE" value="4" />
      <xs:enumeration id="RECENTPLAYER" value="5" />
      <xs:enumeration id="IGO" value="6" />
      <xs:enumeration id="MISC" value="7" />
      <xs:enumeration id="LOGIN" value="8" />
      <xs:enumeration id="UTILITY" value="9" />
      <xs:enumeration id="XMPP" value="10" />
      <xs:enumeration id="CHAT" value="11" />
      <xs:enumeration id="IGO_EVENT" value="12" />
      <xs:enumeration id="EALS_EVENTS" value="13" />
      <xs:enumeration id="LOGIN_EVENT" value="14" />
      <xs:enumeration id="INVITE_EVENT" value="15" />
      <xs:enumeration id="PROFILE_EVENT" value="16" />
      <xs:enumeration id="PRESENCE_EVENT" value="17" />
      <xs:enumeration id="FRIENDS_EVENT" value="18" />
      <xs:enumeration id="COMMERCE_EVENT" value="19" />
      <xs:enumeration id="CHAT_EVENT" value="20" />
      <xs:enumeration id="DOWNLOAD_EVENT" value="21" />
      <xs:enumeration id="PERMISSION" value="22" />
      <xs:enumeration id="RESOURCES" value="23" />
      <xs:enumeration id="BLOCKED_USERS" value="24" />
      <xs:enumeration id="BLOCKED_USER_EVENT" value="25" />
      <xs:enumeration id="GET_USERID" value="26" />
      <xs:enumeration id="ONLINE_STATUS_EVENT" value="27" />
      <xs:enumeration id="ACHIEVEMENT" value="28" />
      <xs:enumeration id="ACHIEVEMENT_EVENT" value="29" />
      <xs:enumeration id="BROADCAST_EVENT" value="30" />
      <xs:enumeration id="PROGRESSIVE_INSTALLATION" value="31" />
      <xs:enumeration id="PROGRESSIVE_INSTALLATION_EVENT" value="32" />
      <xs:enumeration id="CONTENT" value="33" />
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="Service">
    <xs:attribute name="Name" type="xs:string"/>
    <xs:attribute name="Facility" type="tns:Facility" />
  </xs:complexType>

  <xs:complexType name="GetConfig" />

  <xs:complexType name="GetConfigResponse">
    <xs:sequence>
      <xs:element name="Services" type="tns:Service" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="SelectStore">
    <xs:attribute name="StoreId" type="xs:unsignedLong"/>
    <xs:attribute name="CatalogId" type="xs:unsignedLong"/>
    <xs:attribute name="EWalletCategoryId" type="xs:unsignedLong"/>
    <xs:attribute name="VirtualCurrency" type="xs:string"/>
    <xs:attribute name="LockboxUrl" type="xs:string"/>
    <xs:attribute name="SuccessUrl" type="xs:string"/>
    <xs:attribute name="FailedUrl" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="Store">
    <xs:sequence>
      <xs:element name="Catalog" type="tns:Catalog" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="Title" type="xs:string" />
    <xs:attribute name="Group" type="xs:string" />
    <xs:attribute name="Status" type="xs:string" />
    <xs:attribute name="DefaultCurrency" type="xs:string" />
    <xs:attribute name="StoreId" type="xs:unsignedLong" />
    <xs:attribute name="IsDemoStore" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="GetStore" >
    <xs:attribute name="UserId" type="xs:unsignedLong" />
    <!-- Optional Parameter if not specified (== 0) The store Id in select store is used.-->
    <xs:attribute name="StoreId" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="GetStoreResponse" >
    <xs:sequence>
      <xs:element name="Store" type="tns:Store" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="GetCatalog" >
    <xs:attribute name="UserId" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name ="Catalog" >
    <xs:sequence>
      <xs:element name="Categories" type="tns:Category" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="Status" type="xs:string" />
    <xs:attribute name="CurrencyType" type="xs:string" />
    <xs:attribute name="Group" type="xs:string" />
    <xs:attribute name="CatalogId" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="GetCatalogResponse">
    <xs:sequence>
      <xs:element name="Catalog" type="tns:Catalog" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="GetWalletBalance" facility="COMMERCE" groups="Commerce">
    <xs:annotation>
      <xs:documentation>Gets the users virtual paid currency wallet balance.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Currency" type="xs:string">
      <xs:annotation>
        <xs:documentation>The three character virtual currency identifier (e.g., _NR).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetWalletBalanceResponse">
    <xs:attribute name="Balance" type="xs:long" />
  </xs:complexType>

  <xs:complexType name="Checkout" facility="COMMERCE" groups="Commerce">
    <xs:annotation>
      <xs:documentation>Do a direct checkout. This will perform a checkout directly, circumventing the IGO screens. This can only be used for Virtual Currency offers, when there is sufficient balance.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Offers" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>An array of offer identifiers. [Currently only one offer is supported]</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Currency" type="xs:string">
      <xs:annotation>
        <xs:documentation>The currency this transaction should be taken place in. (This is an optimization, to reduce query count on the server.)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryCategories">
    <xs:sequence>
      <xs:element name="FilterCategories" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
  </xs:complexType>

  <xs:complexType name="QueryCategoriesResponse">
    <xs:sequence>
      <xs:element name="Categories" type="tns:Category" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="QueryOffers" facility="COMMERCE" groups="Commerce">
    <xs:annotation>
      <xs:documentation>Receives the offers from the specified categories. Queries the individual offers available for this title. Typically used by in-fiction store implementations. If all filter parameters are not specified the products will be requested on the titles Master TitleId. </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="FilterCategories" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="FilterMasterTitleIds" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element name="FilterOffers" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryOffersResponse">
    <xs:sequence>
      <xs:element name="Offers" type="tns:Offer" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="QueryContent" facility="CONTENT" groups="Content">
    <xs:annotation>
      <xs:documentation>Get the content information for the current content state in Origin. In order to know what the state of the content is in Origin you can call OriginQueryContent to get the baseline of the current state of the content.Any subsequent updates to the content will be provided through the ORIGIN_EVENT_CONTENT events.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="MasterTitleId" alias="GameId" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A filter option, to only get updates for content that belongs to a certain gameId. This is usually a list of masterTitleIds, but if you need to specify offerIds, or contentIds, please prefix with 'offerId:', 'contentId:'. (other valid prefixes are: 'masterTitleId:', 'multiplayerId:'). If NULL all content will be returned.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user for whom the content is requested for.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="MultiplayerId" type="xs:string" >
      <xs:annotation>
        <xs:documentation>The optional multiplayer Id to filter the content on. Specifying a multiplayer Id will cause contentType to be replaced by ORIGIN_QUERY_CONTENT_BASE_GAME. Specify NULL if this parameter is not required.</xs:documentation>
      </xs:annotation>
    </xs:attribute>>
    <xs:attribute name="ContentType" type="xs:int" >
      <xs:annotation>
        <xs:documentation>Specify what kind of content you want returned. contentType is a concatenation of the enumContentType enumeration. (ORIGIN_QUERY_CONTENT_DLC | ORIGIN_QUERY_CONTENT_ULC). Specifying 0 is the same as specifying ORIGIN_QUERY_CONTENT_ALL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryContentResponse">
    <xs:sequence>
      <xs:element name="Content" type="tns:Game" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="QueryEntitlements" facility="COMMERCE" groups="Commerce">
    <xs:annotation>
      <xs:documentation>Queries the entitlements for the user. [deprecated use OriginQueryEntitlementsEx]. The list can be filtered by category, offer or item IDs. The different filters are additive and many combinations will return no results. For example, passing an offer-id and catalog-id which are not associated with each other will never enumerate any items.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="FilterCategories" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A list of category names. This parameter is reserved and should be NULL.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="FilterOffers" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>An array of offer identifiers.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="FilterItems" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>An array of item identifiers.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="FilterGroups" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>The group the entitlements belong to (empty string or undefined means all groups).</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Group" type="xs:string">
      <xs:annotation>
        <xs:documentation>The number of groups (0=query all groups).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="includeChildGroups" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>Indicates whether the group hierarchy should be traversed when finding items.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryEntitlementsResponse" event="true" alias="EntitlementEvent" groups="Events">
    <xs:sequence>
      <xs:element name="Entitlements" type="tns:Entitlement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="Category">
    <xs:sequence>
      <xs:element name="Categories" type="tns:Category" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="Offers" type="tns:Offer" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="Type" type="xs:string"/>
    <xs:attribute name="CategoryId" type="xs:string" />
    <xs:attribute name="ParentId" type="xs:string" />
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="Description" type="xs:string" />
    <xs:attribute name="MostPopular" type="xs:int" />
    <xs:attribute name="ImageId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="Entitlement">
    <xs:attribute name="Type" type="xs:string" />
    <xs:attribute name="ItemId" type="xs:string" />
    <xs:attribute name="EntitlementId" type="xs:string" />
    <xs:attribute name="EntitlementTag" type="xs:string" />
    <xs:attribute name="Group" type="xs:string" />
    <xs:attribute name="ResourceId" type="xs:string" />
    <xs:attribute name="UseCount" type="xs:int" />
    <xs:attribute name="Expiration" type="xs:dateTime" />
    <xs:attribute name="GrantDate" type="xs:dateTime" />
  </xs:complexType>

  <xs:complexType name="Offer">
    <xs:sequence>
      <xs:element name="Entitlements" type="tns:Entitlement" minOccurs="1" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="Type" type="xs:string" />
    <xs:attribute name="OfferId" type="xs:string" />
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="Description" type="xs:string" />
    <xs:attribute name="ImageId" type="xs:string" />
    <xs:attribute name="bIsOwned" type="xs:boolean" />
    <xs:attribute name="bHidden" type="xs:boolean" />
    <xs:attribute name="bCanPurchase" type="xs:boolean" />
    <xs:attribute name="PurchaseDate" type="xs:dateTime" />
    <xs:attribute name="DownloadDate" type="xs:dateTime" />
    <xs:attribute name="PlayableDate" type="xs:dateTime" />
    <xs:attribute name="DownloadSize" type="xs:unsignedLong" />
    <xs:attribute name="Currency" type="xs:string" />
    <xs:attribute name="bIsDiscounted" type="xs:boolean" />
    <xs:attribute name="Price" type="xs:double" />
    <xs:attribute name="LocalizedPrice" type="xs:string" />
    <xs:attribute name="OriginalPrice" type="xs:double" />
    <xs:attribute name="LocalizedOriginalPrice" type="xs:string" />
    <xs:attribute name="InventoryCap" type="xs:int" />
    <xs:attribute name="InventorySold" type="xs:int" />
    <xs:attribute name="InventoryAvailable" type="xs:int" />
  </xs:complexType>

  <xs:complexType name="QueryManifest" facility="COMMERCE" groups="Commerce">
    <xs:annotation>
      <xs:documentation>Queries the result of a purchase transaction. Queries what offers were purchased for a particular manifest. The manifest ID is returned by the ORIGIN_EVENT_PURCHASE event</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user for which the manifest is requested.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Manifest" type="xs:string">
      <xs:annotation>
        <xs:documentation>The manifest identifier from the PURCHASE event.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryManifestResponse">
    <xs:sequence>
      <xs:element name="Entitlements" type="tns:Entitlement" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="ConsumeEntitlement" facility="COMMERCE" groups="Commerce">
    <xs:annotation>
      <xs:documentation>Consumes an entitlement. This function will consume uses of an entitlement. If called with a non-consumable entitlement, it will return an error. If called on a consumable entitlement without enough uses, it will also return an error and will NOT consume the remaining uses.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Entitlement" type="tns:Entitlement">
        <xs:annotation>
          <xs:documentation>The entitlement to consume. The updated entitlement will replace the current.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Uses" type="xs:int">
      <xs:annotation>
        <xs:documentation>The number of uses to consume.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bOveruse" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>True if the function should return success, and zero usage count if uses is greater than the available items.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="ConsumeEntitlementResponse">
    <xs:sequence>
      <xs:element name="Entitlement" type="tns:Entitlement" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="SocialLogin">
    <xs:attribute name="Presence" type="tns:Presence"/>
  </xs:complexType>

  <!--Signal the SDK that a purchase is made. -->
  <xs:complexType name="PurchaseCompleted"/>

  <xs:complexType name="GetLockboxUrl">
    <xs:attribute name="ProductId" type="xs:string" />
    <xs:attribute name="CommerceProfile" type="xs:string" />
    <xs:attribute name="ContentId" type="xs:string" />
    <xs:attribute name="Context" type="xs:string" />
    <xs:attribute name="IsSDK" type="xs:boolean" default="true"/>
  </xs:complexType>

  <xs:complexType name="GetLockboxUrlResponse">
    <xs:attribute name="Url" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="Achievement">
    <xs:attribute name="Id" type="xs:string" />
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="Progress" type="xs:int" />
    <xs:attribute name="Total" type="xs:int" />
    <xs:attribute name="Count" type="xs:int" />
    <xs:attribute name="Description" type="xs:string" />
    <xs:attribute name="HowTo" type="xs:string" />
    <xs:attribute name="ImageId" type="xs:string" />
    <xs:attribute name="GrantDate" type="xs:dateTime" />
    <xs:attribute name="Expiration" type="xs:dateTime" />
  </xs:complexType>

  <xs:complexType name="AchievementSet">
    <xs:sequence>
      <xs:element name="Achievement" type="tns:Achievement" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="GameName" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="AchievementSets" event="true" alias="AchievementEvent" groups="Events">
    <xs:sequence>
      <xs:element name="AchievementSet" type="tns:AchievementSet" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="GrantAchievement" facility="ACHIEVEMENT" groups="Achievements">
    <xs:annotation>
      <xs:documentation>Grant an achievement to the user.*</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user who gets the Achievement granted. Use OriginGetDefaultUser().</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="PersonaId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The origin or game persona who gets the Achievement granted. Get the persona from OriginGetProfile for the Origin Persona.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="AchievementId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The id of the achievement.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="AchievementCode" type="xs:string">
      <xs:annotation>
        <xs:documentation>The achievement code to be granted</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Progress" type="xs:int">
      <xs:annotation>
        <xs:documentation>The amount of progress to add onto the achievement (use 1 for regular achievement).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="EventParam">
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="Value" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="Event">
    <xs:sequence>
      <xs:element name="Attributes" type="tns:EventParam" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="EventId" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="PostAchievementEvents" facility="ACHIEVEMENT" groups="Achievements">
    <xs:sequence>
      <xs:element name="Events" type="tns:Event" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="PersonaId" type="xs:unsignedLong"/>
  </xs:complexType>

  <xs:complexType name="Wincode">
    <xs:attribute name="key" type="xs:string" />
    <xs:attribute name="value" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="PostWincodes" facility="ACHIEVEMENT" groups="Achievements">
    <xs:annotation>
      <xs:documentation>post wincodes.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Code" type="tns:Wincode" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>The wincode keys to post.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="AuthCode" type="xs:string">
      <xs:annotation>
        <xs:documentation>An authorization code for identifying the wincode source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user for whom to post the wincodes for. Use OriginGetDefaultUser().</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="PersonaId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The origin or game persona who you post wincodes for. Get the persona from OriginGetProfile for the Origin Persona.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryAchievements" facility="ACHIEVEMENT" groups="Achievements">
    <xs:annotation>
      <xs:documentation>Queries the achievements a user owns. Query the achievements the user owns including from other titles.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="GameId" type="xs:string" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A list of game ids to query the achievements for. If no id is specified the default AchievementSet for the game is returned.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="PersonaId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The origin or game persona for who you want to get the Achievements for. Get the persona from OriginGetProfile for the Origin Persona.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="All" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If true get owned and unowned achievements.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="AcceptInvite" alias="AcceptGameInvite" facility="XMPP" groups="Game">
    <xs:annotation>
      <xs:documentation>Accept a game invite for an invite received through an ORIGIN_EVENT_INVITE_PENDING event. This function allows the game to accept game invites from other users. If an invite is available for the specified user the game will receive an invite event, and ORIGIN_SUCCESS will be returned. If no invite is pending ORIGIN_NOT_FOUND will be returned.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The local user. Use OriginGetDefaultUser.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="OtherId" type="xs:unsignedLong">
      <xs:annotation>
        <xs:documentation>The user that invited you to a game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:complexType name="player">
    <xs:attribute name="eaid" type="xs:string" />
    <xs:attribute name="uid" type="xs:unsignedLong" />
    <xs:attribute name="pid" type="xs:unsignedLong" />
    <xs:attribute name="ts" type="xs:unsignedLong" />
  </xs:complexType>

  <xs:complexType name="game">
    <xs:sequence>
      <xs:element name="p" alias="players" type="tns:player" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="mt" alias="masterTitle" type="xs:string" />
    <xs:attribute name="name" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="rp">
    <xs:sequence>
      <xs:element name="game" alias="games" type="tns:game" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="ver" alias="version" type="xs:int" />
  </xs:complexType>


  <xs:complexType name="SetDownloaderUtilization" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Instruct Origin to increase/reduce download utilization. If the game wants Origin to reduce its use of network bandwidth it can use this. Only utilization 1 and 0 will be guaranteed, while any intermediate value is 'best effort'. Any changes to the utilization will take some time to take effect.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="Utilization" type="xs:float">
      <xs:annotation>
        <xs:documentation>The amount of utilization the game wants Origin to adhere to: Use one of ORIGIN_DOWNLOAD_UTILIZATION_xxxx eg. ORIGIN_DOWNLOAD_UTILIZATION_FULLSPEED.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- Progressive installation data structures. -->

  <xs:complexType name="IsProgressiveInstallationAvailable" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Check whether Progressive Installation is available for this title. If this function returns false the Progressive Installation support in Origin is not available. The game title should expect all the base game data to be installed.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId allows for checking the install status of DLC content. For the main game, pass in NULL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="IsProgressiveInstallationAvailableResponse">
    <xs:attribute name="ItemId" type="xs:string" />
    <xs:attribute name="Available" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="AreChunksInstalled" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Check whether the chunks you are interested in are installed. This function will do a query to check whether all the chunks you are interested in are installed. All the chunks need to be downloaded and installed in order for the result of this function to be true.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ChunkIds" type="xs:int" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>An array of chunk Ids you are interested in. The Ids should range from [1-N], as the 0 chunk is the base chunk which should be installed, otherwise your game will not run.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId allows for checking the install status of DLC content. For the main game, pass in NULL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="AreChunksInstalledResponse">
    <xs:sequence>
      <xs:element name="ChunkIds" type="xs:int" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ItemId" type="xs:string" />
    <xs:attribute name="Installed" type="xs:boolean" />
  </xs:complexType>

  <xs:simpleType name="ChunkState">
    <xs:restriction base="xs:int" >
      <xs:enumeration id="UNKNOWN" value="0"/>
      <xs:enumeration id="PAUSED" value="1"/>
      <xs:enumeration id="QUEUED" value="2"/>
      <xs:enumeration id="ERROR" value="3"/>
      <xs:enumeration id="DOWNLOADING" value="4"/>
      <xs:enumeration id="INSTALLING" value="5"/>
      <xs:enumeration id="INSTALLED" value="6"/>
      <xs:enumeration id="BUSY" value="7"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ChunkType">
    <xs:restriction base="xs:int" >
      <xs:enumeration id="UNKNOWN" value="0"/>
      <xs:enumeration id="REQUIRED" value="1"/>
      <xs:enumeration id="RECOMMENDED" value="2"/>
      <xs:enumeration id="NORMAL" value="3"/>
      <xs:enumeration id="ONDEMAND" value="4"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ChunkStatus" event="true" groups="Events">
    <xs:attribute name="ChunkId" type="xs:int" />
    <xs:attribute name="Name" type="xs:string" />
    <xs:attribute name="ItemId" type="xs:string" />
    <xs:attribute name="Type" type="tns:ChunkType" />
    <xs:attribute name="State" type="tns:ChunkState" />
    <xs:attribute name="Progress" type="xs:float" />
    <xs:attribute name="Size" type="xs:unsignedLong" />
    <xs:attribute name="ChunkETA" type="xs:int" />
    <xs:attribute name="TotalETA" type="xs:int" />
  </xs:complexType>

  <xs:complexType name="QueryChunkStatus" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Get the status of a chunk. This function will do a query to check the status of the chunk.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId allows for checking the status of DLC content. For the main game, pass in NULL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryChunkStatusResponse">
    <xs:sequence>
      <xs:element name="ChunkStatus" type="tns:ChunkStatus" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="IsFileDownloaded" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Checks whether a file is downloaded. This function will check whether a file if downloaded. The file needs to be in one of the chunks belonging to the game. NOTE: This cannot be used to determine whether a file is downloaded before the chunk is installed. It just reports back whether the file is in a completed chunk or not.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId allows for checking the file download status for files in DLC content. For the main game, pass in NULL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Filepath" type="xs:string">
      <xs:annotation>
        <xs:documentation>The file to check. This should be an absolute path.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="IsFileDownloadedResponse">
    <xs:attribute name="ItemId" type="xs:string" />
    <xs:attribute name="Filepath" type="xs:string" />
    <xs:attribute name="Downloaded" type="xs:boolean" />
  </xs:complexType>

  <xs:complexType name="SetChunkPriority" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Override the download order of the chunks.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ChunkIds" type="xs:int" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>An array of chunkIds. The id in the beginning of the array will be downloaded first. Note: Only include ORIGIN_CHUNK_TYPE_ON_DEMAND chunks if you want them to start downloading.*</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId allows for reordering the priority of chunks for DLC content. For the main game, pass in NULL.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetChunkPriority" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Get the download order of the chunks.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId specifies for what offerId you want the chunk priority. Pass in NULL if you asking for the main game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GetChunkPriorityResponse">
    <xs:sequence>
      <xs:element name="ChunkIds" type="xs:int" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="ItemId" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="QueryChunkFiles" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Get all the files in a chunk.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId specifies for what offerId you want the chunk priority. Pass in NULL if you asking for the main game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ChunkId" type="xs:int">
      <xs:annotation>
        <xs:documentation>The chunk Id of the chunk you want information for.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="QueryChunkFilesResponse">
    <xs:sequence>
      <xs:element name="Files" type="xs:string" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="CreateChunk" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Create a new chunk and have it be prioritized over the existing chunks.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Files" type="xs:string" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>An array of files to put in the chunk.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The offerId specifies for what offerId you want the chunk priority. Pass in NULL if you asking for the main game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="CreateChunkResponse">
    <xs:attribute name="ChunkId" type="xs:int" />
  </xs:complexType>

  <xs:complexType name="StartDownload" facility="PROGRESSIVE_INSTALLATION" groups="ProgressiveInstall">
    <xs:annotation>
      <xs:documentation>Instruct Origin to start downloading a DLC package.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="ItemId" type="xs:string">
      <xs:annotation>
        <xs:documentation>The DLC to download.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="RestartOptions">
    <xs:restriction base="xs:int">
      <xs:enumeration id="NORMAL" value="0">
        <xs:annotation>
          <xs:documentation>When the current game terminates relaunch the game and have the default update flow take place.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration id="FORCE_UPDATE_FOR_GAME" value="1">
        <xs:annotation>
          <xs:documentation>When the current game terminates, initiate an update, and relaunch the game.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="RestartGame" facility="CONTENT" groups="Content">
    <xs:annotation>
      <xs:documentation>Restart the game after the current game has terminated.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="UserId" type="xs:unsignedLong" >
      <xs:annotation>
        <xs:documentation>The user for whom the restart is requested for.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Options" type="tns:RestartOptions" >
      <xs:annotation>
        <xs:documentation>Specify how to restart the game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="StartGame" facility="CONTENT" groups="Content">
    <xs:annotation>
      <xs:documentation>Start any basegame.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="GameId" type="xs:string" >
      <xs:annotation>
        <xs:documentation>The gameId identifies the game to start. Use either the masterTitleId, offerId or contentId. Please prefix the gameId with 'offerId:' or 'contentId:', when not using a masterTitleId. The 'masterTitleId:' prefix is optional.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name ="MultiplayerId" type="xs:string">
      <xs:annotation>
        <xs:documentation>An optional parameter to further narrow down what game to start. The multiplayerId is usually set to the MDM item Id of the standard edition of the game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="CommandLine" type="xs:string" >
      <xs:annotation>
        <xs:documentation>The command line arguments to be passed to the game.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="SendGameMessage" facility="SDK" groups="General">
    <xs:annotation>
      <xs:documentation>Broadcast a message to any other Origin connected game. The message will be received by the recipient as an ORIGIN_EVENT_GAME_MESSAGE event. This could potentially be used by games like battlefield to communicate with Sparta.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="GameId" type="xs:string" >
      <xs:annotation>
        <xs:documentation>An unique id that identifies the sender. The masterTitleId or multiplayerId are good Ids to use here. But you could use something like a GUID as well.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="Message" type="xs:string" >
      <xs:annotation>
        <xs:documentation> The message can be any string. However a json blob or XML message is probably the way to go.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="GameMessageEvent" event="true" groups="Events">
    <xs:attribute name="GameId" type="xs:string" />
    <xs:attribute name="Message" type="xs:string" />
  </xs:complexType>
  
  <!--Ignore this -->
  <xs:complexType name="File">
    <xs:attribute name="name" type="xs:string" />
    <xs:attribute name="size" type="xs:unsignedLong" />
  </xs:complexType>
  
  <xs:complexType name="Chunk">
    <xs:sequence>
      <xs:element name="Files" type="tns:File" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" />
    <xs:attribute name="id" type="xs:int" />
    <xs:attribute name="type" type="tns:ChunkType" />
  </xs:complexType>

  <xs:complexType name="Chunks">
    <xs:sequence>
      <xs:element name="Chunk" type="tns:Chunk" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
  </xs:complexType>
  
  <xs:complexType name="PIOffer">
    <xs:sequence>
      <xs:element name="Chunks" type="tns:Chunks"/>
    </xs:sequence>
    <xs:attribute name="offerId" type="xs:string"/>
  </xs:complexType>
  
  <xs:complexType name="PISimulator">
    <xs:sequence>
      <xs:element name="PIOffers" type="tns:PIOffer" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="downloadSpeed" type="xs:int"/>
    <xs:attribute name="downloadUtilization" type="xs:float"/>
  </xs:complexType>

  <xs:complexType name="ExtendTrial">
    <xs:attribute name="UserId" type="xs:unsignedLong"/>
    <xs:attribute name="RequestTicket" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="ExtendTrialResponse">
    <xs:attribute name="Code" type="xs:int"/>
    <xs:attribute name="TotalTimeRemaining" type="xs:int"/>
    <xs:attribute name="TimeGranted" type="xs:int"/>
    <xs:attribute name="ResponseTicket" type="xs:string"/>
    <xs:attribute name="RetryCount" type="xs:int" default="5"/>
    <xs:attribute name="RetryAfterFailSec" type="xs:int" default="10"/>
    <xs:attribute name="ExtendBeforeExpireSec" type="xs:int" default="60"/>
    <xs:attribute name="SleepBeforeNukeSec" type="xs:int" default="20"/>
  </xs:complexType>
  
</xs:schema>
