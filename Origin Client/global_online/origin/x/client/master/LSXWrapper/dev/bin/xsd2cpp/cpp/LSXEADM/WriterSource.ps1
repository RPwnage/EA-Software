$SchemaFilename = $Generator.NamespaceToFilename($Schema.Namespace).Replace('/','.')
#The first object in the script is the file it will be saved into.
$SchemaFilename + "Writer.cpp"

"#include """ + $SchemaFilename +"Writer.h"""

"
// Generated By: XSD2CPP V2.0
// Author: Hans van Veenendaal
//
// !!!! This file is automatically generated please do not modify !!!!

#include ""WriterCommon.h"""
foreach($i in $Schema.ImportedSchemas)
{
	$filename = $Generator.NamespaceToFilename($i.Namespace)
	if($filename -ne "Serialization")
	{
		"#include """ + $filename + "Writer.h"""
	}
}
""
foreach($i in $Schema.ImportedSchemas)
{
	$filename = $Generator.NamespaceToFilename($i.Namespace)
	if($filename -ne "Serialization")
	{
		"using namespace " + $filename.Replace(".", "::") + ";"
	}
}
""

#Write out the namespace
$NamespaceParts = $SchemaFilename.Split('.')
foreach($i in $NamespaceParts)
{
	"namespace " + $i
	"{"
}

foreach($i in $Schema.ComplexTypes)
{
	"bool Write(INodeDocument * doc, const char * name, " + $Generator.ConvertType($i) + " &data);"
}

""
foreach($i in $Schema.ComplexTypes)
{
	"bool WriteClass(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data);"
}
""

foreach($i in $Schema.SimpleTypes)
{
	if($i.Enumerations.Count -ne 0)
	{
		if($i.EnumValuesSet)
		{
			"void WriteAttribute(INodeDocument * doc, const char *name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	int index = " + $i.Name + "_EnumToIndexMap[data];"
			"	if(index<0 || index>=" + $i.Enumerations.Count + ")index = (" + $Generator.ConvertType($i) + ")0;"
			"	WriteEnumValueAttribute(doc, name, " + $i.Name + "Strings, index);"
			"}"
			""
			"void Write(INodeDocument * doc, const char *name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	int index = " + $i.Name + "_EnumToIndexMap[data];"
			"	if(index<0 || index>=" + $i.Enumerations.Count + ")index = (" + $Generator.ConvertType($i) + ")0;"
			"	WriteEnumValue(doc, name, " + $i.Name + "Strings, index);"
			"}"
			""
		}
		else
		{
			"void WriteAttribute(INodeDocument * doc, const char *name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	if(data<0 || data>=" + $i.Enumerations.Count + ")data = (" + $Generator.ConvertType($i) + ")0;"
			"	WriteEnumValueAttribute(doc, name, " + $i.Name + "Strings, (int)data);"
			"}"
			""
			"void Write(INodeDocument * doc, const char *name, " + $Generator.ConvertType($i) + " &data)"
			"{"
			"	if(data<0 || data>=" + $i.Enumerations.Count + ")data = (" + $Generator.ConvertType($i) + ")0;"
			"	WriteEnumValue(doc, name, " + $i.Name + "Strings, (int)data);"
			"}"
			""
		}
	}
}



foreach($i in $Schema.ComplexTypes)
{
	if($i.IsArrayContainer)
	{
		"bool Write(INodeDocument * doc, const char *name, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	if(!doc->AddArray(name))"
		"		doc->AddChild(name);"
		"	bool ret = WriteClass(doc, data);"
		"	if(!doc->LeaveArray())"
		"		doc->Parent();"
		"	return ret;"
		"}"
		
		"bool WriteClass(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	for(unsigned int i=0; i<data.size(); ++i)"
		"	{"
		"		" + $Generator.GetWriter($i.Elements[0]) + "(doc, data[i]);"
		"	}"
		"	return true;"
		"}"
	}
	else
	{
		"bool Write(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	doc->AddChild(""" + $i.SourceName + """);"
		"	bool ret = WriteClass(doc, data);"
		"	doc->Parent();"
		"	return ret;"
		"}"
		""
		"bool Write(INodeDocument * doc, const char *name, " + $Generator.ConvertType($i) + " &data)"
		"{"
		"	doc->AddChild(name);"
		"	bool ret = WriteClass(doc, data);"
		"	doc->Parent();"
		"	return ret;"
		"}"

		"bool WriteClass(INodeDocument * doc, " + $Generator.ConvertType($i) + " &data)"
		"{"
			if($i.BaseType -ne $null)
			{
			"	WriteClass(doc, *(" + $i.BaseType.Name + " *)&data);"	
			""
			}

			foreach($a in $i.Attributes)
			{
			"	" + $Generator.GetWriter($a) + "(doc, """ + $a.SourceName + """, data." + $a.Name + ");"
			}

			foreach($e in $i.Elements)
			{
				if($e.IsArray)
				{
					"	doc->AddArray(""" + $e.Name + """);"
					if($e.TypeCT -ne $null)
					{
					"	for(unsigned int i=0; i<data." + $e.Name + ".size(); ++i)"
					"	{"
					"		" + $Generator.GetWriter($e) + "(doc, """ + $e.Typename + """, data." + $e.Name + "[i]);"
					"	}"
					}
					else
					{
					"	for(unsigned int i=0; i<data." + $e.Name + ".size(); ++i)"
					"	{"
					"		" + $Generator.GetWriter($e) + "(doc, """ + $e.Name + """, data." + $e.Name + "[i]);"
					"	}"
					}
					"	doc->LeaveArray();"
				}
				else
				{
					"	" + $Generator.GetWriter($e) + "(doc, """ + $e.SourceName + """, data." + $e.Name + ");"
				}
			}
		"	return true;"
		"}"
		""
	}
}

[array]::Reverse($NamespaceParts)
foreach($i in $NamespaceParts)
{
	"} // namespace " + $i
}
