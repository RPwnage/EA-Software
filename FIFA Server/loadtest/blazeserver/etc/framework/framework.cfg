//
// This file contains all configuration for the Blaze framework

framework = {

    // ====================================================
    // configure version
    // ====================================================
    #include "framework/configversion.cfg"

    // ====================================================
    // Per-IP Rate Limit settings
    // ====================================================
    #include "framework/trafficlimits.cfg"

    // ====================================================
    // Endpoint settings
    // ====================================================
    #include "framework/endpoints.cfg"

    // ====================================================
    // Wal cache settings
    // ====================================================
    #include "framework/cache.cfg"

    // ====================================================
    // Database connection settings
    // ====================================================
    #include "framework/databases.cfg"

    // ====================================================
    // Metrics settings
    // ====================================================
    #ifdef USING_BITC
      #include "framework/metrics_bitc.cfg"
    #else
      #include "framework/metrics.cfg"
    #endif

    //Disable exception handling for dev/test to ensure exceptions are noticed during development
    exceptionConfig = {
      #ifdef CORE_FILE_PREFIX
        coreFilePrefix = "#CORE_FILE_PREFIX#"
      #else
        coreFilePrefix = "core"
      #endif

    #if (ENV == "dev" || ENV == "test")
        exceptionHandlingEnabled = false
    #endif

    #if SANITIZER =="1"
        #define REQUEST_TIMEOUT "360s"
    #else
        #define REQUEST_TIMEOUT "10s"
    #endif

    // exceptionCallstackWhitelist. In special circumstances, we may wish to temporarily ignore coring or counting towards thresholds for certain exceptions.
    // For any exception whose callstack hash is in the below list, Blaze disables core dumping and counting its occurrences against the
    // totalFiberExceptionsAllowed and delayPerFiberException thresholds. To get an exception's callstack hash, find the callstack hash value
    // written to the server log when the exception was previously handled. Add it to this list and reload framework to apply the change. E.g.
    //#if (ENV == "prod")
    //    exceptionCallstackWhitelist = [1234]
    //#endif
    }



    // ====================================================
    // Debug settings
    // ====================================================
    #include "framework/debugsettings.cfg"

    // ====================================================
    // Profanity filter settings
    // ====================================================
    profanityConfig = {
        useProfanityService = #ENABLE_PROFANITY_SERVICE#
        profanityServiceFilterId = "#PROFANITY_SERVICE_FILTER_ID#"
        profanityServiceRetryLimit = 2      // The maximum number of retries for a Profanity Service RPC before giving up. Total number of tries is (1 + retryLimit). Depending on the failure, the RPC may not be retried at all.
        profanityServiceRetryDelay = 1000   // The number of milliseconds of delay of first retry. The delay of following retries will increase exponentially.

        // Old Profanity Filter (ignored if useProfanityService is enabled):
        profanityFilter == PROFANITY_EOF
        #include_verbatim "framework/filt-text.txt"
        PROFANITY_EOF
    }

    locStringMaxLength = 4096;

    localization == LOCALIZATION_EOF
    #include_verbatim "framework/localize.csv"
    LOCALIZATION_EOF

    httpXmlConfig = {
        // valid options are:
        //     IDENTIFIER - use enum identifiers
        //     VALUE      - use enum constant value
        enumOption = "IDENTIFIER"

        // valid options are:
        //     ELEMENTS   - use only elements
        //     ATTRIBUTES - use attributes when possible
        xmlOutputOption = "ELEMENTS"

        // valid options are:
        //     EMPTY      - default behavior (HTTP response without valid xml)
        //     XML - Return xml response
        voidRpcOption = "EMPTY"

        // Should XML output use compression
        useCompression = true

        // Should event notifications use compression.
        // Notifications will be compressed only if useCompression is also true and
        // the event subscribe RPC is sent with header 'Accept-Encoding: gzip'.
        compressEventNotifications = false

        // The compression level must be -1 for default, or between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives no compression at all
        compressionLevel = -1
    }

    restConfig = {
        // Should response payload use compression
        useCompression = false

        // The compression level must be -1 for default, or between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives no compression at all
        compressionLevel = -1
    }


    // ====================================================
    // redirector settings
    // ====================================================
    #include "framework/redirectorsettings.cfg"

    // The SandboxId is sent to the Redirector where it is used to trigger a warning message if a user attempts to login with a misconfigured sandbox id.
    // This is designed to avoid certification issues, where a tester may have their local kit setup incorrectly, and will be unable to play online.
    // It is also used by the authentication2 component when fetching an XBL token and for verifying that the user is logging in with the correct sandboxId
    sandboxId = "#SANDBOXID#"

    // ====================================================
    // http services
    // ====================================================
    httpServiceConfig = {
	
        httpServices = {
            // Identity 2.0
            nucleusidentity = {
                url="#NUCLEUS2PROXYHOST#",
                numPooledConnections=512,
                requestTimeout="#REQUEST_TIMEOUT#",
                encodingType="application/JSON",
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                logErrForHttpCodes = ["400-499"],
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                sslKey = "#NUCLEUSSSLKEY#"
            },
            nucleusconnect = {
                url="#NUCLEUS2CONNECTHOST#",
                numPooledConnections=512,
                requestTimeout="#REQUEST_TIMEOUT#",
                encodingType="application/JSON",
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                logErrForHttpCodes = ["400-499"],
                sslCert = "#NUCLEUSSSLCERT#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                sslKey = "#NUCLEUSSSLKEY#"
            },
            nucleusconnect_ext = {
                // This configured 'nucleusconnect_ext' service is specifically needed in order to call the /connect/token API with
                // grant_type=password using the 'test_token_issuer' clientId, which is the only clientId that is allowed to get an
                // access token using a password.  Unfortunately, we can't use the existing 'nucleusconnect' service that's already
                // configured because it connects with a client cert that overrides any provided clientId.
                url="#NUCLEUS2CONNECTHOSTEXT#",
                numPooledConnections=8,
                hasProxyComponent=false,
                logErrForHttpCodes = ["400-499"]
            },
            notify = {
                url="#NOTIFYHOST#",
                numPooledConnections=512,
                encodingType="application/JSON",
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                sslKey = "#NUCLEUSSSLKEY#"
            },
            riverposter = {
                hasProxyComponent=false,
                url = "#RIVERHOST#",
                numPooledConnections=#PIN_RIVER_CONNECTION_MAX#
            },
            xblserviceconfigs = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://sessiondirectory.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=256,
                requestTimeout="#REQUEST_TIMEOUT#",
                encodingType="application/JSON",
                maxHttpCacheMemorySizeinBytes = 0
            },
            xblreputationconfigs = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://userstats.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=32,
                encodingType="application/JSON",
                maxHttpCacheMemorySizeinBytes = 0
            },
            xblprivacyconfigs = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://privacy.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=32,
                encodingType="application/JSON",
                maxHttpCacheMemorySizeinBytes = 0
            },
            xblsocial = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://social.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=32,
                encodingType="application/JSON",
                maxHttpCacheMemorySizeinBytes = 0
            },
            xblprofile = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://profile.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=32,
                encodingType="application/JSON",
                maxHttpCacheMemorySizeinBytes = 0
            },
            xblclientsessiondirectory = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://client-sessiondirectory.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=256,
                requestTimeout="#REQUEST_TIMEOUT#",
                encodingType="application/JSON",
               #ifdef SANDBOXID
                vaultPath = { path="#VAULT_PATH_SSL_XBL#" },
               #endif
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                maxHttpCacheMemorySizeinBytes = 0,
                sslKeyPasswdObfuscator="BlazeRocks",
#if (SANDBOXID == "EARW.1")
                sslCert = "ssl/xbl/EA_XBL_EARW.1_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_EARW.1_key.pem"
#elif (SANDBOXID == "EARW.2")
                sslCert = "ssl/xbl/EA_XBL_EARW.2_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_EARW.2_key.pem"
#elif (SANDBOXID == "EARW.3")
                sslCert = "ssl/xbl/EA_XBL_EARW.3_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_EARW.3_key.pem"
#elif (SANDBOXID == "EARW.99")
                sslCert = "ssl/xbl/EA_XBL_EARW.99_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_EARW.99_key.pem"
#elif (SANDBOXID == "CERT")
                sslCert = "ssl/xbl/EA_XBL_CERT_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_CERT_key.pem"
#elif (SANDBOXID == "CERT.DEBUG")
                sslCert = "ssl/xbl/EA_XBL_CERT.DEBUG_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_CERT.DEBUG_key.pem"
#elif (SANDBOXID == "RETAIL")
                sslCert = "ssl/xbl/EA_XBL_RETAIL_client.pem",
                sslKeyPasswd = "JoGlElIjNpLoPlDlFp",
                sslKey = "ssl/xbl/EA_XBL_RETAIL_key.pem"
#endif
            },
            xbltournamentshub = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_XONE
                url="https://tournamentshub.xboxlive.com",
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_XONE#",
#endif
                numPooledConnections=32,
                encodingType="application/JSON",
                maxHttpCacheMemorySizeinBytes = 0
            },
            psnbaseurl = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_PS4
  #if (ENV == "prod")
                url="https://asm.np.community.playstation.net",
  #elif (ENV == "cert")
                url="https://asm.prod-qa.community.playstation.net",
  #else
                url="https://asm.sp-int.community.playstation.net",
  #endif
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_PS4#",
#endif
                numPooledConnections=256,
                encodingType="application/JSON"
            },
            psnsessioninvitation = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_PS4
                url="sentinel_not_used", // actual url is fetched at runtime from the PSN BaseUrl service
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_PS4#",
#endif
                numPooledConnections=256,
                encodingType="application/JSON" // may be overridden at runtime depending on the PSN call
            },
            psnmatches = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_PS5
  #if (ENV == "prod")
                url="https://s2s.np.playstation.net/api/matches",
  #elif (ENV == "cert")
                url="https://s2s.prod-qa.playstation.net/api/matches",
  #else
                url="https://s2s.sp-lt.playstation.net/api/matches",
  #endif
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_PS5#",
#endif
                numPooledConnections=256,
                encodingType="application/JSON"
            },
            psnsessionmanager = {
#ifndef MOCK_EXTERNAL_SERVICE_URL_PS5
  #if (ENV == "prod")
                url="https://s2s.np.playstation.net/api/sessionManager",
  #elif (ENV == "cert")
                url="https://s2s.prod-qa.playstation.net/api/sessionManager",
  #else
                url="https://s2s.sp-lt.playstation.net/api/sessionManager",
  #endif
#else
                url="#MOCK_EXTERNAL_SERVICE_URL_PS5#",
#endif
                numPooledConnections=256,
                encodingType="application/JSON"
            },
            // Achievements services
            UntrustedAchievementConn = {
                url="#ACHIEVE_HOST#",
                numPooledConnections=32,
                hasProxyComponent=false
            },
            TrustedAchievementConn = {
                url="#TRUSTED_ACHIEVE_HOST#",
                numPooledConnections=32,
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#",
                sslKey = "#NUCLEUSSSLKEY#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                hasProxyComponent=false
            },
            TosConnMgr = {
                url="#TOSHOST#",
                vaultPath = { path="#VAULT_PATH_SSL_TOS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#TOSSSLCERT#",
                sslKey = "#TOSSSLKEY#",
                sslKeyPasswd = "#TOSSSLKEYPASSWD#",
                numPooledConnections=16,
                hasProxyComponent=false
            },
			// ContentReporter service
            BifrostConnMgr = {
                url="#BIFROST_HOST#",
                sslCert = "#NUCLEUSSSLCERT#",
                sslKey = "#NUCLEUSSSLKEY#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                numPooledConnections=4,
                hasProxyComponent=false
            },
            // Connection Concierge service
            ccs = {
                url="#CCSHOST#",
                numPooledConnections=1024,
                encodingType="application/JSON",
                requestTimeout="20s",
                // Blaze server shares the authentication info for CCS and Nucleus.
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                sslKey = "#NUCLEUSSSLKEY#"
            },
            // Recommendation Service
            recommendation = {
                url = "#RECO_SERVER_HOST#",
                numPooledConnections=1024,
                encodingType="application/JSON"
            },
#if (PLATFORM == "pc")
 	    // Shield Service
	    shield = {
			url = "#SHIELD_BACKEND_URL#",
            numPooledConnections=32,
           	encodingType="application/x-www-form-urlencoded"
	    },
#endif
 	    // EA Access Service
	    eaaccess = {
			#if (ENV == "dev" || ENV == "test" || ENV == "cert")
				url = "gateway.lt.internal.ea.com",
			#elif ENV == "prod"
				url = "gateway.internal.ea.com",
			#endif	
				
            // This is the total maximum size of the connection pool for all calls to the xmshd service; choose a value you feel is appropriate
            numPooledConnections=512,
			encodingType="application/JSON"
	    },
	    // XMS HD Service
            xmshd = {
                #if (ENV == "dev" || ENV == "test" || ENV == "cert")
                    // Blaze determines whether the connection is secure or not based on whether the url begins with http:// or https://
                    url = "https://fifa.test.api.easports.com:443"  ,
                 #elif ENV == "prod"
                    url = "https://fifa.api.easports.com:443",
                 #endif

                // This is the total maximum size of the connection pool for all calls to the xmshd service; choose a value you feel is appropriate
                numPooledConnections=1024,
				encodingType="application/JSON",

                #if (ENV == "dev" || ENV == "test" || ENV == "cert")
                // If you don't need to use ssl certs, simply omit sslCert and sslKey
                  sslCert = "ssl/xmshd/fifa.test.api.easports.com.pem",
                  sslKey = "ssl/xmshd/fifa.test.api.easports.com.pem"
                #elif ENV == "prod"
                  sslCert = "ssl/xmshd/fifa.api.clt.pem",
                  sslKey = "ssl/xmshd/fifa.api.clt.pem"
                #endif
            },	    
            // FifaGroup Service
            fifagroups = {
#if (ENV == "dev" || ENV == "test" || ENV == "cert")
                url = "https://groups-e2e.tntdev.tnt-ea.com:443",
                sslCert = "ssl/fifagroups/fifa19.client.prod.eadp.ea.com.pem",
                sslKey = "ssl/fifagroups/fifa19.client.prod.eadp.ea.com.pem",
                sslKeyPasswd = "1amQ3P9w/EynKY3e",
#elif ENV == "prod"
                url = "https://groups.gameservices.ea.com:10091",
                sslCert = "ssl/fifagroups/fifa19.client.prod.eadp.ea.com.pem",
                sslKey = "ssl/fifagroups/fifa19.client.prod.eadp.ea.com.pem",
                sslKeyPasswd = "1amQ3P9w/EynKY3e",
#endif
                numPooledConnections=512,
                encodingType="application/JSON"
            },
            // FifaStats Service
            fifastats = {
#if (ENV == "dev" || ENV == "test" || ENV == "cert")
                url = "https://internal.fifa.stats.e2etest.gameservices.ea.com:11002",
#elif ENV == "prod"
                url = "https://internal.fifa.stats.gameservices.ea.com:11002",				
#endif
                sslCert = "#NUCLEUSSSLCERT#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                sslKey = "#NUCLEUSSSLKEY#",
                numPooledConnections=512,
                encodingType="application/JSON"
            }
            "friends" = {
                url = "#SOCIAL_FRIENDS_HOST#"
                numPooledConnections = 64
                encodingType = "application/JSON"
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#"
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#"
                sslKey = "#NUCLEUSSSLKEY#"
                hasProxyComponent = false
                registerOnlyForLocalComponents = ["gamemanager"]
            }

            "friendRecommendations" = {
                url = "#SOCIAL_FRIENDS_RECOMMENDATION_HOST#"
                numPooledConnections = 64
                encodingType = "application/JSON"
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#"
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#"
                sslKey = "#NUCLEUSSSLKEY#"
                hasProxyComponent = false
                registerOnlyForLocalComponents = ["gamemanager"]
            }

            "groups" = {
                url = "#SOCIAL_GROUPS_HOST#"
                numPooledConnections = 256
                encodingType = "application/JSON"
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#"
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#"
                sslKey = "#NUCLEUSSSLKEY#"
                hasProxyComponent = false
                registerOnlyForLocalComponents = ["gamemanager"]
            }

            ssas = {
                url = "#FIFA_SSF_URL#",
                numPooledConnections=1024,
                encodingType="application/JSON",
                sslCert = "#NUCLEUSSSLCERT#"
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#"
                sslKey = "#NUCLEUSSSLKEY#"
                hasProxyComponent = false
                registerOnlyForLocalComponents = ["volta"]
            }

            preferencecenter = {
                url="#NUCLEUS2PROXYHOST#",
                numPooledConnections=32,
                encodingType="application/JSON",
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#",
                sslKeyPasswd = "#NUCLEUSSSLKEYPASSWD#",
                sslKey = "#NUCLEUSSSLKEY#"
            }
        }
    }

    outboundGrpcServiceConfig = {
        outboundGrpcServices = {
            messagebus = {
                serviceAddress = "#MESSAGEBUSHOST#"
            }
            qoscoordinator = {
                serviceAddress = "#QOSCOORDINATORHOST_INTERNAL#"
                requestTimeout="#REQUEST_TIMEOUT#",
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#"
                sslKey = "#NUCLEUSSSLDECRYPTKEY#"
            }
            statsService = {
                serviceAddress = "#STATSSERVICEHOST#"
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#"
                sslKey = "#NUCLEUSSSLDECRYPTKEY#"
            }
            profanity = {
                serviceAddress = "#PROFANITYHOST#"
                // Match the timeout to the one set on the client for Util::filterForProfanity. The server and client timeout are independent architecturally but we try to get them in
                // the same ballpark (by default).
                requestTimeout = "5s" 
                vaultPath = { path="#VAULT_PATH_SSL_NUCLEUS#" },
                pathType = "#SSL_CLIENT_PATH_TYPE#"
                sslCert = "#NUCLEUSSSLCERT#"
                sslKey = "#NUCLEUSSSLDECRYPTKEY#"
            }
        }
    }

    // ====================================================
    // outbound metrics config
    // ====================================================
    outboundMetricsConfig = {
        outboundMetrics = {
            HTTP = {
                bucketCount = #COMMAND_TIMEOUT_NUM#,
                bucketSize = "1s",
                resources = [
                   {
                      pattern="^#NUCLEUS2PROXYHOST#.*",
                      threshold="2s"
                   }
                ]
            }
        }
    }

    fibers = {
#if (ENV == "dev")
        // Linux stack protection adds 2x PAGE_SIZE (can be 4Mb) for every Blaze::Fiber.
        // There can easily be 1,000s of fibers in each instance, and there are many instance per machine in PROD.
        // We do not enable this in TEST by default due to stress testing.  But otherwise, it is often not a problem to enable this in TEST.
        //
        // DO NOT ENABLE THIS SETTING in PROD or you will likely run out of memory!!!
        forceStackMemoryProtection = true;
#endif
    }

    instanceInfoPublishingConfig = {
        redisRefreshInterval = "10s"
        redisTTL = "20s"
        maxRedisRefreshFailures = 0
    }
}
