/*! ************************************************************************************************/
/*!
    \file reputationserviceutilfactory.cpp


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

#include "framework/blaze.h"
#include "framework/controller/controller.h"
#include "framework/usersessions/reputationserviceutilfactory.h"
#include "framework/usersessions/reputationserviceutil.h"
#include "framework/usersessions/externalreputationserviceutilxboxone.h"



// In order to avoid duplicate symbols the lex and yacc files for stats use the prefix option
// to rename some symbols starting with "yy" to "reputation".  Thus we also must redefine yyFlexLexer to
// reputationFlexLexer here to match.
#undef yyFlexLexer
#define yyFlexLexer reputationFlexLexer
#include "FlexLexer.h"
#include "framework/util/blazelexer.h"

// Forward declaration of main parse method generated by yacc
int blazeparse (BlazeLexer* blaze_flex_lexer);


namespace Blaze
{
    namespace ReputationService
    {
        ReputationServiceFactory::~ReputationServiceFactory()
        {
            destroyReputationServiceUtil();
            destroyReputationExpression();
        }

        bool ReputationServiceFactory::createReputationServiceUtil()
        {
            if (!gController->validateConfiguredMockServices(gUserSessionManager->getConfig().getReputation().getUseMock()))
                return false;

            if (gController->isPlatformHosted(xone) && gUserSessionManager->getConfig().getReputation().getUseExternalReputation())
            {
                mRealServiceCreated = true;
                mReputationServiceUtil = BLAZE_NEW ExternalReputationServiceUtilXboxOne();
                return true;
            }
            mReputationServiceUtil = BLAZE_NEW ReputationServiceUtil();

            return true;
        }

        
        /*! ***********************************************************************/
        /*! \brief resolves the reputation type for the reputation expression

            \param[in] nameSpace - not used
            \param[in] name - not used
            \param[in] context - no context
            \param[out] type - the type of the reputation in the expression
        ***************************************************************************/
        void ReputationServiceFactory::resolveReputationType(const char8_t* nameSpace, const char8_t* name, void* context, Blaze::ExpressionValueType& type)
        {
            // always an int
            type = Blaze::EXPRESSION_TYPE_INT;
        }

        bool ReputationServiceFactory::createReputationExpression()
        {
           
            // Setup and call lex and yacc to parse the derived formula into a hierarchy of expressions
            BlazeLexer::LexResolveTypeCb cb(&ReputationServiceFactory::resolveReputationType);

            BlazeLexer lexer(gUserSessionManager->getConfig().getReputation().getPoorReputationCheckExpression(), nullptr, cb);
            blazeparse(&lexer);

            // Pull the resulting expression back out of the lexer object (though the expression objects
            // are generated by yacc, the lexer is an object that we own here so it also serves as a
            // general purpose data passing mechanism)
            Blaze::Expression* expression = lexer.getExpression();
            if (expression == nullptr)
            {
                BLAZE_WARN_LOG(Log::USER, "[ReputationServiceFactory].createReputationExpression(): encountered a grammatical error while parsing reputation expression.");
                return false;
            }
            else if (expression->getErrorCount() > 0)
            {
                BLAZE_WARN_LOG(Log::USER, "[ReputationServiceFactory].createReputationExpression(): encountered  encountered (" << expression->getErrorCount() << ") errors while parsing reputation expression.");
                delete expression;
                return false;
            }

            if (mReputationExpression != nullptr)
            {
                // destroy the old one because we must be re-configuring
                // wait until this point because we don't want to wipe the old until we know the new one is valid
                delete mReputationExpression;
            }

            mReputationExpression = expression;
            return true;
        }

        void ReputationServiceFactory::destroyReputationExpression()
        {
            if (mReputationExpression != nullptr)
            {
                delete mReputationExpression;
                mReputationExpression = nullptr;
            }
        }

        void ReputationServiceFactory::destroyReputationServiceUtil()
        {
            mReputationServiceUtil = nullptr;
            mRealServiceCreated = false;
        }
    }
}
