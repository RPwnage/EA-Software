/*! ************************************************************************************************/
/*!
    \file   groupuedexpressionlist.cpp


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

#include "framework/blaze.h"

#include "gamemanager/matchmaker/groupuedexpressionlist.h"

// In order to avoid duplicate symbols the lex and yacc files for stats use the prefix option
// to rename some symbols starting with "yy" to "groupUedExpression".  Thus we also must redefine yyFlexLexer to
// groupUedExpressionFlexLexer here to match.
#undef yyFlexLexer
#define yyFlexLexer groupUedExpressionFlexLexer
#include "FlexLexer.h"
#include "framework/util/blazelexer.h"

// Forward declaration of main parse method generated by yacc
int blazeparse (BlazeLexer* blaze_flex_lexer);


namespace Blaze
{
namespace GameManager
{
namespace Matchmaker
{
    GroupUedExpressionList::GroupUedExpressionList()
    {

    }

   GroupUedExpressionList::~GroupUedExpressionList()
   {
       while (!mGroupUedExpressions.empty())
       {
           Expression *expression = mGroupUedExpressions.back();
           mGroupUedExpressions.pop_back();
           delete expression;
       }
   }

    bool GroupUedExpressionList::initialize(const GroupAdjustmentFormulaList &adjustmentFormulas)
    {
        bool success = true;
        // Setup and call lex and yacc to parse the derived formula into a hierarchy of expressions
        BlazeLexer::LexResolveTypeCb cb(&GroupUedExpressionList::resolveGroupUedExpressionType);

        ExpressionList parsedExpressionList;
        parsedExpressionList.reserve(adjustmentFormulas.size());
        for (size_t i = 0; i < adjustmentFormulas.size(); ++i)
        {
            BlazeLexer lexer(adjustmentFormulas[i], nullptr, cb);
            blazeparse(&lexer);

            // Pull the resulting expression back out of the lexer object (though the expression objects
            // are generated by yacc, the lexer is an object that we own here so it also serves as a
            // general purpose data passing mechanism)
            Blaze::Expression* expression = lexer.getExpression();
            if (expression == nullptr)
            {
                ERR_LOG("[GroupUedExpressionList].initialize(): encountered a grammatical error while parsing UED expression at index <<" << i << ".");
                success = false;
                break;
            }
            else if (expression->getErrorCount() > 0)
            {
                ERR_LOG("[GroupUedExpressionList].initialize(): encountered  encountered (" << expression->getErrorCount() << ") errors while parsing UED expression at index <<" << i << ".");
                delete expression;
                success = false;
                break;
            }

            parsedExpressionList.push_back(expression);
        }

         
        if (success)
        {
            // destroy the old ones because we must be re-configuring
            // wait until this point because we don't want to wipe the old until we know the new ones are valid
            while(!mGroupUedExpressions.empty())
            {
                Expression* temp = mGroupUedExpressions.back();
                mGroupUedExpressions.pop_back();
                delete temp;
            }

            mGroupUedExpressions.assign(parsedExpressionList.begin(), parsedExpressionList.end());
        }


        return success;
    }

    void GroupUedExpressionList::resolveGroupUedExpressionType(const char8_t* nameSpace, const char8_t* name, void* context, Blaze::ExpressionValueType& type)
    {
        // always an int
        type = Blaze::EXPRESSION_TYPE_INT;
    }

    void GroupUedExpressionList::resolveGroupUedVariable(const char8_t* nameSpace, const char8_t* name, Blaze::ExpressionValueType type, const void* context, Blaze::Expression::ExpressionVariableVal& val)
    {
        const ResolveGroupUedInfo* info = static_cast<const ResolveGroupUedInfo*>(context);
        *(info->success) = false;

        // need this init to avoid a memory checking tool error; the value will be irrelevant if the resolve is not successful
        val.intVal = 0;
        if (type == Blaze::EXPRESSION_TYPE_INT)
        {
            if (blaze_strcmp(name, GROUP_SIZE_VARIABLE_IDENTIFIER) == 0)
            {
                // this is the group size
                val.intVal = *(info->groupSize);
            }
            else
            {
                // we replace any other variable with the ued value.
                val.intVal = *(info->uedValue);
            }
            *(info->success) = true;
            return;
        }

        BLAZE_ERR_LOG(Log::USER, "[GroupUedExpressionList].resolveGroupUedVariable: resolve failed expression type wasn't an int.");
    }

    UserExtendedDataValue GroupUedExpressionList::calculateAdjustedUedValue(UserExtendedDataValue rawUedValue, uint16_t groupSize) const
    {
        // if there aren't any expressions, shortcut the processing
        if (mGroupUedExpressions.empty())
        {
            SPAM_LOG("[GroupUedExpressionList].calculateAdjustedUedValue: mGroupUedExpressions was empty, returning rawUedValue.");
            return rawUedValue;
        }

        if (groupSize < 1)
        {
            WARN_LOG("[GroupUedExpressionList].calculateAdjustedUedValue: groupSize was '" << groupSize << "', cannot process group sizes < 1, returning rawUedValue.");
            return rawUedValue;
        }

        // now evaluate the reputation
        bool resolveSuccess;
        ResolveGroupUedInfo info;
        info.uedValue = &rawUedValue; 
        info.groupSize = &groupSize;
        info.success = &resolveSuccess;

        // Comments in EntryCriteriaEvaluator indicate load testing showed that constructing this functor was a time sink
        // and declared static. Followed this pattern as the reputation resolve will have a similar call rate.
        static Expression::ResolveVariableCb resolveGroupUedVariableCb(&GroupUedExpressionList::resolveGroupUedVariable);

        uint16_t groupExpressionCount = mGroupUedExpressions.size();
        const Expression* groupUedExpression;
        if (groupSize <= groupExpressionCount)
        {
            groupUedExpression = mGroupUedExpressions[groupSize - 1];
        }
        else
        {
            // groupSize was larger than the expression count
            groupUedExpression = mGroupUedExpressions.back();
        }

        // shouldn't ever be nullptr.
        if ( groupUedExpression == nullptr)
        {
            WARN_LOG("[GroupUedExpressionList].calculateAdjustedUedValue: groupUedExpression for groupSize '" << groupSize << "', was nullptr, returning rawUedValue.");
            return rawUedValue;
        }

        UserExtendedDataValue eval = groupUedExpression->evalInt(resolveGroupUedVariableCb, &info);
        if (resolveSuccess)
        {
            // reputation expression return value treated as bool, true is equivalent to having poor reputation
            return eval;
        }

        WARN_LOG("[GroupUedExpressionList].calculateAdjustedUedValue: calculateAdjustedUedValue failed for groupSize '" << groupSize << "', returning rawUedValue.");
        return rawUedValue;

    }



} // namespace Matchmaker
} // namespace GameManager
} // namespace Blaze
