[ headername="bytevault/tdf/bytevault.h" ]
#include "bytevault/gen/bytevault.tdf"

[
    client_include = false,
    headername="bytevault/tdf/bytevault_server.h" 
]
#include "bytevault/gen/bytevault_server.tdf"

namespace Blaze
{
namespace ByteVault
{

[
    id = core/31,
    description = "Component used for user-centric data, accessible across products and platforms.",
    details = "ByteVault supports RESTful APIs and is a service independent of Blaze. ByteVault services will be centrally monitored 24x7 and software upgrades for ByteVault will not require downtime. ByteVault instances will be stateless so we can scale by standing up new instances. The storage database will be sharded and can be scaled by adding new database nodes.",
    configurationType = ByteVaultConfig,
    proxyOnly = true,
    http = {
        apiVersion = "1.0",
        use_response_header_blazeerror = true
    }
]
component ByteVault
{
    errors
    {
        [ description = "The record payload can be found at the location specified in the Location header", http_status_code = 303 ]
        BYTEVAULT_RECORD_REDIRECT = 1;
        [ description = "The context name does not correspond to any contexts in ByteVault" ]
        BYTEVAULT_INVALID_CONTEXT = 2;
        [ description = "The context name is missing" ]
        BYTEVAULT_MISSING_CONTEXT = 3;
        [ description = "The label is missing" ]
        BYTEVAULT_MISSING_LABEL = 4;
        [ description = "The description is missing" ]
        BYTEVAULT_MISSING_DESCRIPTION = 5;
        [ description = "The category name does not correspond to any categories in ByteVault" ]
        BYTEVAULT_INVALID_CATEGORY = 6;
        [ description = "The category name is missing" ]
        BYTEVAULT_MISSING_CATEGORY = 7;
        [ description = "The record payload is invalid" ]
        BYTEVAULT_INVALID_PAYLOAD = 8;
        [ description = "The Content-Type header is missing from the request" ]
        BYTEVAULT_MISSING_CONTENT_TYPE = 9;
        [ description = "The Content-Length header is missing from the request" ]
        BYTEVAULT_MISSING_CONTENT_LENGTH = 10;
        [ description = "The record name is missing" ]
        BYTEVAULT_MISSING_RECORD_NAME = 11;
        [ description = "The specified user type is invalid" ]
        BYTEVAULT_INVALID_USER_TYPE = 12;
        [ description = "Exceeding max record size" ]
        BYTEVAULT_MAX_RECORD_SIZE_EXCEEDED = 13;
        [ description = "Exceeding max record count" ]
        BYTEVAULT_MAX_RECORD_COUNT_EXCEEDED = 14;
        [ description = "Creation time is missing" ]
        BYTEVAULT_MISSING_CREATION_TIME = 15;
        [ description = "This operation is not allowed", http_status_code = 401 ]
        BYTEVAULT_NOT_ALLOWED = 16;
        [ description = "User is invalid or user authentication failed", http_status_code = 401 ]
        BYTEVAULT_INVALID_USER = 17;
        [ description = "No records match the specified criteria", http_status_code = 404 ]
        BYTEVAULT_NO_MATCHING_RECORD = 18;
        [ description = "The max record size is invalid" ]
        BYTEVAULT_INVALID_MAX_RECORD_SIZE = 19;
        [ description = "The max record count is invalid" ]
        BYTEVAULT_INVALID_MAX_RECORD_COUNT = 20;
        [ description = "The specified action type is invalid" ]
        BYTEVAULT_INVALID_ACTION_TYPE = 21;
        [ description = "The specified action requires authentication", http_status_code = 401 ]
        BYTEVAULT_AUTHENTICATION_REQUIRED = 22;
        [ description = "The specified token type is invalid" ]
        BYTEVAULT_INVALID_TOKEN_TYPE = 23;
        [ description = "The specified trusted source IP is invalid" ]
        BYTEVAULT_INVALID_TRUSTED_SOURCE = 24;
        [ description = "The admin type does not correspond to any admin types in ByteVault"] 
        BYTEVAULT_INVALID_ADMIN_TYPE = 25;
        [ description = "The ByteVaultManager is not initialized" ]
        BYTEVAULT_NOT_INITIALIZED = 26;
        [ description = "The ByteVaultManager is already initialized" ]
        BYTEVAULT_ALREADY_INITIALIZED = 27;
        [ description = "The last update time is invalid" ]
        BYTEVAULT_INVALID_LASTUPDATETIME = 28;
        [ description = "The start and end dates for the range is invalid" ]
        BYTEVAULT_INVALID_DATE_RANGE = 29;
        [ description = "The record name is invalid" ]
        BYTEVAULT_INVALID_RECORD_NAME = 30;
        [ description = "The max history record count is invalid" ]
        BYTEVAULT_INVALID_MAX_HISTORY_RECORD_COUNT = 31;        
    }

    slave
    {
        methods
        {
            [
                id = 1,
                description = "Adds or removes an admin from a context",
                details = "Adds or removes an admin from a context.  Use ADMIN_TYPE_INVALID to remove an admin from a context.",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_NOT_ALLOWED,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_INVALID_ADMIN_TYPE 
                },
                http = {
                    resource = "admins/{adminEmail}",
                    method = "PUT",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    requestPayloadMember = "adminTypeListByContextMap",
                    responsePayloadMember = "admin",
                    success_error_codes = {
                        "resourceCreated" = 201
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            UpsertAdminResponse upsertAdmin(UpsertAdminRequest);

            [
                id = 2,
                description = "Fetches an admin and their permissions per context",
                details = "Fetches an admin user and their corresponding permissions per context.",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "admins/{adminEmail}",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            GetAdminResponse getAdmin(GetAdminRequest);

            [
                id = 3,
                description = "Creating or updating a context",
                details = "Creates a context if it doesn't exist; replaces existing context if it does exist.",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_MISSING_LABEL,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_DESCRIPTION,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE,
                    BYTEVAULT_NOT_ALLOWED
                },
                http = {
                    resource = "contexts/{context}",
                    method = "PUT",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    responsePayloadMember = "context",
                    success_error_codes = {
                        "resourceCreated" = 201
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            UpsertContextResponse upsertContext(UpsertContextRequest);

            [
                id = 4,
                description = "Fetching contexts",
                details = "Fetches contexts.",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    },
                    responsePayloadMember = "contexts",
                    encodeEnumsAsStrings = true
                }
            ]
            GetContextsResponse getContexts(GetContextsRequest);

            [
                id = 104,
                description = "Fetching context",
                details = "Fetches specific context by name",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{context}",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    }
                }
            ]
            Context getContext(GetContextsRequest);

            [
                id = 5,
                description = "Deleting a context",
                details = "Deletes a specific context and the underlying categories and records by context name.",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{context}",
                    method = "DELETE",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    encodeEnumsAsStrings = true,
                    addEncodedPayload = false
                }
            ]
            void deleteContext(DeleteContextRequest);

            [
                id = 6,
                description = "Creating or updating a category",
                details = "Creates a category if it doesn't exist; replaces the existing category if it does exist",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_INVALID_MAX_RECORD_COUNT,
                    BYTEVAULT_INVALID_MAX_RECORD_SIZE,
                    BYTEVAULT_MISSING_DESCRIPTION,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE,
                    BYTEVAULT_INVALID_TRUSTED_SOURCE,
                    BYTEVAULT_NOT_ALLOWED,
                    BYTEVAULT_INVALID_MAX_HISTORY_RECORD_COUNT
                },
                http = {
                    resource = "contexts/{context}/categories/{categoryName}",
                    method = "PUT",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    responsePayloadMember = "category",
                    success_error_codes = {
                        "resourceCreated" = 201
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            UpsertCategoryResponse upsertCategory(UpsertCategoryRequest);

            [
                id = 7,
                description = "Fetching categories by criteria",
                details = "Returns a list of categories matching supplied context and category name",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{context}/categories",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    },
                    responsePayloadMember = "categories",
                    encodeEnumsAsStrings = true
                }
            ]
            GetCategoriesResponse getCategories(GetCategoriesRequest);

            [
                id = 107,
                description = "Fetching a category",
                details = "Returns a category",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{context}/categories/{categoryName}",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    }
                }
            ]
            Category getCategory(GetCategoriesRequest);

            [
                id = 8,
                description = "Delete a category",
                details = "Deletes a category specified by context name and category name",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{context}/categories/{categoryName}",
                    method = "DELETE",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    encodeEnumsAsStrings = true,
                    addEncodedPayload = false
                }
            ]
            void deleteCategory(DeleteCategoryRequest);

            [
                id = 9,
                description = "Create a new record or update an existing record",
                details = "Creates a record if it doesn't exist; partial or full update of a record that exists. A history record will be automatically created if the history is enabled for the category and the necessary criteria are met (minimum history gap)",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_INVALID_PAYLOAD,
                    BYTEVAULT_MISSING_CONTENT_TYPE,
                    BYTEVAULT_MISSING_CONTENT_LENGTH,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_MAX_RECORD_SIZE_EXCEEDED,
                    BYTEVAULT_MAX_RECORD_COUNT_EXCEEDED,
                    BYTEVAULT_NOT_ALLOWED,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE,
                    BYTEVAULT_INVALID_RECORD_NAME
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/records/{recordAddress.recordName}",
                    method = "PUT",
                    contentType = "", // empty string to denote that the Content-Type header will actually be filled in by the custom_request_headers mapping from request TDF
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type",
                        "Content-Type" = "payload.contentType"
                    },
                    url_params = {
                        "subrecordupdate" = "subrecordupdate",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id"
                    },
                    requestPayloadBlob = "payload.blob",
                    custom_response_headers = {
                        "X-LASTUPDATE" = "record.lastUpdateTime",
                        "Location" = "location"
                    },
                    responsePayloadMember = "record",
                    success_error_codes = {
                        "resourceCreated" = 201,
                        "isRemoteResource" = 303
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            UpsertRecordResponse upsertRecord(UpsertRecordRequest);

            [
                id = 10,
                description = "Fetch specified record",
                details = "Fetches the specified record including payload data",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_NO_MATCHING_RECORD,
                    BYTEVAULT_RECORD_REDIRECT,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/records/{recordAddress.recordName}",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    custom_response_headers = {
                        "X-CREATION" = "creation",
                        "X-LASTUPDATE" = "lastUpdate",
                        "Content-Type" = "payload.contentType",
                        "Location" = "location"
                    },
                    url_params = {
                        "subrecord" = "subrecord",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id"
                    },
                    responsePayloadBlob = "payload.blob",
                    success_error_codes = {
                        "isRemoteResource" = 303
                    },
                    encodeEnumsAsStrings = true,
                    addEncodedPayload = false
                }
            ]
            GetRecordResponse getRecord(GetRecordRequest);

            [
                id = 11,
                description = "Fetch specified record info",
                details = "Fetches the specified record but without the payload data",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_NO_MATCHING_RECORD,
                    BYTEVAULT_RECORD_REDIRECT,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/records/{recordAddress.recordName}",
                    method = "HEAD",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    custom_response_headers = {
                        "X-CREATION" = "creation",
                        "X-LASTUPDATE" = "lastUpdate",
                        "Content-Type" = "contentType",
                        "Content-Length" = "payloadSize",
                        "Location" = "location"
                    },
                    url_params = {
                        "subrecord" = "subrecord",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id"
                    },
                    success_error_codes = {
                        "isRemoteResource" = 303
                    }
                }
            ]
            HeadRecordResponse headRecord(GetRecordRequest);

            [
                id = 12,
                description = "Fetch record info for records across owners that match the context, category and record name",
                details = "Fetch record info for records across owners that match the context, category and record name",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/recordinfo",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "recordName" = "recordAddress.recordName",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id",
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            GetRecordInfoResponse getRecordsInfo(GetRecordInfoRequest);

            [
                id = 14,
                description = "Deletes a record",
                details = "Deletes a specified record",
                requires_authentication = false,
                client_export = true,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_NO_MATCHING_RECORD,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/records/{recordAddress.recordName}",
                    method = "DELETE",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id"
                    },
                    encodeEnumsAsStrings = true,
                    addEncodedPayload = false
                }
            ]
            void deleteRecord(DeleteRecordRequest);

            [
                id = 15,
                description = "Archives record(s)",
                details = "Archives records that match the specified criteria",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{context}/categories/{categoryName}/archiverecords/{record}",
                    method = "POST",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            void archiveRecords(ArchiveRecordsRequest);

            [
                id = 16,
                description = "Deletes specified history record",
                details = "Deletes history record that match the specified criteria",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_INVALID_TOKEN_TYPE,
                    BYTEVAULT_INVALID_LASTUPDATETIME,
                    BYTEVAULT_NO_MATCHING_RECORD
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/historyrecords/{recordAddress.recordName}",
                    method = "DELETE",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id",
                        "lastUpdateTime" = "lastUpdateTime"
                    },
                    encodeEnumsAsStrings = true,
                    addEncodedPayload = false
                }
            ]
            void deleteHistoryRecord(DeleteHistoryRecordRequest);

            [
                id = 17,
                description = "Fetch specified history record",
                details = "Fetches the specified history record including the payload data",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_INVALID_LASTUPDATETIME,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_NO_MATCHING_RECORD,
                    BYTEVAULT_RECORD_REDIRECT,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/historyrecords/{recordAddress.recordName}",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    custom_response_headers = {
                        "X-CREATION" = "creation",
                        "X-LASTUPDATE" = "lastUpdate",
                        "Content-Type" = "payload.contentType",
                        "Location" = "location"
                    },
                    url_params = {
                        "subrecord" = "subrecord",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id",
                        "lastUpdateTime" = "lastUpdateTime"
                    },
                    responsePayloadBlob = "payload.blob",
                    success_error_codes = {
                        "isRemoteResource" = 303
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            GetHistoryRecordResponse getHistoryRecord(GetHistoryRecordRequest);
 
            [
                id = 18,
                description = "Fetch specified history record",
                details = "Fetches the specified history record but without the payload data",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_INVALID_LASTUPDATETIME,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_NO_MATCHING_RECORD,
                    BYTEVAULT_RECORD_REDIRECT,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/historyrecords/{recordAddress.recordName}",
                    method = "HEAD",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    custom_response_headers = {
                        "X-CREATION" = "creation",
                        "X-LASTUPDATE" = "lastUpdate",
                        "Content-Type" = "contentType",
                        "Content-Length" = "payloadSize",
                        "Location" = "location"
                    },
                    url_params = {
                        "subrecord" = "subrecord",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id",
                        "lastUpdateTime" = "lastUpdateTime"
                    },
                    success_error_codes = {
                        "isRemoteResource" = 303
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            HeadHistoryRecordResponse headHistoryRecord(GetHistoryRecordRequest);
 
            [
                id = 19,
                description = "Fetch record info for all the manually archived versions of the record identified by the record address.",
                details = "Fetch record info for all the manually archived versions of the record identified by the record address.",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/archivedrecordinfo",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "recordName" = "recordAddress.recordName",
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id",
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    }
                }
            ]
            GetHistoryRecordInfoResponse getArchivedRecordsInfo(GetRecordInfoRequest);

            [
                id = 20,
                description = "Fetches admin change history that matches criteria",
                details = "Fetches admin change history that matches criteria",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_TOKEN_TYPE,
                    BYTEVAULT_INVALID_DATE_RANGE
                },
                http = {
                    resource = "history",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "context" = "context",
                        "category" = "categoryName",
                        "record" = "recordName",
                        "admin" = "adminEmail",
                        "action" = "action",
                        "startdate" = "startDate",
                        "enddate" = "endDate",
                        "maxresultcount" = "maxResultCount",
                        "offset" = "offset"
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            GetAdminChangeHistoryResponse getAdminChangeHistory(GetAdminChangeHistoryRequest);

            [
                id = 21,
                description = "Fetches data rates for record fetches and uploads",
                details = "Fetches data rates, including overall and broken down by context/category for record fetches and uploads",
                internal = true,
                requires_authentication = false,
                client_export = false,
                http = {
                    resource = "datarates",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "context" = "context",
                        "category" = "categoryName"
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            GetDataRatesResponse getDataRates(GetDataRatesRequest);

            [
                id = 22,
                description = "Fetches error rates for Bytevault RPCs",
                details = "Fetches error rates broken down by context/category for each Bytevaylt RPC",
                internal = true,
                requires_authentication = false,
                client_export = false,
                http = {
                    resource = "erorrrates",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "context" = "context",
                        "category" = "categoryName"
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            GetErrorRatesResponse getErrorRates(GetErrorRatesRequest);

            [
                id = 23,
                description = "Restores the specified history record as the active record",
                details = "Restores the specified history record as the active record",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_INVALID_LASTUPDATETIME,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_NO_MATCHING_RECORD,
                    BYTEVAULT_RECORD_REDIRECT,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/restorerecord/{recordAddress.recordName}",
                    method = "PUT",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    custom_response_headers = {
                        "X-LASTUPDATE" = "record.lastUpdateTime",
                        "Location" = "location"
                    },
                    url_params = {
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id",
                        "lastUpdateTime" = "lastUpdateTime"
                    },
                    success_error_codes = {
                        "resourceCreated" = 201,
                        "isRemoteResource" = 303
                    },
                    encodeEnumsAsStrings = true
                }
            ]
            UpsertRecordResponse restoreRecord(GetHistoryRecordRequest);

            [
                id = 24,
                description = "Fetch record info for all the history versions of the record identified by the specified record address.",
                details = "Fetch record info for all the history versions of the record identified by the specified record address.",
                internal = true,
                requires_authentication = false,
                client_export = false,
                errors = {
                    BYTEVAULT_AUTHENTICATION_REQUIRED,
                    BYTEVAULT_INVALID_CONTEXT,
                    BYTEVAULT_INVALID_CATEGORY,
                    BYTEVAULT_MISSING_CONTEXT,
                    BYTEVAULT_MISSING_CATEGORY,
                    BYTEVAULT_MISSING_RECORD_NAME,
                    BYTEVAULT_INVALID_USER,
                    BYTEVAULT_INVALID_USER_TYPE,
                    BYTEVAULT_INVALID_TOKEN_TYPE
                },
                http = {
                    resource = "contexts/{recordAddress.context}/categories/{recordAddress.categoryName}/historyrecordinfo/{recordAddress.recordName}",
                    method = "GET",
                    custom_request_headers = {
                        "Authorization" = "authCredentials.token",
                        "X-TOKEN-TYPE" = "authCredentials.tokenType",
                        "X-USER-ID" = "authCredentials.user.id",
                        "X-USER-TYPE" = "authCredentials.user.type"
                    },
                    url_params = {
                        "ownerType" = "recordAddress.owner.type",
                        "ownerId" = "recordAddress.owner.id"
                    }
                }
            ]
            GetHistoryRecordInfoResponse getHistoryRecordsInfo(GetRecordRequest);

        }
    }
}

}
}

