/*************************************************************************************************/
/*!
    \file   entrycriteria.cpp


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*************************************************************************************************/

#include "framework/blaze.h"

#include "framework/usersessions/usersessionmanager.h"
#include "framework/component/blazerpc.h"

// In order to avoid duplicate symbols the lex and yacc files for stats use the prefix option
// to rename some symbols starting with "yy" to "blaze".  Thus we also must redefine yyFlexLexer to
// blazeFlexLexer here to match.
#undef yyFlexLexer
#define yyFlexLexer blazeFlexLexer
#include "FlexLexer.h"
#include "framework/util/blazelexer.h"

// Forward declaration of main parse method generated by yacc
int blazeparse (BlazeLexer* blaze_flex_lexer);

#include "framework/util/entrycriteria.h"

namespace Blaze
{

bool EntryCriteriaEvaluator::validateEntryCriteria(const EntryCriteriaMap& entryCriteriaMap, EntryCriteriaName& failedCriteria, ExpressionMap* outMap)
{
    return (createCriteriaExpressions(entryCriteriaMap, outMap, true, &failedCriteria) == 0);
}

int32_t EntryCriteriaEvaluator::createCriteriaExpressions(const EntryCriteriaMap& entryCriteriaMap, ExpressionMap* outMap, bool earlyOutOnError, EntryCriteriaName* lastFailedCriteria)
{
    EntryCriteriaMap::const_iterator itr = entryCriteriaMap.begin();
    EntryCriteriaMap::const_iterator end = entryCriteriaMap.end();
    int32_t errorCount = 0;
    for (; itr != end; ++itr)
    {
        EntryCriteriaName criteriaName = itr->first.c_str();
        const char8_t* stringExpression = itr->second.c_str();

        if (criteriaName.c_str()[0] == '\0')
        {
            ++errorCount;
            BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].validateEntryCriteria(): empty criteria name error while parsing "
                "entry criteria name \"\" expression \"" << stringExpression << "\"");
            return errorCount; // early out due to error
        }

        BlazeLexer::LexResolveTypeCb cb(&EntryCriteriaEvaluator::resolveCriteriaType);
        BlazeLexer lexer(stringExpression, nullptr, cb);
        blazeparse(&lexer);

        Expression* expression = lexer.getExpression();
        if (expression == nullptr)
        {
            ++errorCount;
            BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].createCriteriaExpressions(): encountered grammatical error while parsing "
                "entry criteria name \"" << criteriaName.c_str() << "\" expression \"" << stringExpression << "\" (criteria ignored).");
            if (lastFailedCriteria != nullptr)
                *lastFailedCriteria = criteriaName;
            if (earlyOutOnError)
            {
                return errorCount;
            }
        }
        else if (expression->getErrorCount() > 0)
        {
            errorCount += expression->getErrorCount();
            BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].createCriteriaExpressions(): encountered " << errorCount << " errors while parsing "
                "entry criteria name \"" << criteriaName.c_str() << "\" expression \"" << stringExpression << "\" (criteria ignored).");
            delete expression;  // cleanup expression if we don't add it to the map.

            if (lastFailedCriteria != nullptr)
                *lastFailedCriteria = criteriaName;
            if (earlyOutOnError)
            {
                return errorCount;
            }
        }
        else
        {
            if (outMap != nullptr)
            {
                // add parsed expression to the expression map (deleting previous entry, if one exists)
                ExpressionMap::iterator expressionMapIter = outMap->find(criteriaName);
                if ( expressionMapIter == outMap->end())
                {
                    (*outMap)[criteriaName] = expression;
                }
                else
                {
                    BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].createCriteriaExpressions(): expression map already contains a parsed expression named \"" << criteriaName.c_str() << "\"; deleting previous expression.");
                    delete expressionMapIter->second;
                    expressionMapIter->second = expression;
                }
            }
            else
            {
                delete expression;  // cleanup expression.
            }
        }
    }

    return errorCount;
}

int32_t EntryCriteriaEvaluator::createCriteriaExpressions()
{
    int32_t result = createCriteriaExpressions(getEntryCriteria(), &getEntryCriteriaExpressions(), false, nullptr);
    mCreatedExpressions = (result == 0);
    return result;
}

void EntryCriteriaEvaluator::clearCriteriaExpressions()
{
    ExpressionMap& expressionMap = getEntryCriteriaExpressions();
    ExpressionMap::iterator i = expressionMap.begin();
    ExpressionMap::iterator e = expressionMap.end();

    // Free all of the memory and clear the map.
    for (; i != e; ++i)
    {
        delete i->second;
    }
    expressionMap.clear();
    mCreatedExpressions = false;
}

void EntryCriteriaEvaluator::resolveCriteriaType(const char8_t* nameSpace, const char8_t* variable, void* context, Blaze::ExpressionValueType& type)
{
    //for now, we only support int criteria
    type = Blaze::EXPRESSION_TYPE_INT;
}


bool EntryCriteriaEvaluator::evaluateEntryCriteria(BlazeId blazeId, const UserExtendedDataMap& dataMap, EntryCriteriaName& failedCriteria) const
{
    bool resolveSuccess;
    ResolveCriteriaInfo info;
    info.blazeId = blazeId;
    info.extendedDataMap = &dataMap;
    info.success = &resolveSuccess;

    // Matchmaker load testing showed that constructing this functor was a time sink, so it's static now
    static Expression::ResolveVariableCb resolveCriteriaVariableCb(&EntryCriteriaEvaluator::resolveCriteriaVariable);

    if (!mCreatedExpressions)
    {
        // check that criteria expressions have been created already, otherwise evaluating them is fruitless, and there must be a bug where we don't
        // 
        BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].evaluateEntryCriteria: createCriteriaExpressions() was not called before evaluating for blazeid: " << blazeId);
        EA_FAIL();
    }
    
    const ExpressionMap& expressions = getEntryCriteriaExpressions();
    ExpressionMap::const_iterator itr = expressions.begin();
    ExpressionMap::const_iterator end = expressions.end();
    for (; itr != end; ++itr)
    {
        const Blaze::Expression* expression = itr->second;
        int64_t eval = expression->evalInt(resolveCriteriaVariableCb, &info);
        if (eval == 0 || !resolveSuccess)
        {
            failedCriteria = itr->first.c_str();
            return false;
        }
    }

    return true;
}

void EntryCriteriaEvaluator::resolveCriteriaVariable(const char8_t* nameSpace, const char8_t* name, Blaze::ExpressionValueType type, const void* context, Blaze::Expression::ExpressionVariableVal& val)
{
    const ResolveCriteriaInfo* info = static_cast<const ResolveCriteriaInfo*>(context);
    *(info->success) = false;

    // need this init to avoid a memory checking tool error; the value will be irrelevant if the resolve is not successful
    val.intVal = 0;

    if (type == Blaze::EXPRESSION_TYPE_INT)
    {
        UserExtendedDataKey dataKey = INVALID_USER_EXTENDED_DATA_KEY;
        UserExtendedDataName dataName = name;

        // Look up the data key using the name.
        if (!gUserSessionManager->getUserExtendedDataKey(dataName, dataKey))
        {
            BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].resolveCriteriaVariable(): key not found for name '" << name << "'");
            return;
        }

        if (info->extendedDataMap != nullptr)
        {
            UserExtendedDataValue userExtendedDataValue;
            if (!UserSession::getDataValue(*info->extendedDataMap, dataKey, userExtendedDataValue))
            {
                BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].resolveCriteriaVariable(): getDataValue failed for user[" << info->blazeId
                              << "], criteria[" << name << "], key[" << dataKey << "].");
            }
            else
            {
                val.intVal = userExtendedDataValue;
                BLAZE_TRACE_LOG(Log::UTIL, "[EntryCriteriaEvaluator].resolveCriteriaVariable(): Data Value[" << val.intVal << "] for user[" 
                                << info->blazeId << "], criteria[" << name << "], key[" << dataKey << "].");
                *(info->success) = true;
            }
        }
        else
        {
            BLAZE_ERR_LOG(Log::UTIL, "[EntryCriteriaEvaluator].resolveCriteriaVariable(): resolve failed extended data map is null.");
        }
    }
}

} // Blaze
