// EXAMPLES. CAN BE REMOVED - RECOMMEND COMMENTING OUT #include in create_game_templates.cfg rather than editing this file
"simpleGroup" = {

    // Basic joinable game group:
    baseRequest = {
        commonGameData = { gameType = "GAME_TYPE_GROUP" }
        gameCreationData = { 
            networkTopology = "NETWORK_DISABLED"
            voipNetwork = "VOIP_DISABLED"
            gameSettings = ["openToJoinByPlayer", "joinInProgressSupported", "hostMigratable", "allowAnyReputation" ]
         }
    }
     
    //  Attributes to let you set the group size (and Xbox game template)
    attributes = {
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"     = { attrName = "PLAYER_CAPACITY",            default = 4 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"                              = { attrName = "PLAYER_CAPACITY",            default = 4 }
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"    = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
#endif
    }
}

// Basic P2P Game: (Used in scenario.cfg example)
"basicGame" = {

    // Set this to RESET_GAME if you want this to be a resetDedicatedServer request:
    createRequestType = "CREATE_GAME"     // Other options: CREATE_OR_JOIN_GAME (join based on persisted id), RESET_GAME
    
    // The Base Request is just a CreateGameRequest value.  It's provides a simple 'Base' for the request:
    baseRequest = {
        gameCreationData = { 
            networkTopology = "CLIENT_SERVER_PEER_HOSTED"
            voipNetwork = "VOIP_DISABLED"

            gameSettings = ["openToBrowsing",
                            "openToMatchmaking", 
                            "openToInvites", 
                            "openToJoinByPlayer",
                            "hostMigratable",
                            "joinInProgressSupported",     
                            "allowAnyReputation" ]
         } 
    }

    // Attributes are (optionally) sent from the client, to configure the settings used:
    attributes = {
      // Player count is always required: 
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"       = { attrName = "PLAYER_CAPACITY",        default = 8 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"               = { attrName = "PLAYER_CAPACITY",     default = 8 }       // Max Capacity the game can be set to.

      // All games are required to specify a 'mode' (See gameModeAttributeName in gamesession.cfg)
        "CreateGameRequest.gameCreationData.gameAttribs[mode]"               = { attrName = "GAME_MODE",  default = "1" }   // Required
        
      // Bitfields can be set indvidually with Attributes:  (Only overwrites the specified field)
        "CreateGameRequest.gameCreationData.gameSettings[ranked]"            = { attrName = "IS_RANKED",   default = 0 }   // Optional Example - Setting ranked mode independantly.

      // Map elements can be set individually as well:
        "CreateGameRequest.gameCreationData.gameAttribs[ISmap]"              = { attrName = "GAME_MAP",  default = "1" }   // Optional Example - Additional game attributes

      // For game reporting collation handling, set gameReportName.
        "CreateGameRequest.gameCreationData.gameReportName"                  = { attrName = "GAME_REPORT_NAME", default="integratedSample"}

      // For Xbox:
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"          = { default = "" }
#endif
      // For PS5: TRCs require competitive multiplayer games have Matches:
#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { default = "BlazeSampleActivity" }
#endif

    }
}


// Fully configurable P2P Game: (Used in scenario.cfg example)
"fullCreateGame" = {

    attributes = {
        // When creating a game directly, the slot capacities are required (not just the max Player Capacity):
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"       = { attrName = "PLAYER_CAPACITY",        default = 8 }
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_SPECTATOR]"         = { attrName = "SPECTATOR_CAPACITY",     default = 0 }

        "CreateGameRequest.gameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 32 } // Max Capacity the game can be set to.
      //"CreateGameRequest.gameCreationData.networkTopology"        = { attrName = "NET_TOPOLOGY",    default = "CLIENT_SERVER_PEER_HOSTED" }
        "CreateGameRequest.gameCreationData.voipNetwork"            = { attrName = "VOIP_TOPOLOGY",   default = "VOIP_DISABLED" }
        "CreateGameRequest.gameCreationData.gameSettings"           = { attrName = "GAME_SETTINGS",   default =   [ "openToBrowsing",
                                                                                                                    "openToMatchmaking", 
                                                                                                                    "openToInvites", 
                                                                                                                    "openToJoinByPlayer",
                                                                                                                    "hostMigratable",
                                                                                                                    "joinInProgressSupported",     
                                                                                                                    "allowAnyReputation"] }
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"    = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }

        // By MS spec/XRs, if your game max players requires using 'Large' 1st party session (see MS docs), you should set this to true.
        // If true, Blaze handles updating the Large session's member's recent players lists using the externalSessionRecentPlayers settings below.
        "CreateGameRequest.gameCreationData.xblLargeSession"                                = { attrName = "XBOX_LARGE_SESSION", default = false }

        // For Xbox One/XBSX, when 'xblLargeSession' is true, Blaze auto-adds other simultaneously present players based on this grouping type, to each external session member's 1st party recent players list:
        "CreateGameRequest.gameCreationData.externalSessionRecentPlayers.grouping"          = { attrName = "XBOX_RECENT_PLAYERS_GROUPING", default = "TEAM" } //Other possible values: GAME_ROSTER: recent players are from entire game roster. (If no Teams, TEAM works same as GAME_ROSTER). Default is TEAM.

#endif
#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { attrName = "PS5_ACTIVITY_ID", default = "BlazeSampleActivityWithScore" }
#endif

        // All games are required to specify a 'mode' (See gameModeAttributeName in gamesession.cfg)
        "CreateGameRequest.gameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }   // Required
        "CreateGameRequest.gameCreationData.gameAttribs[ISmap]"  = { attrName = "GAME_MAP",  default = "1" }   // Optional Example - Additional game attributes

        // For game reporting collation handling, set gameReportName.
        "CreateGameRequest.gameCreationData.gameReportName" = { attrName = "GAME_REPORT_NAME", default="integratedSample"}

        "CreateGameRequest.gameCreationData.gameName"  = { attrName = "GAME_NAME",  default = "DEFAULT GAME NAME SAMPLE" } 
        "CreateGameRequest.gameCreationData.presenceMode"  = { attrName = "GAME_PRESENCE_MODE",  default = "PRESENCE_MODE_STANDARD" }  // other possible values PRESENCE_MODE_PRIVATE for private games, PRESENCE_MODE_NONE disables
    }
}

"fullResetGame" = {
    createRequestType = "RESET_GAME"
    attributes = {
        // When creating a game directly, the slot capacities are required (not just the max Player Capacity):
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"       = { attrName = "PLAYER_CAPACITY",        default = 8 }

        "CreateGameRequest.gameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 32 } // Max Capacity the game can be set to.
        "CreateGameRequest.gameCreationData.networkTopology"        = { default = "CLIENT_SERVER_DEDICATED" }
        "CreateGameRequest.gameCreationData.voipNetwork"            = { attrName = "VOIP_TOPOLOGY",   default = "VOIP_DISABLED" }
        "CreateGameRequest.gameCreationData.gameSettings"           = { attrName = "GAME_SETTINGS",   default =   [ "openToBrowsing",
                                                                                                                    "openToMatchmaking", 
                                                                                                                    "openToInvites", 
                                                                                                                    "openToJoinByPlayer",
                                                                                                                    "hostMigratable",
                                                                                                                    "joinInProgressSupported",     
                                                                                                                    "allowAnyReputation"] }
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"    = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
#endif
#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { attrName = "PS5_ACTIVITY_ID", default = "BlazeSampleActivityWithScore" }
#endif

        // All games are required to specify a 'mode' (See gameModeAttributeName in gamesession.cfg)
        "CreateGameRequest.gameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }   // Required
        "CreateGameRequest.gameCreationData.gameAttribs[ISmap]"  = { attrName = "GAME_MAP",  default = "1" }   // Optional Example - Additional game attributes

        // For game reporting collation handling, set gameReportName.
        "CreateGameRequest.gameCreationData.gameReportName" = { attrName = "GAME_REPORT_NAME", default="integratedSample"}

        "CreateGameRequest.gameCreationData.gameName"  = { attrName = "GAME_NAME",  default = "DEFAULT GAME NAME SAMPLE" } 
        "CreateGameRequest.gameCreationData.presenceMode"  = { attrName = "GAME_PRESENCE_MODE",  default = "PRESENCE_MODE_STANDARD" }  // other possible values PRESENCE_MODE_PRIVATE for private games, PRESENCE_MODE_NONE disables
    }
}

// A simple packer CSD game
"simplePackerGameCSD" = {
    
    baseRequest = {
        gameCreationData = { 
        
            networkTopology = "CLIENT_SERVER_DEDICATED"
            voipNetwork = "VOIP_DISABLED"
            gameSettings = [ "openToBrowsing",
                             "openToMatchmaking", 
                             "openToInvites", 
                             "openToJoinByPlayer",
                             "hostMigratable",
                             "joinInProgressSupported",     
                             "allowAnyReputation" ]
                             
            slotCapacitiesMap = { SLOT_PUBLIC_PARTICIPANT = 8 }
            maxPlayerCapacity = 8
            teamIds = [1,2]
        }
    }
    
    attributes = {
        "CreateGameRequest.gameCreationData.gameAttribs[mode]"      = { attrName = "DESIRED_GAME_MODE", default = "1" }
        "CreateGameRequest.gameCreationData.gameAttribs[progress]"  = { default = "0" }
        "CreateGameRequest.gamePingSiteAlias"                       = { attrName = "PING_SITE_ALIAS", default = "bio-sjc" }
    }
     
    
    packerConfig = {
        qualityFactors = [
            { gameProperty="game.players", transform="size",
                scoreShaper={ DefaultShaper={ bestValue={ propertyName="game.participantCapacity" }, viableValue=2, worstValue=0 } } }

            { gameProperty="game.pingSite", transform="avg",
                keys={ propertyName="caller.acceptedPingSites"}, scoringMap={ propertyName="players.pingSiteLatencies" },
                scoreShaper={ DefaultShaper={ bestValue=0, viableValue=200, worstValue=10000, granularity=10 } } }

            { gameProperty="game.attributes[progress]", transform="avg",
                keys = { attrName = "DESIRED_PROGRESS_LIST" } // attribute defined in input sanitizer
                scoringMap={ default={ tdfid="map<string,float>", value = {"0"=0, "1"=1, "2"=2, "3"=2, "4"=2, "5"=2} } },
                scoreShaper={ DefaultShaper={ bestValue=0, viableValue=1, worstValue=2 } } }

            { gameProperty="game.teams.players.uedValues", transform="sum", teamMergeOp="MERGE_MIN_MAX_RATIO",
                keys={ default="stats_skilla" }, scoringMap={ propertyName="players.uedValues" },
                scoreShaper={ DefaultShaper={ bestValue=1, viableValue=0, worstValue=0, granularity=0.1 } } }

            //{ gameProperty="game.teams.players", transform="size.min",
            //    scoreShaper={ DefaultShaper={ bestValue={ propertyName="game.teamCapacity" }, viableValue=1 } } }
        ]

        viableGameCooldownThreshold = "1s"
    }
}

// A simple packer game
"simplePackerGame" = {
    
    baseRequest = {
        gameCreationData = { 
        
            networkTopology = "CLIENT_SERVER_PEER_HOSTED"
            voipNetwork = "VOIP_DISABLED"
            gameSettings = [ "openToBrowsing",
                             "openToMatchmaking", 
                             "openToInvites", 
                             "openToJoinByPlayer",
                             "hostMigratable",
                             "joinInProgressSupported",     
                             "allowAnyReputation" ]
                             
            slotCapacitiesMap = { SLOT_PUBLIC_PARTICIPANT = 8 }
            maxPlayerCapacity = 8
            teamIds = [1,2]
        }
    }
    
    attributes = {
        "CreateGameRequest.gameCreationData.maxPlayerCapacity" = { propertyName = "game.participantCapacity", default = 8 }
        "CreateGameRequest.gameCreationData.gameAttribs[mode]" = { attrName = "GAME_MODE", default = "test_mode" }
        "CreateGameRequest.gameCreationData.gameAttribs[MAP]" = { attrName = "GAME_MAP", default = "test_map" }
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]" = { attrName = "PARTICIPANT_CAPACITY", default = 8}
    }
     
    
    packerConfig = {
        qualityFactors = [
            { gameProperty="game.players", transform = "size",                          scoreShaper={ DefaultShaper = { viableValue=2,   bestValue={propertyName = "game.participantCapacity" }, worstValue=0             } } }
            { gameProperty="game.teams.players", transform = "size.min",                scoreShaper={ DefaultShaper = { viableValue=1,   bestValue={propertyName = "game.teamCapacity" }                     } } }
        ]

        viableGameCooldownThreshold = "1s"
    }
    
}

// P2P Game with Teams and Roles: 
"teamGame8v8TwoRoles" = {
    baseRequest = {

        gameCreationData = { 
            maxPlayerCapacity = 32  // maxPlayerCapacity must be >= the combined slotCapacitiesMap values.
            slotCapacitiesMap = { SLOT_PUBLIC_PARTICIPANT = 16, SLOT_PUBLIC_SPECTATOR = 4 }

            teamIds = [1, 2]        // Two teams
            roleInformation = { 
              roleCriteriaMap = { SoldierRole = { roleCapacity = 8 },       // All 8 players on each team can be soldiers
                                  Commander   = { roleCapacity = 1 } }      // but only 1 commander can be on each side.
            }

            networkTopology = "CLIENT_SERVER_PEER_HOSTED"
            voipNetwork     = "VOIP_DISABLED"

            gameSettings = ["openToBrowsing",
                            "openToMatchmaking", 
                            "openToInvites", 
                            "openToJoinByPlayer",
                            "hostMigratable",
                            "joinInProgressSupported",     
                            "allowAnyReputation" ]
         } 
    }

    attributes = {

        "CreateGameRequest.gameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }   // Required
        "CreateGameRequest.gameCreationData.gameAttribs[ISmap]"  = { attrName = "GAME_MAP",  default = "1" }   // Optional Example - Additional game attributes

      // For game reporting collation handling, set gameReportName.
        "CreateGameRequest.gameCreationData.gameReportName"      = { attrName = "GAME_REPORT_NAME", default="integratedSample"}

      // For Xbox:
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"    = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
#endif
      // For PS5: TRCs require competitive multiplayer games have Matches:
#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { attrName = "PS5_ACTIVITY_ID", default = "BlazeSampleTeamActivityWithScore", isOptional = false }
#endif

      // This attribute allows the client to set the Commander capacity to 0, if desired.
        "CreateGameRequest.gameCreationData.roleInformation.roleCriteriaMap[Commander].roleCapacity" = { attrName = "COMMANDER_COUNT",  default = 1 }
    }
}


// Create a game on the dedicated server machine, that can be reset:
"setupResetableDedicatedServer" = {
    baseRequest = {
        serverNotResetable = false;       // false is already the default (RESETABLE state is allowed) - shown here as an example of a CreateGameRequest value that's not in gameCreationData
        gameCreationData = { 
            networkTopology = "CLIENT_SERVER_DEDICATED"
            voipNetwork     = "VOIP_DISABLED"

            gameSettings = ["openToBrowsing",
                            "openToMatchmaking", 
                            "openToInvites", 
                            "openToJoinByPlayer",
                            "hostMigratable",
                            "joinInProgressSupported",     
                            "allowAnyReputation" ]

            gameAttribs = { "mode" = "resetable" }
         } 
    }

    attributes = {
        // Dedicated Servers must provide a ping site when created:
        "CreateGameRequest.gamePingSiteAlias"                                = { attrName = "PING_SITE_ALIAS",        default = "bio-sjc" }

        // Setting this to true would force the dedicated server to go directly into the INITIALIZING state, rather than being added to the RESETABLE pool
        "CreateGameRequest.serverNotResetable"                               = { attrName = "IS_NOT_RESETABLE",       default = false }

        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"       = { attrName = "PLAYER_CAPACITY",        default = 8 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"               = { attrName = "PLAYER_CAPACITY",        default = 8 }       // Max Capacity the game can be set to.

        "CreateGameRequest.clientPlatformListOverride"    = { attrName = "CROSSPLAY_PLATFORMS", default = ["pc", "xone", "ps4"]  }

        // For Xbox:
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"     = { default = "" }
#endif

        // Set dedicated server attributes
        // "CreateGameRequest.dedicatedServerAttribs[serverType]"               = { attrName = "SERVER_TYPE",              default = "nonDLC" }
    }
}

// Find and reset a dedicated server game:
"resetDedicatedServer" = {
    createRequestType = "RESET_GAME"

    baseRequest = {
        gameCreationData = { 
            networkTopology = "CLIENT_SERVER_DEDICATED"
            voipNetwork     = "VOIP_DISABLED"

            gameSettings = ["openToBrowsing",
                            "openToMatchmaking", 
                            "openToInvites", 
                            "openToJoinByPlayer",
                            "hostMigratable",
                            "joinInProgressSupported",     
                            "allowAnyReputation" ]

            gameAttribs = { "mode" = 1 }
         } 
    }

    // Find dedicated server using dedicated server attributes rule 'serverTypeRule'
    // findDedicatedServerRulesMap = { "serverTypeRule" = { desiredValue = "nonDLC",  minFitThresholdValue = 1.0 } }

    attributes = {
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"       = { attrName = "PLAYER_CAPACITY",        default = 8 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"               = { attrName = "PLAYER_CAPACITY",        default = 8 }       // Max Capacity the game can be set to.

      // For game reporting collation handling, set gameReportName.
        "CreateGameRequest.gameCreationData.gameReportName"                  = { attrName = "GAME_REPORT_NAME", default="integratedSample"}

      // For Xbox:
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"    = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
#endif
      // For PS5:
#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { attrName = "PS5_ACTIVITY_ID", default = "BlazeSampleActivity" }
#endif
    }
}

// An example of how to setup a tournament game:
"tournamentGameExample" = {

    // Tournament Games are expected to be Virtual Dedicated Server games, where all players are reserved initially
    baseRequest = {
        gameCreationData = { 
            networkTopology = "CLIENT_SERVER_DEDICATED"
            voipNetwork     = "VOIP_DISABLED"

            // The game is unjoinable except for players reserved when it was created:
            gameSettings = ["hostMigratable",
                            "joinInProgressSupported",
                            "allowAnyReputation",
                            "virtualized",
                            "disconnectReservation",
                            "spectatorBypassClosedToJoin"]    // Allow spectators to join without restriction.  (Remove this if it can impact gameplay)

            // A restricted permission system is used, so that players cannot perform actions that would invalidate the game:
            permissionSystemName = "tournamentGame"

            // To enable generating your game report at the game end event, for TO to fetch, set gameReportName to the game report name.
            //gameReportName = "gameTypeXYZ"
         } 
    }

    attributes = {

      // The tournament provider must provide a URL for events, so that it can be informed when the game starts and ends:
        "CreateGameRequest.gameEventAddress"               = { attrName = "GAME_EVENT_ADDRESS" }
        "CreateGameRequest.gameStartEventUri"              = { attrName = "GAME_START_EVENT_URI" }
        "CreateGameRequest.gameEndEventUri"                = { attrName = "GAME_END_EVENT_URI" }

      // Tournament Id is a arbitrary value provided by the organizer.  The Organizer should refer to ESL, FaceIt, or other external tournament provider.
        "CreateGameRequest.tournamentIdentification.tournamentId"            = { attrName = "TOURNAMENT_ID" }
        "CreateGameRequest.tournamentIdentification.tournamentOrganizer"     = { attrName = "TOURNAMENT_ORGANIZER" }


      // The tournament provider is unlikely to know the game protocol version used. Keep this in sync with client code, or, use
      // match_any_protocol, which allows the virtual game to take on the first joining user's protocol value.
        "CreateGameRequest.commonGameData.gameProtocolVersionString"         = { attrName = "DESIRED_PROTOCOLVERSION", default = "match_any_protocol" }

        "CreateGameRequest.gamePingSiteAlias"                                = { attrName = "PING_SITE_ALIAS", default = "bio-iad" }

      // Various gameplay attributes you want the tournament provider to supply:
      // * Alternatively, you can leave the attributes fixed, and have different templates for the different modes you support.
        "CreateGameRequest.gameCreationData.gameName"                        = { attrName = "GAME_NAME",              default = "" }
        "CreateGameRequest.gameCreationData.gameAttribs[mode]"               = { attrName = "GAME_MODE",              default = "Deathmatch" }
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"       = { attrName = "PLAYER_CAPACITY",        default = 8 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"               = { attrName = "PLAYER_CAPACITY",        default = 8 }
        "CreateGameRequest.gameCreationData.teamIds"                         = { attrName = "TEAM_IDS",               default = [1,2] }

      // Disconnect and reservation timeouts should be long enough to allow matches to persist with only reservations, until they can be removed.
        "CreateGameRequest.gameCreationData.playerReservationTimeout"        = { default = "20d" } // To help ensure cleanup, for instance set default to max tournament duration.
        "CreateGameRequest.gameCreationData.disconnectReservationTimeout"    = { attrName = "DISCONNECT_RESERVATION_TIMEOUT", default = "8d" } // To help ensure cleanup, set to max active game duration.

      // For Xbox:
#if PLATFORM == "xone" || PLATFORM == "xbsx" || XPLAY_HOST_XONE == "1" || XPLAY_HOST_XBSX == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.xone.templateName"          = { default = "BlazeSampleTournament" }
#endif
      // For PS5:
#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { default = "BlazeSampleActivityWithScore" }
#endif
    }
}

// Game group with a game server external owner
"gameserverOwnedGroup" = {
    baseRequest = {
        commonGameData = { gameType = "GAME_TYPE_GROUP" }
        gameCreationData = { 
            networkTopology = "NETWORK_DISABLED"

            // If true, the game's creator will be omitted from the player roster, game persists as long as the creator's user session exists.
            isExternalOwner = true

            gameSettings = ["openToMatchmaking", "openToBrowsing", "openToJoinByPlayer", "openToInvites", "joinInProgressSupported"]
         }
    }
    attributes = {
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]" = { attrName = "PLAYER_CAPACITY", default = 4 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"              = { attrName = "PLAYER_CAPACITY", default = 4 }
        "CreateGameRequest.gameCreationData.skipInitializing"               = { attrName = "SKIP_INITIALIZING", default = true } //to GAMEGROUP_INITIALIZED
        "CreateGameRequest.gamePingSiteAlias"                               = { attrName = "PING_SITE_ALIAS" } // game server should specify its ping site
        "CreateGameRequest.commonGameData.gameProtocolVersionString"        = { attrName = "DESIRED_PROTOCOLVERSION", default = "match_any_protocol" }
    }
}





#if PLATFORM == "ps5" || XPLAY_HOST_PS5 == "1"

// Example for handling the PS5 UX boot to new create-or-join game flow.
"createOrJoinByPlayerSessionId" = {

    // set the createRequestType to CREATE_OR_JOIN_GAME
    createRequestType = "CREATE_OR_JOIN_GAME"

    attributes = {
    
        // Expose the gameCreationData.externalSessionIdentSetup.ps5.playerSession.playerSessionId as a template attribute, which the client sets to the PS5 generated PlayerSessionId it recieved with the launchMultiplayerActivity GameIntent event.
        // Blaze internally automatically creates a persistedGameId for the request, based on the playerSessionId. Note: The value of CreateGameRequest.persistedGameId if set/passed up from client will not be used.
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.playerSession.playerSessionId" = { attrName = "PS5_PLAYER_SESSION_ID", isOptional = false }

        // For PS5: To enable presence in Activities UX
        "CreateGameRequest.gameCreationData.externalSessionIdentSetup.ps5.match.activityObjectId" = { attrName = "PS5_ACTIVITY_ID", default = "BlazeSampleActivityWithScore" }
        
        // Include the game report type, to ensure your game report collation timeout handling which may cleanup/cancel PS5 Matches works:
        "CreateGameRequest.gameCreationData.gameReportName" = { attrName = "GAME_REPORT_NAME", default="integratedSample"}

        // (Other settings configured as needed):        
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]" = { attrName = "PLAYER_CAPACITY",     default = 8 }
        "CreateGameRequest.gameCreationData.slotCapacitiesMap[SLOT_PUBLIC_SPECTATOR]"   = { attrName = "SPECTATOR_CAPACITY",  default = 2 }
        "CreateGameRequest.gameCreationData.maxPlayerCapacity"                          = { attrName = "MAX_PLAYER_CAPACITY", default = 32 }
        "CreateGameRequest.gameCreationData.gameSettings[openToInvites]"            = { default = 1 }// Bitfields can be set indvidually with Attributes (Only overwrites the specified field)
        "CreateGameRequest.gameCreationData.gameSettings[openToJoinByPlayer]"       = { default = 1 }
        "CreateGameRequest.gameCreationData.gameSettings[joinInProgressSupported]"  = { attrName = "IS_JOIN_IN_PROGRESS_SUPPORTED",   default = 1 }
        "CreateGameRequest.gameCreationData.gameSettings[openToBrowsing]"           = { attrName = "IS_OPEN_TO_BROWSE",   default = 1 }
        "CreateGameRequest.gameCreationData.gameSettings[openToMatchmaking]"        = { attrName = "IS_OPEN_TO_MATCHMAKING",   default = 1 }
        "CreateGameRequest.gameCreationData.gameSettings[hostMigratable]"           = { attrName = "IS_HOST_MIGRATABLE",   default = 1 }
        "CreateGameRequest.gameCreationData.gameAttribs[mode]"  = { attrName = "GAME_MODE", default = "1" }   // a mode is required
        "CreateGameRequest.gameCreationData.gameName"           = { attrName = "GAME_NAME",  default = "PS5 UX LAUNCHED NEW GAME" }
        "CreateGameRequest.commonGameData.gameType"             = { attrName = "GAME_TYPE",  default = "GAME_TYPE_GAMESESSION" }
        "CreateGameRequest.gameCreationData.networkTopology"    = { attrName = "NET_TOPOLOGY",  default = "CLIENT_SERVER_PEER_HOSTED" }
    }
}
#endif

