// EXAMPLES. CAN BE REMOVED - RECOMMEND COMMENTING OUT #include in scenarios.cfg rather than editing this file

// Examples:
// simpleQuickMatch just tries to find or create a game with a given number of players, and a given size.
//   It includes the standard rules for finding good hosts, preferring nearby games, and making a game.
//   It does only includes the required game mode attribute, and does not specify scenario attributes for topologies (using the defaults).
//
//   The scenario is split into two subsessions, with the create game subsession starting after 7s, when the find game subsession has fully decayed.
//   NOTE: Subsessions start decayed, so in this example the quickMatchSessionCG will start with its rule thresholds at time 7s.

"simpleQuickMatch" = {
    totalDuration = "15s"

    Variants = {
        "A" = { subSession = ["quickMatchSessionFG", "quickMatchSessionCG"] }
        "CG_only" = { subSession = ["quickMatchSessionCG"] }
        // Criteria can be used to choose between variants based on various census/request data.  See the Blaze Developer docs for more details!
        // "LongTimeToMatch" = { subSession = ["quickMatchSessionFG"], criteria = "ttm > '15s'" }
    }

    defaultVariant = "A"                         // default variant to use. Use "A" if not specified.
    // triggerId = "3001"   // The trigger id is the recommendation type set up in EADP EM server and used for A/B testing. If set, scenario matchmaking will request variants from reco server.
    // userVariants = { 1000106565419 = "A",   1000024761751 = "CG_only" }   // User BlazeIds map to particular variant. Debugging purpose.
    
    subsessions = {
        
        "quickMatchSessionFG" = {                         // Sub session names are arbitrary. Displayed via GOSCC.
            
            rulesList = [ "normalHostViability",    // Prefer hosts with open NAT 
                          "normalPlayerCountRule"   // Find a game with the desired number of players (~4)
                        ]         

            matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                sessionMode = "FindGame"
            }
        },

        "quickMatchSessionCG" = {                        
            
            sessionStartTime = "7s"         // We delay by 7s, so that the FG subsession will have time to fully decay its rules (which decay in 5s).
            // sessionEndTime = "10s"       // If we do not set an early end time, the subsession will run until the end of the scenario's totalDuration. 

            rulesList = [ "normalHostViability",    // Prefer hosts with open NAT 
                          "normalPlayerCountRule",   // Find a game with the desired number of players (~4)
                          "createGameTotalPlayerSlotsRule" 
                        ]
 
            matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                sessionMode = "CreateGame"
            }

            // The CreateGameTemplate will be used as the basis for the create game request:
            createGameTemplate = "basicGame"

            // Scenarios can still set attributes to override what is in the createGameTemplate
            createGameAttributes = {
                // In the template, the mode is fixed, but we can override it with an attribute in the Scenario:
                "GameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }
            }
        }
    }
}

// findGameByMapAndMode just tries to find a game with a given number of players, and a given map and mode.
//   Unlike the single-string game attributes, the Rules' desired map and mode settings are lists, allowing you to specify multiple acceptable settings.

"findGameByMapAndMode" = {
    totalDuration = "30s"
    subsessions = {
        "findGameSession" = {                       

            rulesList = [ "normalHostViability",     // Prefer hosts with open NAT 
                          "normalPlayerCountRule",   // Find a game with the desired number of players (~4)
                          
                          "findGameModeRule",        // Find via game mode: 
                          "findGameMapRule"         // Find via game map: 
                        ]
 
            matchmakingSettings = {                         
                sessionMode = "FindGame"           // Just finding the game
            }
        }
    }
}

// The scenario tries to create a simple CSD game using game packer. 
// Game packer will try to maximize the number of players in the game (minimum viable game is a 2-player game).
"packerSimpleGameCSD" = {
    totalDuration = "15s"

    inputSanitizers = [
        "pingSiteSanitizer",
        "desiredProgressSanitizer"
    ]

    subsessions = {

        "PackerSubsession" = {                    

            filtersList = [
                "participantCapacityFilter",
                "platformFilter"
            ]

            matchmakingSettings = {
                sessionMode = []
            }

            createGameTemplate = "simplePackerGameCSD"
        }
    }
}


// The scenario tries to create a simple game using game packer. 
// Game packer will try to maximize the number of players in the game (minimum viable game is a 2-player game).
"packerSimpleGame" = {
    totalDuration = "15s"
    
    inputSanitizers = [
        "pingSiteSanitizer"
    ]

    subsessions = {

        "PackerSubsession" = {                    

            filtersList = [
                "sampleModeFilter",
                "sampleMapFilter",
                "participantCapacityFilter",
                "platformFilter"
            ]

            matchmakingSettings = {
                sessionMode = []
            }

            createGameTemplate = "simplePackerGame"
        }
    }
}

// fullCreateGame tries to create a game with a given number of players, and a given size.
//   It includes more settings for allowing Topology and the GameSettings to be changed. 

"fullCreateGame" = {
    totalDuration = "15s"
    subsessions = {
        
        "quickMatchSession" = {                         // Sub session names are arbitrary. Displayed via GOSCC.

            rulesList = [ "normalHostViability",        // Prefer hosts with open NAT 
                          "normalPlayerCountRule",      // Find a game with the desired number of players (~4)
                          "createGameTotalPlayerSlotsRule",
                          "expandedPingSiteRule_any",   // A pingsite rule (even match any) has to be enabled in order to choose dedicated servers (rather than just using the host's best pingsite)

                          "avoidPlayersRuleByBlazeId" 
                        ]
 
            matchmakingSettings = {
                sessionMode = "CreateGame"
            }

            // The CreateGameTemplate will be used as the basis for the create game request:
            createGameTemplate = "fullCreateGame"
        }
    }
}


// quickMatchFillLobby - This is an example of how to use multiple subsessions to effiecently fill up game lobbies. (ex. Battlefront)
//
//   It performs 3 stages: 
//   * First it joins any available game lobbies (perferring fuller lobbies)
//   * Then (if no lobbies exist) it joins any available games (perferring fuller games)
//   * Finally, if no lobbies exist, and no non-full games exist, then it creates a new lobby.
//   (With this sequence, we ensure that lobbies are only created when all games are full, and the lobbies are filled as quickly as possible.)
// 
//   This scenario assumes that the GAME_MODE value ('mode') is set to 0 when the game is in a lobby state, and changes to 1 or higher when the game is being played.

"quickMatchFillLobby" = {
    totalDuration = "15s"
    subsessions = {
        
        // First, fill up any lobbies that exist:
        "fillLobbySubsession" = {                     
            
            // sessionEndTime = "30s"  // We don't set an end time for this rule, because we want it to last the full session duration.

            rulesList = [ "findAnyPlayerCountRule", // Accept any size lobby, preferring full ones
                          "findGameLobby"           // Only accept lobbies
                        ]
 
            matchmakingSettings = {
                sessionMode = "FindGame"
            }
        },

        // Second, fill up any games that exist:
        "fillNonEmptyGamesSubsession" = {                     

            // We only need to delay by a short amount of time because the check for lobbies should be very fast                   
            sessionStartTime = "1s"

            rulesList = [ "normalHostViability",    // Prefer hosts with open NAT 
                          "findAnyPlayerCountRule", // Accept any size game, preferring full ones
                          "findGameNotLobby"        // Only accept lobbies
                        ]
 
            matchmakingSettings = {
                sessionMode = "FindGame"
            }
        },

        // Finally, create a new game lobby, if no non-full games exist:
        "createNewLobby" = {                        
            
            // Delay until right before the end of the scenario:
            sessionStartTime = "14s"

            // Since we're creating an empty game lobby at this point, we don't need any rules except the total player slots rule:
            rulesList = [ "createGameTotalPlayerSlotsRule" ]
 
            matchmakingSettings = { 
                sessionMode = "CreateGame"
            }

            createGameAttributes = {
                "GameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 8 }       // Max Capacity the game can be set to.
                "GameCreationData.networkTopology"        = { default = "CLIENT_SERVER_PEER_HOSTED" }
                "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                        "openToMatchmaking", 
                                                                        "openToInvites", 
                                                                        "openToJoinByPlayer",
                                                                        "joinInProgressSupported",
                                                                        "hostMigratable",     
                                                                        "allowAnyReputation"] }
                "GameCreationData.externalSessionIdentSetup.xone.templateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }

                "GameCreationData.gameAttribs[mode]"   = { default = "0" }   // Set the mode to 0 to indicate a lobby
                "GameCreationData.gameAttribs[ISmap]"  = { default = "1" }   // Optional Example - Additional game attributes
            }
        }
    }
}


// When running multiple subsessions, sometimes you may want to enable or disable the subsessions depending
// In this example, we first attempt to find games with the desired mode (GAME_MODE_DESIRE), then if no games exist we attempt to create a game.
// The Client is expected to split the (GAME_MODE_DESIRE) list into (BIG_GAME_MODE_DESIRE) and (SMALL_GAME_MODE_DESIRE) lists, and send all three up in the request.
// If either the BIG or SMALL desired values are missing, then we will cleanly skip that subsession, and the scenario will not register an error.
"selectiveSubsessions" = {
    totalDuration = "5s"
    subsessions = {

        // First try to find games in the combined modes: 
        "findAnySizeGame" = {                     
            rulesList = [ "findAnyPlayerCountRule", "findGameModeRule" ]
            matchmakingSettings = { sessionMode = "FindGame" }
        },

        // Then try to create a Big or Small game. 
        // Both of these succeed at the same time, so the result will be random as to which game is chosen.
        "createBigGame" = {                        
            sessionStartTime = "3s"
            skipSubSessionIfNotSetAttributes = [ "BIG_GAME_MODE_DESIRE" ]    // Only create a 40 player game if BIG_GAME_MODE_DESIRE is set.

            rulesList = [ "createBigGameTotalPlayerSlotsRule", "findBigGameModeRule" ]
            matchmakingSettings = { sessionMode = "CreateGame" }

            createGameAttributes = {
                "GameCreationData.maxPlayerCapacity"      = { default = 40 }       // Max Capacity the game can be set to.
                "GameCreationData.networkTopology"        = { default = "CLIENT_SERVER_PEER_HOSTED" }
                "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                        "openToMatchmaking", 
                                                                        "openToInvites", 
                                                                        "openToJoinByPlayer",
                                                                        "joinInProgressSupported",
                                                                        "hostMigratable",     
                                                                        "allowAnyReputation"] }
                "GameCreationData.externalSessionIdentSetup.xone.templateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
                "GameCreationData.gameAttribs[ISmap]"  = { default = "1" }
            }
        }

        "createSmallGame" = {                        
            sessionStartTime = "3s"
            skipSubSessionIfNotSetAttributes = [ "SMALL_GAME_MODE_DESIRE" ]    // Only create a 20 player game if SMALL_GAME_MODE_DESIRE is set. 
            
            rulesList = [ "createSmallGameTotalPlayerSlotsRule", "findSmallGameModeRule" ]
            matchmakingSettings = { sessionMode = "CreateGame" }

            createGameAttributes = {
                "GameCreationData.maxPlayerCapacity"      = { default = 20 }
                "GameCreationData.networkTopology"        = { default = "CLIENT_SERVER_PEER_HOSTED" }
                "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                        "openToMatchmaking", 
                                                                        "openToInvites", 
                                                                        "openToJoinByPlayer",
                                                                        "joinInProgressSupported",
                                                                        "hostMigratable",     
                                                                        "allowAnyReputation"] }
                "GameCreationData.externalSessionIdentSetup.xone.templateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
                "GameCreationData.gameAttribs[ISmap]"  = { default = "1" }
            }
        }
    }
}
