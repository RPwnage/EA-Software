// matchmaker config file
matchmakerSettings = {

// We do not put the class name here because gamemanager.cfg needs to include this data as 'gamemanager.matchmakerSetting = {', 
//  so that gamemanager can still conditionally override other pieces of data. 
// matchmakerSettings = {
    activeSessionShardingThreshold = 500
    
    // FIFA profile uses default unspecified idlePeriod. For create game processing heavier rules
    // using teams based finalization (e.g. MOBA's), override with a longer idle period to help avoid thrashing.
    // idlePeriod = "250ms"

    #include "component/gamemanager/custommatchmakingrules.cfg"     
    
    gameSizeRange = {min = 0, max = 128} //128 for bigger games //max should be the maximum game size this title supports in any mode.
  
    // Salience -- rules are evaluated in the order presented in the salience config.
    // defined rules not present in the list are processed at the end of the list in order of definition
    // any rules not in this list generate a warning on server startup
    // rules in this list not defined in the rules block cause the mm config to fail
    // NON-rete rules are always evaluated after RETE rules for find game matchmaking and gamebrowser, regardless of position in this list.
    // 
    // RETE performance is a trade off of memory for speed.  That speed however is effected in two ways.  The speed we can process
    // a match per session, and the speed we can update facts about games.  Moving rules like GameSize which update often to the top of the list
    // will speed up our fact updates.  At the same time, rules with large numbers of possible values (arbitrary rules) can widen the tree if
    // put too close to the top, which could degrade speed while matching a session.
    ruleSalience = {
        salienceList = [
            "Predefined_GameStateRule",        
            "Predefined_GameSettingsRule", 
            "Predefined_GameSizeRule", 
            "Predefined_TeamSizeRule",
            "Predefined_RankedGameRule",
			"Predefined_VirtualGameRule",
            "Predefined_PseudoGameRule",
            "Predefined_ExpandedPingSiteRule",
            "OSDK_gameMode",
            "OSDK_rosterVersion",
            "OSDK_categoryId",
            "OSDK_sponsoredEventId",
            "OSDK_arenaChallengeId",
            "gameSpeed",
            "gamePoints",
            "skillLevel",
            "teamSkillAvgBalanceRule",
            "dnfPercent",
            "clubSkillLevel",
            "DNF_Rule",
            "Predefined_HostBalancingRule",
            "Predefined_HostViabilityRule",
            "OSDK_coop",
            "OSDK_playerMyTeam",
            "OSDK_playerOppTeam",
            "OSDK_playerMyTeamAnyBoost",
            "OSDK_playerOppTeamAnyBoost",
            "OSDK_ChlngrClubId",
            "OSDK_clubId",
            "OSDK_clubIdInverse",
            "OSDK_clubGamegroupSize",
            "OSDK_clubLeagueId",
            "OSDK_clubIsDDP",
            "OSDK_language",
            "OSDK_tourTeamIdInverse",
            "OSDK_tourId",
            "OSDK_tourTier",
            "geoLocationRule",
            "Predefined_GameNameRule"
       ]
    }

    rules = {
        // predefined player count preference rule (min/max requirements & desired game player count preferences)
        //
        // The Player Count rule defines how to match entities (user or groups) based upon the
        // number of players in the game or the size of the group.  More information can be found on
        // how this rule is evaluated in playercountrule.h.
        // 
        // The acceptable range of values that this rule operates on is in the gameSizeRange above
        // Any value outside of this range is clamped to the min/max accordingly.
        // The amount of system memory consumed is directly proportional to
        // the product of the series of the range of this rule.
        // Take care to only specify the range that contains the game sizes usable by your title.
        //
        // fitFormula is the formula used to calculate the fit score between two
        // values, your session's calculated value against another session's
        // or game's calculated value.  This allows for for different values
        // to have more preference as the range expands.
         // FIT_FORMULA_GAUSSIAN
        // fitFormula = {name = FIT_FORMULA_GAUSSIAN, params = {fiftyPercentFitValueDifference = 200}}
        // 
        // Uses the gaussian formula to determine the fit.
        // 
        // params
        // fiftyPercentFitValueDifference is the difference between two values that yeilds a 
        // 0.5 fit percent.  This value controls the width of the bell curve used to calculate the
        // fit percent between 2 entities.
        // 
        // Below is a table of examples given a fiftyPercentFitValueDifference of 200.
        //
        // Fit Score : Difference
        //       1.0 : +/- 0 (exact match)
        //       .90 : +/- 77
        //       .75 : +/- 128
        //       .50 : +/- 200
        //       .25 : +/- 282
        //       .10 : +/- 364
        //       .00 : INFINITE (match anything)
        //
        //      At heart, we're evaluating: fit percent = e^( - ((x-b)^2 / (c * 1.2011225)^2 )) where
        //          (x - b) is the difference between the two entities
        //          c is the fiftyPercentFitValueDifference which determines the width of the bell curve.
        //
        // NOTE: see gaussianfunction.h GausianFunction.calculate for the implementation.
        //
        // FIT_FORMULA_LINEAR
        // fitFormula = {name = FIT_FORMULA_LINEAR, params = {minFit=0.0, maxFit=1.0, minVal=10, maxVal=10}}
        // 
        // Uses a linear function starting at the desired value to +maxVal and -minVal using
        // minFit and maxFit to determine the slope.
        //
        // Anyvalues outside of +maxVal and -minVal have value minFit.
        //
        // minFit defaults to 0.0
        // maxFit defaults to 1.0
        // minVal defaults to the smallest minValue of all lists in the rangeOffsetList [minValue, maxValue]
        // maxVal defaults to the largest maxValue of all lists in the rangeOffsetList [minValue, maxValue]
        //
        // FIT_FORMULA_BINARY
        // fitFormula = {name = FIT_FORMULA_BINARY}
        //
        // Uses a binary comparison.  If it is in the range offset 1.0 perfect match
        // if it is not in range then then NO_MATCH.
        //
        // rangeOffsetLists are lists of ranges that can be used by the client
        // to determine the sessions "acceptable value range".  The range works
        // against the calculated UED value or the search value specified by
        // the client.
        // Syntax of the rangeOffsetList:
        // decay = [{ t=0, offset = [100,100]}, { t=5, offset = [200,200]}, { t=10, offset = [INF]}]
        //
        // t is the time since this session has started searching; +0, +5, +10.
        // offset is the acceptable offset around the desired value that indicates
        // a match; +/-100, +/-200, +/-INF.  Offsets don't have to be symetric
        // and if only one value is specified, that value will be used for both the + and - Value.
        // The first value in the offset is the negative expansion, while the second is the positive expansion.
        //
        // Acceptable well known values are
        //   EXACT_MATCH_REQUIRED = 0
        //   INF = infinity (min or max range)
        //
        Predefined_PlayerCountRule = {
            weight = 10000
            fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 2}}

            rangeOffsetLists = [    
                 //values are clamped by the min and max player counts specified in the matchmaking request and gameSizeRange above.
                 { name = "testDecay",         rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"]}, { t=5, offset=[2,2]}] }
                 { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                 { name = "OSDK_matchRelax", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"]}, { t=2, offset=[22,22]}] }
                 { name = "OSDK_matchAny",   rangeOffsets = [{ t=0, offset=["INF"]}] }
                 { name = "ILT_4v4_matchRelax", rangeOffsets = [{ t=0, offset=[2,0]}, { t=2, offset=[22,0]}] }
            ]
        }

        // predefined rule matchmaking via the total player slot count of games (including public, private, filled or free).
        // For use with PlayerCountRule or PlayerSlotUtilizationRule.
        //
        Predefined_TotalPlayerSlotsRule = {
            weight = 10000
            fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 2}}

            rangeOffsetLists = [    
                 //values are clamped by the min and max player counts specified in the matchmaking request and gameSizeRange above.
                 { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                 { name = "OSDK_matchRelax", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"]}, { t=2, offset=[22,22]}] }
                 { name = "OSDK_matchAny",   rangeOffsets = [{ t=0, offset=["INF"]}] }
            ]
        }
        
        // predefined rule matching percent of the total slots in games that would be filled by players
        //
        Predefined_PlayerSlotUtilizationRule = {
            weight = 10000
            fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 200}}
        
            rangeOffsetLists = [
                 { name = "desiredOrMore", rangeOffsets = [{ t=0, offset=[0,"INF"]}, { t=5, offset=[25,"INF"]}, { t=10, offset=[50,"INF"]} { t=15, offset=["INF","INF"]}] }
                 { name = "desiredOrLess", rangeOffsets = [{ t=0, offset=["INF",0]}, { t=5, offset=["INF",25]}, { t=10, offset=["INF",50]} { t=15, offset=["INF","INF"]}] }
                 { name = "matchAny", rangeOffsets = [{ t=0, offset=["INF"]}] }
                 { name = "testDecay", rangeOffsets = [{ t=0, offset=[0,0]}, { t=5, offset=[20,20]}, { t=10, offset=["INF"]}] }
            ]
        }
        
        // [DEPRECATED] game size preference rule (min/max requirements & desired game size preferences)
        // This deprecated rule provides functionality of PlayerCountRule and TotalPlayerSlotsRule, minus TotalPlayerSlotsRule's 
        // separate weight, fitFormula, and rangeOffsetList options for matchmaking by the total slots in game.
        // GameSizeRule cannot be used together with either PlayerCountRule nor TotalPlayerSlotsRule, in matchmaking or game browser requests.
        //
        Predefined_GameSizeRule = {
            weight = 10000
            //
            // OSDK: Ping does only do exact or any matches, specified by threshold
            //
            range = { min = 2, max = 22 } //max should be the maximum game size this title supports in any mode.
            fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 22}}
            rangeOffsetLists = [
              //values are clamped by the min and max player counts specified in the matchmaking request and the range specified above.
              { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
              { name = "OSDK_matchRelax", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"]}, { t=1, offset=[22,0]}] }
              { name = "OSDK_matchAny",   rangeOffsets = [{ t=0, offset=["INF"]}] }
            ]
	    }

        // predefined TeamSizeRule
        // The TeamSizeRule is a counterpoint to the gameSizeRule.  It allows a title to specify
        //   the number of teams in a game as well as size requirements for each team.
        //
        //  Titles typically enable/use either the GameSizeRule or the TeamSizeRule.  While the rules aren't mutually exclusive, they both deal
        //    with the distribution of players in a game and overlap to a large degree.  If both are enabled, the team size rule is the one that
        //    determines the game size when creating the game (game size is the sum of all the team capacities).
        //
        // Unlike other rules, the team size rule does not have a minFitThreshold.  Instead, you specify a set of "rangeOffsetLists" which
        //  have a similar function as the minFitThreshold lists for other rules.
        //      The format is:
        //      { name = <listName>, rangeOffsets = [{ t=<time>, offset=[<minAcceptableSizeOffset>, <maxAcceptableSizeOffset>] }, ...] }
        //      Ex: { name = exampleList,      rangeOffsets = [{ t=0, offset=[EXACT_MATCH_REQUIRED]}, { t=5, offset=[2,2]}, { t=10, offset=[10,10]}] }
        //
        //  The teamSizeRule will match a team that falls inside the rule's "acceptable size range".  This range is built
        //      using the rule's rangeOffsetList and the min, max, and desired sizes sent up by the client.
        //      The acceptable range is the inclusive range from (desiredValue + minOffset) to (desiredValue + maxOffset).
        //      This range is clamped to the min/max values sent up by the client.
        //          For example:
        //           client sends up: min: 2, max:10, desired: 5, listName = "exampleList"
        //             at time 0, we only match teams with 5 players
        //             at time 5, we match teams between 3 and 7 players (desired value +/- 2)
        //             at time 10, we match teams between 2 and 10 players (desired value +/- 10, but clamped to my min/max values)
        //
        //  The rule calculates a fitPercent using a simple linear ramp from the min/max to the desired value.
        //
        // Predefined_TeamSizeRule = {
        //     weight = 10000
        //     rangeOffsetLists = {
        //         requireExactMatch = [ 0:0..0 ]
        //         testDecay = [ 0:0..0, 5:-2..0, 10:-10..0 ]
        //     }
        //     maxNumTeamsInGame = 3
        // }
        // ***** Note: OSDK does not currently expose this functionality *****
        Predefined_TeamSizeRule = {
            weight = 10000
            rangeOffsetLists = [
                { name = "requireExactMatch", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                { name = "testDecay",      rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"]}, { t=5, offset=[2,0]}, { t=10, offset=[10,0]}] }
            ]
            
            // Max number teams (per game) session can specify to search for. Higher values can decrease RETE search performance
            // Any games created with more than this number will not be found by matchmaking
            maxNumTeamsInGame = 2
        }

        // ILT note: TeamBalanceRule and TeamMinSizeRule would typically not be used alongside TeamCompositionRule
        // The TeamBalanceRule replaces the TeamSizeRule.  It allows a title to specify the maximum imbalance allowed when joining a game. 
        //   Imbalance is the difference between the size of the largest team, and the smallest team, after your group would join. 
        //   The acceptable balance value can be set to decay from the desired value over time, using a rangeOffsetList.
        //     Do not use "EXACT_MATCH_REQUIRED", as it prevents joining a games with imbalance less than the desired value.
        // NOTE: If the team count is 1, then this rule will allow any game to be joined.
        // (The TeamCountRule can be used to specify the number of teams when joining or creating a game, default is 1).
        // (The TeamChoiceRule can be used to specify your team choice when joining or creating a game, default is ANY_TEAM_ID).
        Predefined_TeamBalanceRule = {
            weight = 10000
            fitFormula = { name = "FIT_FORMULA_LINEAR" }

            rangeOffsetLists = [
                { name = "requireExactMatch", rangeOffsets = [{ t=0, offset=[0] }] }
                { name = "testDecay", rangeOffsets = [{ t=0, offset=[0]}, { t=10, offset=[2]}] }
            ]
        }
        
        // The TeamMinSizeRule replaces the TeamSizeRule.  It allows a title to specify the smallest sized team allowed when joining a game. 
        //   Games will not be created until every team has at least the minimum allowed value.
        //   The acceptable minimum value can be set to decay from the desired value over time, using a rangeOffsetList.
        //     Do not use "EXACT_MATCH_REQUIRED", as it prevents joining a games with team sizes greatr than the desired minimum.
        // (The TeamCountRule can be used to specify the number of teams when joining or creating a game, default is 1).
        // (The TeamChoiceRule can be used to specify your team choice when joining or creating a game, default is ANY_TEAM_ID).
        Predefined_TeamMinSizeRule = {
            weight = 10000
            fitFormula = { name = "FIT_FORMULA_LINEAR", params = {minFit=0.0, maxFit=1.0, minVal=0, maxVal=10}}

            rangeOffsetLists = [
                { name = "requireExactMatch", rangeOffsets = [{ t=0, offset=[0] }] }
                { name = "testDecay", rangeOffsets = [{ t=0, offset=[0]}, { t=5, offset=[2]}, { t=10, offset=[5]}] }
            ]
        }

        // predefined game ranking preference rule (ranked/unranked game preferences).
        // instead of a fitTable, we provide the fitPercents for matches (ranked/ranked) and non-matches (ranked/unranked)
        // abstain & random are valid values, and are considered matches to either ranked or unranked
        Predefined_RankedGameRule = {
            votingMethod = "VOTE_PLURALITY"
            matchingFitPercent = 1.0
            mismatchFitPercent = 0
            weight = 100
            minFitThresholdLists = {
                OSDK_matchExact = ["0:EXACT_MATCH_REQUIRED"]
                OSDK_matchAny = ["0:0.0"]
            }
        }

        // predefined game virtualized preference rule - checks the game setting flag 'isVirtualized'
        // Only operates in find game mode, as all games created by MM are 'standard'
        // instead of a fitTable, we provide the fitPercents for matches (virtualized/virtualized) and non-matches (virtualized/standard)
        // abstain is a valid values, and are considered matches to either virtualized or standard
        // ***** Note: OSDK does not currently expose this functionality *****
        Predefined_VirtualGameRule = {
            matchingFitPercent = 1.0
            mismatchFitPercent = .5
            weight = 1000
            minFitThresholdLists = {
                requireExactMatch = [ "0:EXACT_MATCH_REQUIRED" ]
                testDecay = [ "0:1.0", "5:.5" ]
            }
        }

        // predefined QoS HostBalancing rule
        // This rule groups good game hosts with bad game hosts (as determined by Network QOS info).
        // The goal is to ration the 'good' hosts and distribute them amongst the bad hosts so that
        // all game members can connect to each other (according to the game's network topology).
        //    NOTE: this rule is ignored during FindGame matchmaking session evaluation; it only applies
        //          to CreateGame matchmaking sessions.
        //
        // The rule has 3 literals used in the minFitThreshold lists:
        //     HOSTS_STRICTLY_BALANCED: 1.0  (good host matched with a bad host)
        //     HOSTS_BALANCED: 0.5  (good host matched with a bad or moderate host)
        //     HOSTS_UNBALANCED: 0.0  (bad hosts are grouped together)
        //
        //  Per email with Al Mundy of Microsoft, this matchmaking rule should not impact compliance with Xbox 360 TCR # 098:
        //  "As long as players with a  strict NAT are able to play online, this is fine. Strict-Strict matches are not required."
        //  Allowing this rule to decay to HOSTS_UNBALANCED can result in players that are unable to connect to each other matching
        //  in create game mode. Titles must allow players with strict NATs to play online, but we can configure matchmaking to prevent
        //  them from matching each other or hosting a game session by only decaying this rule to the HOSTS_BALANCED threshold.
        // ***** Note: OSDK does not currently expose this functionality *****
        //
        Predefined_HostBalancingRule = {
            weight = 1000
            minFitThresholdLists = {
                hostBalancing = [ "0:HOSTS_STRICTLY_BALANCED", "1:HOSTS_BALANCED" ]
                matchAny = [ "0:HOSTS_UNBALANCED" ]
            }
        }

        // The HostViabilityRule is a special case, it behaves slightly differently for FindGame and CreateGame matchmaking sessions.
        //  For full mesh peer to peer games, which can have at most 1 player with a strict firewall, this rule attempts to limit
        //      the number of strict connections in a game.
        //  For peer hosted topologies, the goal is to ration the 'good' hosts and distribute them amongst the bad hosts so that
        //      all game members can connect to each other (according to the game's network topology).
        //  During findGame the rule evaluates your ability to connect to a game (the viability of connection to the game host)
        //      We compare your NAT type (firewall type) against the game's NAT type, allowing you to avoid games you're
        //      unlikely to connect to.
        //  For createGame matchmaking sessions, the rule is only evaluated _after_ all of the players have been collected.  The
        //      rule acts like a filter, only allowing the matchmaking session to create a game if at least 1 player
        //      is a viable host (for the other players to connect to).
        //
        //    The rule has 4 tiers of fitScore:
        //            CONNECTION_ASSURED: 1.0
        //            CONNECTION_LIKELY: 0.75
        //            CONNECTION_FEASIBLE: 0.5
        //            CONNECTION_UNLIKELY: 0.25
        //    
        //    The rule is satisfied when at least 1 of the matched players (including the matchmaking session creator)
        //        has a NAT type (aka Network Address Translation / firewall type) that allows other players to connect.
        //
        //    For example, Let's say I'm behind a strict firewall and trying to create a 3 player peer hosted client server game.
        //       If I've matched 2 other players, the session's gameSize is satisfied and it could try to create a game.
        //        However, we must also satisfy the hostViability rule; if the other two players are also behind strict firewalls,
        //        the matchmaker will continue looking for other players (until the hostViability rule decays), since none of us
        //        are viable hosts.
        //
        //    The relationship between the NAT type and threshold fitscore is:
        //            OPEN to Any NAT Type ---> CONNECTION_ASSURED
        //            MODERATE to MODERATE ---> CONNECTION_LIKELY
        //            MODERATE to STRICT   ---> CONNECTION_FEASIBLE (possible on PS3 or PC where opens are often classified as moderate)
        //            Any other NAT Type combinations ---> CONNECTION_UNLIKELY
        //
        //    Note: this rule can also be customized in the blazeServer code if you want to check the host's bandwidth.
        //        (ex, if your title might require the host to have 1024kbps up in order to host a 32 player game)
        //        See MatchmakingCriteria::isViableGameHost in <blazeServerRootDir>/component/gamemanager/matchmaker/matchmakingcriteria.h
        //
        Predefined_HostViabilityRule = {
            weight = 100
            minFitThresholdLists = {
                OSDK_connAssured = ["0:CONNECTION_ASSURED"]
                OSDK_connLikely = ["0:CONNECTION_LIKELY"]
                OSDK_connFeasible = ["0:CONNECTION_FEASIBLE"]
                OSDK_connUnlikely = ["0:CONNECTION_UNLIKELY"]
            }
        }

        // The ExpandedPingSiterule does CreateGame and FindGame based on the latency to ping sites (data centers). Client side will try to ping QOS latency servers
        // (configured in qossettings.cfg) one by one to retrieve latency for each server as soon as a user logged in. A latency map keyed by server alias
        // is maintained in UserExtendedData for each user, which gets updated every time a QOS latency server ping happens.
        // During FindGame -
        //    The rule evaluates your set of data centers ("best" and all other DCs with latency under the current decay range offset) and attempts to find an existing game
        //    in one of those DCs. For groups of players, the latency value used to determine "best" and other DCs can be controlled via scenario attribute.
        // During CreateGame -
        //    The rule evaluates your set of data centers ("best" and all other DCs with latency under the current decay range offset) against other Matchmaking sessions
        //    in an attempt to find sessions that match one or more of your data centers. For groups of players, the latency value used to determine "best" and other DCs
        //    can be controlled via scenario attribute. How a match is determined can also be controlled via scenario attribute.
        //    When creating dedicated server games via Matchmaking, this rule can control (via scenario attribute) which data center
        //    (if multiple matches are available) the game will be hosted in.

    Predefined_ExpandedPingSiteRule = {
         weight = 10000
         fitFormula = {name = "FIT_FORMULA_LINEAR", params = {maxVal=1000}}
         rangeOffsetLists = [
                { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                { name = "OSDK_matchRelax", rangeOffsets = [{ t=0, offset=[100]}, { t=5, offset=[200]}] }
                { name = "OSDK_matchAny",   rangeOffsets = [{ t=0, offset=["INF"]}] }
            ]
    }
        // geoLocationRule is a matchmaking rule to work off data from Geo IP, a third party tool (http://www.maxmind.com/).
        // 'useGeoIp' must be turned on in framework.cfg, for correct geo location information.  If this is not turned on
        // this rule will fail to initialize.
        //
        // The latitude and longitude of each user is stored in their user session when the login. When matching against
        // other users, both user's information is compared.  When matching against a game session, the game session's
        // topology host's location information is used.  We do not take into account other users in the game, so this
        // rule does not make much sense for Peer 2 Peer topologies.
        //
        // You should avoid using this rule in conjuction with the ping site rule.  While it is possible, the two different
        // rules could counteract each other.
        //
        // range is the acceptable range of distances this rule operates on
        // Any value outside of the range is clamped to the min/max accordingly.
        // Evaluations of sessions or games closer than the min value are considered an exact match.
        // Evaluations of sessions or games farther than the max value are considered a 0 match.
        //
        // FitScore is calculated as a percentage you are from the range's min and max.
        //  - If distance is <= min it is considered a perfect match (1.0 fit score)
        //  - If distance is > max it is considered a zero match (0.0 fit score)
        //  - Otherwise, we calculate the fit score linearly based on the distance between the min & max.
        //  1.0 - ((distance - min) / (max - min))
        //
        geoLocationRule = {
            weight = 10000
            range = { min = 50, max = 4000 } // in miles, the minimum describes the distance considered an exact match, the max is the distance considered a 0% match
            rangeOffsetLists = [
                    //we use a single value in the range list here because the GeoLocation rule is searching within a given radius.
                    { name = "OSDK_matchRelax", rangeOffsets = [    { t=0,  offset=["EXACT_MATCH_REQUIRED"] },
                                                                    { t=9,  offset=[1250] },
                                                                    { t=14, offset=[2500] },
                                                                    { t=19, offset=[3750] },
                                                                    // offset can't equal or excess max range, otherwise any distance can match up until GOS issue https://developer.origin.com/support/browse/GOSOPS-33891 is fixed.
                                                                    { t=22, offset=[3999] } ] } 
			    ]
        }

        // GameNameRule
        // Allows searching for games whose names contain a specified substring.
        // To disable this rule set minLength to 0.
        //
        // relevantChars override allows explicitly specifying search-relevant characters from
        // (extended) 8-bit ascii. If omitted, or empty, defaults relevant characters to a-z, A-Z, and 0-9.
        // Non search-relevant characters are stripped from names/search strings, for matching with this rule.
        // Side: If ignoreCase=true, any character in a-z, A-Z put in relevantChars, gets both upper/lower cases relevant.
        //
        // ignoreCase if true, treat upper and lower case ascii alphabet characters in a-z, A-Z
        // (0x41-0x5A, 0x61-0x7A) as same in terms of searches. Omitting sets to default true.
        //
        // minLength is the min allowed char length (in relevant characters) enforced on all searches.
        // The lowest allowed value for minLength is 3. Omitting sets to default 3. 0 disables rule.
        //
        // weight is the weight of this rule as compared to other rules in MM.
        // ***** Note: OSDK does not currently expose this functionality *****
        Predefined_GameNameRule = {  
            weight = 1000 
            ignoreCase = true
            minLength = 3
            relevantChars = "" // e.g. relevantChars = "abcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()-=_+;:[]{}"
        }

        // AvoidGamesRule
        // Allows preventing matching specific games
        // 
        // maxGameIdListSize is max game ids sessions can specify. Higher values can lower search performance.
        // 
        Predefined_AvoidGamesRule = {  
            maxGameIdListSize = 4
        }

        // AvoidPlayersRule
        // Allows preventing matching games/sessions having specific players.
        //
        // maxPlayersUsed specifies the cutoff number of avoid players actually used for
        // matchmaking by this rule.  Clients specifying more than this, only get 'maxUsedPlayers'
        // of the players used.  Higher values can lower search performance.
        //
        Predefined_AvoidPlayersRule = {
            maxPlayersUsed = 500
        }

        // PreferredPlayersRule
        // Allows matchmaking sessions to increase chance of matching games or other matchmaking
        // sessions having specific preferred players.  Not enabled for GameBrowser.
        //
        // weight is the weight of this rule as compared to other rules in MM.
        //
        // maxPlayersUsed specifies the cutoff number of preferred players, actually used for
        // matchmaking by this rule.  Clients specifying more than this, only get 'maxUsedPlayers'
        // of the players used.  Higher values can lower search performance.
        //
        Predefined_PreferredPlayersRule = {  
            weight = 10000
            maxPlayersUsed = 500
        }
        
        // PreferredGamesRule
        // Allows matchmaking sessions to increase chance of matching specific games
        //
        // weight is the weight of this rule as compared to other rules in MM.
        //
        // maxGamesUsed specifies the cut-off number of games, actually used for
        // matchmaking by this rule.  Clients specifying more than this, only get 'maxGamesUsed'
        // games.  Higher values can lower search performance.
        //
        Predefined_PreferredGamesRule = {
            weight = 10000
            maxGamesUsed = 1000
        }

        // user extended data rules (UED Rules)
        //
        // UED Rule is comprehensive because it takes into account
        // the existing Skill Rule Map, Dnf Rule, and the new UED Rule map
        // that handles all user extended data rules.
        // 
        // UED rules defined in this config determine how to match to entities (users or groups)
        // based on values in the user extended data.  An easy way to get data
        // in the UED is to configure stats in etc/stats.cfg in the userSessionStats list.
        //
        // UED rules are named by convention as <userExtendedDataName>_Rule, and must be specified
        // on the cilent in the UEDRuleCriteria to match this config file.
        // 
        // ruleDefinitionType is the type of definition used for this rule.
        // New UED Rules that specify UED Criteria should omit this value.
        // The following legacy types are also supported:
        //
        // ruleDefinitionType=legacySkillRule
        // ruleDefinitionType=legacyDNFRule
        //
        // legacySkillRule Criteria are specified in the SkillPrefsList
        // legacyDNFRule Criteria are specified in the predefined DNFRule and only
        // one of these configurations is supported.
        //
        // userExtendedDataName is the key used to identify which data in the User Extended Data to use when evaluating
        // this rule.  Keys are in the form component_dataName (ie. stats_skillA).
        //
        // weight is the weight of this rule as compared to other rules in matchmaking
        //
        // groupValueFormula is the formula used to calculate the value of a group.
        // acceptable values are
        //
        // GROUP_VALUE_FORMULA_AVERAGE
        // GROUP_VALUE_FORMULA_MIN
        // GROUP_VALUE_FORMULA_MAX
        // GROUP_VALUE_FORMULA_LEADER
        //
        // fitFormula is the formula used to calculate the fit score between two
        // values, your session's calculated value against another session's
        // or game's calculated value.  This allows for for different values
        // to have more preference as the range expands.
         // FIT_FORMULA_GAUSSIAN
        // fitFormula = {name = FIT_FORMULA_GAUSSIAN, params = {fiftyPercentFitValueDifference = 200}}
        // 
        // Uses the gaussian formula to determine the fit.
        // 
        // params
        // fiftyPercentFitValueDifference is the difference between two values that yeilds a 
        // 0.5 fit percent.  This value controls the width of the bell curve used to calculate the
        // fit percent between 2 entities.
        // 
        // Below is a table of examples given a fiftyPercentFitValueDifference of 200.
        //
        // Fit Score : Difference
        //       1.0 : +/- 0 (exact match)
        //       .90 : +/- 77
        //       .75 : +/- 128
        //       .50 : +/- 200
        //       .25 : +/- 282
        //       .10 : +/- 364
        //       .00 : INFINITE (match anything)
        //
        //      At heart, we're evaluating: fit percent = e^( - ((x-b)^2 / (c * 1.2011225)^2 )) where
        //          (x - b) is the difference between the two entities
        //          c is the fiftyPercentFitValueDifference which determines the width of the bell curve.
        //
        // NOTE: see commonruleformulas.h GausianFunction.calculate for the implementation.
        //
        // FIT_FORMULA_LINEAR
        // fitFormula = {name = FIT_FORMULA_LINEAR, params = {minFit=0.0, maxFit=1.0, minVal=10, maxVal=10}}
        // 
        // Uses a linear function starting at the desired value to +maxVal and -minVal using
        // minFit and maxFit to determine the slope.
        //
        // Anyvalues outside of +maxVal and -minVal have value minFit.
        //
        // minFit defaults to 0.0
        // maxFit defaults to 1.0
        // minVal defaults to the smallest minValue of all lists in the rangeOffsetList [minValue, maxValue]
        // maxVal defaults to the largest maxValue of all lists in the rangeOffsetList [minValue, maxValue]
        //
        // FIT_FORMULA_BINARY
        // fitFormula = {name = FIT_FORMULA_BINARY}
        //
        // Uses a binary comparison.  If it is in the range offset 1.0 perfect match
        // if it is not in range then then NO_MATCH.
        //
        // range is the acceptable range of values that this rule operates on.
        // Any value outside of the range is clamped to the min/max accordingly.
        // The amount of system memory consumed is directly proportional to
        // the product of the series of the range of each rule.
        // Take care to only specify the range that your value requires.  And
        // if you are using many ranged rules to limit the max value of these
        // ranged rules.
        //
        // rangeOffsetLists are lists of ranges that can be used by the client
        // to determine the sessions "acceptable value range".  The range works
        // against the calculated UED value or the search value specified by
        // the client.
        //
        // Syntax of the rangeOffsetList:
        // decay = [{ t=0, offset = [100,100]}, { t=5, offset = [200,200]}, { t=10, offset = [INF]}]
        //
        // t is the time since this session has started searching; +0, +5, +10.
        // offset is the acceptable offset around the desired value that indicates
        // a match; +/-100, +/-200, +/-INF.  Offsets don't have to be symetric
        // and if only one value is specified, that value will be used for both the + and - Value.
        //
        // Acceptable well known values are
        //   "EXACT_MATCH_REQUIRED" = 0
        //   "INF" = infinity (min or max range)
        //
        userExtendedDataRuleMap = {
            fifaSkillLevel = {
                userExtendedDataName = "fifaSkillLevel" //From etc/stats.cfg userstats
                weight = 100
                groupValueFormula = "GROUP_VALUE_FORMULA_AVERAGE"
                fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 40}}
                range = { min = 0, max = 100 }
                rangeOffsetLists = [
                    { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                    { name = "OSDK_matchAny", rangeOffsets = [{ t=0, offset=["INF"] }] }
                    { name = "OSDK_matchRelax", rangeOffsets = [{ t=0,  offset=["EXACT_MATCH_REQUIRED"] },
                                                              { t=2,  offset=[5] },
                                                              { t=5, offset=[15] },
                                                              { t=8, offset=[30] },
                                                              { t=11, offset=[70] },
                                                              { t=14, offset=["INF"]            }    ]}
                    { name = "OSDK_skillWithin3", rangeOffsets = [{ t=0, offset=[3] }] }
                    { name = "OSDK_skillWithin5", rangeOffsets = [{ t=0, offset=[5] }] }
                    { name = "OSDK_skillWithin7", rangeOffsets = [{ t=0, offset=[7] }] }
                    { name = "OSDK_skillWithin10",rangeOffsets = [{ t=0, offset=[10] }] }
                    { name = "OSDK_skillWithin20",rangeOffsets = [{ t=0, offset=[20] }] }
                ]
            }
            // OSDK: Decay the Similar DNF rule to ANY after 1 sec. Before 1 sec, server will try to matchup users with similar DNF
            // and will evaluate games so the best fitscore match will be used after 1 sec.
            dnfPercent = {
                userExtendedDataName = "stats_dnf" //From etc/stats.cfg userstats
                weight = 50
                groupValueFormula = "GROUP_VALUE_FORMULA_AVERAGE"
                fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 20}}
                range = { min = 0, max = 100 }
                rangeOffsetLists = [
                    { name = "OSDK_matchRelax", rangeOffsets =[    { t=0,    offset=["EXACT_MATCH_REQUIRED"]    },
                                    { t=1,    offset=[5]            },
                                    { t=14,    offset=[10]            },
                                    { t=19,    offset=[15]            },
                                    { t=22,    offset=[20]            },
                                    { t=25,    offset=[30]            },
                                    { t=29,    offset=["INF"]            }    ]}
                ]
            }
            // Configuration for the basic DNF_Rule.
            // 
            // weight - The Weight of the Rule.
            // 
            // dnfKey is the key used to identify which data in the User Extended Data to use when evaluating
            // this rule.  Keys are in the form component_dataName (ie. stats_dnf).
            //
            DNF_Rule = {
                userExtendedDataName = "stats_dnf" // From etc/stats.cfg
                weight = 100
                groupValueFormula = "GROUP_VALUE_FORMULA_MAX" // Dnf uses a MAX formula
                fitFormula = { name = "FIT_FORMULA_BINARY" }  // binary cause its a filter
                range =  { min = 0, max = 100 } 
                rangeOffsetLists = [
                    { name = "lessThan", rangeOffsets = [{ t=0, offset=["INF",0] }] }
                ]
            }

            clubSkillLevel = {
                // OSDK: To be overriden by client passing in club skill level
                userExtendedDataName = "stats_skillLevel" // Dummy data name from etc/stats.cfg userstats
                weight = 100
                groupValueFormula = "GROUP_VALUE_FORMULA_AVERAGE"
                fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 40}}
                range = { min =0, max = 100 }
                rangeOffsetLists = [
                    { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                    { name = "OSDK_matchAny", rangeOffsets = [{ t=0, offset=["INF"] }] }
                    { name = "OSDK_matchRelax", rangeOffsets = [{ t=0,  offset=["EXACT_MATCH_REQUIRED"] },
                                                              { t=9,  offset=[5] },
                                                              { t=14, offset=[10] },
                                                              { t=19, offset=[15] },
                                                              { t=22, offset=[20] },
                                                              { t=25, offset=[30] },
                                                              { t=28, offset=[40] }] }
                    { name = "OSDK_skillWithin3", rangeOffsets = [{ t=0, offset=[3] }] }
                    { name = "OSDK_skillWithin5", rangeOffsets = [{ t=0, offset=[5] }] }
                    { name = "OSDK_skillWithin7", rangeOffsets = [{ t=0, offset=[7] }] }
                    { name = "OSDK_skillWithin10",rangeOffsets = [{ t=0, offset=[10] }] }
                    { name = "OSDK_skillWithin20",rangeOffsets = [{ t=0, offset=[20] }] }
                ]
            }

            intraClubH2HSkillLevel = {
                // OSDK: To be overriden by client passing in club skill level
                userExtendedDataName = "stats_skillLevel" // Dummy data name from etc/stats.cfg userstats
                weight = 100
                groupValueFormula = "GROUP_VALUE_FORMULA_AVERAGE"
                fitFormula = { name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 40}}
                range = { min =0, max = 100 }
                rangeOffsetLists = [
                    { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                    { name = "OSDK_matchAny", rangeOffsets = [{ t=0, offset=["INF"] }] }
                    { name = "OSDK_matchRelax", rangeOffsets = [{ t=0,  offset=["EXACT_MATCH_REQUIRED"] },
                                                              { t=9,  offset=[5] },
                                                              { t=14, offset=[10] },
                                                              { t=19, offset=[15] },
                                                              { t=22, offset=[20] },
                                                              { t=25, offset=[30] },
                                                              { t=28, offset=[40] }] }
                ]
            }

            futSkillRating = {
                userExtendedDataName = "futSkillRating"
                weight = 100
                groupValueFormula = "GROUP_VALUE_FORMULA_AVERAGE"
                fitFormula = {name = "FIT_FORMULA_LINEAR", params = {minFit=0.0, maxFit=1.0, minVal=0, maxVal=330}}
                range = { min =0, max = 3000 }
                rangeOffsetLists = [
                    { name = "OSDK_matchExact", rangeOffsets = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }] }
                    { name = "OSDK_matchAny", rangeOffsets = [{ t=0, offset=["INF"] }] }
                    { name = "OSDK_matchRelax", rangeOffsets = [
                        {t = 0, offset=[25] },
                        {t = 3, offset=[50] },
                        {t = 6, offset=[60] },
                        {t = 8, offset=[90] },
                        {t = 10, offset=[130] },
                        {t = 12, offset=[190] },
                        {t = 13, offset=[270] },
                        {t = 14, offset=[420] },
                        {t = 15, offset=["INF"] }]
                    }
                    { name = "mediumDurationRelax", rangeOffsets = [
                        {t = 0, offset=[0,1] },
                        {t = 300, offset=[1,1] },
                        {t = 600, offset=[1,2] },
                        {t = 900, offset=[2,2] },
                        {t = 1200, offset=[2,3] },
                        {t = 1500, offset=[3,3] },
                        {t = 1800, offset=[3,4] },
                        {t = 2100, offset=[4,4] },
                        {t = 2400, offset=[4,5] },
                        {t = 3000, offset=[5,5] },
                        {t = 3300, offset=[25] },
                        {t = 3600, offset=[50] },
                        {t = 3800, offset=[60] },
                        {t = 3900, offset=[90] },
                        {t = 4200, offset=["INF"] }]
                    }
                ]
            }

            // dawngate_skill_Rule
            // For Dawngate may be used to clamp overall skill ranges, outside of team based rules.
            //dawngate_skill_Rule = {
                //userExtendedDataName = "teamSkill" // client UED index 1
                //weight = 10000
                //groupValueFormula = "GROUP_VALUE_FORMULA_OFFSET_AVERAGE"
                //fitFormula = {name = "FIT_FORMULA_GAUSSIAN", params = {fiftyPercentFitValueDifference = 300}}
                //range = { min = 0, max = 2000 }
                //rangeOffsetLists = [ // Please see RSeiff for details.
                    //{ name = "decayPlus0", rangeOffsets = [
                        //{ t=0, offset=[100, 100] },
                        //{ t=600, offset=[150, 150] },
                        //{ t=780, offset=[200, 200] },
                        //{ t=960, offset=[250, 250] },
                        //{ t=1200, offset=[300, 300] }
                      //]
                    //}
                //]
            //}
        } // userExtendedDataRuleMap

        teamUEDBalanceRuleMap = {

            teamSkillAvgBalanceRule = {
                userExtendedDataName = "teamSkill" // client UED index 1
                weight = 10000
                teamValueFormula="GROUP_VALUE_FORMULA_AVERAGE"
                fitFormula = {name = "FIT_FORMULA_LINEAR"} 
                range = { min = 0, max = 2000 }
                bucketPartitions = 100
                maxFinalizationPickSequenceRetries = 5

                // decayPlus0 min fit threshold is based of Dawngate beta's skill rule.
                rangeOffsetLists = [
                    { name = "veryQuickMatch", rangeOffsets = [{ t=0, offset=[100]}, { t=2, offset=[400]}, { t=3, offset=["INF"]} ] }
                    { name = "quickDecay", rangeOffsets = [{ t=0, offset=[100]}, { t=5, offset=[200]}, { t=10, offset=[700]}] }
                    { name = "longDecay", rangeOffsets = [{ t=0, offset=[100]}, { t=30, offset=[200]}, { t=100, offset=[700]}] }
                    { name = "noDecay", rangeOffsets = [{ t=0, offset=[100]}] }
                    { name = "matchAny", rangeOffsets = [{ t=0, offset=["INF"]} ] }
                    { name = "decayPlus0", rangeOffsets = [
                        { t=0, offset=[20] },
                        { t=120, offset=[40] },
                        { t=240, offset=[60] },
                        { t=360, offset=[80] },
                        { t=480, offset=[100] },
                        { t=600, offset=[150] },
                        { t=780, offset=[200] },
                        { t=960, offset=[250] },
                        { t=1200, offset=[300] }
                      ] 
                    }
                ]
            }
        }

        teamUEDPositionParityRuleMap = {
            topAndBottomPlayersRule = {
                userExtendedDataName = "teamSkill" // client UED index 1
                fitFormula = { name = "FIT_FORMULA_LINEAR"}
                topPlayersToCompare = 1
                bottomPlayersToCompare = 1
                weight = 10000
                range = { min = 0, max = 2000 }
                maxFinalizationPickSequenceRetries = 5
                rangeOffsetLists = [
                    { name = "noDecay", rangeOffsets = [{ t=0, offset=[100]}] }
                    { name = "quickDecay", rangeOffsets = [{ t=0, offset=[50]}, { t=10, offset=[100]}, { t=120, offset=[200]}, { t=240, offset=["INF"]}] }
                ]
            }
        }

//        teamCompositionRuleMap = {
//            // 5 v 5
//            competitiveMode = {
//                weight = 500
//                possibleValues = [ "5",    "4,1",   "3,2",  "3,1,1", "2,2,1", "2,1,1,1", "1,1,1,1,1" ]
//                fitTable =       [ 1.0,     0.8,     0.7,     0.5,     0.5,     0.2,     0.0,  // 5
//                                   0.8,     1.0,     0.8,     0.6,     0.6,     0.3,     0.0,  // 4,1
//                                   0.7,     0.8,     1.0,     0.8,     0.7,     0.5,     0.0,  // 3,2
//                                   0.5,     0.6,     0.8,     1.0,     0.9,     0.6,     0.1,  // 3,1,1
//                                   0.5,     0.6,     0.7,     0.9,     1.0,     0.7,     0.3,  // 2,2,1
//                                   0.2,     0.3,     0.5,     0.6,     0.7,     1.0,     0.6,  // 2,1,1,1
//                                   0.0,     0.0,     0.0,     0.1,     0.3,     0.6,     1.0 ] // 1,1,1,1,//1
//
//                maxFinalizationGameTeamCompositionsAttempted = 10 // 0 disables capping. 
//                
//                // veryQuickMatch sanity tests quick decay to match-any
//                // decayLimited has at least one group size same
//                minFitThresholdLists = {
//                    requireExactMatch = [ "0:EXACT_MATCH_REQUIRED" ]
//                    veryQuickMatch = ["0:EXACT_MATCH_REQUIRED", "3:0.0"]
//                    quickMatch = [ "0:EXACT_MATCH_REQUIRED", "5:.8", "10:.7", "30:.6"]
//                    matchAny = [ "0:0" ]
//                    decayLimited = [ "0:EXACT_MATCH_REQUIRED", "120:.6"]
//                }
//            }
//        } // teamCompositionRuleMap

        gameAttributeRules = {
            // NOTE: the following rules are defined to work with the tests defined at Matchmaker bt tests page on Confluence.
            //  please don't modify the following rules without updating the tests that use them...
            //
            // NOTE 2: all genericRules have a ruleType, which defaults to EXPLICIT_TYPE.

            // OSDK Predefined Rule - Roster Version Rule
            OSDK_rosterVersion = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_rosterVersion"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }

            // OSDK Predefined Rule - Category ID Rule
            OSDK_categoryId = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_categoryId"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }
     
            // OSDK Predefined Rule - Sponsored Event ID Rule
            OSDK_sponsoredEventId = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_sponsoredEventId"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }
            
            // OSDK Predefined Rule - Arena Challenge ID Rule
            OSDK_arenaChallengeId = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_arenaChallengeId"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }

            // OSDK Predefined Rule - Challenge Club ID Rule
            OSDK_ChlngrClubId = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_ChlngrClubId"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }
            }

            // OSDK Predefined Rule - Club ID Rule
            OSDK_clubId = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_clubId"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }
            
            // OSDK Predefined Rule - Club ID inverse Rule
            // This rule prevents the same clubs from matching up. It works opposite ("not equal") by reversing
            // the matching and mismatch fit percentage.
            OSDK_clubIdInverse = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_clubIdInverse"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 0
                mismatchFitPercent = 1.0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }

        // OSDK Predefined Rule - Club League ID (season) Rule
        // !!!*** NOTE: ***!!! IMPORTANT: When you update the fit table here, make sure to update the 
        // corresponding items in osdk_clubs_custom.cfg
        OSDK_clubLeagueId = {
            weight = 100
            attributeType = "GAME_ATTRIBUTE"
            attributeName = "OSDK_clubLeagueId"
            votingMethod = "OWNER_WINS"
            
            possibleValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"]
            sparseFitTable = {
                diagonalValue = 1.0
                offDiagonalValue = 0.0
                randomValue = 0.0
                sparseValues = []
                }
       
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
                    OSDK_matchAny = ["0:0.0"]
                OSDK_matchRelax = ["0:1.0", "5:0.0"]
                OSDK_matchBrowse = ["0:0.0"]
            }
        }
        
        // OSDK Predefined Rule - Club Game Group Size Rule
        OSDK_clubGamegroupSize = {
            weight = 100
            attributeName = "OSDK_clubGamegroupSize"
            votingMethod = "OWNER_WINS"
            
            possibleValues = ["11", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]
            fitTable = [
                1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.1,
                0.9, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1,
                0.8, 0.9, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2,
                0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3,
                0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4,
                0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5,
                0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7, 0.6,
                0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7,
                0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8,
                0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9,
                0.1, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0
            ]
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
                OSDK_matchRelax = ["0:1.0", "3:0.9", "5:0.8", "11:0.7", "14:0.6", "17:0.5", "20:0.0"]
            }       
        }

            // OSDK Predefined Rule - Club Is DDP Version Rule
            OSDK_clubIsDDP = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_clubIsDDP"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
                }        
            }        
            
            
            // OSDK Predefined Rule - Language Rule
            OSDK_language = {
                weight = 100
                attributeName = "OSDK_language"
                votingMethod = "VOTE_PLURALITY"            
                possibleValues = ["abstain", "-1", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "random"]
                sparseFitTable = {
                    diagonalValue = 1.0
                    offDiagonalValue = 0.0
                    randomValue = 0
                    sparseValues = []
                }            
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
        		    OSDK_matchAny = ["0:0.0"]
                }
            }
            
            // OSDK Predefined Rule - Tournament team ID inverse Rule
            // This rule prevents the same tournament team ID from matching up. It works opposite ("not equal") by reversing
            // the matching and mismatch fit percentage.
            OSDK_tourTeamIdInverse = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_tourTeamIdInverse"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 0
                mismatchFitPercent = 1.0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0", "5:0.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }
            
            // OSDK Predefined Rule - Tournament ID Rule
            OSDK_tourId = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_tourId"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }
            
            // OSDK Predefined Rule - Tournament Tier Rule
            OSDK_tourTier = {
                weight = 100
                attributeName = "OSDK_tourTier"
                votingMethod = "VOTE_PLURALITY"
                defaultAbstainValue = "1"
                possibleValues = ["1", "2", "3", "4", "5"]
                fitTable = [
                    1.0, 0.7, 0.4, 0.2, 0.1,
                    0.7, 1.0, 0.7, 0.4, 0.2,
                    0.4, 0.7, 1.0, 0.7, 0.4,
                    0.2, 0.4, 0.7, 1.0, 0.7,
                    0.1, 0.2, 0.4, 0.7, 1.0
                ]
         
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
   		            OSDK_matchAny = ["0:0.0"]
                    OSDK_matchRelax = ["0:1.0", "5:0.7", "10:0.4", "15:0.2", "20:0.1"]
                }
            }
            
            // OSDK Predefined Rule - Seasonal Play Playoff Division Rule
            OSDK_playoffDivision = {
                weight = 100
                attributeName = "OSDK_playoffDivision"
                votingMethod = "VOTE_PLURALITY"
                defaultAbstainValue = "1"
                possibleValues = ["0", "1", "2", "3", "4"]
                sparseFitTable = {
                    diagonalValue = 1.0
                    offDiagonalValue = 0.3
                    randomValue = 0
                    sparseValues = [["0", "1", 0.1],
                                   ["0", "2", 0.1],
                                   ["0", "3", 0.1],
                                   ["0", "4", 0.1],
                                   ["1", "0", 0.1],
                                   ["2", "0", 0.1],
                                   ["3", "0", 0.1],
                                   ["4", "0", 0.1]]
                }            
         
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
                    OSDK_matchAny = ["0:0.0"]
                    OSDK_matchRelax = ["0:1.0", "3:0.3", "23:0.0"]
                }
            }
            
            // OSDK Predefined Rule - Game Mode Rule
            OSDK_gameMode = {
                weight = 100
                attributeName = "OSDK_gameMode"
                votingMethod = "VOTE_PLURALITY"
                defaultAbstainValue = "abstain" // This should not occur and isn't handled by the Ping client
                possibleValues = ["abstain", "0", "1", "2", "3", "4", "5", "6", "8", "9", "10", "11", "12", "13", "14", "20", "40", "41", "42", "80", "81", "82"]      

                sparseFitTable = {
                    diagonalValue = 1.0
                    offDiagonalValue = 0.0
                    randomValue = 0
                    sparseValues = []
                }            
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
                    OSDK_matchAny = ["0:0.0"]
                }
            }

            // OSDK Predefined Rule - Co-op Rule
            OSDK_coop = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_coop"
                votingMethod = "OWNER_WINS"

                matchingFitPercent = 1.0
                mismatchFitPercent = 0

                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
       		        OSDK_matchAny = ["0:0.0"]
                }        
            }
            
            // Ping game only Rule - Game Speed Rule
            gameSpeed = {
                weight = 100
                attributeName = "gameSpeed"
                votingMethod = "VOTE_PLURALITY"
                defaultAbstainValue = "1"
                possibleValues = ["abstain", "0", "1", "2"]

                sparseFitTable = {
                    diagonalValue = 1.0
                    offDiagonalValue = 0.0
                    randomValue = 0
                    sparseValues = []
                }            
     
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
                    OSDK_matchAny = ["0:0.0"]
                }
           }
        
    // FIFA Club Tournament Rule
        fifaClubTournament = {
            weight = 100
            attributeName = "fifaClubTournament"
            votingMethod = "OWNER_WINS"
            defaultAbstainValue = "0"
            possibleValues = ["0", "1", "2", "3", "4", "5"]

            sparseFitTable = {
                diagonalValue = 1.0
                offDiagonalValue = 0.0
                randomValue = 0
                sparseValues = []
            }            
 
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }
        }
            
            // Ping game only Rule - Game Points Rule
        gamePoints = {
                weight = 100
                attributeName = "gamePoints"
                votingMethod = "VOTE_PLURALITY"
                defaultAbstainValue = "5"
                possibleValues = ["abstain", "1", "3", "5", "10", "15", "20"]

                sparseFitTable = {
                    diagonalValue = 1.0
                    offDiagonalValue = 0.0
                    randomValue = 0
                    sparseValues = []
                }
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:1.0"]
                    OSDK_matchAny = ["0:0.0"]
                }
    } // game points rule
        

    fifaGameMode = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaGameMode"
            votingMethod = "OWNER_WINS"
            possibleValues = [ "-1", "0", "1", "2", "3", "4", "5", "6"]      
        
            fitTable = [
              "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0"
            ]
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:EXACT_MATCH_REQUIRED"]
            }
        }
        
        //
        // fifaTeamLevel Rule
        // Possible values for Team Level Rule: 
        //      "-1" = no restriction, "0" = 0.5-1.5 star, "1" = 2.0-3.5 star, "2" =4.0-5.0 star
        
        //  Fit table is linearly distributed across star levels, with respect to the 2 inputs
        //  
        //
        //  Relaxtion goes: 0-10 sec 100% match, 10-15 sec 80% match, 15-20 sec 50% match, 20+ sec match any
        //
        fifaTeamLevel = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaTeamLevel"
            votingMethod = "OWNER_WINS"
            defaultAbstainValue = "0" 
            possibleValues = ["0", "1", "2","3","4"]

            fitTable = [
              "1.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "1.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "1.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "1.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "1.0"
              ]
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }        
        
    //
    // fifaTeamStarRating Rule
    // Possible values for Team Star Rating Rule: 
    //     "0" = 0.0 star
    //       "5" = 0.5 star
    //    "10" = 1.0 star
    //    "15" = 1.5 star
    //    "20" = 2.0 star
    //    "25" = 2.5 star
    //    "30" = 3.0 star
    //    "35" = 3.5 star 
    //    "40" = 4.0 star
    //    "45" = 4.5 star
    //    "50" = 5.0 star
    fifaTeamStarRating = {
        weight = 5000
        ruleType = "EXPLICIT_TYPE"
        attributeName = "fifaTeamStarRating"
        votingMethod = "OWNER_WINS"
        possibleValues = ["0", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50"]
        fitTable = [
            "1.0", "0.9", "0.8", "0.7", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0",
            "0.9", "1.0", "0.9", "0.8", "0.7", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0",
            "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.0", "0.0", "0.0", "0.0", "0.0",
            "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.0", "0.0", "0.0", "0.0",
            "0.0", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.0", "0.0", "0.0",
            "0.0", "0.0", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.0", "0.0",
            "0.0", "0.0", "0.0", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.0",
            "0.0", "0.0", "0.0", "0.0", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7",
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8",
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.7", "0.8", "0.9", "1.0", "0.9",
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.7", "0.8", "0.9", "1.0"
        ]         
        minFitThresholdLists = {
            OSDK_matchRelax = ["0:1.0", "20:0.9", "35:0.8"]
        }            
    }

    // 35 x 35 matrix. brute force ftw.
    fifaTeamOVR = {
        weight = 5000
        ruleType = "EXPLICIT_TYPE"
        attributeName = "fifaTeamOVR"
        possibleValues = [
            "56", "57", "58", "59", "60",
            "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", 
            "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", 
            "81", "82", "83", "84", "85", "86", "87", "88", "89", "90"
        ]
        
        fitTable = [
            "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", "0.6", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", "0.7", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", "0.8", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", "0.9", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0", "1.0", 
            "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.0"
        ]
        
        minFitThresholdLists = {
            OSDK_matchExact = [0:EXACT_MATCH_REQUIRED, 20:1.0]
            OSDK_matchAny = [0:0.0]
            OSDK_matchRelax = [0:1.0, 10:0.9, 15:0.8, 20:0.7, 25:0.6, 30:0.5]
        }
    }
    
        //
        // fifaHalfLength Rule
        // Possible values for Team Level Rule: 
        //      "-1" = no restriction, "0" = 2 min, "1" = 3 min, "2" = 4 min, "3" = 5 min,
        //      "4" = 6 min, "5" = 7 min, "6" = 8 min, "7" = 9 min,
        //      "8" = 10 min, "9" = 15 min, "10" = 20 min
        //
        //  Fit table is linearly distributed across half lenghts, with respect to the 2 inputs
        //                                        
        //  Relaxtion goes: 0-10 sec 100% match, 10-15 sec 80% match, 15-20 sec 50% match, 20+ sec match any
        //
        fifaHalfLength = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaHalfLength"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" ]

            fitTable = [
              "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
              "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
              "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
              "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
              "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", 
              "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0", "0.0",
              "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "0.0", "1.0"              
            ] 
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }
                
        // fifaCustomController Rule
        // Possible values for Custom Controller Rule: 
        //      "-1" = no restriction, "0" = Manual
        //  fitTable = {
        //      "1.0", "0.0", "0.0",
        //      "0.0", "1.0", "0.0",
        //      "0.0", "0.0", "1.0"
        //    }    
        //  Relaxtion goes: 0-10 sec 100% match, 10+ sec 50% match
        fifaCustomController = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaCustomController"
            votingMethod = "OWNER_WINS"
            defaultAbstainValue = "0" 
            possibleValues = ["0", "1", "2", "3"]

            fitTable = [
              "1.0", "0.0", "0.0", "0.0",
              "0.0", "1.0", "0.0", "0.0",
              "0.0", "0.0", "1.0", "0.0",
              "0.0", "0.0", "0.0", "1.0"
            ]
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:1.0"]
            }            
        }
        
        // fifaGameSpeed Rule
        // Possible values for Game Speed Rule: 
        //      "0" = slow, "1" = normal, "2" = fast
        //  fitTable = {
        //      "1.0", "0.0", "0.0",
        //      "0.0", "1.0", "0.0",
        //      "0.0", "0.0", "1.0"
        //    }                        
        //  Relaxtion goes: 0-10 sec 100% match, 10+ sec 50% match
        fifaGameSpeed = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaGameSpeed"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0","1","2"]

            fitTable = [
              "1.0", "0.0", "0.0", 
              "0.0", "1.0", "0.0", 
              "0.0", "0.0", "1.0"
            ] 
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }
        
    fifaDivision = {
        weight = 100
        ruleType = "EXPLICIT_TYPE"
        attributeName = "fifaDivision"
        votingMethod = "OWNER_WINS"
        possibleValues = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]
        fitTable = [
            "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0", "0.0",
            "0.9", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0", "0.0",
            "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0", "0.0",
            "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5", "0.0",
            "0.6", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.6", "0.5",
            "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7", "0.6",
            "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8", "0.7",
            "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "0.9", "0.8",
            "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "0.9",
            "0.0", "0.0", "0.0", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0"
        ]         
        minFitThresholdLists = {
            OSDK_matchRelax = ["0:1.0", "5:0.9", "10:0.8", "25:0.7"]
        }            
    }
    
    fifaCoopDivision = {
        weight = 100
        ruleType = "EXPLICIT_TYPE"
        attributeName = "fifaCoopDivision"
        votingMethod = "OWNER_WINS"
        possibleValues = ["1", "2", "3", "4", "5"]
        fitTable = [
            "1.0", "0.9", "0.8", "0.0", "0.0",
            "0.9", "1.0", "0.9", "0.8", "0.0",
            "0.8", "0.9", "1.0", "0.9", "0.8",
            "0.0", "0.8", "0.9", "1.0", "0.9",
            "0.0", "0.0", "0.8", "0.9", "1.0"
        ]         
        minFitThresholdLists = {
            OSDK_matchRelax = ["0:1.0", "10:0.9", "20:0.8"]
        }           
    }
    

    fifaCup = {
        weight = 100
        ruleType = "EXPLICIT_TYPE"
        attributeName = "fifaCup"
        votingMethod = "OWNER_WINS"
        possibleValues = ["1", "2", "3", "4"]
        fitTable = [
            "1.0", "0.9", "0.8", "0.7",
            "0.9", "1.0", "0.9", "0.8",
            "0.8", "0.9", "1.0", "0.9",
            "0.7", "0.8", "0.9", "1.0"
        ]         
        minFitThresholdLists = {
            OSDK_matchRelax = ["0:1.0", "14:0.9", "22:0.8", "35:0.7"]
        }            
    }
        
    // fifaRoster Rule
    // Possible values for Roster Rule: 
    //     "0" = custom, "1" = online
    fifaRoster = {
        weight = 100
        ruleType = "EXPLICIT_TYPE"
        attributeName = "fifaRoster"
        votingMethod = "OWNER_WINS"
        possibleValues = ["0", "1"]
        fitTable = [
            "1.0", "0.0",
            "0.0", "1.0"
        ] 
        minFitThresholdLists = {
            OSDK_matchExact = ["0:1.0"]
            OSDK_matchAny = ["0:0.0"]
        }            
    }
        
        // fifaPPT Rule
        // Possible values for OTP game player per team: 
        //      "0" = 5 , "1" = 10
        //  fitTable = {
        //      "1.0", "0.0",
        //      "0.0", "1.0",
        //    }                        
        //  Relaxtion goes: 0-10 sec 100% match, 10+ sec 50% match
        fifaPPT = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaPPT"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0","1"]

            fitTable = [
              "1.0", "0.0",  
              "0.0", "1.0"
            ] 
            
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }
        
        // fifaGKControl Rule
        // Possible values for OTP game GK control: 
        // "-1" = Any, "0" = AI, "1" = Human
        fifaGKControl = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaGKControl"
            votingMethod = "OWNER_WINS"
            possibleValues = ["abstain", "0", "1"]
            defaultAbstainValue = "1" 
            fitTable = [
                "1.0", "0.0", "0.0",  
                "1.0", "1.0", "0.0",
                "1.0", "0.0", "1.0"
            ]
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }
        
        // fifaClubNumPlayers Rule
        // Possible values:
        //  "0"    = Loc:   2 -  3,    Opp:  Any
        //  "1"    = Loc:   2 -  3,    Opp:  >= 4
        //  "2"    = Loc:   2 -  3,    Opp:  >= 7
        //  "3"    = Loc:   2 -  3,    Opp:  >= 10
        // "10"    = Loc:   4 -  6,    Opp:  Any
        // "11"    = Loc:   4 -  6,    Opp:  >= 4
        // "12"    = Loc:   4 -  6,    Opp:  >= 7
        // "13"    = Loc:   4 -  6,    Opp:  >= 10
        // "20"    = Loc:   7 -  9,    Opp:  Any
        // "21"    = Loc:   7 -  9,    Opp:  >= 4
        // "22"    = Loc:   7 -  9,    Opp:  >= 7
        // "23"    = Loc:   7 -  9,    Opp:  >= 10
        // "30"    = Loc:  10 - 11,    Opp:  Any
        // "31"    = Loc:  10 - 11,    Opp:  >= 4
        // "32"    = Loc:  10 - 11,    Opp:  >= 7
        // "33"    = Loc:  10 - 11,    Opp:  >= 10
        fifaClubNumPlayers = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaClubNumPlayers"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0", "1", "2", "3", "10", "11", "12", "13", "20", "21", "22", "23", "30", "31", "32", "33"]
            fitTable = [
            //    0    1    2    3    10    11    12    13    20    21    22    23    30    31    32    33
                "1.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.0",    "0.0",    "0.0",    "0.1",    "0.0",    "0.0",    "0.0",    "0.1",    "0.0",    "0.0",    "0.0",     //  0
                "0.0",    "0.0",    "0.0",    "0.0",    "1.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.0",    "0.0",    "0.0",    "0.1",    "0.0",    "0.0",    "0.0",    //  1
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "1.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.0",    "0.0",    "0.0",    //  2
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "1.0",    "0.0",    "0.0",    "0.0",    //  3
                "0.1",    "1.0",    "0.0",    "0.0",    "0.1",    "0.1",    "0.0",    "0.0",    "0.1",    "0.1",    "0.0",    "0.0",    "0.1",    "0.1",    "0.0",    "0.0",    // 10
                "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "1.0",    "0.0",    "0.0",    "0.1",    "0.1",    "0.0",    "0.0",    "0.1",    "0.1",    "0.0",    "0.0",    // 11
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "1.0",    "0.0",    "0.0",    "0.1",    "0.1",    "0.0",    "0.0",    // 12
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "1.0",    "0.0",    "0.0",    // 13
                "0.1",    "0.1",    "1.0",    "0.0",    "0.1",    "0.1",    "0.1",    "0.0",    "0.1",    "0.1",    "0.1",    "0.0",    "0.1",    "0.1",    "0.1",    "0.0",    // 20
                "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.1",    "1.0",    "0.0",    "0.1",    "0.1",    "0.1",    "0.0",    "0.1",    "0.1",    "0.1",    "0.0",    // 21
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.1",    "1.0",    "0.0",    "0.1",    "0.1",    "0.1",    "0.0",    // 22
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.1",    "1.0",    "0.0",    // 23
                "0.1",    "0.1",    "0.1",    "1.0",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    // 30
                "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.1",    "0.1",    "1.0",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    "0.1",    // 31
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.1",    "0.1",    "1.0",    "0.1",    "0.1",    "0.1",    "0.1",    // 32
                "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.0",    "0.1",    "0.1",    "0.1",    "1.0"    // 33
            ]
            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
                OSDK_matchRelax = ["0:1.0", "5:0.1"]
                OSDK_matchBrowse = ["0:0.1"]
            }            
        }
        
        // fifaClubMMAny Rule
        // Possible values for rule: 
        //      "00" = no restriction, Any CPU controlled; "01" = no restriction, Any user controlled; "10" = require match, Any CPU controlled; "11" = require match, Any user controlled
        //            
        fifaClubMMAny = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaClubMMAny"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0","1","10","11"]

            fitTable = [
              "1.0", "1.0", "1.0", "0.0" 
              "1.0", "1.0", "0.0", "1.0"
              "1.0", "0.0", "1.0", "0.0"
              "0.0", "1.0", "0.0", "1.0"
            ]

            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }        

        // fifaClubMMGK Rule
        // Possible values for rule: 
        //      "00" = no restriction, GK CPU controlled; "01" = no restriction, GK user controlled; "10" = require match, GK CPU controlled; "11" = require match, GK user controlled
        //            
        fifaClubMMGK = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaClubMMGK"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0","1","10","11"]

            fitTable = [
              "1.0", "1.0", "1.0", "0.0" 
              "1.0", "1.0", "0.0", "1.0"
              "1.0", "0.0", "1.0", "0.0"
              "0.0", "1.0", "0.0", "1.0"
            ]

            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }        
        
        // fifaMatchClubType Rule
        // Possible values for rule: 
        //      "00" = match any, club chosen; "01" = match any, nat team chosen; "10" = match type, club chosen; "11" = match type, nat team chosen
        //            
        fifaMatchClubType = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaMatchClubType"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0","1","10","11"]

            fitTable = [
              "1.0", "1.0", "1.0", "0.0" 
              "1.0", "1.0", "0.0", "1.0"
              "1.0", "0.0", "1.0", "0.0"
              "0.0", "1.0", "0.0", "1.0"
            ]

            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }

        // fifaMatchGuests Rule
        // Possible values for rule: 
        //      "00" = match any, no guests, "01" = match any, guest; "10" = match same, no guest; "11" = match same, guest
        //            
        fifaMatchGuests = {
            weight = 100
            ruleType = "EXPLICIT_TYPE"
            attributeName = "fifaMatchGuests"
            votingMethod = "OWNER_WINS"
            possibleValues = ["0","1","10","11"]

            fitTable = [
              "1.0", "1.0", "1.0", "0.0" 
              "1.0", "1.0", "0.0", "1.0"
              "1.0", "0.0", "1.0", "0.0"
              "0.0", "1.0", "0.0", "1.0"
            ]

            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0"]
                OSDK_matchAny = ["0:0.0"]
            }            
        }

        // used to explicitly avoid the value that is assigned to this rule (note fit percent values)
        fifaAvoidTeam = {
            weight = 100
            ruleType = "ARBITRARY_TYPE"
            attributeName = "fifaAvoidTeam"
            votingMethod = "OWNER_WINS"

            matchingFitPercent = 0
            mismatchFitPercent = 1.0

            minFitThresholdLists = {
                OSDK_matchExact = ["0:1.0", "15:0.0"]
            }        
        }
            
        // Moving FUT specific matchmaking rules into a separate file
        #include "component/gamemanager/futmatchmakingrules.cfg"

		// Moving EURO specific matchmaking rules into a separate file
		//#include "component/gamemanager/euromatchmakingrules.cfg"

		// geoLocationRule is a matchmaking rule to work off data from Geo IP, a third party tool (http://www.maxmind.com/).
		// 'useGeoipData' must be turned on in usersessions.cfg, for correct geo location information.  If this is not turned on
		// this rule will fail to initialize.
		//
		// The latitude and longitude of each user is stored in their user session when the login. When matching against
		// other users, both user's information is compared.  When matching against a game session, the game session's
		// topology host's location information is used.  We do not take into account other users in the game, so this
		// rule does not make much sense for Peer 2 Peer topologies.
		//
		// You should avoid using this rule in conjuction with the ping site rule.  While it is possible, the two different
		// rules could counteract each other.
		//
		// FitScore is calculated as a percentage you are from the 'tooFarDistanceMatch' or 'exactDistanceMatch'.
		//  - If distance is <= exactDistanceMatch it is considered a perfect match (1.0 fit score)
		//  - If distance is > tooFarDistanceMatch it is considered a zero match (0.0 fit score)
		//  - Otherwise, we calculate the fit score linearly as a percentage of the distance it is from too far. 
		//  1.0 - ((distance - mExactDistanceMatch) / (mTooFarDistanceMatch - mExactDistanceMatch))
		//
    } // genericRules

        playerAttributeRules = {

            // OSDK Predefined Rule - Player MyTeam Rule
            // This rule has to be player attribute type
            OSDK_playerMyTeam = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_playerOppTeam"
                matchingFitPercent = 1.0 
                mismatchFitPercent = 0.0
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:EXACT_MATCH_REQUIRED", "1:0.0"]
                    OSDK_matchAny = ["0:0.0"]
                }
            }

            // OSDK Predefined Rule - Player OppTeam Rule
            // This rule has to be player attribute type
            OSDK_playerOppTeam = {
                weight = 100
                ruleType = "ARBITRARY_TYPE"
                attributeName = "OSDK_playerMyTeam"
                matchingFitPercent = 1.0 
                mismatchFitPercent = 0.0
                minFitThresholdLists = {
                    OSDK_matchExact = ["0:EXACT_MATCH_REQUIRED", "1:0.0"]
                    OSDK_matchAny = ["0:0.0"]
                }
            }

            // OSDK Predefined Rule - My Team ANY Boost Rule
            // Use in conjunction with OSDK_playerMyTeam where this rule will give a fitscore boost
            // when OSDK_playerMyTeam is set to ANY value.
            // OSDK_playerMyTeamAnyBoost will have a value of "1" if OSDK_playerMyTeam = ANY.
            OSDK_playerMyTeamAnyBoost = {
                weight = 100
                attributeName = "OSDK_playerOppTeamAnyBoost"
                possibleValues = ["0", "1"]
                fitTable =       [ 0.0, 0.5,
                                   0.5, 0.0 ]

                minFitThresholdLists = {
                OSDK_matchAny = ["0:0.5", "1:0.0"]
                }
            }

            // OSDK Predefined Rule - Opponent Team ANY Boost Rule
            // Use in conjunction with OSDK_playerOppTeam where this rule will give a fitscore boost
            // when OSDK_playerOppTeam is set to ANY value.
            // OSDK_playerOppTeamAnyBoost will have a value of "1" if OSDK_playerOppTeam = ANY.
            OSDK_playerOppTeamAnyBoost = {
                weight = 100
                attributeName = "OSDK_playerMyTeamAnyBoost"
                possibleValues = ["0", "1"]
                fitTable =       [ 0.0, 0.5,
                                   0.5, 0.0 ]

                minFitThresholdLists = {
                OSDK_matchAny = ["0:0.5", "1:0.0"]
                }
            }
        }   // playerAttributeRules


        // QoS validation rule does a post-match evaluation of QoS to a game session.
        // Network topologies in this map are tested versus measured packet loss and latency.
        // Matchmaking sessions that fail a QoS check update an internal avoid list of players or games (as appropriate)
        // and either re-enter matchmaking, if not yet expired, or report a matchmaking failure dependent on the setting of
        // continueMatchingAfterValidationFailure.
        // Omitted network topologies do not have QoS validation performed, and sessions matchmaking to create a reservation do not
        // perform QoS validation.
        // A user's avoid list and QoS tier persist for the life of their usersession, and packet loss and latency values higher
        // than that provided in a topology's highest tier are never accepted, regardless of failure count.
        // When being promoted to the next QoS tier, a user's avoid lists are cleared.
        qosValidationRule = {
            // if true matchmaking will continue after validation failure
            continueMatchingAfterValidationFailure = false
        //    connectionValidationCriteriaMap = {
        //        PEER_TO_PEER_FULL_MESH = {
        //            qosCriteriaList = [{ name = "Tier1"
        //                                maximumLatencyMs = 200
        //                                 maximumPacketLoss = 5.00
        //                                 attemptsAtTier = 2
        //                                },
        //                               { name = "Tier2"
        //                                maximumLatencyMs = 500
        //                                 maximumPacketLoss = 10.00
        //                                 attemptsAtTier = 5
        //                                },
        //                               { name = "Tier3"
        //                                 maximumLatencyMs = 1000
        //                                 maximumPacketLoss = 100.00
        //                                }]
        //        }
        //    }
        }

        // Moving EURO specific matchmaking rules into a separate file
        //#include "component/gamemanager/euromatchmakingrules.cfg"

        // geoLocationRule is a matchmaking rule to work off data from Geo IP, a third party tool (http://www.maxmind.com/).
        // 'useGeoipData' must be turned on in usersessions.cfg, for correct geo location information.  If this is not turned on
        // this rule will fail to initialize.
        //
        // The latitude and longitude of each user is stored in their user session when the login. When matching against
        // other users, both user's information is compared.  When matching against a game session, the game session's
        // topology host's location information is used.  We do not take into account other users in the game, so this
        // rule does not make much sense for Peer 2 Peer topologies.
        //
        // You should avoid using this rule in conjuction with the ping site rule.  While it is possible, the two different
        // rules could counteract each other.
        //
        // FitScore is calculated as a percentage you are from the 'tooFarDistanceMatch' or 'exactDistanceMatch'.
        //  - If distance is <= exactDistanceMatch it is considered a perfect match (1.0 fit score)
        //  - If distance is > tooFarDistanceMatch it is considered a zero match (0.0 fit score)
        //  - Otherwise, we calculate the fit score linearly as a percentage of the distance it is from too far. 
        //  1.0 - ((distance - mExactDistanceMatch) / (mTooFarDistanceMatch - mExactDistanceMatch))
        //
//TODO zap till goip db is working
            //geoLocationRule = {

                //weight = 500
                //exactDistanceMatch = 50 // in miles
                //tooFarDistanceMatch = 5000 // in miles
            
                //minFitThresholdLists = {
                    //quickMatch = [ 0:1.0, 5:.75, 10:.5, 15:.25 ]
                //}
            //}
    } // rules

    externalSessions = {
        "xbsx" = {
            // GDNP service config identifier
            scid = "#XONE_SCID#"

            // List of session template names of external session supported.
            sessionTemplateNames = [ #XONE_SESSION_TEMPLATE_NAME_LIST# ]

            contractVersion = "#XONE_EXTERNAL_SESSION_CONTRACT_VERSION#"

            externalSessionNamePrefix = "#ENV#"

            // Title id specified for external sessions (For Xbox One can be decimal or '0x'-prefixed hexadecimal).
            externalSessionTitle = "#XONE_TITLEID#"

          #if defined(MOCK_EXTERNAL_SERVICE_URL_XONE)
            useMock = true
          #endif
        }
        "xone" = {
            scid = "#XONE_SCID#"
            sessionTemplateNames = [ #XONE_SESSION_TEMPLATE_NAME_LIST# ]
            contractVersion = "#XONE_EXTERNAL_SESSION_CONTRACT_VERSION#"
            externalSessionNamePrefix = "#ENV#"
            externalSessionTitle = "#XONE_TITLEID#"
          #if defined(MOCK_EXTERNAL_SERVICE_URL_XONE)
            useMock = true
          #endif
        }
    }

// }  // matchmakerSettings
