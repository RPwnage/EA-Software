/*************************************************************************************************/
/*!
    \file   statsconfig.cpp


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*************************************************************************************************/

/*************************************************************************************************/
/*!
    \class StatsConfigData

    Encapsulates all of the stat configuration data that both the master and slave need.
*/
/*************************************************************************************************/

/*** Include Files *******************************************************************************/
#include "framework/blaze.h"
#include "framework/database/dbscheduler.h"
#include "statscommontypes.h"
#include "statsconfig.h"
#include "framework/util/expression.h"
#include "framework/util/shared/blazestring.h"
#include "framework/util/locales.h"
#include "stats/tdf/stats.h"
#include "stats/statsslaveimpl.h"


#include "EASTL/algorithm.h"
#include "EASTL/sort.h"
#include "EASTL/bonus/sort_extra.h"


// In order to avoid duplicate symbols the lex and yacc files for stats use the prefix option
// to rename some symbols starting with "yy" to "stats".  Thus we also must redefine yyFlexLexer to
// statsFlexLexer here to match.
#undef yyFlexLexer
#define yyFlexLexer blazeFlexLexer
#include "FlexLexer.h"
#include "framework/util/blazelexer.h"

// Forward declaration of main parse method generated by yacc
int blazeparse (BlazeLexer* blaze_flex_lexer);

namespace Blaze
{
namespace Stats
{

static bool isPowerOf2(uint32_t v) { return v && !(v & (v - 1)); }

StatsConfigData::~StatsConfigData()
{
    cleanStatsConfig();
}

void StatsConfigData::cleanStatsConfig()
{
    mCategoryMap.clear();
    mGroupMap.clear();

    if (mLeaderboardGroupsMap)
    {
        delete mLeaderboardGroupsMap;
        mLeaderboardGroupsMap = nullptr;
    }
    
    if (mStatLeaderboardTree != nullptr)
    {
        delete mStatLeaderboardTree;
        mStatLeaderboardTree = nullptr;
    }
    
    if (mStatLeaderboardsMap != nullptr)
    {
        for (StatLeaderboardsMap::const_iterator iter = mStatLeaderboardsMap->begin();
             iter != mStatLeaderboardsMap->end(); ++iter)
        {
            delete iter->second;
        }
        mStatLeaderboardsMap->clear();
        delete mStatLeaderboardsMap;
        mStatLeaderboardsMap = nullptr;
    }

    CategoryDependencySet::const_iterator depIter = mCategoryDependencySet.begin();
    CategoryDependencySet::const_iterator depEnd = mCategoryDependencySet.end();
    while (depIter != depEnd)
    {
        CategoryDependency* catDep = *depIter++;
        delete catDep;
    }
    mCategoryDependencySet.clear();
}

/*************************************************************************************************/
/*!
    \brief parseStatsConfig

    Call all the parse functions.

    \param[in]  config - stats config file input to be parsed
    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseStatsConfig(const StatsConfig& config, ConfigureValidationErrors& validationErrors)
{
    config.copyInto(mConfigCopy);

    mConfig = &mConfigCopy;
    if (!parseKeyScopes(validationErrors))
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsConfig(): Failed to parse key scopes");
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    if (!parseCategories(validationErrors))
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsConfig(): Failed to parse categories");
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    if (!parseStatGroups(validationErrors))
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsConfig(): Failed to parse groups");
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    if (!parseLeaderboardGroups(validationErrors))
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsConfig(): Failed to parse leaderboard groups");
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    if (!parseLeaderboardHierarchy(validationErrors))
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsConfig(): Failed to parse leaderboard hierarchy");
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    return validationErrors.getErrorMessages().empty();
}

bool StatsConfigData::parseStatsConfig(const StatsConfig& config)
{
    ConfigureValidationErrors validationErrors;
    if (!parseStatsConfig(config, validationErrors))
    {
        for (ConfigureValidationErrors::StringValidationErrorMessageList::const_iterator it = validationErrors.getErrorMessages().begin();
            it != validationErrors.getErrorMessages().end(); ++it)
        {
            ERR_LOG(it->c_str());
        }      
        return false;
    }

    return true;
}

/*************************************************************************************************/
/*!
    \brief parseCategoryStats

    Extract stat categories from the config file and turn them into object representations.

    \param[in]  category - the category to parse stats for
    \param[out] statMap - map to be populated with Stat objects keyed by their name
    \param[out] derivedList - list to be populated with Stat objects who are derived (in order
                              of dependency)
    \param[out] configOrderList - list to be populated with Stat objects as ordered in the config
    \param[in]  stats - stats list input to be parsed
    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseCategoryStats(const StatCategory& category, 
    StatMap& statMap, StatList& stats, ConfigureValidationErrors& validationErrors)
{
    // First step, parse the basics of the whole category
    for (StatList::iterator itr = stats.begin(), end = stats.end(); itr != end; ++itr)
    {
        Stat* stat = *itr;

        const char8_t* statname = stat->getName();
        if (statname[0] == '\0')
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategoryStats(): stat name must be present");
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            continue;
        }
        if (!isIdentifierChar(*statname) || (*statname >= '0' && *statname <= '9'))
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategoryStats(): the first character of stat name '%s' cannot be '%c'", stat->getName(), *statname);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            continue;
        }
        while (*(++statname) != '\0')
        {
            if (!isIdentifierChar(*statname))
            {
                break;
            }
        }
        if (*statname != '\0')
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategoryStats(): stat name '%s' cannot include '%c' character", stat->getName(), *statname);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            continue;
        }

        const char8_t* type = stat->getType();
        int64_t defIntVal = 0;
        float_t defFloatVal = 0.0;
        const char8_t* defStringVal = "";

        static const char8_t* TYPE_INT = "int";
        static const char8_t* TYPE_FLOAT = "float";
        static const char8_t* TYPE_STRING = "string";
        StatTypeDb typeDb;
 
        uint32_t size = stat->getSize();
        const char8_t* defaultStatValue = stat->getDefault();

        if (blaze_strncmp(type, TYPE_INT, sizeof(TYPE_INT)) == 0)
        {
            if (0 == size)
                size = sizeof(int32_t);

            typeDb.set(STAT_TYPE_INT, size);

            if (defaultStatValue[0] != '\0')
            {
                blaze_str2int(defaultStatValue, &defIntVal);
            }
        }
        else if (blaze_strncmp(type, TYPE_FLOAT, sizeof(TYPE_FLOAT)) == 0)
        {
            typeDb.set(STAT_TYPE_FLOAT, sizeof(float));
            if (defaultStatValue[0] != '\0')
            {
                float val = 0.0;
                blaze_str2flt(defaultStatValue, val);
                defFloatVal = (float_t) val;
            }
        }
        else if (blaze_strncmp(type, TYPE_STRING, sizeof(TYPE_STRING)) == 0)
        {
            if (0 == size)
                size = 255;

            typeDb.set(STAT_TYPE_STRING, size);
            defStringVal = defaultStatValue;
        }
        else
        {
            // if none of the types match we cannot make a good decision so bail!
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategoryStats(): Stat '%s' uses unsupported type '%s'", stat->getName(), type);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            continue;
        }

        if (!typeDb.isValidSize())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategoryStats(): size of %d not valid for stat of type %s", typeDb.getSize(), type);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            continue;
        }

        const char8_t* format = stat->getFormat();
        char8_t recreateFormat[STATS_FORMAT_LENGTH];
        if (!validateFormat(typeDb.getType(), format, typeDb.getSize(), recreateFormat, sizeof(recreateFormat)))
        {
            WARN_LOG("[StatsConfigData].parseCategoryStats(): Defaulting format of " << stat->getName() << " based on type");
            switch (typeDb.getType())
            {
                case STAT_TYPE_INT:
                {
                    if (typeDb.getSize() == 8)
                    {
                        format = "%" PRId64;
                    }
                    else
                        format = "%d";
                    break;
                }
                case STAT_TYPE_FLOAT:
                    format = "%.2f";
                    break;
                case STAT_TYPE_STRING:
                    format = "%s";
                    break;
            }
        }
        else
        {
            //point to recreate format
            format = recreateFormat;
        }

        stat->init(&category, typeDb, format, defIntVal, defFloatVal, defStringVal);

        // could check statMap before Stat alloc, but "name" could be longer than final getName()
        if (statMap.find(stat->getName()) != statMap.end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategoryStats(): duplicate stat found for %s", stat->getName());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            continue;
        }
        statMap[stat->getName()] = stat;

        TRACE_LOG("[StatsConfigData].parseCategoryStats(): A Stat is: " << stat->getName() << " " << stat->getType() << " " << stat->getDefaultIntVal());
    }

    return validationErrors.getErrorMessages().empty();
}

/*************************************************************************************************/
/*!
    \brief parseDerivedStats

    After parsing all the main information about the stat categories, this method parses and
    validates the formulae for any derived stats.  This must be done after all stat categories
    have been parsed, as derived formulae are allowed to refer to stats from other categories,
    and we need to be able to verify that those stats both exist and determine their data type.

    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseDerivedStats(ConfigureValidationErrors& validationErrors)
{
    // First step, parse derived formulae into expressions

    // During this first stage of parsing, we put all non-derived stats in the validatedStats bucket,
    // and all derived stats go in the toBeValidateStats bucket.  Later stages will iterate through
    // the toBeValidated stats bucket looking for derived stats who depend only on validatedStats,
    // thus ensuring there are no circular dependencies
    StringSet validatedStats;
    CategoryStatList toBeValidatedStats;

    for (CategoryMap::iterator catIter = mCategoryMap.begin(); catIter != mCategoryMap.end(); ++catIter)
    {
        StatCategory* cat = catIter->second;
        for (StatMap::iterator iter = cat->getStatsMap()->begin(); iter != cat->getStatsMap()->end(); ++iter)
        {
            Stat* stat = iter->second;
            const char8_t* derived = stat->getDerived();
            if (derived[0] == '\0')
            {
                validatedStats.insert(stat->getQualifiedName());
                continue;
            }

            CategoryStat& catStat = toBeValidatedStats.push_back();
            catStat.categoryName = cat->getName();
            catStat.statName = stat->getName();

            // Setup and call lex and yacc to parse the derived formula into a hierarchy of expressions
            BlazeLexer::LexResolveTypeCb cb(this, &StatsConfigData::resolveStatType);
            StatMap* statMap = cat->getStatsMap();
            BlazeLexer lexer(derived, static_cast<void*>(statMap), cb);
            StatDependencyContainer container(stat->getDependencies(), &mCategoryMap, cat->getName());
            lexer.setDependencyContainer(&container);
            blazeparse(&lexer);

            // Pull the resulting expression back out of the lexer object (though the expression objects
            // are generated by yacc, the lexer is an object that we own here so it also serves as a
            // general purpose data passing mechanism)
            Blaze::Expression* expression = lexer.getExpression();
            if (expression == nullptr)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseDerivedStats(): encountered a grammatical error while parsing "
                    "derived formula for %s", stat->getQualifiedName());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            else if (expression->getErrorCount() > 0)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseDerivedStats(): encountered %d error while parsing "
                    "derived formula for %s", expression->getErrorCount(), stat->getQualifiedName());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }

            // While yacc will have already caught any internal problems with attempts to converts strings
            // to numeric data types, we need to perform one final check ourselves that we are not attempting
            // to assign a string expression to a numeric stat
            if (expression->isString() && stat->getDbType().getType() != STAT_TYPE_STRING)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseDerivedStats(): attempt to assign string type expression to non string type"
                    "stat: %s type: %d", stat->getQualifiedName(), stat->getDbType().getType());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }

            // At this point the expression is valid, though we still need to verify later whether there
            // are any circular dependencies
            stat->setDerivedExpression(expression);

            TRACE_LOG("[StatsConfigData].parseDerivedStats(): Successfully parsed expression for " << stat->getQualifiedName());
        }
    }

    // Second step, there are actually two tasks we can accomplish together, one is to validate there are
    // no circular dependencies, while we are doing that we can also build up the data structures that track
    // how the various stat categories depend upon each other

    // Create an initial starting point, wich each category having its own CategoryDependency object,
    // as we progress and find categories that need to be tied together, we will consolidate entries from
    // their separate CategoryDependency objects into one, and have both categories point to the same object,
    // this StatsConfig remains the official owner for this memory as it is the easiest place to perform the
    // cleanup at shutdown time
    for (CategoryMap::const_iterator iter = mCategoryMap.begin(); iter != mCategoryMap.end(); ++iter)
    {
        CategoryDependency* catDep = BLAZE_NEW CategoryDependency();
        catDep->catSet.insert(iter->first);
        mCategoryDependencySet.insert(catDep);
        iter->second->setCategoryDependency(catDep);
    }

    size_t size = toBeValidatedStats.size();
    while (size > 0)
    {
        CategoryStatList::iterator iter = toBeValidatedStats.begin();
        CategoryStatList::const_iterator end = toBeValidatedStats.end();
        while (iter != end)
        {
            bool satisfied = true;
            CategoryStat catStat = *iter;
            StatCategory* currCat = mCategoryMap.find(catStat.categoryName)->second;
            const Stat* stat = currCat->getStatsMap()->find(catStat.statName)->second;
            const DependencyMap* dependencies = stat->getDependencies();
            for (DependencyMap::const_iterator depIter = dependencies->begin(); depIter != dependencies->end(); ++depIter)
            {
                // The current stat we are processing may depend on many other stats, a collection of which
                // may come from a single category, we only want to validate the category<->category dependency stuff once
                StatCategory* otherCat = mCategoryMap.find(depIter->first)->second;
                if (currCat != otherCat)
                {
                    // Remember the fact that we have at least one cross-category dependency,
                    // we can take some shortcuts during normal runtime if there are absolutely no cross cat dependencies
                    mHasMultiCategoryDerivedStats = true;

                    // In order to do cross category derived stats, we need to be working with apples and apples,
                    // so verify that both categories involved have the same entity type, period types, and keyscopes
                    if (currCat->getCategoryEntityType() != otherCat->getCategoryEntityType())
                    {
                        eastl::string msg;
                        msg.sprintf("[StatConfig].parseDerivedStats(): Error, cat %s has a derived formula that depends on cat %s, "
                            "but differs in entity type", currCat->getName(), otherCat->getName());
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                    for (int32_t periodType = 0; periodType < STAT_NUM_PERIODS; ++periodType)
                    {
                        if (currCat->isValidPeriod(periodType) != otherCat->isValidPeriod(periodType))
                        {
                            eastl::string msg;
                            msg.sprintf("[StatConfig].parseDerivedStats(): Error, cat %s has a derived formula that depends on cat %s, "
                                "but differs in period types", currCat->getName(), otherCat->getName());
                            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                            str.set(msg.c_str());
                            return false;
                        }
                    }
                    if (currCat->hasScope() != otherCat->hasScope())
                    {
                        eastl::string msg;
                        msg.sprintf("[StatConfig].parseDerivedStats(): Error, cat %s has a derived formula that depends on cat %s, "
                            "but only one category has scopes", currCat->getName(), otherCat->getName());
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                    if (currCat->hasScope())
                    {
                        if (currCat->getScopeNameSet()->size() != otherCat->getScopeNameSet()->size())
                        {
                            eastl::string msg;
                            msg.sprintf("[StatConfig].parseDerivedStats(): Error, cat %s has a derived formula that depends on cat %s, "
                                "but differs in number of scopes", currCat->getName(), otherCat->getName());
                            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                            str.set(msg.c_str());
                            return false;
                        }
                        for (ScopeNameSet::const_iterator it = currCat->getScopeNameSet()->begin();
                        it != currCat->getScopeNameSet()->end(); ++it)
                        {
                            if (!otherCat->isValidScopeName(*it))
                            {
                                eastl::string msg;
                                msg.sprintf("[StatConfig].parseDerivedStats(): Error, cat %s has a derived formula that depends on cat %s, "
                                    "but differ in scopes", currCat->getName(), otherCat->getName());
                                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                                str.set(msg.c_str());
                                return false;
                            }
                        }
                    }

                    // Any two categories where a stat from one relies on the other will forever be tied together, as updates
                    // to stats from either category will require fetching the other category's stats, so if we have not already
                    // made the association between the two, tie them together now
                    CategoryDependency* currDep = currCat->getCategoryDependency();
                    CategoryDependency* otherDep = otherCat->getCategoryDependency();
                    if (currDep != otherDep)
                    {
                        // Need to go through all of the categories in the other dependency collection, and repoint all of them to this
                        // dependency set, as well as consolidating the category dependencies
                        for (StringSet::const_iterator otherIter = otherDep->catSet.begin(); otherIter != otherDep->catSet.end(); ++otherIter)
                        {
                            currDep->catSet.insert(*otherIter);
                            mCategoryMap.find(*otherIter)->second->setCategoryDependency(currDep);
                        }

                        // And also consolidate all stat dependencies from both buckets
                        currDep->catStatList.insert(currDep->catStatList.end(), otherDep->catStatList.begin(), otherDep->catStatList.end());

                        // Then turf the other dependency
                        mCategoryDependencySet.erase(otherDep);
                        delete otherDep;
                    }
                }

                // Having validated any category<-> category dependencies, we now look at the one or more stats
                // we depend on from that category to see if all dependencies from that particular category are validated
                for (StatSet::const_iterator statIter = depIter->second.begin(); statIter != depIter->second.end(); ++statIter)
                {
                    if (*statIter != stat && validatedStats.find((*statIter)->getQualifiedName()) == validatedStats.end())
                    {
                        satisfied = false;
                        break;
                    }
                }

                // Once we hit one non-satisfied dependency, no point in validating the remainder of the categories
                // we may depend on so break out of the loop and try another stat
                if (!satisfied)
                    break;
            }

            // Advance the iterator but remember it, we will use it to perform an erase below if we satisfied all
            // dependencies for a stat
            CategoryStatList::iterator erase = iter++;

            if (satisfied)
            {
                // Push back an entry into the ordered list of derived stats, this will be used
                // during stat updates to determine the order of evaluation for all derived stats
                CategoryStat& catStatDerived = currCat->getCategoryDependency()->catStatList.push_back();
                catStatDerived.categoryName = catStat.categoryName;
                catStatDerived.statName = catStat.statName;

                // Take the entry out of the toBeValidated list and mark it as validated
                validatedStats.insert(stat->getQualifiedName());
                toBeValidatedStats.erase(erase);
            }
        }

        // If the above loop didn't resolve a single derived stat, then that means we encountered
        // a circular definition and we have to give up
        if (toBeValidatedStats.size() == size)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseDerivedStats(): "
                "Could not resolve all dependencies for derived stats");
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        size = toBeValidatedStats.size();
    }

    // Third step, for each derived formula, compute its default value based on the default values of all
    // stats it depends on
    char8_t* buf = BLAZE_NEW_ARRAY(char8_t, STATS_STATVALUE_LENGTH);
    for (CategoryDependencySet::const_iterator iter = mCategoryDependencySet.begin();
        iter != mCategoryDependencySet.end(); ++iter)
    {
        for (CategoryStatList::const_iterator slIter = (*iter)->catStatList.begin();
            slIter != (*iter)->catStatList.end(); ++slIter)
        {
            StatCategory* cat = mCategoryMap.find((*slIter).categoryName)->second;
            Stat* stat = cat->getStatsMap()->find((*slIter).statName)->second;

            const Blaze::Expression* derivedExpression = stat->getDerivedExpression();
            Blaze::Expression::ResolveVariableCb cb(this, &StatsConfigData::resolveStatDefaultValue);

            if (stat->getDbType().getType() == STAT_TYPE_INT)
            {
                stat->setDefaultIntVal(derivedExpression->evalInt(cb, static_cast<void*>(cat->getStatsMap())));
            }
            else if (stat->getDbType().getType() == STAT_TYPE_FLOAT)
            {
                stat->setDefaultFloatVal(derivedExpression->evalFloat(cb, static_cast<void*>(cat->getStatsMap())));
            }
            else if (stat->getDbType().getType() == STAT_TYPE_STRING)
            {
                buf[0] = '\0';
                derivedExpression->evalString(cb, static_cast<void*>(cat->getStatsMap()), buf, STATS_STATVALUE_LENGTH);
                stat->setDefaultStringVal(buf);
            }
        }
    }
    delete[] buf;

    return true;
}

/*************************************************************************************************/
/*!
    \brief parseCategories

    Parses core parameters describing categories into StatCategory objects, delegates to
    parseCategoryStats() to perform the individual stat parsing.

    \param[in]  config - stats config file input to be parsed
    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseCategories(ConfigureValidationErrors& validationErrors)
{
    const CategoriesList& categoryList = mConfig->getCategories();
    uint32_t catId = 0;

    CategoriesList::const_iterator itr = categoryList.begin();
    CategoriesList::const_iterator end = categoryList.end();

    for (; itr != end ; ++itr)
    {
        const StatCategory* cat = *itr;

        const char8_t* name = cat->getName();
        TRACE_LOG("[StatsConfigData].parseCategories(): Processing a category: " << name);

        if (strlen(name) > cat->getNameMaxStringLength()-1)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategories(): category name [%s] exceeds maximum length [%" PRIu32 "]",
                name, cat->getNameMaxStringLength()-1);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        EA::TDF::ObjectType entityType;
        const char8_t* entityTypeName = cat->getEntityType();
        if (entityTypeName != nullptr)
        {
            entityType = BlazeRpcComponentDb::getBlazeObjectTypeByName(entityTypeName);
        }
        else
        {
            entityType = EA::TDF::OBJECT_TYPE_INVALID;
        }

        int32_t periodTypes = cat->getPeriodTypes();

        // validate the period types
        const int32_t periodTypesMask = ~(((~0U) >> STAT_NUM_PERIODS) << STAT_NUM_PERIODS);
        if ((periodTypes & periodTypesMask) == 0)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategories(): no valid period specified for category %s", name);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        if ((periodTypes & ~periodTypesMask) != 0)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseCategories(): invalid period specified for category %s", name);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }


        const ScopeList& scopeList = cat->getScope();
        const char8_t* scopeName   = nullptr;
        ScopeNameSet* scopeNameSet = nullptr;
       
        if (!scopeList.empty())
        {
            scopeNameSet = BLAZE_NEW ScopeNameSet();
            
            ScopeList::const_iterator it   = scopeList.begin();
            ScopeList::const_iterator last = scopeList.end();
            for (; it != last ; ++it)
            {
                scopeName = it->c_str();
                TRACE_LOG("[StatsConfigData].parseCategories(): Processing a scope in a stats category. Current scopeName is " << scopeName);
                if (getKeyScopeMap().find(scopeName) == getKeyScopeMap().end())
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseCategories(): scope name(%s) defined for the category(%s) is not defined in key scope.", scopeName, cat->getName());
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    delete scopeNameSet;
                    return false;
                }
                scopeNameSet->insert(scopeName);
            }
        }

        StatMap* statMap = BLAZE_NEW StatMap;
        StatCategoryPtr newCat = BLAZE_NEW StatCategory;
        cat->copyInto(*newCat);
        newCat->init(++catId, entityType, statMap, scopeNameSet);

        if (!parseCategoryStats(*newCat, *statMap, newCat->getStats(), validationErrors))
        {
            return false;
        }

        mCategoryMap[newCat->getName()] = newCat;
        mCategoryIdMap[newCat->getId()] = newCat;
        TRACE_LOG("[StatsConfigData].parseCategories(): category '" << newCat->getName() << "' assigned id " << newCat->getId());
    }

    return parseDerivedStats(validationErrors);
}

/*************************************************************************************************/
/*!
    \brief initShards

    Parses and validates the stats shards configuration.

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::initShards()
{
    // The stats master/slave impl should already have validated this, but no easy way to get at it here,
    // so we simply re-fetch it from the scheduler, and for safety's sake revalidate it
    uint32_t statsDbId = gDbScheduler->getDbId(mConfig->getDbName());
    if (statsDbId == DbScheduler::INVALID_DB_ID)
    {
        ERR_LOG("[StatsConfigData].initShards(): Main stats db config invalid");
        return false;
    }
    mShardConfiguration.init(statsDbId);

    const ShardInfoList& shardInfoList = mConfig->getShardInfoList();
    ShardMap& shardMap = mShardConfiguration.getShardMap();

    // Go through the config, and validate and convert db names into db ids
    ShardInfoList::const_iterator itr = shardInfoList.begin();
    ShardInfoList::const_iterator end = shardInfoList.end();
    for (; itr != end; ++itr)
    {
        const ShardInfo* shardInfo = *itr;
        EA::TDF::ObjectType entityType = shardInfo->getEntityType();
        const DbNameList& list = shardInfo->getDbNames();
        if (list.empty())
        {
            ERR_LOG("[StatsConfigData].initShards(): empty shard db name list");
            return false;
        }

        ShardMap::const_iterator entry = shardMap.find(entityType);
        if (entry != shardMap.end())
        {
            ERR_LOG("[StatsConfigData].initShards(): duplicate entity type in shard map");
            return false;
        }

        shardMap[entityType].getDbIds().reserve(list.size());
        shardMap[entityType].init(statsDbId, entityType);

        for (DbNameList::const_iterator dbItr = list.begin(); dbItr != list.end(); ++dbItr)
        {
            uint32_t dbId = gDbScheduler->getDbId(*dbItr);
            if (dbId == DbScheduler::INVALID_DB_ID)
            {
                ERR_LOG("[StatsConfigData].initShards(): unknown DB referenced in shard map");
                return false;
            }

            shardMap[entityType].getDbIds().push_back(dbId);
        }
    }

    return true;
}


/*! ************************************************************************************************/
/*! \brief parses core parameters describing key scope item into KeyScopeItem obj and saved
     into KeyScopesMap obj in config

    \param[in]config - base StatsConfig object to retrieve key scope config data
    \param[out] validationErrors - error messages for config validation

    \return true - parse runs properly and there is no bad settings in the config file
***************************************************************************************************/
bool StatsConfigData::parseKeyScopes(ConfigureValidationErrors& validationErrors)
{
    KeyScopesMap& keyScopeMap = mConfig->getKeyscopes();  
    const char8_t* keyScopeItemName;

    KeyScopesMap::iterator itr = keyScopeMap.begin();
    KeyScopesMap::iterator end = keyScopeMap.end();
    for(;itr != end; itr++)
    {
        // key scope item's name
        if (itr->first.length() > STATS_STAT_NAME_LENGTH)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseKeyScopes(): key scope item name [%s] exceeds maximum length [%" PRIu32 "]",
                itr->first.c_str(), STATS_STAT_NAME_LENGTH);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        keyScopeItemName = itr->first;

        // key scope item for the given scope item name
        KeyScopeItem* keyScopeItem= itr->second;
        if (parseKeyScopeItem(keyScopeItemName, *keyScopeItem, validationErrors) == false)
        {
            return false;
        }
    }

    return true;
}

bool StatsConfigData::parseKeyScopes(const StatsConfig& config)
{
    ConfigureValidationErrors validationErrors;
    if (!parseKeyScopes(validationErrors))
    {
        for (ConfigureValidationErrors::StringValidationErrorMessageList::iterator it = validationErrors.getErrorMessages().begin();
            it != validationErrors.getErrorMessages().end(); ++it)
        {
            ERR_LOG(it->c_str());
        }      
        return false;
    }

    return true;
}

/*! ************************************************************************************************/
/*! \brief parse each key scope item content in the config file

    \param[in] keyScopeItemName  - name of the keyscopeItem eg. level
    \param[in] keyScopeItem  - config keyscope item
    \param[out] validationErrors - error messages for config validation

    \return true if there are no bad settings in the key scope item, otherwise false
***************************************************************************************************/
bool StatsConfigData::parseKeyScopeItem(const char8_t* keyScopeItemName, KeyScopeItem& keyScopeItem, ConfigureValidationErrors& validationErrors)
{
    if (keyScopeItem.getEnableAggregation())
    {
        if (keyScopeItem.getAggregateKeyValue() < 0)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseKeyScopeItem(): key scope item [%s] cannot specify negative aggregate key value [%" PRId64 "]",
                keyScopeItemName, keyScopeItem.getAggregateKeyValue());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
    }

    if (!parseKeyScopeValues(keyScopeItem.getKeyScopeValues(), validationErrors))
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseKeyScopeItem(): key scope item [%s] has bad values",
            keyScopeItemName);
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    // validate any aggregate key value
    // If no key scope values are specified, then all are valid and the aggregate key value can be any.
    // Otherwise, the aggregate key value can't be specified in the key scope values.
    if (keyScopeItem.getEnableAggregation())
    {
        bool isMatch = false;
        ScopeStartEndValuesMap::const_iterator upperIter = keyScopeItem.getKeyScopeValues().upper_bound(keyScopeItem.getAggregateKeyValue());
        if ( upperIter != keyScopeItem.getKeyScopeValues().begin() )
        {
            --upperIter;
            
            if ( keyScopeItem.getAggregateKeyValue() >= upperIter->first 
            && keyScopeItem.getAggregateKeyValue() <=  upperIter->second )
            {
                isMatch = true;
            }
        }

        // will match...
        if ( isMatch )
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseKeyScopeItem(): key scope item [%s] has non-unique aggregate key value [%" PRId64 "]",
                keyScopeItemName, keyScopeItem.getAggregateKeyValue());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
    }

    return true;
}

/*! ************************************************************************************************/
/*! \brief parse the values of a leaderboard's key scope item in the config file

    The values can be a sequence of ranges, e.g. values = [1:3, 5, 8, 10:13, 14]

    \param[in] keyScopeItemName  - name of the keyscopeItem eg. level
    \param[in] keyScopeValuesSequence  - config sequence
    \param[in] keyScopeStartEndValuesMap  - parsed keyscope item
    \param[out] validationErrors - error messages for config validation

    \return true if there are no bad settings in the key scope item's values, otherwise false
***************************************************************************************************/
bool StatsConfigData::parseKeyScopeLeaderboardValues(const char8_t* keyScopeItemName, const ScopeValueList& keyScopeValuesSequence, ScopeStartEndValuesMap& keyScopeStartEndValuesMap, ConfigureValidationErrors& validationErrors)
{
    // iterate through the ranges
    ScopeValueList::const_iterator item = keyScopeValuesSequence.begin();
    ScopeValueList::const_iterator last = keyScopeValuesSequence.end();

    for (; item != last; ++item)
    {
        const char8_t* startRange = *item;

        // unlike parseKeyScopeValues, special keywords are allowed here

        if (blaze_strcmp(startRange, "?") == 0)
        {
            if (!keyScopeStartEndValuesMap.empty())
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): not allowed other values with"
                    " user-defined value for a keyscope (including another user-defined value)");
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }

            // in this case, keyscope value can be negative...

            // populate the start-end values map
            keyScopeStartEndValuesMap[KEY_SCOPE_VALUE_USER] = KEY_SCOPE_VALUE_USER;
        }
        else
        {
            ScopeValue startValue = -1;
            ScopeValue endValue = -1;

            /// @todo deprecate or rename to aggregrate?
            if (blaze_strcmp(startRange, "total") == 0)
            {
                // replace with actual key value right away
                startValue = endValue = getAggregateKeyValue(keyScopeItemName);

                if (startValue < 0)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): [%s] key scope does not have aggregate",
                        keyScopeItemName);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
            }
            else
            {
                // extract the start and end values of the current range
                const char8_t* endRange = blaze_str2int(startRange, &startValue);
                if (endRange == startRange)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): invalid start range [%s]", startRange);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
                if (startValue < 0)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): [%s] key scope value cannot be negative [%" PRId64 "]",
                        startRange, startValue);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }

                if (strlen(endRange) == 0)
                {
                    // a single value range
                    endValue = startValue;
                }
                else
                {
                    // check the range delimiter
                    if (endRange[0] != ':')
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): incorrectly formed range [%s]", startRange);
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }

                    // skip the range delimiter
                    ++endRange;

                    if (endRange == blaze_str2int(endRange, &endValue))
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): invalid end range [%s]", startRange);
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                    if (endValue < startValue)
                    {
                        // this implies that endValue cannot be negative (so that validation is not needed here)
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): [%s] end of range [%" PRId64 "] cannot be less than start of range [%" PRId64 "]",
                            startRange, endValue, startValue);
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                }
            }

            // check for overlap in the start-end values map
            ScopeStartEndValuesMap::const_iterator itr = keyScopeStartEndValuesMap.begin();
            ScopeStartEndValuesMap::const_iterator end = keyScopeStartEndValuesMap.end();
            for (; itr != end; ++itr)
            {
                if (startValue < itr->first)
                {
                    if (endValue >= itr->first)
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): duplicate values not allowed [%s]", startRange);
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                    break;
                }

                if (startValue <= itr->second)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): duplicate values not allowed [%s]", startRange);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
            }

            // populate the start-end values map
            keyScopeStartEndValuesMap[startValue] = endValue;
        }
    }

    if (keyScopeStartEndValuesMap.find(KEY_SCOPE_VALUE_USER) != keyScopeStartEndValuesMap.end())
    {
        if (keyScopeStartEndValuesMap.size() > 1)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseKeyScopeLeaderboardValues(): not allowed other values with user-defined value for a keyscope");
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
    }

    // trim the start-end values map by merging contiguous adjacent mappings, e.g. [1] = 2, [3] = 3 becomes [1] = 3
    ScopeStartEndValuesMap::iterator curItr = keyScopeStartEndValuesMap.begin();
    ScopeStartEndValuesMap::iterator nextItr;
    for (; curItr != keyScopeStartEndValuesMap.end(); ++curItr)
    {
        while (1)
        {
            nextItr = curItr;
            ++nextItr;
            if (nextItr == keyScopeStartEndValuesMap.end())
            {
                break;
            }
            if (curItr->second + 1 != nextItr->first)
            {
                // not contiguous
                break;
            }
            // merge
            curItr->second = nextItr->second;
            keyScopeStartEndValuesMap.erase(nextItr);
        }
    }

    return true;
}

/*! ************************************************************************************************/
/*! \brief parse the values of a key scope item in the config file

    The values are a map of ranges, e.g. values = [1=3, 5=5, 8=8, 10=13, 14=14]

    \param[in] keyScopeStartEndValuesMap  - parsed keyscope item
    \param[out] validationErrors - error messages for config validation

    \return true if there are no bad settings in the key scope item's values, otherwise false
***************************************************************************************************/
bool StatsConfigData::parseKeyScopeValues(ScopeStartEndValuesMap& keyScopeStartEndValuesMap, ConfigureValidationErrors& validationErrors)
{
    // iterate through the ranges
    ScopeStartEndValuesMap::const_iterator itr = keyScopeStartEndValuesMap.begin();
    ScopeStartEndValuesMap::const_iterator end = keyScopeStartEndValuesMap.end();
    for (; itr != end; ++itr)
    {
        // check the start and end values of the current range
        ScopeValue startValue = itr->first;
        ScopeValue endValue = itr->second;
        if (endValue < startValue)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseKeyScopeValues(): End of range [%" PRId64 "] cannot be less than start of range [%" PRId64 "]",
                endValue, startValue);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        // check for overlap in the start-end values map
        ScopeStartEndValuesMap::const_iterator itr2 = keyScopeStartEndValuesMap.begin();
        for (; itr2 != itr; ++itr2)
        {
            if (startValue < itr2->first)
            {
                if (endValue >= itr2->first)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseKeyScopeValues(): duplicate values not allowed, range [%" PRId64 "] = [%" PRId64 "] overlaps with range [%" PRId64 "] = [%" PRId64 "]",
                        startValue, endValue, itr2->first, itr2->second);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
                break;
            }

            if (startValue <= itr2->second)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseKeyScopeValues(): duplicate values not allowed, range [%" PRId64 "] = [%" PRId64 "] overlaps with range [%" PRId64 "] = [%" PRId64 "]",
                    startValue, endValue, itr2->first, itr2->second);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
        }
    }

    // trim the start-end values map by merging contiguous adjacent mappings, e.g. [1] = 2, [3] = 3 becomes [1] = 3
    ScopeStartEndValuesMap::iterator curItr = keyScopeStartEndValuesMap.begin();
    ScopeStartEndValuesMap::iterator nextItr;
    for (; curItr != keyScopeStartEndValuesMap.end(); ++curItr)
    {
        while (1)
        {
            nextItr = curItr;
            ++nextItr;
            if (nextItr == keyScopeStartEndValuesMap.end())
            {
                break;
            }
            if (curItr->second + 1 != nextItr->first)
            {
                // not contiguous
                break;
            }
            // merge
            curItr->second = nextItr->second;
            keyScopeStartEndValuesMap.erase(nextItr);
        }
    }

    return true;
}

/// @todo cleanup: have callers access KeyScopeItem directly and deprecate getAggregateKeyValue() and isValidScopeValue() ?
ScopeValue StatsConfigData::getAggregateKeyValue(const char8_t* scopeName) const
{
    KeyScopesMap::const_iterator itr = getKeyScopeMap().find(scopeName);
    if (itr != getKeyScopeMap().end())
    {
        const KeyScopeItem* scopeItem = itr->second;
        if (scopeItem->getEnableAggregation())
        {
            return scopeItem->getAggregateKeyValue();
        }
    }

    /// @todo use "unknown" reserved value
    return KEY_SCOPE_VALUE_AGGREGATE;
}

/*************************************************************************************************/
/*!
\brief isNumber

Test string to determine if it is a number.  Will look for standard positive or negative decimal 
numeric sequences, hexidecimal sequences using the 0x syntax, or floating poing sequences using
the nnnn.nnn syntax.

\param[in]  value - nullptr-terminated string to test 

\return - true of entire string is a number, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::isNumber(const char8_t* value) 
{
    if ( value == nullptr || *value == '\0' )
    {
        return false;
    }

    bool isHex = (value[0] == '0' && LocaleTokenToLower(value[1]) == 'x'); // Allow hex characters
    uint32_t numDigits = 0;                                     // Not valid until we see at least 1 digit

    if (isHex == true)
    {
        // We've already seen the hex signature, so start at the 3rd character
        for (uint32_t i = 2 ; value[i] != '\0' ; ++i)
        {
            if ((value[i] >= '0' && value[i] <= '9') ||
                (LocaleTokenToLower(value[i]) >= 'a' && LocaleTokenToLower(value[i]) <= 'f'))
            {
                ++numDigits;
            }
            else
            {
                return false;
            }
        }
    }
    else
    {
        bool seenDecimalPlace = false;

        // Decimal or floating point
        for (uint32_t i = 0 ; value[i] != '\0' ; ++i)
        {
            if (value[i] >= '0' && value[i] <= '9')
            {
                ++numDigits;
            }
            else if (value[i] == '-' && i == 0)
            {
                /*empty*/;           // First character can be a minus, but it doesn't count as a digit.
            }
            else if (value[i] == '.' && seenDecimalPlace == false)
            {
                seenDecimalPlace = true;        // Hey, it's floating point!  Decimal doesn't count as a digit though.
            }
            else
            {
                return false;
            }
        }
    }

    // All other failure conditions will have returned false from within the loop.  So if we've
    // seen a digit, and we've fallen out of the loop, we're golden.
    return (numDigits > 0);
}

bool StatsConfigData::isValidScopeValue(const char8_t* scopeName, const ScopeValue scopeValue) const
{
    if (scopeValue < 0)
    {
        // only non-negative values allowed
        return false;
    }

    KeyScopesMap::const_iterator itr = getKeyScopeMap().find(scopeName);
    if (itr != getKeyScopeMap().end())
    {
        const KeyScopeItem* scopeItem = itr->second;
        if (scopeItem->getKeyScopeValues().empty())
        {
            // no explicit keyscope values, so all are valid
            return true;
        }

        if (scopeItem->getEnableAggregation() && scopeItem->getAggregateKeyValue() == scopeValue)
        {
            return true;
        }
        
        ScopeStartEndValuesMap::const_iterator upperIter = scopeItem->getKeyScopeValues().upper_bound(scopeValue);
        if (  upperIter == scopeItem->getKeyScopeValues().begin() )
        {
            return false;
        }
        --upperIter;
        
        return ( scopeValue>=upperIter->first && scopeValue<=upperIter->second );
    }

    return false;
}

ScopeValue StatsConfigData::getKeyScopeSingleValue(const ScopeStartEndValuesMap& scopeValues) const
{
    if (scopeValues.size() == 1)
    {
        ScopeStartEndValuesMap::const_iterator valuesItr = scopeValues.begin();
        if (valuesItr->first == valuesItr->second)
        {
            return valuesItr->first;
        }
    }
    return KEY_SCOPE_VALUE_MULTI;
}

/*************************************************************************************************/
/*!
    \brief parseStatDescs

    Parses descriptive values for individual stats used to build up a stat group.

    \param[in]  group - parent stat group
    \param[in|out] descDataList - list to be searched to match descriptions up to Stat objects
    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseStatDescs(const StatGroup& group, StatDescList& descDataList, ConfigureValidationErrors& validationErrors)
{
    if (descDataList.empty())
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] must reference at least one stat.", 
            group.getName());
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }
    int32_t statIndex = 0;
    int32_t primaryCategoryCount = 0;
    const StatCategory& groupCategory = *(group.getStatCategory());
    
    for (StatDescList::iterator i = descDataList.begin(), e = descDataList.end(); i != e; ++i)
    {
        StatDesc* desc = *i;

        const char8_t* statName = desc->getName();
        if (statName[0] == '\0')
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatsDescs(): Found a stat description with no name in group [%s]", 
                group.getName());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        
        const StatCategory* statCategory = group.getStatCategory();
        
        const bool isPrimary = desc->getCategory()[0] == '\0' ||
            blaze_stricmp(desc->getCategory(), groupCategory.getName()) == 0;
        if (isPrimary)
        {
            primaryCategoryCount++;
        }
        else
        {
            // stat's category is different from group's category
            CategoryMap::const_iterator cat = mCategoryMap.find(desc->getCategory());
            if (cat == mCategoryMap.end())
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] category [%s] "
                    "does not exist", group.getName(), statName, desc->getCategory());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            // override stat category
            statCategory = cat->second;

            if (statCategory->getCategoryType() == CATEGORY_TYPE_GLOBAL)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] is in category [%s] "
                    "of type CATEGORY_TYPE_GLOBAL which prohibits stats groups", group.getName(), statName, desc->getCategory());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            
            TRACE_LOG("[StatsConfigData].parseStatsDescs(): Secondary stat [" << statName << "] uses category [" << statCategory->getName() << "]");
        }

        if (statCategory->getCategoryEntityType() != groupCategory.getCategoryEntityType())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] in category's [%s] "
                "entity type [%s] does not match group category's [%s] entity type [%s]",
                group.getName(), statName, statCategory->getName(),
                statCategory->getCategoryEntityType().toString().c_str(),
                groupCategory.getName(),
                groupCategory.getCategoryEntityType().toString().c_str());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        int32_t periodType = desc->getPeriodType();

        if (periodType != -1)
        {
            if ((statCategory->getPeriodTypes() & periodType) == 0)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] periodType(%xd) "
                    "does not match any periodTypes(%xd) in category [%s]",
                    group.getName(), statName, periodType,
                    statCategory->getPeriodTypes(), statCategory->getName());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            if (!isPowerOf2(periodType))
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] periodType(%xd) "
                    "bitmask can only have a single bit set.",
                    group.getName(), statName, periodType);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            for (int32_t period = 0; period < STAT_NUM_PERIODS; ++period)
            {
                if (periodType == (1 << period))
                {
                    // convert the period type mask into an actual period type enum value
                    periodType = period;
                    break;
                }
            }
        }
        else if (!isPrimary)
        {
            /// @todo allow secondary to inherit from primary ...
            // need to check intersection of period types for this stat's and the group's categories;
            // further validation then needed at request time.
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] must specify a period type.",
                group.getName(), statName);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        EA::TDF::tdf_ptr<ScopeNameValueMap> statScopeMap = nullptr;
        const ScopeNameSet* scopeSet = statCategory->getScopeNameSet();
        if (scopeSet != nullptr && !scopeSet->empty())
        {
            // NOTE: only perform scope validation if the category actually has a scope
            const ScopeNameValueMap* groupScopeMap = group.getScopeNameValueMap();
            if (desc->getScope().empty())
            {
                if (groupScopeMap == nullptr)
                {
                    // scope value is not defined in either the secondary stat nor in
                    // the stat group category, this is an invalid configuration.
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] scope value "
                        "omitted and parent group's scope is nullptr.",
                        group.getName(), statName);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
                // create a new map that will fill in the values of the parent group
                statScopeMap = BLAZE_NEW ScopeNameValueMap;
                // validate that the scopes mandated for this stat desc are completely
                // defined by scope values of the parent group
                for (ScopeNameSet::const_iterator itr = scopeSet->begin(), itrEnd = scopeSet->end(); itr != itrEnd; ++itr)
                {
                    ScopeNameValueMap::const_iterator it = groupScopeMap->find(itr->c_str());
                    if (it == groupScopeMap->end())
                    {
                        // scope value is not defined in either the secondary stat nor in
                        // the stat group category, this is an invalid configuration.
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseStatsDescs(): Neither stat [%s] "
                            "nor the group [%s] itself specify a value for scope [%s]",
                            statName, group.getName(), itr->c_str());
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                    // propagate the stat group scope value into the stat desc
                    (*statScopeMap)[it->first] = it->second;
                }
            }
            else
            {
                // NOTE: overridden category's stat scope always inherits '?' and '*' keyscope values
                // from the category of the parent stat group; therefore, only literal keyscope
                // values and 'total' reserved keyword are acceptable.
                statScopeMap = parseScopeSetting(desc->getScope(), SCOPE_RESERVED_TOTAL, validationErrors);
                if (statScopeMap != nullptr)
                {
                    // make sure that all scopes in scopeSet are either defined with a literal value
                    // in stat desc, or are able to be propagated from group.getScopeNameValueMap()
                    for (ScopeNameSet::const_iterator itr = scopeSet->begin(), itrEnd = scopeSet->end(); itr != itrEnd; ++itr)
                    {
                        if (statScopeMap->find(itr->c_str()) != statScopeMap->end())
                            continue;
                        // if not found already
                        ScopeNameValueMap::const_iterator it = nullptr;
                        if (groupScopeMap == nullptr || (it = groupScopeMap->find(itr->c_str())) == groupScopeMap->end())
                        {
                            // scope value is not defined in either the secondary stat nor in
                            // the stat group category, this is an invalid configuration.
                            eastl::string msg;
                            msg.sprintf("[StatsConfigData].parseStatsDescs(): Neither stat [%s] "
                                "nor the group [%s] itself specify a value for scope [%s]",
                                statName, group.getName(), itr->c_str());
                            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                            str.set(msg.c_str());
                            return false;
                        }
                        // propagate the stat group scope value into the stat desc
                        (*statScopeMap)[it->first] = it->second;
                    }
                }
                else
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseStatsDescs(): Failed to parse group [%s] stat's [%s] keyscope ",
                        group.getName(), statName);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
            }
        }
        
        if (statScopeMap != nullptr && statScopeMap->empty())
        {
            // we never pass an empty scope map to the stat desc
            statScopeMap = nullptr;
        }
        
        StatMap::const_iterator statIter = statCategory->getStatsMap()->find(statName);
        if (statIter == statCategory->getStatsMap()->end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] not found in category [%s]",
                group.getName(), statName, statCategory->getName());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        const Stat& stat = *statIter->second;
        const char8_t* format = desc->getFormat();

        char8_t recreateFormat[STATS_FORMAT_LENGTH];

        if (format[0] == '\0')
        {
            format = stat.getStatFormat();
        }
        else if (validateFormat(stat.getDbType().getType(), format, stat.getTypeSize(), recreateFormat, sizeof(recreateFormat)))
        {
            //point to recreate format
            format = recreateFormat; 
        }
        else
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatsDescs(): Group [%s] stat [%s] has invalid format string [%s]",
                group.getName(), statName, format);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        
        desc->init(&stat, &group, statScopeMap, periodType, format, statIndex++);
    }

    if (primaryCategoryCount < 1)
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseStatsDescs(): Stat group [%s] "
            "contains no stats from the primary category [%s]", 
            group.getName(), group.getStatCategory()->getName());
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    return true;
}

/*************************************************************************************************/
/*!
    \brief parseStatGroups

    Parses overall descriptions of stat groups from config file into StatGroup objects,
    and delegates to parseStatDescs() handle individual stat descriptions.

    \param[in]  Config - stats config file input to be parsed
    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseStatGroups(ConfigureValidationErrors& validationErrors)
{
    StatGroupsList::const_iterator itr = mConfig->getStatGroups().begin();
    StatGroupsList::const_iterator end = mConfig->getStatGroups().end();

    for (; itr != end; ++itr)
    {
        const StatGroup* group = *itr;

        const char8_t* name = group->getName();
        INFO_LOG("[StatsConfigData].parseStatGroups(): Processing a group: " << name);

        if (strlen(name) > group->getNameMaxStringLength()-1)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatGroups(): group name [%s] exceeds maximum length [%" PRIu32 "]",
                name, group->getNameMaxStringLength()-1);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        const char8_t* category = group->getCategory();
        if (category[0] == '\0')
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatGroups(): Group %s is missing a category", name);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        CategoryMap::const_iterator catIter = mCategoryMap.find(category);
        if (catIter == mCategoryMap.end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatGroups(): Category %s associated with "
                "group %s does not exist", category, name);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        if (catIter->second->getCategoryType() == CATEGORY_TYPE_GLOBAL)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseStatGroups(): Category %s associated with "
                "group %s is of type CATEGORY_TYPE_GLOBAL. Group stats of this category "
                "type are not supported.", category, name);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        // parse the stat group scope, could be nullptr if the category for the group does not have a scope
        EA::TDF::tdf_ptr<ScopeNameValueMap> scopeNameValueMap;
        if (catIter->second->hasScope())
        {
            const ScopeMap& scopeMap = group->getScope();

            if (!scopeMap.empty())
            {
                // parse scope name/value pair setting for the group
                scopeNameValueMap = parseStatGroupScope(scopeMap, validationErrors);

                // make sure the setting matches category scope name settings
                if (!catIter->second->isValidScopeNameSet(scopeNameValueMap))
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseStatGroups(): Category %s the group %s belongs to has mismatched scope settings.",
                        category, name);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
            }
            else
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseStatGroups(): Category %s the group %s belongs to has scope setting, however, group does not specifiy any scope.",
                    category, name);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
        }

        StatGroupPtr newGroup = BLAZE_NEW StatGroup;
        group->copyInto(*newGroup);
        newGroup->init(catIter->second, scopeNameValueMap);

        if (!parseStatDescs(*newGroup, newGroup->getStats(), validationErrors))
        {
            return false;
        }

        newGroup->buildSelectableCategories();

        mGroupMap[newGroup->getName()] = newGroup;
    }
    
    return true;
}

/*! ************************************************************************************************/
/*! \brief parse the scope definition in the stat group, a stat group can also have no any scope

    Note: caller is responsible to delete the ScopeNameValueMap obj

    \param[in]scopeMap - config map for the scope
    \param[out] validationErrors - error messages for config validation

    \return the ScopeNameValueMap created for the stat group, nullptr means it's a group without scope
        or the scope config setting has problem
***************************************************************************************************/
EA::TDF::tdf_ptr<ScopeNameValueMap> StatsConfigData::parseStatGroupScope(const ScopeMap&  scopeMap, ConfigureValidationErrors& validationErrors)
{
    return parseScopeSetting(scopeMap, SCOPE_RESERVED_ALL, validationErrors);
}

/*! ************************************************************************************************/
/*! \brief common method to parse a scope definition into a ScopeNameValueMap object

    Note: caller is responsible to delete the ScopeNameValueMap obj

    \param[in]scopeMap - config map for the scope
    \param[in]validReservedKeywords - combination of ScopeReservedValue, which indicates what kind of 
                                       scope reserved keywords is supported by the item being parsed
    \param[out] validationErrors - error messages for config validation

    \return the ScopeNameValueMap created for the stat group, nullptr means it's a group without scope
         or the scope config setting has problem
***************************************************************************************************/
EA::TDF::tdf_ptr<ScopeNameValueMap>  StatsConfigData::parseScopeSetting(const ScopeMap& scopeMap, const uint16_t validReservedKeywords, ConfigureValidationErrors& validationErrors)
{
    EA::TDF::tdf_ptr<ScopeNameValueMap> scopeNameValueMap;
    const char8_t* scopeName;
    ScopeValue scopeValue = 0;

    for (ScopeMap::const_iterator iter=scopeMap.begin(),end=scopeMap.end(); iter!=end; ++iter)
    {
        if (!scopeNameValueMap)
        {
            scopeNameValueMap = BLAZE_NEW ScopeNameValueMap();
        }

        scopeName = iter->first;

        // make sure the key scope name is defined in keyscopes
        KeyScopesMap::const_iterator it = getKeyScopeMap().find(scopeName);
        if (it == getKeyScopeMap().end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseScopeSetting(): scope name [%s] is not defined in keyscopes config", scopeName);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return nullptr;
        }

        // check for reserved keywords--which will be converted to reserved values ("magic numbers")
        const char8_t* scopeKeyword = iter->second;
        bool foundReservedKeyword = false;
        if (validReservedKeywords != 0)
        {
            if ((validReservedKeywords & SCOPE_RESERVED_EVERYTHING) && (blaze_strcmp(scopeKeyword, "*") == 0))
            {
                scopeValue = KEY_SCOPE_VALUE_ALL;
                foundReservedKeyword = true;
            }
            else if ((validReservedKeywords & SCOPE_RESERVED_USER_SPECIFIED) && (blaze_strcmp(scopeKeyword, "?") == 0))
            {
                scopeValue = KEY_SCOPE_VALUE_USER;
                foundReservedKeyword = true;
            }
            else if ((validReservedKeywords & SCOPE_RESERVED_TOTAL) && (blaze_strcmp(scopeKeyword, "total") == 0))
            {
                scopeValue = getAggregateKeyValue(scopeName);
                if (scopeValue == KEY_SCOPE_VALUE_AGGREGATE)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseScopeSetting(): aggregate for scope [%s] is not defined in keyscopes config", scopeName);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return nullptr;
                }
                foundReservedKeyword = true;
            }
        }

        if (!foundReservedKeyword)
        {
            if ( !isNumber(scopeKeyword) )
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseScopeSetting(): value [%s] for scope [%s] is not valid", scopeKeyword, scopeName);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return nullptr;
            }

            blaze_str2int(scopeKeyword, &scopeValue);

            if (!isValidScopeValue(scopeName, scopeValue))
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseScopeSetting(): value [%" PRId64 "] for scope [%s] is not defined in keyscopes config", scopeValue, scopeName);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());

                return nullptr;
            }
        }

        scopeNameValueMap->insert(eastl::make_pair(scopeName, scopeValue));
    }

    return scopeNameValueMap;
}

/*************************************************************************************************/
/*!
    \brief parseLeaderboardStatDescs

    Parses descriptive values for individual stats used to build up a leaderboard group.

    \param[in]  group - parent leaderboard group
    \param[in|out] descDataList - list to be searched to match descriptions up to Stat objects
    \param[out] validationErrors - error messages for config validation

    \return - true if parsing successful, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseLeaderboardStatDescs(const LeaderboardGroup& group, LbStatList& descDataList, ConfigureValidationErrors& validationErrors)
{
    if (descDataList.empty())
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] must reference at least one stat.", 
            group.getGroup());
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }
    int32_t statIndex = 0;
    int32_t primaryCategoryCount = 0;
    const StatCategory& groupCategory = *group.getStatCategory();
    for (LbStatList::iterator i = descDataList.begin(), e = descDataList.end(); i != e; ++i)
    {
        GroupStat* groupStat = *i;

        const char8_t* statName = groupStat->getName();
        if (statName[0] == '\0')
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Found a stat description with no name in group [%s]", 
                group.getGroup());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        // default to group's stat category first
        const StatCategory* statCategory = group.getStatCategory();

        const bool isPrimary = groupStat->getCategory()[0] == '\0' ||
            blaze_stricmp(groupStat->getCategory(), groupCategory.getName()) == 0;
        if (isPrimary)
        {
            ++primaryCategoryCount;
        }
        else
        {
            // stat's category is different from group's category
            CategoryMap::const_iterator cat = mCategoryMap.find(groupStat->getCategory());
            if (cat == mCategoryMap.end())
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] category [%s] "
                    "does not exist", group.getGroup(), statName, groupStat->getCategory());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            // override stat category
            statCategory = cat->second;

            if (statCategory->getCategoryEntityType() != groupCategory.getCategoryEntityType())
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] in category's [%s] "
                    "entity type [%s] does not match group category's [%s] entity type [%s]",
                    group.getGroup(), statName, statCategory->getName(),
                    statCategory->getCategoryEntityType().toString().c_str(),
                    groupCategory.getName(),
                    groupCategory.getCategoryEntityType().toString().c_str());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }

            TRACE_LOG("[StatsConfigData].parseLeaderboardStatDescs(): Secondary stat [" << statName << "] uses category [" << statCategory->getName() << "]");
        }

        int32_t periodType = groupStat->getPeriodType();

        if (periodType != -1)
        {
            if ((statCategory->getPeriodTypes() & periodType) == 0)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] periodType(%xd) "
                    "does not match any periodTypes(%xd) in category [%s]",
                    group.getGroup(), statName, periodType,
                    statCategory->getPeriodTypes(), statCategory->getName());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            if (!isPowerOf2(periodType))
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] periodType(%xd) "
                    "bitmask can only have a single bit set.",
                    group.getGroup(), statName, periodType);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
            for (int32_t period = 0; period < STAT_NUM_PERIODS; ++period)
            {
                if (periodType == (1 << period))
                {
                    // convert the period type mask into an actual period type enum value
                    periodType = period;
                    break;
                }
            }
        }
        else if (!isPrimary)
        {
            // will inherit from the hierarchy node (parsed later)

            // for now, do an intersection check of period types for this stat's and the group's categories
            // (there will be more validation when the hierarchy is parsed)
            if ((groupCategory.getPeriodTypes() & statCategory->getPeriodTypes()) == 0)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] "
                    "category [%s] periodTypes(%xd) must intersect with group "
                    "category [%s] periodTypes(%xd) when inheriting period type",
                    group.getGroup(), statName,
                    statCategory->getName(), statCategory->getPeriodTypes(),
                    groupCategory.getName(), groupCategory.getPeriodTypes());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
        }

        StatMap::const_iterator statIter = statCategory->getStatsMap()->find(statName);
        if (statIter == statCategory->getStatsMap()->end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] not found in category [%s]",
                group.getGroup(), statName, statCategory->getName());
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        const Stat& stat = *statIter->second;

        /// @todo allow multiple use of any stat (but simplify life a bit now...)
        LbStatList::const_iterator groupStatItr = descDataList.begin();
        for (; groupStatItr != i; ++groupStatItr)
        {
            const GroupStat* groupStatTemp = *groupStatItr;
            if (groupStatTemp->getStat() == &stat)
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] from category [%s] cannot be used more than once",
                    group.getGroup(), statName, statCategory->getName());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
        }

        const char8_t* format = groupStat->getFormat();

        char8_t recreateFormat[STATS_FORMAT_LENGTH];

        if (format[0] == '\0')
        {
            format = stat.getStatFormat();
        }
        else if (validateFormat(stat.getDbType().getType(), format, stat.getTypeSize(), recreateFormat, sizeof(recreateFormat)))
        {
            // point to recreate format
            format = recreateFormat;
        }
        else
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Group [%s] stat [%s] has invalid format string [%s]",
                group.getGroup(), statName, format);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        EA::TDF::tdf_ptr<ScopeNameValueListMap> statScopeMap;
        const ScopeNameSet* scopeSet = statCategory->getScopeNameSet();
        if (scopeSet != nullptr && !scopeSet->empty())
        {
            // this stat's category has keyscopes ...
            if (!groupStat->getScope().empty())
            {
                // accept any defined here, but only allowed literal values or the 'total' keyword
                // (will do any inheriting, combining and validating when hierarchy is parsed)
                statScopeMap = parseLeaderboardScope(groupStat->getScope(), SCOPE_RESERVED_TOTAL, validationErrors);
                if (statScopeMap == nullptr)
                {
                    // see error from parseScopeSetting()
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Unable to parse keyscope for"
                        " stat [%s] in group [%s]",
                        statName, group.getGroup());
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }
            }
        }
        else
        {
            if (!groupStat->getScope().empty())
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Keyscope provided for stat [%s]"
                    " in group [%s] but stat's category [%s] does not use keyscopes",
                    statName, group.getGroup(), statCategory->getName());
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return false;
            }
        }

        if (statScopeMap != nullptr && statScopeMap->empty())
        {
            // we never pass an empty scope map to the stat desc
            statScopeMap = nullptr;
        }

        if (isPrimary)
        {
            if (periodType != -1 || statScopeMap != nullptr)
            {
                // want to track primary category stats using the group's period and scope
                --primaryCategoryCount;
            }
        }

        groupStat->init(&stat, &group, statScopeMap, periodType, format, statIndex++);
    }

    if (primaryCategoryCount < 1)
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].parseLeaderboardStatDescs(): Leaderboard group [%s]"
            " contains no stats from the primary category [%s] using group parameters",
            group.getGroup(), group.getStatCategory()->getName());
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }

    return true;
}

/*************************************************************************************************/
/*!
    \brief parseLeaderboardGroups

    Parses parameters describing leaderboard groups into LeaderboardGroup objects containing 
    description of individual leaderboard groups. Objects are placed into map 
    mLeaderboardGroupsMap. 

    \param[in]   config - StatsConfig data
    \param[out] validationErrors - error messages for config validation
    
    \return true on success or false otherwise

*/
/*************************************************************************************************/
bool StatsConfigData::parseLeaderboardGroups(ConfigureValidationErrors& validationErrors)
{
    INFO_LOG("[StatsConfigData].parseLeaderboardGroups(): Processing leaderboard groups");
    const LeaderboardGroupsList& leaderboardGroupsList = mConfig->getLeaderboardGroups();
  
    mLeaderboardGroupsMap = BLAZE_NEW LeaderboardGroupsMap;
    
    LeaderboardGroupsList::const_iterator iter = leaderboardGroupsList.begin();
    LeaderboardGroupsList::const_iterator end = leaderboardGroupsList.end();

    for ( ; iter != end; ++iter)
    {
        const LeaderboardGroup* leaderboardGroup = *iter;

        const char8_t* group = leaderboardGroup->getGroup();
        if (group[0] == '\0')
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardGroups(): <group> keyword not found");
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        if (strlen(group) > leaderboardGroup->getGroupMaxStringLength()-1)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardGroups(): group name [%s] exceeds maximum length [%" PRIu32 "]",
                group, leaderboardGroup->getGroupMaxStringLength()-1);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        const char8_t* category = leaderboardGroup->getCategory();
        if (category[0] == '\0') 
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardGroups(): group: %s: <category> keyword not found", group);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        CategoryMap::const_iterator catIter = mCategoryMap.find(category);
        if (catIter == mCategoryMap.end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardGroups(): group: %s: category <<%s>> is not defined.", group, category);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }

        LeaderboardGroupPtr newLbGroup = BLAZE_NEW LeaderboardGroup;
        leaderboardGroup->copyInto(*newLbGroup);
        newLbGroup->init(catIter->second);

        if (!parseLeaderboardStatDescs(*newLbGroup, newLbGroup->getStats(), validationErrors))
        {
            return false;
        }

        newLbGroup->buildSelectableCategories();

        (*mLeaderboardGroupsMap)[newLbGroup->getGroup()] = newLbGroup;
    }

    return true;
}

/*************************************************************************************************/
/*!
    \brief getLeaderboardGroup

    Get leaderboard group by its name in the mLeaderboardGroupsMap. 

    \param[in]   boardName leaderboard name
    
    \return - pointer to the LeaderboardGroup object or nullptr on failue

*/
/*************************************************************************************************/
const LeaderboardGroup* StatsConfigData::getLeaderboardGroup(const char8_t* group) const
{
    LeaderboardGroupsMap::const_iterator iter = mLeaderboardGroupsMap->find(group);
    
    if (iter == mLeaderboardGroupsMap->end())
        return nullptr;
        
    return iter->second;
}


/*************************************************************************************************/
/*!
    \brief testNodeName

    Tests if name already used by some leaderboard tree node

    \param[in]  statLeaderboardTree - pointer to array of hierarchy descriptors
    \param[in]  name - name to be tested
    \return true if name already in use

*/
/*************************************************************************************************/
bool StatsConfigData::testNodeName(StatLeaderboardTree* statLeaderboardTree, const char8_t* name)
{
    size_t size = statLeaderboardTree->size();
    for (size_t j = 0; j < size; ++j)
    {
        if (blaze_strcmp((*statLeaderboardTree)[j]->getName(), name) == 0) return true;
    }
    
    return false;
}

/*************************************************************************************************/
/*!
    \brief parseNextSequence

    Parse a level in the leaderboard hierarchy configs. It is called recursively to parse entire 
    hierarchy.

    \param[in]  level - current level
    \param[in]  treeList - list to hold the parsed tree structure
    \param[in]  prevSequence - config sequence containing level of the tree
    \param[out] validationErrors - error messages for config validation

    \return number of children for the node or -1 if error
*/
/*************************************************************************************************/
int32_t StatsConfigData::parseNextSequence(int32_t level, StatLeaderboardTree* treeList, const LeaderboardHierarchyList& prevSequence, ConfigureValidationErrors& validationErrors)
{
    const char8_t* groupName = nullptr;
    int32_t periodType = 0;
    int32_t count = 0;
    int32_t childCtr = 0;
    const LeaderboardGroup* leaderboardGroup = nullptr;
    
    LeaderboardHierarchyList::const_iterator iter = prevSequence.begin();
    LeaderboardHierarchyList::const_iterator end = prevSequence.end();
    treeList->reserve(prevSequence.size());
    for ( ; iter != end; ++iter)
    {
        const StatLeaderboardTreeNode* treeNode = *iter;
        const LeaderboardHierarchyList& nextSequence = treeNode->getNext();
        const char8_t* nodeName = treeNode->getName();

        if (strlen(nodeName) > treeNode->getNameMaxStringLength()-1)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseNextSequence(): leaderboard tree node name [%s] exceeds maximum length [%" PRIu32 "]",
                nodeName, treeNode->getNameMaxStringLength()-1);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return -1;
        }

        groupName = treeNode->getGroup();
        periodType = treeNode->getPeriodType();

        EA::TDF::tdf_ptr<ScopeNameValueListMap> scopeNameValueListMap;
        // if (nextSequence.empty()) map defines leaderboard otherwise it is a folder
        if (nextSequence.empty())
        {
            // Convert bit mask notation to the index
            switch (periodType)
            {
            case 0x1:
                periodType = 0;
                break;
            case 0x2:
                periodType = 1;
                break;
            case 0x4:
                periodType = 2;
                break;
            case 0x8:
                periodType = 3;
                break;
            default:
                periodType = -1;
                break;
            }
                
            leaderboardGroup = getLeaderboardGroup(groupName);
            if (leaderboardGroup == nullptr) 
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseNextSequence(): group <<%s>> is not defined.", groupName);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return -1;
            }

            if(!leaderboardGroup->getStatCategory()->isValidPeriod(periodType))
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseNextSequence(): period type <<%d>> (group: <<%s>>) is not defined.", periodType, groupName);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return -1;
            }            

            // if the category the leaderboard group belongs to has a scope, we need to parse scope value and 
            // validate scope
            if (leaderboardGroup->getStatCategory()->hasScope())
            {
                const ScopeMap& scopeMap = treeNode->getScope();
                const ScopesMap& scopesMap = treeNode->getScopes();
                if (!scopeMap.empty() && !scopesMap.empty())
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseNextSequence(): leaderboard %s cannot specify both 'scope' and 'scopes' settings", nodeName);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return -1;
                }
                else if (!scopesMap.empty() || !scopeMap.empty())
                {
                    if (!scopesMap.empty())
                    {
                        scopeNameValueListMap = parseLeaderboardScopes(scopesMap, validationErrors);
                    }
                    else
                    {
                        scopeNameValueListMap = parseLeaderboardScope(scopeMap, SCOPE_RESERVED_ALL, validationErrors);
                    }

                    // make sure the setting matches category scope name settings
                    if (!leaderboardGroup->getStatCategory()->isValidScopeNameSet(scopeNameValueListMap))
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseNextSequence(): Category %s the group %s belongs to has mismatched scope settings.",
                            leaderboardGroup->getStatCategory()->getName(), groupName);
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return -1;
                    }

                    // make sure we won't be creating too many leaderboard structures
                    if (treeNode->getInMemory() && scopeNameValueListMap != nullptr)
                    {
                        ScopeNameValueListMap::const_iterator scopeMapItr = scopeNameValueListMap->begin();
                        ScopeNameValueListMap::const_iterator scopeMapEnd = scopeNameValueListMap->end();
                        for (; scopeMapItr != scopeMapEnd; ++scopeMapItr)
                        {
                            if (getKeyScopeSingleValue(scopeMapItr->second->getKeyScopeValues()) == KEY_SCOPE_VALUE_USER)
                            {
                                KeyScopesMap::const_iterator itemIter = getKeyScopeMap().find(scopeMapItr->first.c_str());
                                // validation that this keyscope item exists has already been done
                                const KeyScopeItem* scopeItem = itemIter->second;
                                ScopeValue numPossibilities = 0;
                                ScopeStartEndValuesMap::const_iterator valuesItr = scopeItem->getKeyScopeValues().begin();
                                ScopeStartEndValuesMap::const_iterator valuesEnd = scopeItem->getKeyScopeValues().end();
                                for (; valuesItr != valuesEnd; ++valuesItr)
                                {
                                    numPossibilities += valuesItr->second - valuesItr->first + 1;
                                }

                                // an empty values map means all values are possible
                                if (numPossibilities == 0 || numPossibilities > getMaxKeyScopeGeneratedLeaderboards() )
                                {
                                    eastl::string msg;
                                    msg.sprintf("[StatsConfigData].parseNextSequence(): user-specified category %s will build too many leaderboard structures, numPossibilities(%d) (Max %d), treeNode(%s)",
                                        leaderboardGroup->getStatCategory()->getName(), numPossibilities, getMaxKeyScopeGeneratedLeaderboards(), treeNode->getName());
                                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                                    str.set(msg.c_str());
                                    return -1;
                                }
                            }
                        }
                    }
                }
                else
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseNextSequence(): Category %s the group %s belongs to has scope setting, however, group does not specifiy any scope.",
                        leaderboardGroup->getStatCategory()->getName(), groupName);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return -1;
                }
            }
        }//if (nextSequence == nullptr)

        if (testNodeName(treeList, nodeName))
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseNextSequence(): leaderboard/folder name: <%s> is not unique in the leaderboard hierachy.", nodeName);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return -1;
        }

        // By default all in-memory leaderboards will store some extra rows to replace any
        // deletions of stats in the main leaderboard, the number of extra rows may be
        // overridden in the config file if the default percentage based scheme is
        // inadequate.  If deletions are very frequent the number of extras should be
        // configured relatively high, conversely if deletions are impossible an appropriate
        // value may be as low as 0.
        int32_t size = treeNode->getSize();
        const char8_t* extraBuf = treeNode->getExtra();
        int32_t extra = static_cast<int32_t>(RANK_TABLE_EXTRA * size);

        if (extraBuf[0] != '\0')
        {
            blaze_str2int(extraBuf, &extra);
        }

        if (size <= 0)
        {
            size = 1;
            WARN_LOG("[StatsConfigData].parseNextSequence(): adjusting leaderboard <" << nodeName << "> to have minimum size of " << size);
        }

        StatLeaderboardTreeNodePtr newTreeNode = treeNode->clone();
        StatLeaderboardData& treeNodeData = newTreeNode->getData();
        treeNodeData.init(scopeNameValueListMap, periodType, size, extra, level);

        count = 0;
        if (nextSequence.size() != 0)
        {
            count = parseNextSequence(level+1, treeList, nextSequence, validationErrors);
            if (count < 0)
            {
                return -1;
            }
        }

        treeNodeData.setChildCount(count);
        treeList->push_back(newTreeNode);
        ++childCtr;
    }

    return childCtr;
}

/*! ************************************************************************************************/
/*! \brief parseLeaderboardScope

    Parse the scope definition in the leaderboard for the 'scope' setting--which is the old
    setting of only allowing one value per keyscope, e.g. scope = { weapon = 5 }

    Note: caller is responsible to delete the ScopeNameValueListMap obj

    \param[in] scopeMap - config map for the scope, could be nullptr
    \param[in]validReservedKeywords - combination of ScopeReservedValue, which indicates what kind of 
                                       scope reserved keywords is supported by the item being parsed
    \param[out] validationErrors - error messages for config validation

    \return the ScopeNameValueListMap created for the leaderboard, nullptr means it's a LB without scope
    or the scope config setting has problem
***************************************************************************************************/
EA::TDF::tdf_ptr<ScopeNameValueListMap> StatsConfigData::parseLeaderboardScope(const ScopeMap& scopeMap, const uint16_t validReservedKeywords, ConfigureValidationErrors& validationErrors)
{
    EA::TDF::tdf_ptr<ScopeNameValueListMap> scopeNameValueListMap;
    const char8_t* scopeName;
    ScopeValue scopeValue = 0;

    for (ScopeMap::const_iterator iter=scopeMap.begin(),end=scopeMap.end(); iter!=end; ++iter)
    {
        if (scopeNameValueListMap == nullptr)
        {
            scopeNameValueListMap = BLAZE_NEW ScopeNameValueListMap();
        }

        scopeName = iter->first;

        // make sure the key scope name is defined in keyscopes
        KeyScopesMap::const_iterator it = getKeyScopeMap().find(scopeName);
        if (it == getKeyScopeMap().end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardScope(): scope name [%s] is not defined in keyscopes config", scopeName);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return nullptr;
        }

        // check for reserved keywords--which will be converted to reserved values ("magic numbers")
        const char8_t* scopeKeyword = iter->second;

        if ((validReservedKeywords & SCOPE_RESERVED_USER_SPECIFIED) && blaze_strcmp(scopeKeyword, "?") == 0)
        {
            scopeValue = KEY_SCOPE_VALUE_USER;
        }
        else if ((validReservedKeywords & SCOPE_RESERVED_TOTAL) && blaze_strcmp(scopeKeyword, "total") == 0)
        {
            // replace with actual key value right away
            scopeValue = getAggregateKeyValue(scopeName);
        }
        else
        {        
            if ( !isNumber(scopeKeyword) )
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardScope(): value [%s] for scope [%s] is not valid", scopeKeyword, scopeName);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return nullptr;
            }

            blaze_str2int(scopeKeyword, &scopeValue);

            if (!isValidScopeValue(scopeName, scopeValue))
            {
                eastl::string msg;
                msg.sprintf("[StatsConfigData].parseLeaderboardScope(): value [%" PRId64 "] for scope [%s] is not defined in keyscopes config", scopeValue, scopeName);
                EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                str.set(msg.c_str());
                return nullptr;
            }
        }

        ScopeValues* scopeValues = BLAZE_NEW ScopeValues();
        (scopeValues->getKeyScopeValues())[scopeValue] = scopeValue;
        scopeNameValueListMap->insert(eastl::make_pair(scopeName, scopeValues));
    }

    return scopeNameValueListMap;
}

/*! ************************************************************************************************/
/*! \brief parseLeaderboardScopes

    Parse the scope definition in the leaderboard for the 'scopes' setting--which is the new
    setting of allowing more than one value per keyscope, e.g. scope = { weapon = [5,7] }

    Note: caller is responsible to delete the ScopeNameValueListMap obj

    \param[in] scopeMap - config map for the scope, could be nullptr
    \param[out] validationErrors - error messages for config validation

    \return the ScopeNameValueListMap created for the leaderboard, nullptr means it's a LB without scope
    or the scope config setting has problem
***************************************************************************************************/
EA::TDF::tdf_ptr<ScopeNameValueListMap> StatsConfigData::parseLeaderboardScopes(const ScopesMap& scopeMap, ConfigureValidationErrors& validationErrors)
{
    EA::TDF::tdf_ptr<ScopeNameValueListMap> scopeNameValueListMap = nullptr;
    const char8_t* scopeName;

    for (ScopesMap::const_iterator iter=scopeMap.begin(),end=scopeMap.end(); iter!=end; ++iter)
    {
        if (scopeNameValueListMap == nullptr)
        {
            scopeNameValueListMap = BLAZE_NEW ScopeNameValueListMap();
        }

        scopeName = iter->first;

        // make sure the key scope name is defined in keyscopes
        KeyScopesMap::const_iterator it = getKeyScopeMap().find(scopeName);
        if (it == getKeyScopeMap().end())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardScopes(): scope name [%s] is not defined in keyscopes config", scopeName);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return nullptr;
        }

        ScopeValuesPtr scopeValues = BLAZE_NEW ScopeValues();
        const ScopeValueList& valuesSequence = *iter->second;;
        if (!parseKeyScopeLeaderboardValues(scopeName, valuesSequence, scopeValues->getKeyScopeValues(), validationErrors))
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardScopes(): key scope item [%s] has bad values",
                scopeName);
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return nullptr;
        }
        scopeNameValueListMap->insert(eastl::make_pair(scopeName, scopeValues));
    }

    return scopeNameValueListMap;
}

/*! ************************************************************************************************/
/*! \brief parse the scope definition in the user stat

    Note: caller is responsible to delete the ScopeNameValueMap obj

    \param[in]scopeMap - config map for the scope
    \param[out] validationErrors - error messages for config validation

    \return the ScopeNameValueMap created for the stat group, nullptr means it's a group without scope
    or the scope config setting has problem
***************************************************************************************************/
EA::TDF::tdf_ptr<ScopeNameValueMap> StatsConfigData::parseUserStatsScope(const ScopeMap& scopeMap, ConfigureValidationErrors& validationErrors)
{
    return parseScopeSetting(scopeMap, SCOPE_RESERVED_TOTAL, validationErrors);
}

StatTypeDb StatsConfigData::getScopeDbType(const char8_t* scopeName) const
{
    KeyScopesMap::const_iterator find = getKeyScopeMap().find(scopeName);
    if (find == getKeyScopeMap().end())
        return StatTypeDb();

    // Calculate the keyscope value range
    const KeyScopeItem* scopeItem = find->second;
    if (scopeItem->getKeyScopeValues().empty())
    {
        // no explicit keyscope values, so all are valid
        return StatTypeDb(STAT_TYPE_INT, 8);
    }

    ScopeStartEndValuesMap::const_reverse_iterator valuesLast = scopeItem->getKeyScopeValues().rbegin();
    ScopeValue maxValue = valuesLast->second;

    if (scopeItem->getEnableAggregation() && scopeItem->getAggregateKeyValue() > maxValue)
    {
        maxValue = scopeItem->getAggregateKeyValue();
    }

    // Choose the appropriate DB type based on the maximum value of the key scope
    if (maxValue <= 0x7f)
        return StatTypeDb(STAT_TYPE_INT, 1);
    if (maxValue <= 0x7fff)
        return StatTypeDb(STAT_TYPE_INT, 2);
    if (maxValue <= 0x7fffff)
        return StatTypeDb(STAT_TYPE_INT, 3);
    if (maxValue <= 0x7fffffff)
        return StatTypeDb(STAT_TYPE_INT, 4);

    return StatTypeDb(STAT_TYPE_INT, 8);
}

/*! ***********************************************************************/
/*! \brief resolves a stat's type from its name

    \param[in] nameSpace - the category of the stat to look up
    \param[in] name - the name of the stat to look up
    \param[in] context - component specific context for the stat type to resolve (statMap)
    \param[out] type - the type of the stat
***************************************************************************/
void StatsConfigData::resolveStatType(const char8_t* nameSpace, const char8_t* name, void* context, Blaze::ExpressionValueType& type)
{
    type = Blaze::EXPRESSION_TYPE_NONE;

    // If the nameSpace is null, then the stat has a dependency on another stat from the same
    // category, lex/yacc has no direct way to know which category that is, so we in the stat map
    // from the category to the lexer, but if the nameSpace is specified, then we simply look
    // in the category map owned by the StatsConfig
    const StatMap* statMap = nullptr;
    if (nameSpace == nullptr)
        statMap = static_cast<const StatMap*>(context);
    else
    {
        CategoryMap::const_iterator catIter = mCategoryMap.find(nameSpace);
        if (catIter != mCategoryMap.end())
            statMap = catIter->second->getStatsMap();
    }

    if (statMap == nullptr)
        return;

    StatMap::const_iterator iter = statMap->find(name);
    if (iter != statMap->end())
    {
        type = static_cast<Blaze::ExpressionValueType>(iter->second->getDbType().getType());
    }
}

/*************************************************************************************************/
/*!
    \brief resolveStatDefaultValue

    Implements the ResolveVariableCb needed by the Blaze expression framework to look up the values
    of named variables.

    \param[in]  nameSpace - the name of the category to lookup
    \param[in]  name - the name of the stat to lookup
    \param[in]  type - the data type the variable is expected to have
    \param[in]  context - opaque reference to what we know is a map of stat names to values
    \param[out] val - value to be filled in by this method
*/
/*************************************************************************************************/
void StatsConfigData::resolveStatDefaultValue(const char8_t* nameSpace, const char8_t* name, Blaze::ExpressionValueType type,
    const void* context, Blaze::Expression::ExpressionVariableVal& val)
{
    const StatMap* statMap = nullptr;
    if (nameSpace == nullptr)
    {
        statMap = static_cast<const StatMap*>(context);
    }
    else
    {
        // At this point the category should already have been validated, so no need to worry about missing category
        statMap = mCategoryMap.find(nameSpace)->second->getStatsMap();
    }
    
    const Stat* stat = statMap->find(name)->second;

    switch (type)
    {
        case Blaze::EXPRESSION_TYPE_INT:
            val.intVal = stat->getDefaultIntVal();
            break;
        case Blaze::EXPRESSION_TYPE_FLOAT:
            val.floatVal = stat->getDefaultFloatVal();
            break;
        case Blaze::EXPRESSION_TYPE_STRING:
            val.stringVal = stat->getDefaultStringVal();
            break;
        default:
            break;
    }
}

/*************************************************************************************************/
/*!
    \brief levelcompare

    A comparison function used by list sort method.

    \param[in]  first - list element to be compared
    \param[in]  second - the following element to be compared

*/
/*************************************************************************************************/
bool levelCompare(StatLeaderboardTreeNodePtr first, StatLeaderboardTreeNodePtr second)
{
    return (first->getData().getLevel() < second->getData().getLevel());
}

/*************************************************************************************************/
/*!
    \brief parseleaderboardhierarchy

    Parse leaderboard hierarchy through the call to the parseNextSequence(),
    build a linear list containing structure of the hierarchy tree

    \param[in]  config - config map with hierarchy
    \param[out] validationErrors - error messages for config validation
    
    \return true on success or false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::parseLeaderboardHierarchy(ConfigureValidationErrors& validationErrors)
{
    //  verify we're starting with an empty tree array.
    mStatLeaderboardTree = BLAZE_NEW StatLeaderboardTree();
    mStatLeaderboardsMap = BLAZE_NEW StatLeaderboardsMap;
    
    const LeaderboardHierarchyList& nextSequence = mConfig->getLeaderboardHierarchy();

    int32_t count = static_cast<int32_t>(nextSequence.size());
    
    //return if the leaderboard hierarchy is empty
    if (count == 0)
    {
        return true;
    }

    StatLeaderboardTreeNode* treeNode = BLAZE_NEW StatLeaderboardTreeNode();
    treeNode->setName("TopFolder");
    treeNode->setDesc("Top folder of leaderboard hierarchy");

    treeNode->getData().setChildCount(count);
    mStatLeaderboardTree->push_back(treeNode);

    if (parseNextSequence(1, mStatLeaderboardTree, nextSequence, validationErrors) < 0)  return false;
    
    BlazeStlAllocator sortAllocator("StatSort");
    eastl::stable_sort(mStatLeaderboardTree->begin(), mStatLeaderboardTree->end(), sortAllocator, levelCompare);
 
    StatLeaderboardTree::iterator iterParent = mStatLeaderboardTree->begin();
    StatLeaderboardTree::iterator iterChild = iterParent;
    StatLeaderboardTree::iterator iterEnd = mStatLeaderboardTree->end();
    
    int32_t nodeIndex = 0;
    int32_t nextLevel;
    
    while (iterParent != iterEnd)
    {
        if ((*iterParent)->getData().getChildCount() == 0) { ++iterParent; continue;} // No children or leaf
        nextLevel = (*iterParent)->getData().getLevel()+1;
    
        while (iterChild != iterEnd)
        {
            if ((*iterChild)->getData().getLevel() == nextLevel) break;
            ++iterChild;
            ++nodeIndex;
        }

        if (iterChild == iterEnd)
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): Child not found");
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            break;
        }
        
        (*iterParent)->getData().setFirstChild(nodeIndex);

        for (int32_t i = 0; i < (*iterParent)->getData().getChildCount(); i++)
        {
            StatLeaderboardTreeNode* childNode = *iterChild;
            
            if (childNode->getData().getChildCount() == 0) // Leaf
            {
                const LeaderboardGroup* leaderboardGroup = getLeaderboardGroup(childNode->getGroup());
                if (leaderboardGroup == nullptr) 
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] group [%s] is not defined",
                        childNode->getName(), childNode->getGroup());
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }

                // validate period type and scopes for each stat (which could get overridden)
                LbStatList::const_iterator groupStatItr = leaderboardGroup->getStats().begin();
                LbStatList::const_iterator groupStatEnd = leaderboardGroup->getStats().end();
                for (; groupStatItr != groupStatEnd; ++groupStatItr)
                {
                    const GroupStat* groupStat = *groupStatItr;
                    const Stat* stat = groupStat->getStat();
                    const StatCategory* statCategory = &(stat->getCategory());

                    int32_t periodType = groupStat->getStatPeriodType();
                    if (periodType == -1)
                    {
                        // use group period type (inherited)
                        periodType = childNode->getData().getPeriodType();
                    }
                    if (!statCategory->isValidPeriod(periodType))
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] stat [%s] has invalid period type [%d]",
                            childNode->getName(), stat->getName(), periodType);
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }

                    if (statCategory == leaderboardGroup->getStatCategory() && groupStat->getScopeNameValueListMap() == nullptr)
                    {
                        // [minor optimization] skip primary category stats that don't override scopes because
                        // validation has already been done for the group scope (which is the primary category)
                    }
                    else if (!statCategory->isValidScopeNameSet(groupStat->getScopeNameValueListMap(), childNode->getData().getScopeNameValueListMap()))
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] stat [%s] has mismatched scope settings.",
                            childNode->getName(), stat->getName());
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }
                }

                const Stat* rankingStats[MAX_RANKING_STATS] = {nullptr};

                // If a ranking stat was provided, add the primary stat to the beginning of the secondary ranking list. 
                RankingStatList& rankingStatList = childNode->getMultiStatRanking();
                if (childNode->getStatName()[0] != 0)
                {
                    //  Add an empty space to the start: 
                    Stats::RankingStatData* curNode = rankingStatList.pull_back();
                    for( int32_t pos = rankingStatList.size()-2; pos >= 0; --pos )
                    {
                        // Copy all elements down:
                        Stats::RankingStatData* prevNode = rankingStatList.at(pos);
                        
                        // Verify that the primary ranking stat isn't already in the list:
                        if (blaze_strcmp(childNode->getStatName(), prevNode->getStatName()) == 0)
                        {
                            eastl::string msg;
                            msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] duplicates ranking stat [%s] in mStatName and mMultiStatRanking. Only one is needed.",
                                childNode->getName(), childNode->getStatName());
                            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                            str.set(msg.c_str());
                            return false;
                        }
                        
                        prevNode->copyInto(*curNode);
                        curNode = prevNode;
                    }
                    // Use Ranking Stat for first element:
                    curNode->setStatName(childNode->getStatName());  
                    curNode->setAscending(childNode->getAscending());
                }

                int32_t rankingStatListSize = rankingStatList.size();
                if (rankingStatListSize > MAX_RANKING_STATS)
                {
                    eastl::string msg;
                    msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] has [%d] ranking stats (Max %d)",
                        childNode->getName(), rankingStatListSize, MAX_RANKING_STATS);
                    EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                    str.set(msg.c_str());
                    return false;
                }

                for( int32_t pos = 0; pos < rankingStatListSize; ++pos )
                {
                    Stats::RankingStatData* curNode = rankingStatList.at(pos);
                    const Stat* curStat = nullptr;

                    const StatList& statList = leaderboardGroup->getStatCategory()->getStats();
                    StatList::const_iterator statItr = statList.begin();
                    StatList::const_iterator statEnd = statList.end();
                    for (; statItr != statEnd; ++statItr)
                    {
                        const Stat* stat = *statItr;

                        // look for the ranking stat
                        if (blaze_strcmp(stat->getName(), curNode->getStatName()) == 0)
                        {
                            // although period type and keyscope override can be same as group settings,
                            // keep ranking stat validation simpler by not having them
                            curStat = stat;
                            break;
                        }
                    }

                    if (curStat == nullptr)
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] ranking stat [%s] is missing from group [%s]",
                            childNode->getName(), curNode->getStatName(), leaderboardGroup->getGroup());
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }

                    if (curStat->getDbType().getType() != STAT_TYPE_FLOAT && curStat->getDbType().getType() != STAT_TYPE_INT)
                    {
                        eastl::string msg;
                        msg.sprintf("[StatsConfigData].parseLeaderboardHierarchy(): lb [%s] ranking stat [%s] only float or int allowed",
                            childNode->getName(), curNode->getStatName());
                        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
                        str.set(msg.c_str());
                        return false;
                    }                

                    curNode->setIsInt(curStat->getDbType().getType() == STAT_TYPE_INT);
                    rankingStats[pos] = curStat;
                }

                RankingStatValue cutoffStatValue = {0};
                bool cutoffStatValueDefined = false;
                if (childNode->getCutoffStatValue()[0] != '\0')
                {
                    cutoffStatValueDefined = true;
                    if (rankingStats[0]->getDbType().getType() == STAT_TYPE_INT)
                    {
                        blaze_str2int(childNode->getCutoffStatValue(), &cutoffStatValue.intVal);
                    }
                    else
                    {
                        cutoffStatValue.floatVal = (float) strtod(childNode->getCutoffStatValue(), nullptr);
                    }
                }

                StatLeaderboard* leaderboard = BLAZE_NEW StatLeaderboard(nodeIndex, leaderboardGroup,
                    childNode, rankingStats, cutoffStatValueDefined, cutoffStatValue);

                (*mStatLeaderboardsMap)[nodeIndex] = leaderboard;
            }
            
            ++iterChild;
            ++nodeIndex;
            if (iterChild == iterEnd) 
                break;
        }
        ++iterParent;
    }

    StatLeaderboardTree& statLeaderboardTree = *mStatLeaderboardTree;
    uint32_t treeSize = static_cast<uint32_t>(statLeaderboardTree.size());

    mFolderIndexMap.clear();

    for (uint32_t i = 0; i < treeSize; i++)
    {
        int32_t firstChild = statLeaderboardTree[i]->getData().getFirstChild();

        if (firstChild != 0)
        {
            for (int32_t j = firstChild; j < firstChild + statLeaderboardTree[i]->getData().getChildCount(); ++j)
            {
                statLeaderboardTree[j]->getData().setParent(i);
            }

            // add folder to folder->index map for faster lookups of folder by name
            mFolderIndexMap.insert(LeaderboardFolderIndexMap::value_type(statLeaderboardTree[i]->getName(), i));
        }
        else // Leaderboard
        {
          mLeaderboardIndexMap[statLeaderboardTree[i]->getName()] = i;
        }
    }

    statLeaderboardTree[0]->getData().setParent(0);

    return true;
}

/*************************************************************************************************/
/*!
    \brief getStatLeaderboard

    Returns pointer to the StatLeaderboard object.

    \param[in] - boardId - ID of board
    \param[in] - boardName - board name; if present is used instead of ID
    
    \return true on success or false otherwise
*/
/*************************************************************************************************/
const StatLeaderboard* StatsConfigData::getStatLeaderboard(uint32_t boardId, const char8_t* boardName) const
{

    if (mStatLeaderboardsMap == nullptr)
    {
        ERR_LOG("[StatsConfigData].getStatLeaderboard: Config data was not loaded");
        return nullptr;
    }

    if (*boardName == '\0')
    {
        if ((boardId & FolderDescriptor::IS_LEADERBOARD) == 0)
        {
            ERR_LOG("[StatsConfigData].getStatLeaderboard: >" << boardId << "< Invalid board ID (1)");
            return nullptr;
        }

        boardId &= ~FolderDescriptor::IS_LEADERBOARD;
     
        if (boardId >= mStatLeaderboardTree->size())
        {
            ERR_LOG("[StatsConfigData].getStatLeaderboard: >" << boardId << "< Invalid board ID (2)");
            return nullptr;
        }
    }
    else
    {
        LeaderboardIndexMap::const_iterator iter = mLeaderboardIndexMap.find(boardName);
        if (iter == mLeaderboardIndexMap.end()) 
        {
            ERR_LOG("[StatsConfigData].getStatLeaderboard: board: >" << boardName << "< was not found");
            return nullptr;
        }
        boardId = iter->second;
    }

    StatLeaderboardsMap::const_iterator iter = mStatLeaderboardsMap->find(boardId);
    if (iter == mStatLeaderboardsMap->end())
    {
        ERR_LOG("[StatsConfigData].getStatLeaderboard: Unknown leaderboard >" << mStatLeaderboardTree->at(boardId)->getName() << "<");
        return nullptr;
    }

    return iter->second;
}


/*************************************************************************************************/
/*!
    \brief validateConfigLeaderboardHierarchy

    Validate whether config has the same Leaderboards as referenceConfig.

    \param[in] - config - the config data
    \param[in] - referenceConfigPtr - the pointer of referenceConfig
    \param[out] - validationErrors - error messages for config validation
    
    \return success if config has the same Leaderboards as referenceConfig, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::validateConfigLeaderboardHierarchy(const StatsConfig& config, const StatsConfig* referenceConfigPtr, ConfigureValidationErrors& validationErrors)
{
    if (referenceConfigPtr != nullptr)
    {
        const LeaderboardHierarchyList& referLbList = referenceConfigPtr->getLeaderboardHierarchy();
        const LeaderboardHierarchyList& lbList = config.getLeaderboardHierarchy();
        if (referLbList.size() != lbList.size())
        {
            eastl::string msg;
            msg.sprintf("[StatsConfigData].validateConfigLeaderboardHierarchy(): The count of leaderboards can not be changed");
            EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
            str.set(msg.c_str());
            return false;
        }
        for (LeaderboardHierarchyList::const_iterator referIt = referLbList.begin(); referIt != referLbList.end(); ++referIt)
        {
            // call recursion to vlidate all the leaderboards
            if (!validateConfigLeaderboardHierarchyNode(*referIt, lbList, validationErrors))
                return false;
        }
    }

    return true;
}

/*************************************************************************************************/
/*!
    \brief validateConfigLeaderboardHierarchyNode

    Validate whether lbList has a leaderboard same as referNode.

    \param[in] - referNode - the leaderboard to be validated
    \param[in] - lbList - the leaderboard list expected to have a leaderboard same as referNode
    \param[out] - validationErrors - error messages for config validation
    
    \return success if lbList has a leaderboard same as referNode, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::validateConfigLeaderboardHierarchyNode(const StatLeaderboardTreeNode* referNode, const LeaderboardHierarchyList& lbList, ConfigureValidationErrors& validationErrors)
{
    LeaderboardHierarchyList::const_iterator it = lbList.begin();
    for (; it != lbList.end(); ++it)
    {
        if (strcmp(referNode->getName(), (*it)->getName()) == 0)
            break;
    }
    if (it == lbList.end())
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].validateConfigLeaderboardHierarchyNode(): Leaderboard [%s] is not found from config", referNode->getName());
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }
    
    if (referNode->getNext().size() != (*it)->getNext().size())
    {
        eastl::string msg;
        msg.sprintf("[StatsConfigData].validateConfigLeaderboardHierarchyNode(): The count of leaderboards can not be changed");
        EA::TDF::TdfString& str = validationErrors.getErrorMessages().push_back();
        str.set(msg.c_str());
        return false;
    }
    for (LeaderboardHierarchyList::const_iterator childIt = referNode->getNext().begin(); childIt != referNode->getNext().end(); ++childIt)
    {
        if (!validateConfigLeaderboardHierarchyNode(*childIt, (*it)->getNext(), validationErrors))
            return false;
    }

    return true;
}

/*************************************************************************************************/
/*!
    \brief isIdentifierChar

    Validate whether the character is valid.

    \param[in] - ch - the character to be validated
    
    \return success if the character is valid, false otherwise
*/
/*************************************************************************************************/
bool StatsConfigData::isIdentifierChar(char8_t ch)
{
    return  (ch >= '0' && ch <= '9') ||
            (ch >= 'a' && ch <= 'z') ||
            (ch >= 'A' && ch <= 'Z') ||
            (ch == '_');
}

// **************************************** The end **************************************************
} // Stats
} // Blaze
