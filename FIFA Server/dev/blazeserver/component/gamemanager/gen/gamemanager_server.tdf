/*! ************************************************************************************************/
/*!
    \file gamemanager_server.tdf


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

[headername="gamemanager/tdf/gamemanager_types.h"]
#include "gamemanager/gen/gamemanager_types.tdf"
[headername="gamemanager/tdf/gamemanager.h"]
#include "gamemanager/gen/gamemanager.tdf"

[headername="gamemanager/tdf/gameaction_server.h"]
#include "gamemanager/gen/gameaction_server.tdf"

[headername="gamemanager/tdf/matchmaker.h"]
#include "gamemanager/gen/matchmaker.tdf"

[headername="framework/tdf/userinfotypes_server.h"]
#include "framework/gen/userinfotypes_server.tdf"

[headername="framework/tdf/userdefines.h"]
#include "framework/gen/userdefines.tdf"

[headername="framework/tdf/userpineventtypes_server.h"]
#include "framework/gen/userpineventtypes_server.tdf"

[headername="framework/tdf/slivermanagertypes_server.h"]
#include "framework/gen/slivermanagertypes_server.tdf"

[headername="gamemanager/tdf/externalsessiontypes_server.h"] // for JoinExternalSessionParameters in JoinGameMasterResponse
#include "gamemanager/gen/externalsessiontypes_server.tdf"

[headername="proxycomponent/ccs/tdf/ccs.h"]
#include "proxycomponent/ccs/gen/ccs.tdf"

[headername="framework/tdf/uuid.h"]
#include "framework/gen/uuid.tdf"

[headername="framework/tdf/metricsdatatypes.h"]
#include "framework/gen/metricsdatatypes.tdf"

namespace Blaze
{
namespace GameManager
{// GM_AUDIT: the replicated reason classes should use unions keyed off the update reason to save space
//   but that may need to wait for unions to support lists/maps (the Wiki has an ominous warning)
//
//   Long-term, I'd like to get rid of async MM notifications (except in the case of failure).
//   On success, we'd send the MM success info (id, fitScore, maxPossibleFitScore, etc) in the player
//   replication reason, and the slave would trigger the notification.  This guarantees the order of 
//    notifications (MM Finished before joinGame), allowing us to cleanup some ugly client logic and make
//    HTTP/gRPC access easier.

enum IdType
{
    GAMEMANAGER_IDTYPE_GAME,                    // Game Ids
    GAMEMANAGER_IDTYPE_GAME_REPORT,             // Game Report Id
    GAMEMANAGER_IDTYPE_GAMEBROWSER_LIST,        // Game Browser List Id
    GAMEMANAGER_IDTYPE_EXTERNALSESSION,         // Unique Id used as part of the External Sessions' names 
    GAMEMANAGER_IDTYPE_SCENARIO                 // Scenario Id
};

[description="An unsorted collection of GameTypes."]
typedef list<GameType> GameTypeList;

typedef map<FitScore, GameIdList> GameIdsByFitScoreMap;

[description = "Reason a replicated player is being replicated"]
enum PlayerReplicatedReason
{
    PLAYER_ATTRIB_CHANGED,
    PLAYER_CUSTOMDATA_CHANGED,
    PLAYER_JOINED_FROM_QUEUE,
    PLAYER_STATE_CHANGED,
    PLAYER_JOINED_FROM_RESERVATION,
    PLAYER_TEAM_ROLE_OR_SLOT_CHANGED,
    PLAYER_TEAM_OR_ROLE_CHANGED_WITH_CAPACITY_CHANGE,
    PLAYER_ADDED,
    PLAYER_REMOVED,
    PLAYER_QUEUE_POSITION_CHANGED
};

[tdfid = "hash", trackChanges = true]
class UserSessionInfo
{
    [tag="sess"]
    UserSessionId mSessionId;

    [tag="uinf"]
    UserInfoData mUserInfo;

    [tag="uext"]
    UserExtendedDataMap mDataMap;

    [tag="mets"]
    Blaze::ClientMetrics mClientMetrics;

    [tag="cume"]
    ClientUserMetrics mClientUserMetrics;

    [tag="ctyp"]
    ClientType mClientType;

    [tag="svcn", description="The service name that the client used to connect to the Blaze Server."]
    ServiceName mServiceName;

    [tag="prod", description="The product name that the client used to authenticate."]
    ProductName mProductName;
    
    [tag="host"]
    bool hasHostPermission;

    [tag="conn"]
    ConnectionGroupId mConnectionGroupId;

    [tag="addr", description="The connection IP/port associated with this user."]
    string(64) mConnectionAddr;

    [tag="pnet"] 
    NetworkAddress mNetworkAddress;
        
    [tag="qdat", description="Bandwidth and NAT type info."]    
    Util::NetworkQosData mQosData;
        
    [tag="bps", description="The best available ping site."]
    PingSiteAlias mBestPingSiteAlias;

    [tag="lat"]
    PingSiteLatencyByAliasMap mLatencyMap;

    [tag="long"]
    float mLongitude;

    [tag="lati"]
    float mLatitude;

    [tag="ctry"]
    string(MAX_GEOCOUNTRY_LENGTH) mCountry;

    [tag="tz"]
    string(MAX_TIMEZONE_LENGTH) mTimeZone;

    [tag="isp"]
    string(MAX_ISP_LENGTH) mISP;

    [tag="rep", default=false]
    bool mHasBadReputation;

    [tag="eaut", description="Cached external sessions auth info."]
    ExternalUserAuthInfo mExternalAuthInfo;

    [tag="jext", description="Whether user joins external sessions"]
    bool mHasExternalSessionJoinPermission;
    
    [tag="gsze", description="The size of the user's group"]
    uint16_t mGroupSize;

    [tag="dsui", description="The dirty sock user index of the player on their client"]
    int32_t mDirtySockUserIndex;

    [tag="uuid", description="the connection group uuid of the session"] 
    UUID mUUID;
};

typedef list<UserSessionInfo> UserSessionInfoList;

[tdfid = "hash", trackChanges = true]
class UserJoinInfo
{
    [tag="usi"]
    UserSessionInfo mUser;

    [tag="pgrp"] 
    UserGroupId mUserGroupId;

    [tag="host", default=false] 
    bool isHost;

    [tag="opt", default=false] 
    bool isOptional;

    [tag="qosv", description="If true, the users creating this game will need their QoS validated.", default=false]
    bool mPerformQosValidation;

    [tag="scei", description="Optional Scenario Info.  NOTE: NOT SET UNTIL REACHING GAME MASTER.  Scenarios do not set this data, the use the ScenarioInfo on StartMatchmakingInternalRequest." ]
    ScenarioInfo mScenarioInfoPerUser;

    [tag="prto", default="0s", description="Optional override for the player reservation timeout. Typically set by Scenarios."]
    TimeValue mPlayerReservationTimeout;
};

typedef list<UserJoinInfo> UserJoinInfoList;

[description = "Reason a game is being updated, used in events"]
enum GameUpdateReason
{
    GAME_RESET,
    GAME_INITIALIZED,
};

class GetGameInfoSnapshotRequest
{
    [tag="gid"] GameId mGameId;
};

class GamePlayerInfo
{
    [tag="atrb", description="Player game attributes specific to the game."] Collections::AttributeMap mAttributeMap;
    [tag="rmr", description="The reason the player was removed from the game."] PlayerRemovedReason mRemovedReason;
    [tag="loc", description="The account locale of the player."] Locale mAccountLocale;
    [tag="cnty", description="The account country of the player."] uint32_t mAccountCountry;
    [tag="fnsh", description="Set if the player finished the game."] bool mFinished;
    [tag="uid", description="The user session id of the player"] UserSessionId mUserSessionId;
    [tag="encr", description="The user's encrypted id. This may be exposed to external services instead a BlazeId."] EncryptedBlazeId mEncryptedBlazeId;
    [tag="eid", description="The user identification of the player"] UserIdentification mUserIdentification;
    [tag="tidx", description="The team index occupied by this player."] TeamIndex mTeamIndex;
};

class GameInfo
{
    [tag="grid", description="The unique value assigned at the beginning of the game."] GameReportingId mGameReportingId;
    [tag="gtyp", description="Game Type of the game report."] GameReportName mGameReportName;

    typedef map<PlayerId, GamePlayerInfo> PlayerInfoMap;
    [tag="rprt", description="Player info."] PlayerInfoMap mPlayerInfoMap;
    [tag="atrb", description="Game attributes specific to the game."] Collections::AttributeMap mAttributeMap;
    [tag="gset", description="Game settings flags specific to the game."] GameManager::GameSettings mGameSettings;

    [tag="gmdr", description="Real-time game duration in milliseconds."] uint32_t mGameDurationMs;    
    [tag="trst", description="Does the game support trusted game reporting."] bool mTrustedGameReporting;
    [tag="gid",  description="Game Id"] GameId mGameId;
    [tag="esid", description="External Session Identificaton"] ExternalSessionIdentification mExternalSessionIdentification;

    [tag = "tid"] TournamentIdentification mTournamentIdentification;
};

[
    description = "Described the state of a started game relevent to game reporting.",
    details = "Send from game manager master to game reporting when a game begins."
]
class StartedGameInfo
{
    [tag="grid", description="The unique value assigned at the beginning of the game."] GameReportingId mGameReportingId;
    [tag="gtyp", description="The game type assigned at beginning of game."] GameReportName mGameReportName;
    [tag="trus", description="Trusted game reporting enabled."] bool mTrustedGameReporting;
    [tag="host", description="Topology host ID"] BlazeId topologyHostId;
    [tag="topo", description="Topology"] GameNetworkTopology topology;
    [tag="gid",  description="Game Id"] GameId mGameId;
};


[description="External session data cached to the blaze game, at create/reset or host injection on master"]
class ExternalSessionMasterRequestData
{
    [tag="exts"] ExternalSessionIdentification mExternalSessionIdentSetupMaster;
    [tag="perr"] ExternalSessionJoinInitError mJoinInitErr;
};

typedef map<UserSessionId, GameSetupReason> UserSessionGameSetupReasonMap;

class JoinGameMasterRequest
{
    [tag="jreq", allowref=true]
    JoinGameRequest mJoinRequest;

    [tag="uinf", allowref=true]
    UserJoinInfo mUserJoinInfo;

    [tag="exsd", allowref=true]
    ExternalSessionMasterRequestData mExternalSessionData;
};

[description="Response to slave after joining the game."]
class JoinGameMasterResponse
{
    [tag="jex", description="Info for joining users who have just joined the blaze game, to their external session"]
    JoinExternalSessionParameters mExternalSessionParams;

    [tag="jrsp", description="Response sent from slave to clients", allowref=true]
    JoinGameResponse mJoinResponse;
};

[
    description = "Request object for creation of the game.",
    details = "Send from matchmaker slave, or gamemanager slave to game manager master to create a new game."
]
class CreateGameMasterRequest
{
    [tag="cret", allowref=true]
    CreateGameRequest mCreateRequest;

    [tag="attr", description="Create game template used by dedicated server search."]
    TemplateName mCreateGameTemplateName;

    [tag="nxpl", default=false, description="If true, the platform override list provided in the create game request is a non-crossplay platform set."]
    bool mIsCrossplayEnabled;
    
    [tag="usrs"] 
    UserJoinInfoList mUsersInfo;

    [tag="exsd"]
    ExternalSessionMasterRequestData mExternalSessionData;
    
    [tag="mmid", default=INVALID_MATCHMAKING_SESSION_ID, description="If game is created via matchmaking, the finalizing session id"]
    MatchmakingSessionId mFinalizingMatchmakingSessionId;

    [tag="gid", description="Game that should be available to reset."]
    GameId mGameIdToReset;

    [tag="pseu", default=false, description="Pseudo games do not use real users to start up, and automatically enter the PREGAME state."]
    bool isPseudoGame;

    [tag="eown"]
    UserSessionInfo mExternalOwnerInfo;
};

[description="Response to slave after create the game."]
class CreateGameMasterResponse
{
    [tag="jex", description="Info for joining users who have just joined the blaze game, to their external session"]
    JoinExternalSessionParameters mExternalSessionParams;

    [tag="crsp", description="Response sent from slave to clients", allowref=true]
    CreateGameResponse mCreateResponse;
    
    [tag="pins", description="Contains partial PIN events for respondants that require them."]
    PINSubmission mPinSubmission;
};

class CreateGameMasterErrorInfo
{
    [tag="prex", description="If the create game attempt didn't create because a game with the specified persisted id already existed, caller may try to join this game id instead.", default=INVALID_GAME_ID]
    GameId mPreExistingGameIdWithPersistedId;
};

[
    description = "Create game request coming from create-game matchmaking.",
    details = "Send from matchmaker slave to game manager master to create a new game."
]
class MatchmakingCreateGameRequest
{
    [tag="creq", description="The create game request used."] 
    CreateGameMasterRequest mCreateReq;
    
    [tag="smap", description="Map of user session setup reasons to user session ids."]
    UserSessionGameSetupReasonMap mUserSessionGameSetupReasonMap;
    
    [tag="pgid", description="Privileged game id for reset (if requested.)", default=INVALID_GAME_ID]
    GameId mPrivilegedGameIdPreference;
    
    [tag="rpgi", description="If set, mPrivilegedGameIdPreference must be used. Otherwise, random servers will be used if the specified one is unavailable.", default=false]
    bool mRequirePrivilegedGameId;

    [tag="ttag", description="The track tag stored from external data source and will be sent to PIN"]
    string(32) mTrackingTag;
};

// Packer Request is currently the same as the MM request.  If this needs to change in the future, feel free to do so. 
typedef MatchmakingCreateGameRequest PackerCreateGameRequest;


[
    description = "Join game response coming from create-game matchmaking."
]
class MatchmakingJoinGameResponse
{
    [tag="jlst", description="The matchmaking session ids of sessions that successfully joined the game."] 
    list<MatchmakingSessionId> mJoinedMatchmakingSessions;
    
    [tag="flst", description="The matchmaking session ids of sessions that failed to join the game."] 
    list<MatchmakingSessionId> mFailedToJoinMatchmakingSessions;

    [tag="jext"] JoinExternalSessionParameters mExternalSessionParams;
};


// host injection
class ChooseHostForInjectionRequest
{
    [tag="vstr", description="GPVS of the game session needing a host injection."] 
        GameProtocolVersionString mGameProtocolVersionString;
 
    [tag="gctr", description="Ping site alias of the game needing a host injection."]
        PingSiteAliasList mGamePingSiteAliasList;
     
    [tag="ntop", description="Network topology of the game session requiring a host injection."]
        GameNetworkTopology mNetworkTopology;
    
    [tag="jifo", description="The info the user joining the game and initiating the injection.", allowref=true]
        UserSessionInfo mJoinerSessionInfo;

    [tag="plyc", default = 0, description="Player capacity needed for the new game. When set to 0, the player capacity will not be checked."] 
        uint16_t mRequiredPlayerCapacity;

    [tag="gid", description="Game that should be available to reset."]
        GameId mGameIdToReset;
};
 
class ChooseHostForInjectionResponse
{
    [tag="uifo", description="Info of the host to be injected."]
       UserSessionInfo mHostInfo;

    
    [tag="hnet", description="Network address list of the injecting host."] 
        NetworkAddressList mHostNetworkAddressList;
    
    [tag="gid", description="The injecting host's GameId."]
        GameId mHostPreviousGameId;
};

// request from slave to master for usergroup join game rpc
class JoinGameByGroupMasterRequest
{
    [tag="jreq", allowref=true] JoinGameRequest mJoinRequest;
    [tag="usrs", allowref=true] UserJoinInfoList mUsersInfo;
    [tag="jlea", default=true] bool mJoinLeader;

    [tag="exsd", allowref=true]
    ExternalSessionMasterRequestData mExternalSessionData;
};

[description="Request to update the blazeServer with info about 1 or more of your peer mesh connections. Moved to gamemanager_server.tdf to be backward compatible with SDK 15.1.1.2.0 and older."]
class UpdateMeshConnectionRequest
{
    [tag="gid"] GameId mGameId;
    [tag="scg"] ObjectId mSourceGroupId;
    [tag="tcg"] ObjectId mTargetGroupId;
    [tag="stat"] PlayerNetConnectionStatus mPlayerNetConnectionStatus;
    [tag="flgs"] PlayerNetConnectionFlags mPlayerNetConnectionFlags;
    [tag="qosi"] MeshConnectionQosInfo mQosInfo;
};

[description="Request to update the blazeServer with info about 1 or more of your peer mesh connections."]
class UpdateMeshConnectionMasterRequest
{
    [tag="gid"] GameId mGameId;
    [tag="sidl"] ConnectionGroupId mSourceConnectionGroupId;
    [tag="tidl"] ConnectionGroupId mTargetConnectionGroupId;
    [tag="stat"] PlayerNetConnectionStatus mPlayerNetConnectionStatus;
    [tag="flgs"] PlayerNetConnectionFlags mPlayerNetConnectionFlags;
    [tag="qosi"] MeshConnectionQosInfo mQosInfo;
    [tag="devi"] string(128) mDeviceInfo;
    [tag="addr"] string(65) mConnectionAddr;
    [tag="nttp"] Util::NatType mNatType;
};

class RemovePlayerMasterRequest
{
    [tag="gid"] GameId mGameId;
    [tag="pid"] PlayerId mPlayerId;
    
    [tag="reas", description="the 'blaze system reason' why the player is being removed."] 
        PlayerRemovedReason mPlayerRemovedReason;

    [tag="cntx", description="a title-defined context (reason code) passed to the removePlayer notification"]
        PlayerRemovedTitleContext mPlayerRemovedTitleContext;
    
    [tag="nid", description="Account Id of the account assocated with the player id (used when banning the player's acct)."]
        AccountId mAccountId;

    [tag="sctx", description="a title-defined context for use in reporting and debugging."]
        string(128) mTitleContextString;
};

class RemovePlayerMasterResponse
{
    [tag="gid"] GameId mGameId;

    [tag="rext", description="Info of player removed from game, for removing from external sessions."]
    LeaveGroupExternalSessionParameters mExternalSessionParams;
};

class LeaveGameByGroupMasterRequest
{
    [tag="gid"] GameId mGameId;
    [tag="pid"] PlayerId mPlayerId;

    [tag="nid", default=INVALID_ACCOUNT_ID, description="Account Id of the account assocated with the player id (used when banning a player's acct)."]
        AccountId mBanAccountId;

    [tag="reas", description="the 'blaze system reason' why the group is being removed."] 
        PlayerRemovedReason mPlayerRemovedReason;

    [tag="cntx", description="a title-defined context (reason code) passed to the removePlayer notification"]
        PlayerRemovedTitleContext mPlayerRemovedTitleContext;

    [tag="sctx", description="a title-defined context for use in reporting and debugging."]
        string(128) mTitleContextString;
    
    [tag="sidl", description="Holding user group's session id list."]
        UserSessionIdList mSessionIdList;
        
    [tag="llea", default=true] bool mLeaveLeader;
};

class LeaveGameByGroupMasterResponse
{
    [tag="rext", description="Infos of players removed from game as result of leave request"]
    LeaveGroupExternalSessionParameters mExternalSessionParams;
};

[description="Request a list of players be banned from game session."]
class BanPlayerMasterRequest
{
    [tag="gid", description="Game players are being banned from"] GameId mGameId;
    [tag="plst", description="A list of players to be banned from game."] PlayerIdList mPlayerIds;
    [tag="alst", description="A list of account Ids assocated with the list of player ids."] AccountIdList mAccountIds;

    [tag="cntx", description="if the users are currently in the game, they're kicked out (with this PlayerRemovedTitleContext)."]
        PlayerRemovedTitleContext mPlayerRemovedTitleContext;
};

class BanPlayerMasterResponse
{
    [tag="rext", description="Infos of players removed from game as result of ban"]
    LeaveGroupExternalSessionParameters mExternalSessionParams;
};

[description="remove a player from banned list at game session."]
class RemovePlayerFromBannedListMasterRequest
{
    [tag="gid", description="Game Id"] GameId mGameId;
    [tag="pid", description="Player Id of the player is removed from banned list."] PlayerId mPlayerId; 
    [tag="nid", description="Account Id of the account assocated with the player id."] AccountId mAccountId;
};

[description="Validate if the master owns a game that points to the persisted id."]
class HasGameMappedByPersistedIdMasterRequest
{
    [tag="psid"] PersistedGameId mPersistedGameId;
};

class HasGameMappedByPersistedIdMasterResponse
{
    [tag="gid", description="Game Id"] GameId mGameId;
};

[description="Reserve the persisted id for a game."]
class ReservePersistedIdMasterRequest
{
    [tag="psid"] PersistedGameId mPersistedGameId;
    [tag="slid"] SliverId mPersistedIdOwnerSliverId;
};

[description="This represents a player in the game. This object is replicated across the slaves.",
 tdfid = "hash", trackChanges = true]
class ReplicatedGamePlayerServer
{
// Common Values Shared with ReplicatedGamePlayer
    [tag="gid"]  GameId mGameId;
    [tag="sid", default=DEFAULT_JOINING_SLOT]  SlotId mSlotId;
    [tag="stat"] PlayerState mPlayerState;
    [tag="blob"] blob mCustomData;
    [tag="patt"] Collections::AttributeMap mPlayerAttribs;
    [tag="slot", default=SLOT_PUBLIC_PARTICIPANT] SlotType mSlotType;
    [tag="tidx", default=UNSPECIFIED_TEAM_INDEX, description="The team index occupied by this player."] 
        TeamIndex mTeamIndex;
    [tag="role", description="The Role this player is assigned to."]
        RoleName mRoleName;
    [tag="ugid"] UserGroupId mUserGroupId;
    [tag="jvmm", default=false] bool mJoinedViaMatchmaking;
    [tag="time", default="0s", description="join timestamp, TimeValue string when joined in the master." ] // Note default is JOINED_GAME_TIMESTAMP_NOT_JOINED, represented as 0s here as TimeValue defaults don't support named constants.
        TimeValue mJoinedGameTimestamp;
    [tag="rcre", default="0s", description="reservation creation timestamp, TimeValue string when reservation is made in the master" ] // Note default is NO_RESERVATION_TIMESTAMP, represented as 0s here as TimeValue defaults don't support named constants.
        TimeValue mReservationCreationTimestamp;
    [tag="csid", default=DEFAULT_JOINING_SLOT] SlotId mConnectionSlotId;
    [tag="jfps", description="To be deprecated as this flag is replaced by PlayerSettings."]
        bool mHasJoinFirstPartyGameSessionPermission;
    [tag="pset"] PlayerSettings mPlayerSettings;
    [tag="encr", description="The user's encrypted id. This may be exposed to external services instead a BlazeId."]
        EncryptedBlazeId mEncryptedBlazeId;
    [tag="scen", description="Scenario Name"]
        ScenarioName mScenarioName;

// ReplicatedGamePlayer tracks a custom subset of these values
    [tag="join"]
    UserSessionInfo mUserInfo;

// Values that are not replicated to client via ReplicatedGamePlayer:
    [tag="inqu", default=false] bool mInQueue;
    [tag="plid", description="The target player whose team the player is wants to join (used for GameSession Queue Only)"]
        PlayerId mTargetPlayerId;
};



[description="This represents the master data portion of the player object.", tdfid = "hash"]
class PlayerDataMaster
{
    [tag="jgto"] TimeValue mJoinGameTimeout;
    [tag="pkto"] TimeValue mPendingKickTimeout;
    [tag="rtov", description="Override for the normal reservation timeout duration. Set by Scenarios."] TimeValue mReservationTimeoutOverride;
    [tag="reto", description="Reservation end time. Set when a reservation is started."] TimeValue mReservationTimeout;
    [tag="rets", description="Reservation start time. Used when a reservation duration changes, such as when moving out of the queue."] TimeValue mReservationTimerStart;
    [tag="necc"] bool mNeedsEntryCriteriaCheck;
    [tag="idre"] bool mIsDisconnectReservation;
    [tag="iugp", default=true, description="on 360, we need to track which players can utilize the game's presence; platform limitation requires that all members of a game with presence enabled are in no other presence sessions"]
     bool mIsUsingGamePresence;
    [tag="opsi"] UserSessionId mOriginalPlayerSessionId;
    [tag="ocgi"] ConnectionGroupId mOriginalConnectionGroupId;
    [tag="ougi"] UserGroupId mOriginalUserGroupId;
    [tag="qiwp", default=0] SlotId mQueuedIndexWhenPromoted;
    [tag="jome", default=SYS_JOIN_TYPE_INVALID] JoinMethod mJoinMethod;
    [tag="gety", default=GAME_ENTRY_TYPE_DIRECT] GameEntryType mGameEntryType;
    [tag="scei"] ScenarioInfo mScenarioInfo;
    [tag="tmfm", description="Whether the player finished their first match in the game session."] 
     bool mFinishedFirstMatch;
    [tag="difm", default=0, description="Duration of time spent in first match for the user in the gamesession. Only set for users who joined the game via matchmaking."]
     int64_t mDurationInFirstMatchesSec;
    [tag="tmfi", default=0] uint16_t mTotalMatchesFinished;
    [tag="tdim", default=0] int64_t mTotalDurationInMatchesSec;
    [tag="qvto"] TimeValue mQosValidationTimeout;
    [tag="ptvr"] string(32) mProtoTunnelVer;
};


// QoS validation
class LinkQosData
{
    [tag="lcon", description="Status of this specific link in a game mesh.", default=DISCONNECTED]
    PlayerNetConnectionStatus mLinkConnectionStatus;
    
    [tag="ping", description="Latency of this specific link in a game mesh."]
    uint32_t mLatencyMs;
    
    [tag="loss", description="Packet loss of this specific link in a game mesh."]
    float mPacketLoss;

    [tag="iscc", description="Whether the link in the game mesh used CCS hosted connectivity."]
    bool mConnectivityHosted;
};

typedef map<PlayerId, LinkQosData> LinkQosDataMap;

class PlayerQosData
{
    [tag="gcon", description="Overall connection status to a game.", default=DISCONNECTED]
    PlayerNetConnectionStatus mGameConnectionStatus;
    
    [tag="lmap", description="Individual network link Qos data."]
    LinkQosDataMap mLinkQosDataMap;
};

typedef map<PlayerId, PlayerQosData> GameQosDataMap;

typedef list<UserGroupId> UserGroupIdList;

// GM_TODO: we should track the groupId of every player who joins, and refcount the groups so we can handle players leaving
//   this feature was originally added for OSDK under time pressure, so we're going with a bare bones impl for now.
[description="A set of GroupIds, currently max size 2."]
typedef UserGroupIdList SingleGroupMatchIdList;

[description="This represents the game. This object is replicated to the search slaves.",
 tdfid = "hash", trackChanges = true]
class ReplicatedGameDataServer
{ 
   [tag="game"] ReplicatedGameData mReplicatedGameData;
   [tag="host"] UserSessionInfo mTopologyHostUserInfo;
   [tag="sgmi"] SingleGroupMatchIdList mSingleGroupMatchIds;
   [tag="ilfj"] bool mIsLockedForJoins;
};

[description="Enum indicating CCS mode when connection concierge connectivity was used. Used for GameManager Metrics.", generateProto=true]
enum ConnConciergeModeMetricEnum
{
    CC_UNUSED,              // sentinel value indicating no attempt to use connection concierge was made.
    CC_HOSTEDONLY_MODE,     // game's CCS mode was hosted only
    CC_HOSTEDFALLBACK_MODE  // peers couldn't connect to each other, leading to use of connection concierge
};

[tdfid = "hash", trackChanges = true]
class ClientCCSConnectionInfo
{
    [tag="ccsi"] HostedConnectivityInfo mHostedConnectivityInfo;
    [tag="ctwr", default=false] bool mCCSTriggerWasReceived; 
    [tag="ccsr", default=CC_UNUSED] ConnConciergeModeMetricEnum mConnConciergeMode;
    [tag="ccrp", default=false] bool mCCSRequestInProgress;
};

class CCSRequestPair
{
    [tag="conf", default=Blaze::INVALID_CONNECTION_GROUP_ID] ConnectionGroupId mConsoleFirstConnGrpId;
    [tag="cons", default=Blaze::INVALID_CONNECTION_GROUP_ID] ConnectionGroupId mConsoleSecondConnGrpId;
    [tag="time", description="The timestamp when first request from the pair arrives."] TimeValue mRequestPairCreationTime;
};

typedef list<CCSRequestPair> CCSRequestPairs;

union CCSAllocateRequestInternal
{
    [tag="hcre"] Blaze::CCS::GetHostedConnectionRequest mV1Request;
    [tag="hccr"] Blaze::CCS::GetHostedConsoleConnectionRequest mV2Request;
};

class CCSAllocateRequest
{
    [tag="crep"] CCSRequestPairs mCCSRequestPairs;
    [tag="req"] CCSAllocateRequestInternal mRequest;
    [tag="gid"] GameId mGameId;
};

class CCSAllocateRequestMaster
{
    [tag="crep"] CCSRequestPairs mCCSRequestPairs;
    [tag="hcre"] Blaze::CCS::GetHostedConnectionResponse mHostedConnectionResponse;
    [tag="gid"] GameId mGameId;
    [tag="suss"] bool mSuccess;
    //+ For logging on coreMaster in case of an error
    [tag="err"] Blaze::CCS::CCSErrorResponse mErr; 
    [tag="oreq"] CCSAllocateRequest mRequestOut;
    //-
};

class CCSFreeRequest
{
    [tag="fhcr"] Blaze::CCS::FreeHostedConnectionRequest mFreeHostedConnectionRequest;
    [tag="gid"] GameId mGameId;
};

class CCSLeaseExtensionRequest
{
    [tag="lexr"] Blaze::CCS::LeaseExtensionRequest mLeaseExtensionRequest;
    [tag="gid"] GameId mGameId;
};

class CCSLeaseExtensionRequestMaster
{
    [tag="lexr"] Blaze::CCS::LeaseExtensionResponse mLeaseExtensionResponse;
    [tag="gid"] GameId mGameId;
    [tag="suss"] bool mSuccess;
    //+ For logging on coreMaster
    [tag="err"] Blaze::CCS::CCSErrorResponse mErr; 
    [tag="oreq"] CCSLeaseExtensionRequest mRequestOut;
    //- 
};

[description="Enum indicating how the user joined. Used for GameManager Metrics.", generateProto=true]
enum ConnectionJoinType
{
    [description = "Connection was due to a user creating the game directly (not via matchmaking)."]
    CREATED,
    [description = "Connection was due to a user joining the game directly (not via matchmaking)."]
    DIRECTJOIN,
    [description = "Connection was due to a user creating or joining the game via matchmaking."]
    MATCHMAKING
};

enum GameModeByJoinMethodType
{
    [description = "placeholder invalid"] GAMEMODE_BY_INVALID,

    GAMEMODE_BY_DIRECTJOIN,
    GAMEMODE_BY_MATCHMAKING,
    GAMEMODE_BY_REMATCH
};

[description="This represents the master data portion of the game object.", tdfid = "hash", trackChanges = true]
class GameDataMaster
{
    typedef list<uint64_t> EndpointSlotList; // analog for EndpointBitset(256), always 4 x 64 bit values
    typedef map<ConnectionGroupId, SlotId> ConnectionSlotMap;
    typedef map<ConnectionGroupId, PlayerIdList> PlayerIdListByConnectionGroupIdMap;
    typedef map<AccountId, TimeValue> BannedAccountMap; 
    typedef list<BlazeId> PendingPreferredJoinList;

    [tdfid = "hash", trackChanges = true]
    class ClientConnectionDetails
    {
        [tag="scgi"] ConnectionGroupId mSourceConnectionGroupId;
        [tag="tcgi"] ConnectionGroupId mTargetConnectionGroupId;
        [tag="stat", default=DISCONNECTED] PlayerNetConnectionStatus mStatus;
        [tag="flag"] PlayerNetConnectionFlags mFlags;
        [tag="late"] uint32_t mLatency;
        [tag="pktl"] float mPacketLoss;
        [tag="cini"] TimeValue mConnInitTime;
        [tag="hisc", default=false] bool mWasConnected;
        [tag="cinf"] ClientCCSConnectionInfo mCCSInfo;

        [tag="join"] ConnectionJoinType mJoinType;
        [tag="game"] bool mConnectionGame; //set if doing game connection(possibly including voip). Unset if voip only connection.
        [tag="qosd"] bool mQosEnabled;
        [tag="qosp"] bool mQosValidationPassed;
        [tag="prem"] bool mRemoveEndpointCalled; //set if either player/side in the connection is being removed from the game
    };

    typedef map<ConnectionGroupId, ClientConnectionDetails> ClientConnectionDetailsMap;
    typedef map<ConnectionGroupId, ClientConnectionDetailsMap> ClientNetConnectionStatusMesh;

    [tdfid = "hash", trackChanges = true]
    class DnfPlayer
    {
        [tag="pid"] PlayerId mPlayerId;
        [tag="rmrs"] PlayerRemovedReason mRemovedReason;
        [tag="attr"] Collections::AttributeMap mAttributes;
        [tag="aloc"] Locale mAccountLocale;
        [tag="cnty"] uint32_t mAccountCountry;
        [tag="uid"] UserSessionId mUserSessionId;
        [tag="encr"] EncryptedBlazeId mEncryptedBlazeId;
        [tag="tidx", description="The team index last occupied by this player"] TeamIndex mTeamIndex;
        [tag="eid", description="The user identification of the player"] UserIdentification mUserIdentification;
    };

    typedef list<DnfPlayer> DnfPlayerList;

    [tdfid = "hash", trackChanges = true]
    class MatchmakingQosData
    {
        [tag="refc", description="when reaching 0, dispatch to mm slave"]
         uint16_t mRefCount;
        [tag="qosm", description="map of each user's individual QoS data"]
         GameQosDataMap mQosDataMap;
    };

    typedef map<MatchmakingSessionId, MatchmakingQosData> MatchmakingQosMap;
    typedef map<PlayerId, MatchmakingSessionId> MatchmakingSessionMap;
    
    // Map can't be used currently as EATDF currently does not support ObjectId as keys. 
    // Worked around it by using a list. Due to small data size, it is unlikely to cause performance hit. 
    [tdfid = "hash", trackChanges = true]
    class UserGroupTargetPlayer
    {
        [tag="ugid", description="The user group Id that should follow the target player."]
         UserGroupId mUserGroupId;
        [tag="tpid", description="The target player this user group follows."]
         PlayerId mTargetPlayerId;
    };
    typedef list<UserGroupTargetPlayer> UserGroupTargetPlayerList;
    
    [tdfid = "hash", trackChanges = true]
    class UserGroupQueuedPlayersCount
    {
        [tag="ugi", description="The user group Id that has queued players."]
         UserGroupId mUserGroupId;
        [tag="qpct", description="The count of the queued players in this user group."]
         uint16_t mQueuedPlayersCount;
    };
    typedef list<UserGroupQueuedPlayersCount> UserGroupQueuedPlayersCountList;

    typedef list<ConnectionGroupId> ConnectionGroupIdList;
    [tdfid = "hash", trackChanges = true]
    class CleanupMeshTask
    {
        [tag="tio"] TimeValue mTimeout;
        [tag="pids"] ConnectionGroupIdList mConnectionGroupIdList;
    };
    typedef map<ConnectionGroupId, CleanupMeshTask> CleanupMeshTasksByConnectionGroupId;

    [tag="cmtm"] CleanupMeshTasksByConnectionGroupId mCleanupMeshTasksMap;
    [tag="mesh"] ClientNetConnectionStatusMesh mClientConnMesh;
    [tag="dlst"] DnfPlayerList mDnfPlayerList;
    [tag="surl"] GameStatusURL mGameStatusUrl;

    [tag="gead"] GameStatusURL mGameEventAddress;
    [tag="gseu"] GameStatusURL mGameStartEventUri;
    [tag="geeu"] GameStatusURL mGameEndEventUri;
    [tag="gsen"] string(255) mGameEventContentType;

    [tag="tid"] TournamentIdentification mTournamentIdentification;

    [tag="osil", description="This Bitvector is for players in the mesh"] 
     EndpointSlotList mOpenSlotIdList;
    [tag="csil", description="This Bitvector is for machines in the mesh. With Multiple Local Users, a machine may have >1 players, however it has a single network connection to other machines"]
     EndpointSlotList mConnectionSlotIdList;
    [tag="cslm", description="caches connection groups by slot id, for quick lookup when adding MLU players to determine if we need a new slot"]
     ConnectionSlotMap mConnectionSlotMap;

    [tag="gsta"] bool mGameStarted;
    [tag="gstf"] bool mGameFinished;
    [tag="mito"] TimeValue mMigrationTimeout;
    [tag="pmst"] GameState mPreHostMigrationState;
    [tag="hmty", description="only valid when game state is MIGRATING."] HostMigrationType mHostMigrationType;
    [tag="nmir"] uint16_t mNumMigrationsReceived;
    [tag="pust"] GameState mPreUnresponsiveState;
    [tag="bacm"] BannedAccountMap mBannedAccountMap;
    [tag="baco"] AccountId mOldestBannedAccount;
    [tag="gsti"] TimeValue mGameStartTime;
    [tag="gpvs"] GameProtocolVersionString mInitialGameProtocolVersionString;
    [tag="tmpl"] TemplateName mInitialGameTemplateName;
    [tag="npsd", default=false] bool mIsNpSessionUnavailable;
    [tag="igcf"] bool mIsGameCreationFinalized;
    
    [tag="ppjl", description="Set to track players during game's locked for preferred joins state, who have not yet issued their joins nor opt outs"]
     PendingPreferredJoinList mPendingPreferredJoinList;

    [tag="lpto"] TimeValue mLockForPreferredJoinsTimeout;
    [tag="labt"] TimeValue mLockedAsBusyTimeout;

    // number of pending queue pumps which may add players to mPendingPreferredJoinSet
    [tag="qppe", description="number of pending queue pumps which may add players to mPendingPreferredJoinSet"]
     uint16_t mQueuePumpsPending;
    [tag="aqmp", description="true if there are queued players that are eligible to be promoted to the game with their current slot/team/role settings"]
     bool mIsAnyQueueMemberPromotable;

    [tag="crhi"] UserSessionInfo mCreatorHostInfo;
    [tag="pres"] bool mIsPendingResyncExternalSession;
    [tag="tesd"] uint32_t mTotalExternalSessionsDesynced;
    [tag="iphc"] bool mIsPingingHostConnection;
    [tag="msem"] MatchmakingSessionMap mMatchmakingSessionMap;
    [tag="mqom"] MatchmakingQosMap mMatchmakingQosDataMap;
    [tag="esui"] ExternalSessionUpdateInfo mExternalSessionUpdateInfo;
    [tag="ugtl"] UserGroupTargetPlayerList mUserGroupTargetPlayerList;
    [tag="ugql"] UserGroupQueuedPlayersCountList mUserGroupQueuedPlayersCountList;
    [tag="gjip"] bool mGroupJoinInProgress;
    [tag="cgip"] PlayerIdListByConnectionGroupIdMap mPlayerIdListByConnectionGroupIdMap;
    
    [tag="csid", default=""] CCSConnectionSetId mConnectionSetId;
    [tag="nhcn", default=0] uint32_t mNumHostedConnections;
    [tag="nfcr", default=0] uint32_t mNumInflightCCSRequests;
    typedef list<CCSRequestPair> CCSRequests;
    [tag="pccr"] CCSRequests mPendingCCSRequests;
    [tag="crft"] TimeValue mCCSRequestIssueTime;
    [tag="celt"] TimeValue mCCSExtendLeaseTime;

    [tag="enip"] bool enableNetworkAddressProtection;

    [tag="esta"] ExternalSessionStatus mExternalSessionStatus;
    [tag="edat"] ExternalSessionCustomData mExternalSessionCustomData;
    [tag="emem"] ExternalMemberInfoListByActivityTypeInfo mTrackedExternalSessionMembers;
    [tag="etrn"] TournamentSessionData mTournamentSessionData;
    [tag="exrp"] ExternalSessionRecentPlayersSettings mExternalSessionRecentPlayersSettings;
    [tag="xlrg"] bool mXblLargeSession;

    [tag="edso", description="List of external data sources api's used to override this game."]
    DataSourceNameList mDataSourceNameList;
};


class GetExternalDataSourceApiListRequest
{
    [tag="gid", description="The Game id."]
    GameId mGameId;
};

class GetExternalDataSourceApiListResponse
{
    [tag="edso", description="List of external data sources api's used to override this game.", allowref=true]
    DataSourceNameList mDataSourceNameList;
};

////////////////////////////////////////////////////////////////////////////////
// Preferred Join Opt Out TDFs /////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description = "request from slave to master for opting players out of a preferred join."]
class PreferredJoinOptOutMasterRequest
{
    [tag="gid", description="The Game id that player is opting out of."]
        GameId mGameId;

    [tag="sidl", description="Holding conn group's session id list."]
        UserSessionIdList mSessionIdList;
};

////////////////////////////////////////////////////////////////////////////////
// External Sessions TDFs //////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description = "request from slave to master for cleaning external session's members who should not be in the external session."]
class ResyncExternalSessionMembersRequest
{
    [tag="gid", description="The Game id to clean up external session for."]
        GameId mGameId;
};

[description="Fetch info on the game's external session."]
class GetExternalSessionInfoMasterRequest
{
    [tag="usr"] UserIdentification mCaller;
    [tag="gid"] GameId mGameId;
};

class GetExternalSessionInfoMasterResponse
{
    [tag="crea", description="the game's current values used to create, update and/or track members of its external session(s), including game's external session identification, which may be empty if game has no external session."]
    ExternalSessionCreationInfo mExternalSessionCreationInfo;

    [tag="ismb", description="whether caller was a game member. (Some external session related ops require game membership)."]
    bool mIsGameMember;

    [tag="isad", description="whether caller was an admin. (Some external session related ops require admin permissions)."]
    bool mIsGameAdmin;
};

[description="Request to track the user as advertising the game's external session."]
class TrackExtSessionMembershipRequest
{
    [tag="gid", description="id of the game."]
    GameId mGameId;

    [tag="usid", description="user to track."]
    ExternalMemberInfo mUser;

    [tag="news", description="the expected session of the game, to track membership for."]
    ExternalSessionIdentification mExtSessionToAdvertise;

    [tag="newu", description="snapshot of the Blaze game info used to create/join the session, on the slave. If the master's game info since changed, the session's properties will be re-synced as appropriate."]
    ExternalSessionUpdateInfo mExtSessionOrigUpdateInfo;

    [tag="paty", description="info specifying the platform/activity-type specific membership list to track with."]
    ExternalSessionActivityTypeInfo mExtSessType;
};

[description="Request to track the user as not advertising the game's external session."]
class UntrackExtSessionMembershipRequest
{
    [tag="gid", description="id of the game."]
    GameId mGameId;

    [tag="usid", description="user to track."]
    ExternalMemberInfo mUser;

    [tag="olds", description="if specified, and the game has this session, all its members will be tracked as removed from the session. For cleanup after PSN errors etc"]
    ExternalSessionIdentification mExtSessionToUntrackAll;

    [tag="paty", description="info specifying the platform/activity-type specific membership list to track with."]
    ExternalSessionActivityTypeInfo mExtSessType;
};

class UntrackExtSessionMembershipResponse
{
    [tag="ssta", default=GAME_PLAY_STATE_INVALID]
    SimplifiedGamePlayState mSimplifiedState;
};

[description="The name of the formula used to calculate the UserExtendedData value of a group or team of users."]
enum GroupValueFormula
{
    GROUP_VALUE_FORMULA_AVERAGE,
    GROUP_VALUE_FORMULA_MIN,
    GROUP_VALUE_FORMULA_MAX,
    GROUP_VALUE_FORMULA_LEADER,
    GROUP_VALUE_FORMULA_SUM
};


[description="map tracking group sizes and their number of instances in TeamComposition's or teams."]
typedef map<uint16_t, uint16_t> GroupSizeCountMap;

[description="A list of team composition's group size count maps. Each index in this list corresponds to its respective team's TeamIndex (and TeamComposition) in the game."]
typedef list<GroupSizeCountMap> GroupSizeCountMapByTeamList;

[description="A list of different game team compositions' group size count maps (GroupSizeCountMapByTeamList's)."]
typedef list<GroupSizeCountMapByTeamList> GroupSizeCountMapByTeamListList;

[description="TeamSelectionCriteria sub-criterias which can be ranked by relative priority. Note the default prioritization is the order in which the value is defined in the TeamSelectionCriteriaPriority enumeration."]
enum TeamSelectionCriteriaPriority
{
    TEAM_SELECTION_PRIORITY_TYPE_TEAM_BALANCE,
    TEAM_SELECTION_PRIORITY_TYPE_TEAM_COMPOSITION,
    TEAM_SELECTION_PRIORITY_TYPE_TEAM_UED_BALANCE
};
typedef list<TeamSelectionCriteriaPriority> TeamSelectionCriteriaPriorityList;


[description="Specifies parameters for selecting the team to join in a game.  ONLY USED FOR SINGLE TEAM JOINS."]
class TeamSelectionCriteria
{
    [tag="cnt", description="The required vacant slot space available on the team."]
    uint16_t mRequiredSlotCount;

    [tag="uedk", default=INVALID_USER_EXTENDED_DATA_KEY, description="The User extended data key for which team UED values are checked for balance. Ignored if INVALID_USER_EXTENDED_DATA_KEY."]
    UserExtendedDataKey mTeamUEDKey;
    
    [tag="uedr", description="The User extended data rule for which team UED values are checked for balance. Ignored if mTeamUEDKey is INVALID_USER_EXTENDED_DATA_KEY."]
    RuleName mTeamUEDRuleName;
    
    [tag="uedf", description="The calculation method for team UED balance requirements. Ignored if mTeamUEDKey is INVALID_USER_EXTENDED_DATA_KEY."]
    GroupValueFormula mTeamUEDFormula;
    
    [tag="uedv", description="The joining player or group's Team UED value. Ignored if mTeamUEDKey is INVALID_USER_EXTENDED_DATA_KEY."]
    UserExtendedDataValue mTeamUEDJoiningValue;

    [tag="tgsz", description="A list of group size count maps for acceptable game team compositions."]
    GroupSizeCountMapByTeamListList mAcceptableGameTeamCompositionsList;

    [tag="prio", description="List of explicitly specified priorities. Any TeamSelectionCriteriaPriority values specified in this list get their associated sub-criterias prioritized over those that are not specified here. Remaining possible TeamSelectionCriteriaPriority values not specified in this list follow the order in which the value is defined in the TeamSelectionCriteriaPriority enumeration."]
    TeamSelectionCriteriaPriorityList mCriteriaPriorityList;
};

[description="Request to set a game session as responsive or not."]
class SetGameResponsiveRequest
{
    [tag="gid", description="ID of the game session to set responsive or not."]
    GameId mGameId;

    [tag="resp", description="Whether to set responsive or not."]
    bool mResponsive;
};

class PackerFoundGameRequest
{
    [tag="fjid", description="Finalization Job ID"]
    uint64_t mFinalizationJobId;

    [tag="oid", description="The matchmaking session's owner's user sessionid"]
    UserSessionId mOwnerUserSessionId;

    [tag="req", description="join request for this match"]
    JoinGameByGroupMasterRequest mJoinGameByGroupRequest;

    [tag="smap", description="Map of user session setup reasons to user session ids."]
    UserSessionGameSetupReasonMap mUserSessionGameSetupReasonMap;

    [tag="gid", description="matched GameId."]
    GameId mGameId;

    [tag="treq", description="requirements for the team of the game this session is attempting to join."]
    TeamSelectionCriteria mFoundTeam;

    [tag="gmrv", description="Expected game record version"]
    uint64_t mGameRecordVersion;
};

class PackerFoundGameResponse
{
    [tag="gid", default=INVALID_GAME_ID, description="The GameId if this session joined a game on the master, INVALID_GAME_ID otherwise."]
    GameId mJoinedGameId;

    [tag="jext", description="External Session Parameters"]
    JoinExternalSessionParameters mExternalSessionParams;

    [tag="pins", description="PIN event to submit when MM is complete"]
    PINSubmission mPinSubmission;

    [tag="gmrv", description="Game record version"]
    uint64_t mGameRecordVersion;
};

class ProcessTelemetryReportRequest
{
    [tag="gid", description="ID of the game session to set responsive or not."]
    GameId mGameId;

    [tag="bpsa", description="Best ping site alias of the caller."]
    PingSiteAlias mBestPingSiteAlias;

    [tag="trpt", description="The telemetry report (from the client) to process."]
    TelemetryReportRequest mReport;
};


[generateProto=true]
enum DemanglerConnectionHealthcheck
{
    CONNECTION_WITHOUT = 0,              //connection without
    CONNECTION_SUCCESS_WITH_DEMANGLER,     //connection attempts success after using demangler 
    CONNECTION_SUCCESS_WITHOUT_DEMANGLER,  //connection attempts success w/o needing to demangler
    CONNECTION_FAILURE_WITH_DEMANGLER,     //connection attempts failed (demangler was tried) 
    CONNECTION_FAILURE_WITHOUT_DEMANGLER   //connection attempts failed (demangler not attempted)) 
};

[description="Enum used for GameManager Metrics, indicating whether peer connection was successful"]
enum ConnSuccessMetricEnum
{
    SUCCESS,
    FAILED,
    INCOMPLETE
};
[description="Enum used for GameManager Metrics, indicating whether peer connection used demangler"]
enum ConnDemanglerMetricEnum
{
    WITHOUT_DEMANGLER,
    WITH_DEMANGLER
};

[description="Enum used for GameManager Metrics, indicating whether peer connection result was player impacting or not", generateProto=true]
enum ConnImpactingMetricEnum
{
    IMPACTING,    // non-MM-QoS'd connections that are either without CC fall back, or are the CC fall back connections themselves
    NONIMPACTING  // MM-QoS'd connections, or connections with CC fall back available
};

enum ConnConciergeEligibleEnum
{
    CC_ELIGIBLE,
    CC_INELIGIBLE
};

class PktReceivedMetrics
{
    [tag="cnpr",description="Total counts of leaving clients not receiving packets from dedicated server host."]
    int64_t mClientNoPktReceived;
    [tag="cpre",description="Total counts of leaving clients receiving packets from dedicated server host."]
    int64_t mClientPktReceived;
    [tag="cnre",description="Total counts of clients not sending pkt information to blaze server."]
    int64_t mClientNoResp;
    [tag="hnpr",description="Total counts of dedicated server host not receiving packets from a leaving client."]
    int64_t mDedicatedServerHostNoPktReceived; 
    [tag="hpre",description="Total counts of dedicated server host receiving packets from a leaving client."]
    int64_t mDedicatedServerHostPktReceived;
    [tag="hnre",description="Total counts of dedicated server host not sending pkt information to blaze server."]
    int64_t mDedicatedServerHostNoResp; 
};

typedef map<GameId, PktReceivedMetrics> PktReceivedMetricsByGameIdMap;

class GetPktReceivedMetricsResponse
{
    [tag="dspr",description="Map that tracks whether a leaving client & dedicated server host are receiving packets from each other. Map is keyed by dedicated server host."]
    PktReceivedMetricsByGameIdMap mPktReceivedMetricsByGameIdMap;
};

class GetPktReceivedMetricsRequest
{
    [tag="gid",description="Filter metrics by game id. If not specified, then all metrics will be returned."]
    GameId mGameId;
};

bitfield MeshDisconnectReceived
{
    mDedicatedServer : 1;
    mClient : 1;
};

typedef string(32) TeamName; //max length is that of PS5 Match team name
typedef map<TeamId, TeamName> TeamNameByTeamIdMap;

} // namespace GameManager

} // namespace Blaze
