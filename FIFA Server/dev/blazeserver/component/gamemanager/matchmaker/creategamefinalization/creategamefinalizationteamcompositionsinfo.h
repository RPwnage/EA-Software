/*! ************************************************************************************************/
/*!
    \file   creategamefinalizationteamcompositionsinfo.h

    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

#ifndef BLAZE_CREATE_GAME_FINALIZATION_TEAM_COMPOSITIONS_INFO
#define BLAZE_CREATE_GAME_FINALIZATION_TEAM_COMPOSITIONS_INFO

#include "gamemanager/matchmaker/teamcompositionscommoninfo.h"// for GameTeamCompositionsId
#include "gamemanager/matchmaker/creategamefinalization/creategamefinalizationteaminfo.h"// for CreateGameFinalizationTeamInfoVector in initialize()

namespace Blaze
{

namespace GameManager
{

namespace Matchmaker
{
    class CreateGameFinalizationTeamInfo;
    class CreateGameFinalizationSettings;
    class TeamCompositionFilledInfo;

    /*! ************************************************************************************************/
    /*! \brief Used to track finalization state with respect to team compositions, and to select next buckets
        and teams that will be filled. Possible team compositions capacities are generated by team compositions rule.
    ***************************************************************************************************/
    class CreateGameFinalizationGameTeamCompositionsInfo
    {
    public:

        // General outline how we implement TeamCompositionRule finalization (for more details see TDD's).
        // 1) Need to build out a set of possible team compositions you can currently fullfill to match.
        // 2) Need to (in this class) track of which compositions you're going for in this finalization sequence attempt.
        // 3) Need to (in this class) track which parts of the compositions you're trying to fill right now, and which parts are filled/remain.
        // 4) Restrict bucket choices, depending on Game TeamCompositions allowed
        // * Depending on the compositions and tracking around that select appropriate buckets only for the current pick.
        // * we make calls to the 'markTeamCompositionTried()' type of fn's throughout.
        // 5) Appropriately call a method like TeamCompositionRule::areFinalizingTeamsAcceptableToCreateGame()

        /*! ************************************************************************************************/
        /*! \brief CreateGameFinalizationGameTeamCompositionsInfo ctor
        *************************************************************************************************/
        CreateGameFinalizationGameTeamCompositionsInfo();

        bool initialize(const CreateGameFinalizationSettings& p, const GameTeamCompositionsInfo& gameTeamCompositions, const MatchmakingSession& pullingSession, CreateGameFinalizationTeamInfoVector& createGameFinalizationTeamInfoVector);

        GameTeamCompositionsId getCurrentGameTeamCompositionsId() const { return ((mCurrentGameTeamCompositionsInfo != nullptr)? mCurrentGameTeamCompositionsInfo->mGameTeamCompositionsId : INVALID_GAME_TEAM_COMPOSITONS_ID); }
        const GameTeamCompositionsInfo* getCurrentGameTeamCompositionsInfo() const { return mCurrentGameTeamCompositionsInfo; }
        bool isFullfilled() const;
        const char8_t* toLogStr() const;
    private:
        void reset(CreateGameFinalizationTeamInfoVector& createGameFinalizationTeamInfoVector);
        bool validateStatePreInitialize(const CreateGameFinalizationSettings& p, const GameTeamCompositionsInfo& gameTeamCompositionsInfo, const MatchmakingSession& pullingSession, CreateGameFinalizationTeamInfoVector& createGameFinalizationTeamInfoVector) const;
    private:
        const GameTeamCompositionsInfo* mCurrentGameTeamCompositionsInfo;//pre: pointer to this object, owned by the rule definition, never gets invalidated while we need it.
        
        typedef eastl::list<TeamCompositionFilledInfo> TeamCompositionTriedInfoList;
        TeamCompositionTriedInfoList mTeamCompositionFilledInfoList;
        mutable eastl::string mLogStr;//on-demand
        eastl::string mOwningSessionLogStr;
    };

     /*! ************************************************************************************************/
    /*! \brief Class tracking the group sizes filled in the TeamComposition.
    *************************************************************************************************/
    class TeamCompositionFilledInfo
    {
    public:
        TeamCompositionFilledInfo();
        void initialize(const CreateGameFinalizationGameTeamCompositionsInfo& p, const TeamComposition& composition);

        // return next group size to fill, or 0 if none unfilled
        uint16_t getNextUnfilledGroupSize() const;
        bool markGroupSizeFilled(uint16_t groupSizeToMarkFilled);
        void clearGroupSizeFilled(uint16_t groupSizeToMarkFilled);
        bool hasUnfilledGroupSize(uint16_t groupSize) const;
        bool isFull() const { return (getNextUnfilledGroupSize() == UINT16_MAX); }
        GameTeamCompositionsId getGameTeamCompositionsId() const { return ((mParent != nullptr)? mParent->getCurrentGameTeamCompositionsId() : INVALID_GAME_TEAM_COMPOSITONS_ID); }

        const char8_t* toLogStr(bool doPrintFilledKey = false) const;
        const char8_t* getParentLogStr() const { return ((mParent == nullptr)? "<GameTeamCompositions unknown>" : mParent->toLogStr()); }
    private:
        const CreateGameFinalizationGameTeamCompositionsInfo* mParent;
        const TeamComposition* mTeamComposition;//pre: pointer to this object, owned by the rule definition, never gets invalidated while we need it.

        typedef eastl::pair<uint16_t, bool> GroupSizeIsFilledPair;
        typedef eastl::vector<GroupSizeIsFilledPair> GroupSizeIsFilledPairVector; // index is the index in the TeamComposition
        GroupSizeIsFilledPairVector mGroupSizeIsFilledPairVector;
        mutable eastl::string mLogStrBuf;
    };

} // namespace Matchmaker
} // namespace GameManager
} // namespace Blaze

#endif // BLAZE_CREATE_GAME_FINALIZATION_TEAM_COMPOSITIONS
