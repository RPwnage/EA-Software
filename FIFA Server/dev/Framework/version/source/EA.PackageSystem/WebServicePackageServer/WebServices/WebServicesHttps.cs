// Originally based on NAnt - A .NET build tool
// Copyright (C) 2003-2018 Electronic Arts Inc.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// As a special exception, the copyright holders of this software give you 
// permission to link the assemblies with independent modules to produce 
// new assemblies, regardless of the license terms of these independent 
// modules, and to copy and distribute the resulting assemblies under terms 
// of your choice, provided that you also meet, for each linked independent 
// module, the terms and conditions of the license of that module. An 
// independent module is a module which is not derived from or based 
// on these assemblies. If you modify this software, you may extend 
// this exception to your version of the software, but you are not 
// obligated to do so. If you do not wish to do so, delete this exception 
// statement from your version. 
// 
// Electronic Arts (Frostbite.Team.CM@ea.com)

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source cod


using System.Net.Http;
using System.Web;

using NAnt.Authentication;
using NAnt.Core.PackageCore;
using EA.PackageSystem;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

namespace EA.PackageSystem.PackageCore.Services
{
	using NAnt.Core.Util;
	using System;
	using System.Collections.Generic;
	using System.IO;
	using System.Linq;
	using System.Net;
	using System.Security.Cryptography;
	using System.Security.Policy;
	using System.Text;
	using System.Threading;
	using System.Threading.Tasks;
	using System.Xml;
	using static EA.PackageSystem.PackageServerRestV2Api;

	public class WebServicesHttps : IWebServices
	{
		private readonly HttpClient PackageServerClient;
		private readonly PackageServerRestV2Api PackageServerApi;
		private readonly TimeSpan DefaultTimeout;
		private const int MAX_RETRIES = 3;
		private const string BEARER = "Bearer ";
		private IEnumerable<string> ManifestTags = new List<string>() { "manifestVersion", "packageName", "versionName", "summary", "contactName", "contactEmail", "status", "description" };
		public WebServicesHttps(HttpClient client, TimeSpan defaultTimeout, PackageServerRestV2Api packageServerApi)
		{
			PackageServerClient = client;
			DefaultTimeout = defaultTimeout;
			PackageServerApi = packageServerApi;
		}

		public async Task<ReleaseBase[]> GetPackageReleasesV2(string name)
		{
			string URI = PackageServerApi.GetPackageReleases(name, true);
			UriBuilder builder = new UriBuilder(URI);
			var query = HttpUtility.ParseQueryString(builder.Query);
			builder.Query = query.ToString();
			HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, builder.ToString());
			var response = await PackageServerClient.SendAsync(request);
			if (response.IsSuccessStatusCode)
			{
				using (Stream receiveStream = response.Content.ReadAsStreamAsync().Result)
				{
					using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))
					{
						try
						{
							var responseText = readStream.ReadToEndAsync().Result;
							var unpacked = JsonConvert.DeserializeObject<IEnumerable<PackageRelease>>(responseText, new JsonSerializerSettings
							{
								ContractResolver = new DefaultContractResolver { NamingStrategy = new SnakeCaseNamingStrategy() }
							});
							return unpacked.ToArray();
						}
						catch (Exception e)
						{
							throw new Exception($"Error deserialising response from package server - {e}");
						}
					}
				}
			}
			return null;
		}


		/// <summary>
		/// Get a specific release of a package
		/// </summary>
		/// <param name="name">name of the package</param>
		/// <param name="version">version of the package</param>
		/// <returns></returns>
		public async Task<ReleaseBase> GetReleaseV2(string name, string version)
		{
			string URI = PackageServerApi.GetPackageReleases(name, true);
			UriBuilder builder = new UriBuilder(URI);
			var query = HttpUtility.ParseQueryString(builder.Query);
			builder.Query = query.ToString();
			Stream receiveStream;
			StreamReader readStream;
			HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, builder.ToString());
			var response = await PackageServerClient.SendAsync(request);
			if (response.IsSuccessStatusCode)
			{
				receiveStream = response.Content.ReadAsStreamAsync().Result;
				using (receiveStream)
				{
					readStream = new StreamReader(receiveStream, Encoding.UTF8);
					using (readStream)
					{
						try
						{
							var responseText = readStream.ReadToEndAsync().Result;
							var unpacked = JsonConvert.DeserializeObject<IEnumerable<PackageRelease>>(responseText);
							var target = unpacked.FirstOrDefault(package =>
								package.Version.Equals(version) || (package.Metadata.Legacy_Version != null && package.Metadata.Legacy_Version.Equals(version)));
							return target;
						}
						catch (Exception e)
						{
							throw new Exception($"Error deserialising response from package server - {e}");
						}
					}
				}
			}
			else
			{
				return null;
			}
		}

		public bool UsingNewPackageServer() => true;

		public string PostPackageV2OrGetError(string fileName, string manifestContents, string changes, int statusId, string statusComment, string requiredReleases, string account)
		{
			// first get the upload URL from the package server
			var PackageNameAndVersion = Path.GetFileName(fileName).Split(new[] { '-' }, 2);
			string packageName = PackageNameAndVersion.ElementAt(0);
			string packageVersion = PackageNameAndVersion.ElementAt(1).Replace(".zip", "");
			// Check that package doesn't already exist 
			var packageExistsResponse = GetReleaseV2(packageName, packageVersion).Result;
			if (packageExistsResponse != null)
			{
				throw new Exception($"Cannot post package as it already exists");
			}

			PackageUploadPayloadResponse uploadUrl;
			uploadUrl = GetUploadURL(packageName, packageVersion, manifestContents);

			// then post the package to the endpoint 
			var errors = PostPackage(fileName, uploadUrl.url, uploadUrl.storage_key, uploadUrl.user, StorageDestination.ARTIFACTORY);

			if (!String.IsNullOrEmpty(errors))
			{
				return errors;
			}

			PostPackagePayload package = ParseManifestContents(manifestContents);
			package.version = packageVersion;
			// Register the package to the package server
			var registered = RegisterPackage(package, packageName);
			return registered;
		}

		public void Dispose()
		{
			// do nothing
		}


		/// <summary>
		/// Get URL for downloading package
		/// </summary>
		/// <param name="name"></param>
		/// <param name="version"></param>
		/// <returns></returns>
		public async Task<string> GetDownloadUrl(string name, string version)
		{
			var response = await GetDownloadUrlResponse(name, version);
			if (!response.IsSuccessStatusCode)
			{
				throw new Exception($"Error getting download URL for {name}-{version} from server: status code {response.StatusCode} -\n message - {response.Content.ReadAsStringAsync().Result}");
			}
			else
			{
				using (Stream receiveStream = response.Content.ReadAsStreamAsync().Result)
				{
					using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))
					{
						try
						{
							var responseText = readStream.ReadToEndAsync().Result;
							return ParsePackageServerResponseBody(responseText).url;
						}
						catch (Exception e)
						{
							throw new Exception($"Error deserialising response from package server - {e}");
						}
					}
				}
			}
		}


		// Will deprecate soon after testing nemesis create package if doesn't exist methods work.
		/// <summary>
		/// Try creating a new package
		/// </summary>
		/// <param name="name"></param>
		/// <param name="version"></param>
		/// <param name="manifestContent"></param>
		/// <returns></returns>
		public bool CreateNewPackage(string name, string manifestContent)
		{
			// make sure package doesn't already exist
			if (GetPackageReleasesV2(name).Result != null)
			{
				throw new Exception($"Failed to create package as package {name} already exists on the package server.");
			}
			var packageDetails = ParseManifestContents(manifestContent);
			if (packageDetails.author == null || String.IsNullOrEmpty(packageDetails.author.email))
			{
				throw new Exception($"Can't create new package without an owner, please ensure the author and author email section of the manifest are not null");
			}
			CreatePackagePayload payload = new CreatePackagePayload();
			payload.name = name;
			payload.package_id = name;
			payload.contact = packageDetails.author;
			payload.metadata = packageDetails.metadata;
			payload.admins = new List<string>() { packageDetails.author.email };
			payload.description = packageDetails.description ?? "";
			var body = JsonConvert.SerializeObject(payload);
			string uriEndpoint = PackageServerApi.GetPackages();
			var requestContent = new StringContent(body, Encoding.UTF8, "application/json");
			HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, uriEndpoint);

			request.Content = requestContent;
			var response = PackageServerClient.SendAsync(request).Result;
			if (response.IsSuccessStatusCode != true)
			{
				using (Stream receiveStream = response.Content.ReadAsStreamAsync().Result)
				{
					using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))
					{

						var responseText = readStream.ReadToEndAsync().Result;
						throw new Exception($"Attempt to create package at {uriEndpoint} failed with status code {response.StatusCode} \n message from server: {responseText}");
					}
				}
			}
			return response.IsSuccessStatusCode;
		}



		/// <summary>
		/// Get the Upload URL from the package server
		/// </summary>
		/// <param name="name">package name</param>
		/// <param name="version">package version</param>
		/// <param name="manifestContent">contents of manifest for verification</param>
		/// <returns></returns>
		private PackageUploadPayloadResponse GetUploadURL(string name, string version, string manifestContent)
		{
			string uriEndpoint = PackageServerApi.GetUploadUrl(name, version);
			var httpContent = new StringContent(manifestContent, Encoding.UTF8, "text/xml");
			var response = PackageServerClient.PostAsync(uriEndpoint, httpContent).Result;
			string result;
			PackageUploadPayloadResponse packageDetails;
			if (response.StatusCode == HttpStatusCode.NotFound)
			{
				// TODO - remove this soon as registering a new package should create a new one if it's not good.
				throw new Exception($"Error getting upload URL for {name}-{version} from server at {uriEndpoint}: " +
					$"\n Status code {response.StatusCode} -\n message - {response.Content.ReadAsStringAsync().Result}" +
				$"Try creating a new package with --createnewpackage");
			}
			else if (!response.IsSuccessStatusCode)
			{
				throw new Exception($"Error getting upload URL for {name}-{version} from server at {uriEndpoint}: \n Status code {response.StatusCode} -\n message - {response.Content.ReadAsStringAsync().Result}");
			}
			else
			{
				result = ParseUploadResponse(response, out packageDetails);
				if (!String.IsNullOrEmpty(result))
				{
					throw new Exception($"Error getting upload URL for {name}-{version} from server at {uriEndpoint}: \n Status code {response.StatusCode} -\n message - {response.Content.ReadAsStringAsync().Result}");
				}
			}
			return packageDetails;
		}

		/// <summary>
		/// Parses the response from a get_upload request, string response should be empty if successful otherwise contains error details 
		/// </summary>
		/// <param name="response"></param>
		/// <param name="packageDetails"></param>
		/// <returns></returns>
		private string ParseUploadResponse(HttpResponseMessage response, out PackageUploadPayloadResponse packageDetails)
		{
			if (response.IsSuccessStatusCode)
			{
				string repsonseStr = response.Content.ReadAsStringAsync().Result;
				packageDetails = ParsePackageServerResponseBody(repsonseStr);
				return "";
			}
			else
			{
				packageDetails = null;
			}
			return $"Status code { response.StatusCode} \n message - { response.Content.ReadAsStringAsync().Result}";
		}

		/// <summary>
		/// Send file to storage
		/// </summary>
		/// <param name="filePath">path to file to send</param>
		/// <param name="destinationUrl">path to storage</param>
		/// <param name="key">api key to use</param>
		/// <param name="user">user to use</param>
		/// <param name="destination">the storage destination</param>
		/// <returns></returns>
		private string PostPackage(string filePath, string destinationUrl, string key, string user, StorageDestination destination = StorageDestination.ARTIFACTORY)
		{
			switch (destination)
			{
				// TODO switch this out to an artifactory helper class and inject the http client there
				case StorageDestination.ARTIFACTORY:
					FileInfo file = new FileInfo(filePath);
					HttpClient client = new HttpClient();
					client.Timeout = Timeout.InfiniteTimeSpan;
					client.DefaultRequestHeaders.Add("Authorization", $"Bearer {key}");

					HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Put, destinationUrl);
					HttpResponseMessage response;
					bool success = false;
					int retry = 0;
					string responseText = "";
					while (success == false && retry < MAX_RETRIES)
					{
						retry++;
						using (var filestream = File.OpenRead(file.FullName))
						{
							var length = filestream.Length.ToString();
							var streamContent = new StreamContent(filestream);
							streamContent.Headers.Add("Content-Type", "application/octet-stream");
							streamContent.Headers.Add("Content-Length", length);
							request.Content = streamContent;
							response = client.SendAsync(request).Result;
							responseText = response.Content.ReadAsStringAsync().Result;
						}

						if (response.IsSuccessStatusCode == true)
						{
							success = true;
							return "";
						}
					}
					if (success == false)
					{
						return ($"Error registering package to the package server: {responseText}");
					}
					break;

				default:
					break;
			}
			return "";
		}

		public bool EditPackageStatus(string package, string release, string status)
		{
			var body = $@"{{""status_name"":""{status}""}}";
			var uriEndpoint = PackageServerApi.GetPackageRelease(package, release);
			var requestContent = new StringContent(body, Encoding.UTF8, "application/json");
			var request = new HttpRequestMessage(new HttpMethod("PATCH"), uriEndpoint);

			request.Content = requestContent;
			var response = PackageServerClient.SendAsync(request).Result;
			if (response.IsSuccessStatusCode != true)
			{
				using (Stream receiveStream = response.Content.ReadAsStreamAsync().Result)
				{
					using (StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8))
					{
						var responseText = readStream.ReadToEndAsync().Result;
						throw new Exception($"Attempt to edit release status at {uriEndpoint} failed with status code {response.StatusCode} \n message from server: {responseText}");
					}
				}
			}
			return response.IsSuccessStatusCode;
		}

		private string RegisterPackage(PostPackagePayload package, string packageName)
		{
			string URI = PackageServerApi.GetPackageReleases(packageName, false);
			UriBuilder builder = new UriBuilder(URI);
			var query = HttpUtility.ParseQueryString(builder.Query);

			var body = JsonConvert.SerializeObject(package);
			var requestContent = new StringContent(body, Encoding.UTF8, "application/json");
			HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, URI);

			request.Content = requestContent;
			var response = PackageServerClient.SendAsync(request).Result;
			if (response.IsSuccessStatusCode)
			{
				return "";
			}
			else
			{
				return ($"Error registering package to the package server: {response.StatusCode} - {response.Content.ReadAsStringAsync().Result}");
			}
		}

		private PostPackagePayload ParseManifestContents(string manifest)
		{
			// at this stage we've already validated the manifest with the package server
			// null checking for sanity sake
			PostPackagePayload release = new PostPackagePayload();
			XmlDocument document = new XmlDocument();
			document.LoadXml(manifest);
			XmlNode packageNode = document.GetChildElementByName("package");
			XmlNode changesNode = packageNode.GetChildElementByName("changes");
			XmlNode author = packageNode.GetChildElementByName("contactName");
			XmlNode authorMail = packageNode.GetChildElementByName("contactEmail");
			XmlNode statusName = packageNode.GetChildElementByName("status");
			XmlNode descriptionNode = packageNode.GetChildElementByName("description");
			XmlNode license = packageNode.GetChildElementByName("license");
			XmlNode licensecomment = packageNode.GetChildElementByName("licenseComment");
			XmlNode homeUrl = packageNode.GetChildElementByName("homePageUrl");
			// get metadata?
			if (!String.IsNullOrEmpty(license?.InnerText))
			{
				release.metadata.Add("license", license.InnerText);
			}
			if (!String.IsNullOrEmpty(homeUrl?.InnerText))
			{
				release.metadata.Add("homePageUrl", homeUrl.InnerText);
			}
			if (!String.IsNullOrEmpty(licensecomment?.InnerText))
			{
				release.metadata.Add("licensecomment", licensecomment.InnerText);
			}
			release.changes = changesNode?.InnerText ?? "";
			release.description = descriptionNode?.InnerText ?? "";
			release.author = new PackageUser()
			{
				email = authorMail?.InnerText ?? "",
				name = author?.InnerText ?? ""
			};
			release.status_name = statusName?.InnerText ?? "unknown";

			return release;
		}

		private PackageUploadPayloadResponse ParsePackageServerResponseBody(string responseText)
		{
			var deserialized = JsonConvert.DeserializeObject<PackageUploadPayloadResponse>(responseText);
			// If the url has both a transport and a protocol scheme, we don't want the transport part.
			// E.g. artifactory+https://artifactory.ea.com/artifactory/eapackages-generic-virtual/packages/icepick/icepick-25.0.0.zip
			// Where artifactorty is the transport scheme and https is the protocol scheme, seperated by a '+'.
			var urlParts = deserialized.url.Split('+');
			if (urlParts.Length > 1)
			{
				deserialized.storage_name = urlParts[0];
				deserialized.url = urlParts[1];
			}
			return deserialized;
		}

		private Task<HttpResponseMessage> GetDownloadUrlResponse(string name, string version)
		{
			string URI = PackageServerApi.GetDownloadUrl(name, version);
			UriBuilder builder = new UriBuilder(URI);
			var query = HttpUtility.ParseQueryString(builder.Query);
			builder.Query = query.ToString();
			HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, builder.ToString());
			return PackageServerClient.SendAsync(request);
		}
	}
}
