/*! ************************************************************************************************/
/*!
    \file   scenario.cpp


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

#include "framework/blaze.h"

#include "EAStdC/EAHashCRC.h"
#include "EASTL/algorithm.h"

#include "framework/connection/outboundhttpservice.h"
#include "framework/database/dbscheduler.h"
#include "framework/util/connectutil.h"
#include "framework/util/random.h"
#include "framework/usersessions/reputationserviceutil.h"
#include "framework/uniqueid/uniqueidmanager.h"

#include "gamemanager/scenario.h"
#include "gamemanager/gamemanagerslaveimpl.h"
#include "gamemanager/matchmaker/matchmakingconfig.h"
#include "gamemanager/gamemanagervalidationutils.h"
#include "gamemanager/gamemanagerhelperutils.h"
#include "gamemanager/externalsessions/externalsessionscommoninfo.h"
#include "gamemanager/externalsessions/externaluserscommoninfo.h"
#include "gamemanager/templateattributes.h"
#include "gamemanager/inputsanitizer.h"

#include "proxycomponent/recommendation/tdf/recommendation.h"
#include "proxycomponent/recommendation/rpc/recommendationslave.h"

// In order to avoid duplicate symbols the lex and yacc files for stats use the prefix option
// to rename some symbols starting with "yy" to "reputation".  Thus we also must redefine yyFlexLexer to
// reputationFlexLexer here to match.
#undef yyFlexLexer
#define yyFlexLexer thisisjustsadFlexLexer
#include "FlexLexer.h"
#include "framework/util/blazelexer.h"

// Forward declaration of main parse method generated by yacc
int blazeparse (BlazeLexer* blaze_flex_lexer);


// matchmaker component includes
#include "gamemanager/rpc/matchmakerslave/startmatchmakinginternal_stub.h"
#include "gamemanager/rpc/matchmakerslave/cancelmatchmakinginternal_stub.h"

#include "component/authentication/authenticationimpl.h"
#include "rpc/gamepackermaster.h"
#include "tdf/gamepacker_server.h"

namespace Blaze
{
namespace GameManager
{
    extern bool bypassNetworkTopologyQosValidation(GameNetworkTopology networkTopology);


    static const char8_t* PROJECT_ID_STR = "projectid";
    static const char8_t* PERSONA_ID_STR = "personaId";
    static const char8_t* LANGUAGE = "en";
    static const char8_t* COUNTRY = "us";
    static const char8_t* RECO_GROUP = "reco_group";
    static const char8_t* RECO_TAG = "reco_tag";

    BlazeRpcError MatchmakingScenarioManager::convertMatchmakingComponentErrorToGameManagerError(const BlazeRpcError &mmRpcError)
    {
        switch(mmRpcError)
        {

        case ERR_OK:
        case ERR_TIMEOUT:
        case ERR_GUEST_SESSION_NOT_ALLOWED:
        case ERR_AUTHORIZATION_REQUIRED:
        case ERR_AUTHENTICATION_REQUIRED:
        case ERR_SYSTEM:
        case ERR_COULDNT_CONNECT:
            return mmRpcError;
        case MATCHMAKER_ERR_INVALID_MATCHMAKING_CRITERIA:
            return GAMEMANAGER_ERR_INVALID_MATCHMAKING_CRITERIA;
        case MATCHMAKER_ERR_UNKNOWN_MATCHMAKING_SESSION_ID:
            return GAMEMANAGER_ERR_UNKNOWN_MATCHMAKING_SESSION_ID;
        case MATCHMAKER_ERR_NOT_MATCHMAKING_SESSION_OWNER:
            return GAMEMANAGER_ERR_NOT_MATCHMAKING_SESSION_OWNER;
        case MATCHMAKER_ERR_MATCHMAKING_NO_JOINABLE_GAMES:
            return GAMEMANAGER_ERR_MATCHMAKING_NO_JOINABLE_GAMES;
        case MATCHMAKER_ERR_MATCHMAKING_USERSESSION_NOT_FOUND:
            return GAMEMANAGER_ERR_MATCHMAKING_USERSESSION_NOT_FOUND;
        case MATCHMAKER_ERR_MATCHMAKING_EXCEEDED_MAX_REQUESTS:
            return GAMEMANAGER_ERR_MATCHMAKING_EXCEEDED_MAX_REQUESTS;
        case MATCHMAKER_ERR_INVALID_GAME_ENTRY_TYPE:
            return GAMEMANAGER_ERR_INVALID_GAME_ENTRY_TYPE;
        case MATCHMAKER_ERR_INVALID_GROUP_ID:
            return GAMEMANAGER_ERR_INVALID_GROUP_ID;
        case MATCHMAKER_ERR_PLAYER_NOT_IN_GROUP:
            return GAMEMANAGER_ERR_PLAYER_NOT_IN_GROUP;
        case MATCHMAKER_ERR_GAME_CAPACITY_TOO_SMALL:
            return GAMEMANAGER_ERR_GAME_CAPACITY_TOO_SMALL;
        case MATCHMAKER_ERR_INVALID_GAME_ENTRY_CRITERIA:
            return GAMEMANAGER_ERR_INVALID_GAME_ENTRY_CRITERIA;
        case MATCHMAKER_ERR_ROLE_NOT_ALLOWED:
            return GAMEMANAGER_ERR_ROLE_NOT_ALLOWED;
        case MATCHMAKER_ERR_SESSION_TEMPLATE_NOT_SUPPORTED:
            return GAMEMANAGER_ERR_SESSION_TEMPLATE_NOT_SUPPORTED;
        case MATCHMAKER_ERR_EXTERNAL_SESSION_ERROR:
            return GAMEMANAGER_ERR_EXTERNAL_SESSION_ERROR;
        case MATCHMAKER_ERR_FILTER_INVALID_VALUE:
            return GAMEMANAGER_ERR_INVALID_MATCHMAKING_CRITERIA;
        default:
            // caught an unrecognized error code, pass it through, but log an error:
            ERR_LOG("[MatchmakingScenarioManager].convertMatchmakingComponentErrorToGameManagerError: Unrecognized error '" << ErrorHelp::getErrorName(mmRpcError) 
                << "' returned from matchmaker component.");
            return mmRpcError;
        }
    }

    MatchmakingScenarioManager::MatchmakingScenarioManager(GameManagerSlaveImpl* componentImpl) :
        mComponent(componentImpl),
        mMatchmakerSlave(nullptr),
        mConfig(nullptr),
        mDedicatedServerOverrideMap(RedisId(GameManager::GameManagerSlave::COMPONENT_INFO.name, "dedicatedServerOverrideMap"))
    {
  
    }

    Blaze::Matchmaker::MatchmakerSlave* MatchmakingScenarioManager::getMatchmakerSlave() const
    { 
        if (mMatchmakerSlave == nullptr)
        {
            mMatchmakerSlave = static_cast<Blaze::Matchmaker::MatchmakerSlave*>(gController->getComponent(Blaze::Matchmaker::MatchmakerSlave::COMPONENT_ID, false, true));
            if (mMatchmakerSlave == nullptr)
            {
                ERR_LOG("[MatchmakingScenarioManager].getMatchmakerSlave: Unable to resolve matchmaker component.");
            }              
        }

        return mMatchmakerSlave; 
    }

    Blaze::GamePacker::GamePackerMaster* MatchmakingScenarioManager::getGamePackerMaster() const
    {
        auto* gamepackerMaster = static_cast<Blaze::GamePacker::GamePackerMaster*>(gController->getComponent(Blaze::GamePacker::GamePackerMaster::COMPONENT_ID, false, true));
        return gamepackerMaster;
    }

    MatchmakingScenarioManager::~MatchmakingScenarioManager()
    {
        Fiber::cancel(mCensusDataFiber, ERR_CANCELED);

        clearScenarios();
        clearScenarioConfigs();
        clearActiveScenarioConfigInfoMap();
        mDedicatedServerOverrideMap.deregisterCollection();
    }

    bool MatchmakingScenarioManager::onActivate()
    {

        // Startup the Census Caching fiber when the server starts. 
        Fiber::CreateParams params;
        params.namedContext = "MatchmakingScenarioManager::getGameManagerCensusDataFiber";
        gFiberManager->scheduleCall<MatchmakingScenarioManager>(this, &MatchmakingScenarioManager::getGameManagerCensusDataFiber, params, &mCensusDataFiber);

        return true;
    }

    void MatchmakingScenarioManager::onResolve()
    {
        mDedicatedServerOverrideMap.registerCollection();
    }

    void MatchmakingScenarioManager::getGameManagerCensusDataFiber()
    {
        // Technically it's inefficient to poll for the data before someone has requested its use, but if we wait until a request comes in we'll always be outdated.
        while (Fiber::sleep(mConfig->getCensusCacheUpdateRate(), "Waiting to update GM Census Data") == ERR_OK)
        {
            if (mComponent == nullptr)
                continue;

            // Get the data from any GameManager
            GameManagerCensusData newData;
            BlazeRpcError err = mComponent->getCensusDataInternal(newData);
            if (err == Blaze::ERR_OK)
            {
                // Not much to do, just take the new data and copy it over
                newData.copyInto(mGMCensusData);
            }
        }
    }

    void MatchmakingScenarioManager::getStatusInfo(ComponentStatus& componentStatus) const
    {

        ComponentStatus::InfoMap &componentInfoMap = componentStatus.getInfo();


        const MatchmakingCensusData& censusData = mGMCensusData.getMatchmakingCensusData();
        for (const auto& curTimeToMatchPingsite : censusData.getEstimatedTimeToMatchPerPingsiteGroup())
        {
            for (const auto& curTimeToMatch : *curTimeToMatchPingsite.second)
            {
                StringBuilder keyStr, valueStr;
                keyStr << "GMTimeToMatchMs_" << curTimeToMatchPingsite.first;
                valueStr << curTimeToMatch.second.getMillis();
                componentInfoMap[keyStr.get()] = valueStr.get();
            }
        }

        for (const auto& curPMR : censusData.getPlayerMatchmakingRatePerPingsiteGroup())
        {
            for (const auto& curGroupPMR : *curPMR.second)
            {
                StringBuilder keyStr, valueStr;
                keyStr << "GMPlayerMatchingRate_" << curPMR.first;
                if (!curGroupPMR.first.empty())         // Add metrics per-group as needed.
                    keyStr << "_" << curGroupPMR.first;
                valueStr << curGroupPMR.second;
                componentInfoMap[keyStr.get()] = valueStr.get();
            }
        }


        for (const auto& curScenarioData : censusData.getScenarioMatchmakingData())
        {
            StringBuilder keyStr, valueStr;
            keyStr << "GMTimeToMatchMs_" << curScenarioData.first << "_global";
            valueStr << curScenarioData.second->getGlobalEstimatedTimeToMatch().getMillis();
            componentInfoMap[keyStr.get()] = valueStr.get();

            keyStr.reset();
            valueStr.reset();
            keyStr << "GMPlayerMatchingRate_" << curScenarioData.first << "_global";
            valueStr << curScenarioData.second->getGlobalPlayerMatchmakingRate();
            componentInfoMap[keyStr.get()] = valueStr.get();

            for (const auto& curTimeToMatchPingsite : curScenarioData.second->getEstimatedTimeToMatchPerPingsiteGroup())
            {
                for (const auto& curTimeToMatch : *curTimeToMatchPingsite.second)
                {
                    keyStr.reset();
                    valueStr.reset();
                    keyStr << "GMTimeToMatchMs_" << curScenarioData.first << "_" << curTimeToMatchPingsite.first;
                    if (!curTimeToMatch.first.empty())         // Add metrics per-group as needed.
                        keyStr << "_" << curTimeToMatch.first;
                    valueStr << curTimeToMatch.second.getMillis();
                    componentInfoMap[keyStr.get()] = valueStr.get();
                }
            }

            for (const auto& curPMR : curScenarioData.second->getPlayerMatchmakingRatePerPingsiteGroup())
            {
                for (const auto& curGroupPMR : *curPMR.second)
                {
                    keyStr.reset();
                    valueStr.reset();
                    keyStr << "GMPlayerMatchingRate_" << curScenarioData.first << "_" << curPMR.first;
                    if (!curGroupPMR.first.empty())         // Add metrics per-group as needed.
                        keyStr << "_" << curGroupPMR.first;
                    valueStr << curGroupPMR.second;
                    componentInfoMap[keyStr.get()] = valueStr.get();
                }
            }
        }
       
    }

    bool MatchmakingScenarioManager::fetchRecoGroup(MatchmakingScenarioConfigInfoRef variantConfig, StartMatchmakingScenarioRequest& request, ScenarioVariantName &recoGroup, eastl::string &tag)
    {
        const char8_t* scenarioName = request.getScenarioName();

        // fetch scenario and tracking tag from Reco service
        Blaze::Recommendation::GetScenarioVariantRequest req;
        Blaze::Recommendation::GetScenarioVariantResponse rep;
        Blaze::Recommendation::RecommendationSlave *recoSlave = (Blaze::Recommendation::RecommendationSlave *)Blaze::gOutboundHttpService->getService(Blaze::Recommendation::RecommendationSlave::COMPONENT_INFO.name);
        if (recoSlave == nullptr)
        {
            ERR_LOG("[MatchmakingScenarioManager].fetchRecoGroup: Reco service is not available.");
            return false;
        }

        req.getPayload().setClientId(mComponent->getConfig().getScenariosConfig().getExperimentManagerTitleId());

        Authentication::AuthenticationSlaveImpl* authComp = static_cast<Authentication::AuthenticationSlaveImpl*>(gController->getComponentManager().getLocalComponentStub(Authentication::AuthenticationSlave::COMPONENT_ID));
        if (authComp == nullptr)
        {
            ERR_LOG("[MatchmakingScenarioManager].fetchRecoGroup: Failed to fetch local authentication component; unable to set project id.");
        }
        else
        {
            req.getPayload().setTid(authComp->getProjectId(gCurrentLocalUserSession->getProductName()));
        }

        // we don't just use the default platform because there may be a HTTP/gRPC session matchmaking on behalf of a console user session
        // and we'll want to use the player's platform for recommendations.
        ClientPlatformType clientPlatform = gController->getDefaultClientPlatform();
        if (gCurrentLocalUserSession != nullptr)
        {
            ClientPlatformType playerPlatform = gCurrentLocalUserSession->getClientPlatform();
            if (playerPlatform != INVALID)
            {
                clientPlatform = playerPlatform;
            }
        }

        req.getPayload().setPlat(UserSessionManager::blazeClientPlatformTypeToPINClientPlatformString(clientPlatform));
        req.getPayload().setLanguage(LANGUAGE);
        req.getPayload().setCountry(COUNTRY);

        req.getPayload().setTidt(PROJECT_ID_STR);

        eastl::string blazeId;
        blazeId.append_sprintf("%" PRIi64, gCurrentLocalUserSession->getUserInfo().getId());
        req.getPayload().getPidm()[PERSONA_ID_STR] = blazeId.c_str();

        ScenarioMap::const_iterator sConfig = mComponent->getConfig().getScenariosConfig().getScenarios().find(scenarioName);
        if (sConfig == mComponent->getConfig().getScenariosConfig().getScenarios().end())
        {
            // Shouldn't get to this point without a valid scenario config...
            return false;
        }

        eastl::string recoType = sConfig->second->getTriggerId();
        if (recoType.empty())
        {
            // If the recoType was missing, don't continue.
            return false;
        }
        req.getPayload().getTriggerids().push_back(recoType.c_str());

        BlazeRpcError err = recoSlave->getScenarioVariant(req, rep);
        if (err == ERR_OK)
        {
            if (!rep.getTriggers().empty())
            {
                // look up recoType again after blocking call in case of reconfigure
                ScenarioMap::const_iterator sConfigItr = mComponent->getConfig().getScenariosConfig().getScenarios().find(scenarioName);
                if (sConfigItr == mComponent->getConfig().getScenariosConfig().getScenarios().end())
                {
                    return false;
                }
                eastl::string triggerId = sConfigItr->second->getTriggerId();
                if (triggerId.empty())
                {
                    // If the recoType was missing, don't continue.
                    return false;
                }

                if (blaze_stricmp(triggerId.c_str(), recoType.c_str()) != 0)
                {
                    ERR_LOG("[MatchmakingScenarioManager].fetchRecoGroup: recoType " << triggerId << " mismatch with older"
                        << recoType << " after calling Reco service, a reconfigure may take place.");
                    return false;
                }
                
                Recommendation::TriggerList::const_iterator it = rep.getTriggers().begin();
                Recommendation::TriggerList::const_iterator end = rep.getTriggers().end();
                for (; it != end; ++it)
                {
                    const Recommendation::Trigger* trigger = *it;
                    if (blaze_stricmp(trigger->getTriggerId(), recoType.c_str()) == 0)
                    {
                        for (auto& actionItem : trigger->getActions())
                        {
                            tag = actionItem->getTrack().getTrackingTag();
                            recoGroup = actionItem->getAction().getExperimentVariant();
                        }                        
                        return true;
                    }
                }
            }
            else
            {
                WARN_LOG("[MatchmakingScenarioManager].fetchRecoGroup: failed to get variant for scenario " << scenarioName << ", response from reco is empty.")
            }
        }
        else
        {
            ERR_LOG("[MatchmakingScenarioManager].fetchRecoGroup: failed to get variant for scenario " << scenarioName
                << " , got error '" << ErrorHelp::getErrorName(err) << "'.");
        }
        return false;
    }

    bool checkSubVariants(const ScenarioVariantNameList& SubVariants, eastl::set<eastl::string>& acceptableVariants, const ScenarioVariantsMap& scenarioVariantsMap, MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo& criteriaCheckInfo)
    {
        bool subVariantPassedCriteria = false;
        ScenarioVariantNameList::const_iterator varItr = SubVariants.begin();
        ScenarioVariantNameList::const_iterator varEnd = SubVariants.end();
        for (; varItr != varEnd; ++varItr)
        {
            ScenarioVariantsMap::const_iterator curVariant = scenarioVariantsMap.find(*varItr);
            if (curVariant != scenarioVariantsMap.end())
            {
                if (curVariant->second->checkCriteria(criteriaCheckInfo))
                {
                    subVariantPassedCriteria = true;

                    // Check if any of the subvariants pass (if so, use them instead)
                    if (!checkSubVariants(curVariant->second->mSubVariants, acceptableVariants, scenarioVariantsMap, criteriaCheckInfo))
                    {
                        // Only add the current variant if none of the subvariants pass:
                        acceptableVariants.insert(varItr->c_str());
                    }
                }
            }
        }

        return subVariantPassedCriteria;
    }

    ClientPlatformType getPlatformFromPJD(const PlayerJoinData& pjd)
    {
        ClientPlatformType platform = INVALID;
        for (auto playerData : pjd.getPlayerDataList())
        {
            ClientPlatformType curPlatform = playerData->getUser().getPlatformInfo().getClientPlatform();
            if (platform == INVALID)
                platform = curPlatform;
            else if (platform != curPlatform)
                platform = common;              // common == multi-platform.  No, there's no 'crossplay enabled' variant selector.
        }
        return platform;
    }

    bool MatchmakingScenarioManager::selectScenarioVariant(MatchmakingScenarioConfigInfoRef variantConfig, StartMatchmakingScenarioRequest& request, 
                                                           ScenarioVariantName &variant, eastl::string &tag, const OverrideUserSessionInfo *overrideUserSessionInfo)
    {
        const char8_t* scenarioName = request.getScenarioName();
        BlazeId blazeId = gCurrentLocalUserSession->getBlazeId();
        ScenarioVariantName recoGroup = "";

        // Scope to indicate that values may be invalid after blocking call 
        {
            ScenarioMap::const_iterator sConfig = mComponent->getConfig().getScenariosConfig().getScenarios().find(scenarioName);
            if (sConfig == mComponent->getConfig().getScenariosConfig().getScenarios().end())
            {
                // Shouldn't get to this point without a valid scenario config...
                return false;
            }

            // 1) Check for User Variant override (overrides everything) 
            UserVariantsMap& userByVariantMap = variantConfig->mUserByVariantMap;
            UserVariantsMap::const_iterator userIt = userByVariantMap.find(blazeId);
            if (userIt != userByVariantMap.end())
            {
                variant = userIt->second.c_str();
                return true;
            }

            if (request.getScenarioAttributes().find(RECO_GROUP) != request.getScenarioAttributes().end())
                recoGroup = request.getScenarioAttributes()[RECO_GROUP]->getValue().asString();
            if (request.getScenarioAttributes().find(RECO_TAG) != request.getScenarioAttributes().end())
                tag = request.getScenarioAttributes()[RECO_TAG]->getValue().asString();
        }

        // 2.5) Lookup the host information:
        // A better way to do this is to perform the lookup outside of this function, and pass it along to the Scenario.
        UserSessionInfo hostInfo;
        {
            // So, I can just call this directly.  The problem is that now I'm doing this lookup twice (once here, and then later in the Scenario itself).
            // I'd like to pass the data onto the Scenario after this, but I'll just take the performance hit for the moment. 
            BlazeRpcError result = ValidationUtils::setJoinUserInfoFromSession(hostInfo, *gCurrentUserSession, &mComponent->getExternalSessionUtilManager());
            if (result != ERR_OK)
                return false;

            // set up override UED
            if (overrideUserSessionInfo != nullptr)
            {
                // this is an all-or-nothing operation, we replace the owner user session info with the contents of the override, if provided.
                overrideUserSessionInfo->getDataMap().copyInto(hostInfo.getDataMap());
                overrideUserSessionInfo->getQosData().copyInto(hostInfo.getQosData());
                hostInfo.setBestPingSiteAlias(overrideUserSessionInfo->getBestPingSiteAlias());
                overrideUserSessionInfo->getLatencyMap().copyInto(hostInfo.getLatencyMap());
                hostInfo.setLatitude(overrideUserSessionInfo->getLatitude());
                hostInfo.setLongitude(overrideUserSessionInfo->getLatitude());
                hostInfo.setCountry(overrideUserSessionInfo->getCountry());
                hostInfo.setTimeZone(overrideUserSessionInfo->getTimeZone());
                hostInfo.setISP(overrideUserSessionInfo->getISP());
            }
        }

        // 3) Perform criteria based lookup if available (if not, attempt to lookup based on recoGroup)
        ScenarioConfigByNameMap::const_iterator scenarioConfigIter = mScenarioConfigByNameMap.find(scenarioName);
        if (scenarioConfigIter == mScenarioConfigByNameMap.end())
        {
            // This indicates that the scenarios were reconfigured and this one was deleted, while we were getting the recoGroup.
            return false;
        }

        // Fill out the info that will be used in the criteria to lookup various pieces of data:
        MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo criteriaCheckInfo;
        criteriaCheckInfo.mHostUserInfo = &hostInfo;
        criteriaCheckInfo.mRecoGroup = &recoGroup;
        criteriaCheckInfo.mRequest = &request;
        criteriaCheckInfo.mPlatform = getPlatformFromPJD(request.getPlayerJoinData());

        // for each (variant) 
        const char* defaultVariant = scenarioConfigIter->second->mScenarioConfig->getDefaultVariant();

        bool criteriaAreUsed = false;
        eastl::set<eastl::string> acceptableVariants;
        const ScenarioVariantsMap& scenarioVariantsMap = scenarioConfigIter->second->mScenarioVariantsMap;
        for (auto& varItr : scenarioVariantsMap)
        {
            // In the case of the default variant, don't need any more checks:
            if (varItr.second->mScenarioVariantConfig == nullptr)
                continue;

            if (varItr.second->mScenarioVariantConfig->getCriteria()[0] != '\0')
                criteriaAreUsed = true;

            // Check if the criteria passes:
            if (!varItr.second->mIsSubVariant && varItr.second->checkCriteria(criteriaCheckInfo))
            {
                // Check if any of the subvariants pass (if so, use them instead)
                if (!checkSubVariants(varItr.second->mSubVariants, acceptableVariants, scenarioVariantsMap, criteriaCheckInfo))
                {
                    // Only add the current variant if none of the subvariants pass:
                    acceptableVariants.insert(varItr.first.c_str());
                }
            }
        }
        
        if (criteriaAreUsed)
        {
            if (acceptableVariants.empty())
            {
                variant = defaultVariant;
            }
            else
            {
                if (acceptableVariants.size() > 1)
                {
                    WARN_LOG("[MatchmakingScenarioManager].selectScenarioVariant: Multiple variant were valid for scenario: " << request.getScenarioName() << ".  Choose variant " << variant.c_str() << ".");
                }
                variant = acceptableVariants.begin()->c_str();
            }
        }
        else
        {
            variant = defaultVariant;
        }


        // If somehow the variants we found are no longer valid, switch back to the default one:
        ScenarioVariantsMap::const_iterator it = scenarioVariantsMap.find(variant.c_str());
        if (it == scenarioVariantsMap.end())
        {
            WARN_LOG("[MatchmakingScenarioManager].selectScenarioVariant: Variant " << variant << " does not exist in scenario: " << request.getScenarioName() << ", switch to use default.");
            variant = defaultVariant;
        }

        // Final check for Default's subvariants:
        // Only if no acceptable values were found, and we defaulted.  If a variant passed criteria but was missing, we don't do this.
        if (acceptableVariants.empty())
        {
            acceptableVariants.clear();
            it = scenarioConfigIter->second->mScenarioVariantsMap.find(variant.c_str());
            if (it != scenarioVariantsMap.end())
            {
                // Check if any of the subvariants pass (if so, use them instead)
                checkSubVariants(it->second->mSubVariants, acceptableVariants, scenarioVariantsMap, criteriaCheckInfo);
            }

            if (!acceptableVariants.empty())
            {
                if (acceptableVariants.size() > 1)
                {
                    WARN_LOG("[MatchmakingScenarioManager].selectScenarioVariant: Multiple variant were valid for scenario: " << request.getScenarioName() << ".  Choose variant " << variant.c_str() << ".");
                }
                variant = acceptableVariants.begin()->c_str();
            }
        }

        return true;
    }    

    void disableFiltersHack(CallerProperties& callerProps, const PropertyManager& propertyManager, StartMatchmakingInternalRequest& request)
    {
        // Hacks to selectively disable some global filters until we get an actual way to disable filters. 

        if (callerProps.dedicatedServerOverrideGameId() == GameManager::INVALID_GAME_ID)
        {
            request.getMatchmakingFilters().getMatchmakingFilterCriteriaMap().erase(GameManager::PropertyManager::FILTER_NAME_DSO);
        }

       // NOTE: for setFilter/rangeFilter, optionalValue should not be needed because optional=true when the set/range is empty is sufficient to disable the filter
       // PACKER_TODO: need to figure out how to make bitwise filter optional as well...
        {
            // handle conditional game protocol version string
            EA::TDF::GenericTdfType gpvs;
            bool found = propertyManager.convertProperty(callerProps, "caller.gameProtocolVersionString", gpvs);
            if (!found || gpvs.get().asString() == GameManager::GAME_PROTOCOL_VERSION_MATCH_ANY)
            {
                TRACE_LOG("[Scenario].disableFiltersHack: no game protocol version string provided (or match any) => remove 'gpvsFilter' filter.");
                request.getMatchmakingFilters().getMatchmakingFilterCriteriaMap().erase(GameManager::PropertyManager::FILTER_NAME_GPVS);
            }
        }
    }

    void fillInSubsessionCallerProperties(CallerProperties& callerProps, StartMatchmakingInternalRequest& request)
    {
    }

    void lookupDedicatedServerOverrideGameId(CallerProperties& callerProps, BlazeId playerId, StartMatchmakingInternalRequest& request, const RedisKeyMap<GameManager::PlayerId, GameManager::GameId>& redisMap)
    {
        // handle conditional dedicated server override
        GameManager::GameId gameId = GameManager::INVALID_GAME_ID;
        //if (request.getRequest().getGameCreationData().getNetworkTopology() == CLIENT_SERVER_DEDICATED)
        {
            // NOTE: This is a Redis lookup command:
            RedisError rc = redisMap.find(playerId, gameId);
            if (rc == REDIS_ERR_OK)
            {
                TRACE_LOG("[GamePackerMasterImpl].initializeAggregateProperties: found dedicated server override gameId(" << gameId << ") override for userId(" << playerId << ") => use 'dsoFilter'");
            }
            else if (rc == REDIS_ERR_NOT_FOUND)
            {
                TRACE_LOG("[GamePackerMasterImpl].initializeAggregateProperties: no dedicated server override for userId(" << playerId << ")");
            }
            else
            {
                ERR_LOG("[GamePackerMasterImpl].initializeAggregateProperties: failed to find dedicated server override for userId(" << playerId << "). Redis error: " << RedisErrorHelper::getName(rc));
            }
        }
//        else
        //{
            //TRACE_LOG("[GamePackerMasterImpl].initializeAggregateProperties: network topology(" << request.getRequest().getGameCreationData().getNetworkTopology() << ") does not use dedicated server override => disable 'dsoFilter'");
        //}

        callerProps.dedicatedServerOverrideGameId() = gameId; // PACKER_TODO: we probably don't need the property if the filter is disabled...
    }

    void fillInCallerProperties(CallerProperties& callerProps, const UserJoinInfoList& userJoinInfo)
    {
        // This function only sets properties that are known at the start of matchmaking (after loading all players)
        // No old matchmaking rules logic is used.

        // Properties not set: 
        // bestPingSite(), pingSiteLatencies()   - Used old MM pingsite rule
        // faction()                             - Set per-subsession
        // dedicatedServerOverrideGameId()       - Requires DB hit
        
        // member list & player count
        callerProps.addPlayersSourceData(userJoinInfo);
    }

    void fillInGlobalProperties(PropertyDataSources& properties)
    {
        // Fill in Global DataSources like:  qos.pingsiteLatencies  (If they ever get added)
    }


    BlazeRpcError MatchmakingScenarioManager::createScenario(StartMatchmakingScenarioRequest& request, StartMatchmakingScenarioResponse& response,
        MatchmakingCriteriaError& critErr, const InetAddress& callerNetworkAddress, const OverrideUserSessionInfo *overrideUserSessionInfo /*= nullptr*/)
    {
        response.setScenarioId(INVALID_SCENARIO_ID);

        StringBuilder buf;

        // If the scenario name is found, initialize a scenario:
        ScenarioConfigByNameMap::const_iterator curScenarioConfigIter = mScenarioConfigByNameMap.find(request.getScenarioName());
        if (curScenarioConfigIter == mScenarioConfigByNameMap.end())
        {
            critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Client requested non-existent scenario: " << request.getScenarioName() << ".").get());
            ERR_LOG(buf.get());
            return GAMEMANAGER_ERR_INVALID_SCENARIO_NAME;
        }

        // use the MatchmakingScenarioConfigInfoRef so we don't have to worry about the iterator being invalidated
        MatchmakingScenarioConfigInfoRef curScenarioConfig = curScenarioConfigIter->second;

        // Override any attributes in the source config with values from the config defined attributes:
        for (const auto& curOverride : curScenarioConfig->mScenarioConfig->getAttributeOverrides())
        {
            const auto& curAttrName = curOverride.first;
            const auto& curAttrValue = curOverride.second;

            if (curAttrValue->isValid())
            {
                auto itr = request.getScenarioAttributes().find(curAttrName);
                if (itr != request.getScenarioAttributes().end())
                {
                    WARN_LOG("[MatchmakingScenarioManager].createScenario: AttributeOverrides in "<< request.getScenarioName() <<" overrides value sent from the client (" << curAttrName << ").  Consider removing value on client.");
                }
                else
                {
                    TRACE_LOG("[MatchmakingScenarioManager].createScenario: AttributeOverrides in " << request.getScenarioName() << " filling in value (" << curAttrName << ").");
                    request.getScenarioAttributes()[curAttrName] = request.getScenarioAttributes().allocate_element();
                }
                request.getScenarioAttributes()[curAttrName]->set(curAttrValue->get());
            }
            else
            {
                if (request.getScenarioAttributes().erase(curAttrName) != 0)
                {
                    WARN_LOG("[MatchmakingScenarioManager].createScenario: AttributeOverrides in " << request.getScenarioName() << " clears value sent from the client (" << curAttrName << ").  Consider removing value on client.");
                }
            }
        }


        // IF THIS IS GROUP MATCHMAKING THIS CAN BE A BLOCKING CALL - All Reconfigurable data Must be REACQUIRED.
        UserIdentificationList groupUserIds;
        const UserGroupId& userGroupId = request.getPlayerJoinData().getGroupId();
        if (userGroupId == EA::TDF::OBJECT_ID_INVALID && request.getPlayerJoinData().getPlayerDataList().empty())
        {
            // If there was no group (and no loose players), just set the current user session, and assume it's a normal matchmaking attempt: 
            ValidationUtils::insertHostSessionToPlayerJoinData(request.getPlayerJoinData(), gCurrentLocalUserSession);
        }
        else
        {
            // validate group existence & membership
            BlazeRpcError blazeErr = ValidationUtils::loadGroupUsersIntoPlayerJoinData(request.getPlayerJoinData(), groupUserIds, *mComponent);
            if (blazeErr != Blaze::ERR_OK)
            {
                if (blazeErr == GAMEMANAGER_ERR_PLAYER_NOT_IN_GROUP)
                {
                    // Indirect matchmaking sessions don't need to add their players to the group:
                    if (!gUserSessionManager->isSessionAuthorized(UserSession::getCurrentUserSessionId(), Blaze::Authorization::PERMISSION_START_INDIRECT_MATCHMAKING_SESSION))
                        return blazeErr;
                }
                else
                {
                    return blazeErr;
                }
            }
        }


        // Gather the properties that will be accessible:
        CallerProperties callerProperties;
        {
            // Fill in any global properties (qos.pingsiteAliasList)
            fillInGlobalProperties(callerProperties);

            bool indirectMatchmakingAttempt = true;
            for (auto& playerData : request.getPlayerJoinData().getPlayerDataList())
            {
                if (playerData->getUser().getBlazeId() == UserSession::getCurrentUserBlazeId())
                {
                    indirectMatchmakingAttempt = false;
                    break;
                }
            }

            // PACKER_TODO:  This is redundant, since the same calcs are being done in the submaster request code. 
            // We need to get the players even earlier than before, since this information must be known to the properties that will be used by the sanitizer:
            PlayerJoinData playerJoinData = request.getPlayerJoinData();
            UserJoinInfoList userInfos;
            BlazeRpcError blazeErr = ValidationUtils::userIdListToJoiningInfoList(request.getPlayerJoinData(), groupUserIds, userInfos, &mComponent->getExternalSessionUtilManager(), indirectMatchmakingAttempt);
            if (blazeErr != Blaze::ERR_OK)
            {
                return blazeErr;
            }

            fillInCallerProperties(callerProperties, userInfos);
        }

        // Convert the caller properties into the format that we actually want: 
        // We can't do a full conversion yet, because we don't have the variant selected.  
        // Instead, we just convert the values that are used by the Input sanitizers:

        // Apply Input Sanitizer logic: 
        {
            PropertyNameList sanitizerPropertiesUsed;
            const auto& inputSanitizerConfig = getComponent().getConfig().getInputSanitizers();

            // Add Global & Local Sanitizers:
            SanitizerNameList sanitizersToApply = mConfig->getGlobalInputSanitizers();
            sanitizersToApply.insert(sanitizersToApply.end(), curScenarioConfig->mScenarioConfig->getInputSanitizers().begin(), curScenarioConfig->mScenarioConfig->getInputSanitizers().end());

            // Convert the Properties into the expected format:  (In a sane world, this would just gather the values from their source based on the propertyNames.)
            BlazeRpcError blazeErr = getSanitizersPropertiesUsed(inputSanitizerConfig, sanitizersToApply, sanitizerPropertiesUsed);
            if (blazeErr != ERR_OK)
            {
                critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Input Sanitizers failed to gather Properties for scenario " << request.getScenarioName() << ".").get());
                ERR_LOG(buf.get());
                return blazeErr;
            }
            mPropertyManager.convertProperties(callerProperties, sanitizerPropertiesUsed, callerProperties.mSanitizedProperties);

            // Apply the sanitizers:
            const char8_t* failingSanitizer = "";
            blazeErr = applySanitizers(inputSanitizerConfig, sanitizersToApply, request.getScenarioAttributes(), callerProperties.mSanitizedProperties, failingSanitizer);
            if (blazeErr != ERR_OK)
            {
                critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Input Sanitizer " << failingSanitizer << " failed for scenario " << request.getScenarioName() << ".").get());
                ERR_LOG(buf.get());
                return blazeErr;
            }
        }

        // If multiple variants are defined in this scenario, A/B testing is enabled
        ScenarioVariantsMap& scenarioVariantsMap = curScenarioConfig->mScenarioVariantsMap;   
        eastl::string tag;

        // BLOCKING CALL - All Reconfigurable data Must be REACQUIRED.
        if (!mComponent->getExternalDataManager().fetchAndPopulateExternalData(request))
        {
            WARN_LOG("[MatchmakingScenarioManager].createScenario: Failed to fetch and populate external data in scenario(" << request.getScenarioName() << ")");
        }
        
        ScenarioVariantName variant = "";
        if (!selectScenarioVariant(curScenarioConfig, request, variant, tag, overrideUserSessionInfo))
        {
            return ERR_SYSTEM;
        }

        // Create the Scenario based on the selected variant:
        ScenarioVariantsMap::const_iterator it = scenarioVariantsMap.find(variant.c_str());
        if (it == scenarioVariantsMap.end())
        {
            critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Default variant " << variant << " does not exist in scenario: " << request.getScenarioName() << ".").get());
            ERR_LOG(buf.get());
            return GAMEMANAGER_ERR_INVALID_SCENARIO_VARIANT;
        }

        // Handle multiple Matchmaking initiator in a user group
        // the externalDataManager call is blocking, so the iterator could be invalidated
        MatchmakingScenarioVariantConfigInfoRef variantConfig = it->second;

        bool isPackerScenario = false;
        for (auto& curInfo : variantConfig->mScenarioSessionConfigList)
        {
            auto* subSessionConfig = curInfo->mSubSessionConfig;
            auto* createGameTemplateName = subSessionConfig->getCreateGameTemplate();
            auto& createGameTempatesCfgMap = getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates();
            auto itr = createGameTempatesCfgMap.find(createGameTemplateName);
            if (itr == createGameTempatesCfgMap.end())
                continue;
            if (!itr->second->getPackerConfig().getQualityFactors().empty())
            {
                isPackerScenario = true;
                break;
            }
        }

        uint64_t uniqueIdBase = 0;
        auto error = gUniqueIdManager->getId(GameManagerSlave::COMPONENT_ID, GAMEMANAGER_IDTYPE_SCENARIO, uniqueIdBase, SLIVER_KEY_BASE_MIN);
        if (error != Blaze::ERR_OK)
        {
            critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: couldn't get scenario Id, got error '" << ErrorHelp::getErrorName(error) << "'.").get());
            ERR_LOG(buf.get());
            return error;
        }

        SliverId commonSliverId = INVALID_SLIVER_ID; // Common sliver id used for all packer sub-sessions common to a single scenario id because currently they are created via individual requests but must go to the same instance.
        
        if (isPackerScenario)
        {
            auto* component = getGamePackerMaster();
            if (component == nullptr)
            {
                critErr.setErrMessage((buf << "[MatchmakingScenario].createScenario: No packer master!").get());
                ERR_LOG(buf.get());
                return ERR_COMPONENT_NOT_FOUND;
            }

            commonSliverId = component->getSliverIdByLoad();
            if (commonSliverId == INVALID_SLIVER_ID)
            {
                critErr.setErrMessage((buf << "[MatchmakingScenario].createScenario: Failed to obtain a sliver by load.").get());
                ERR_LOG(buf.get());
                return ERR_SYSTEM;
            }
        }
        
        // Needed to ensure uniqueness because legacy mm scenarios and packer scenarios both share id space
        MatchmakingScenarioId scenarioId = BuildSliverKey(commonSliverId, uniqueIdBase);

        // {{ PACKER_TODO: Figure out if we still need this legacy sharding for scenarios, seems like we shouldn't
        if (!isPackerScenario)
        {
            //set the id so it routes to us in a legacy(non sliver) sharding mode
            auto localInstanceId = gController->getInstanceId();
            scenarioId = BuildInstanceKey64(localInstanceId, scenarioId); 
        }
        // }}
        
        response.setScenarioId(scenarioId);

        UserGroupId groupId = request.getPlayerJoinData().getGroupId();
        if (groupId != EA::TDF::OBJECT_ID_INVALID && groupUserIds.size() > 0 && groupId.type != ENTITY_TYPE_CONN_GROUP)
        {
            TimeValue totalDur = variantConfig->getTotalDurationFromConfig() + mComponent->getConfig().getMatchmakerSettings().getQosValidationTimeout()
                + mComponent->getConfig().getGameSession().getScenarioTTLBufferTime();
            
            char8_t userGroupStr[256];
            groupId.toString(userGroupStr, sizeof(userGroupStr));
            uint32_t limit = mComponent->getConfig().getGameSession().getMaxActiveSessionsPerUserGroup();
            RedisResponsePtr resp;
            RedisError redisError = mComponent->testAndUpdateScenarioConcurrencyLimit(groupId, scenarioId, limit, totalDur, resp);
            if (redisError != REDIS_ERR_OK)
            {
                critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Error when adding Matchmaking Scenario Id(" << scenarioId << ") to redis for userGroupId(" << userGroupStr
                    << ") with TTL(" << totalDur.getSec() << "s) with err(" << RedisErrorHelper::getName(redisError) << ").").get());
                ERR_LOG(buf.get());
                return ERR_SYSTEM;
            }
            else if (resp->isArray())
            {
                uint32_t arraySize = resp->getArraySize();
                if (arraySize >= limit)
                {
                    buf << "Matchmaking scenario request for UserGroup(" << userGroupStr << ") exceeds limit(" << limit << "), the concurrent running matchmaking ids are: ";
                    for (uint32_t i = 0; i < arraySize; ++i)
                    {
                        const RedisResponse& element = resp->getArrayElement(i);
                        if (element.isString())
                        {
                            buf << element.getString() << ", ";
                        }
                    }
                    buf.trim(2);
                    critErr.setErrMessage(buf.get());
                    return GAMEMANAGER_ERR_MATCHMAKING_USER_GROUP_EXCEEDED_MAX_REQUESTS;
                }
            }
            else if (!resp->isInteger())
            {
                critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Unexpected redis result when adding Matchmaking Scenario Id(" << scenarioId << ") to redis for userGroupId(" << userGroupStr
                    << ") with TTL(" << totalDur.getSec() << "s), response type is not integer.").get());
                ERR_LOG(buf.get());
                return ERR_SYSTEM;
            }
            else if (resp->getInteger() != 1)
            {
                critErr.setErrMessage((buf << "[MatchmakingScenarioManager].createScenario: Unexpected redis result when adding Matchmaking Scenario Id(" << scenarioId << ") to redis for userGroupId(" << userGroupStr
                    << ") with TTL(" << totalDur.getSec() << "s), response is integer, but value is: " << resp->getInteger()).get());
                ERR_LOG(buf.get());
                return ERR_SYSTEM;
            }
        }
        
        MatchmakingScenario* newScenario = BLAZE_NEW MatchmakingScenario(scenarioId, request, variantConfig, *this, overrideUserSessionInfo);  // Non-Blocking
        mScenarioByIdMap[scenarioId] = newScenario;

        if (!tag.empty())
        {
            newScenario->setTrackingTag(tag);
            response.setRecoTrackingTag(tag.c_str());
        }

        response.setScenarioVariant(variant);
        
        // We hold a Ref here, so that the Scenario won't be deleted while we're calling setupAndStartSessions:  (Could happen if a one subsession scenario completed instantly.)
        MatchmakingScenarioRef safetyRefScenario;
        safetyRefScenario = newScenario;

        // Setup the Scenario's sessions (potential criteria errors here - Will trigger scenario to cancel):
        return newScenario->setupAndStartSessions(response, critErr, callerNetworkAddress, groupUserIds, callerProperties);    // Blocking
    }

    BlazeRpcError MatchmakingScenarioManager::getScenarioVariants(const Blaze::GameManager::GetScenarioVariantsRequest& request, Blaze::GameManager::GetScenarioVariantsResponse& response)
    {
        ScenarioConfigByNameMap::const_iterator curScenarioConfig = mScenarioConfigByNameMap.find(request.getScenarioName());
        if (curScenarioConfig == mScenarioConfigByNameMap.end())
        {
            TRACE_LOG("[MatchmakingScenarioManager].getScenarioVariants() - Client requested non-existent scenario: " << request.getScenarioName() << ".");
            return GAMEMANAGER_ERR_INVALID_SCENARIO_NAME;
        }

        // populate variants map
        const ScenarioConfig* scenarioConfig = curScenarioConfig->second->mScenarioConfig;
        if (scenarioConfig != nullptr)
        {
            scenarioConfig->getVariants().copyInto(response.getVariants());
        }        

        UserVariantsMap& userVariantsMap = curScenarioConfig->second->mUserByVariantMap;
        userVariantsMap.copyInto(response.getUserVariants());
        response.setDefaultVariant(curScenarioConfig->second->mScenarioConfig->getDefaultVariant());

        return ERR_OK;
    }

    BlazeRpcError MatchmakingScenarioManager::userScenarioVariantUpdate(const Blaze::GameManager::SetUserScenarioVariantRequest& data)
    {
        ScenarioConfigByNameMap::const_iterator curScenarioConfig = mScenarioConfigByNameMap.find(data.getScenarioName());
        if (curScenarioConfig == mScenarioConfigByNameMap.end())
        {
            ERR_LOG("[MatchmakingScenarioManager].userScenarioVariantUpdate() - Client requested non-existent scenario: " << data.getScenarioName() << ".");
            return GAMEMANAGER_ERR_INVALID_SCENARIO_NAME;
        }
                
        const char8_t* variant = data.getScenarioVariant();
        ScenarioVariantsMap& scenarioVariantsMap = curScenarioConfig->second->mScenarioVariantsMap;
        if (scenarioVariantsMap.find(variant) == scenarioVariantsMap.end())
        {
            ERR_LOG("[MatchmakingScenarioManager].userScenarioVariantUpdate() - Client requested non-existent variant: " << variant << ".");
            return GAMEMANAGER_ERR_INVALID_SCENARIO_VARIANT;
        }
        else
        {
            UserVariantsMap& userVariantsMap = curScenarioConfig->second->mUserByVariantMap;
            userVariantsMap[data.getBlazeId()] = data.getScenarioVariant();
        }

        return ERR_OK;
    }

    BlazeRpcError MatchmakingScenarioManager::clearUserScenarioVariant(const Blaze::GameManager::ClearUserScenarioVariantRequest& data)
    {
        ScenarioConfigByNameMap::const_iterator curScenarioConfig = mScenarioConfigByNameMap.find(data.getScenarioName());
        if (curScenarioConfig == mScenarioConfigByNameMap.end())
        {
            TRACE_LOG("[MatchmakingScenarioManager].clearUserScenarioVariant() - Client requested non-existent scenario: " << data.getScenarioName() << ".");
            return GAMEMANAGER_ERR_INVALID_SCENARIO_NAME;
        }

        BlazeId blazeId = data.getBlazeId();
        UserVariantsMap& userVariantsMap = curScenarioConfig->second->mUserByVariantMap;     

        if (blazeId == INVALID_BLAZE_ID)
        {
            userVariantsMap.clear();
        }
        else
        {
            if (userVariantsMap.find(blazeId) == userVariantsMap.end())
            {
                ERR_LOG("[MatchmakingScenarioManager].clearUserScenarioVariant() - User with BlazeId " << blazeId << " not found.");
                return GAMEMANAGER_ERR_USER_NOT_FOUND;
            }
            else
            {
                userVariantsMap.erase(blazeId);
            }
        }

        return ERR_OK;
    }

    void MatchmakingScenarioManager::onUserScenarioVariantUpdate(const Blaze::GameManager::SetUserScenarioVariantRequest& data)
    {
        userScenarioVariantUpdate(data);
    }

    void MatchmakingScenarioManager::onClearUserScenarioVariant(const Blaze::GameManager::ClearUserScenarioVariantRequest& data)
    {
        clearUserScenarioVariant(data);
    }    

    void MatchmakingScenarioManager::onUserSessionExtinction(UserSessionId userSessionId)
    {
        // Lookup all the scenarios owned by the user session, and cancel them. 
        UserSessionMasterPtr userSession = gUserSessionMaster->getLocalSession(userSessionId);
        if (userSession != nullptr)
        {
            UserSessionMMStateDataPtr stateData = userSession->getCustomStateTdf<UserSessionMMStateData>(GameManagerSlave::COMPONENT_ID);
            if (stateData != nullptr)
            {
                MatchmakingScenarioDataByIdMap& scenarioDataMap = stateData->getMatchmakingScenarioDataByIdMap();

                // Make a copy of the current sessionSet in case something happens (a scenario is removed) that invalidates the existing one. 
                MatchmakingScenarioIdList sessionList;
                sessionList.reserve(scenarioDataMap.size());
                for (MatchmakingScenarioDataByIdMap::iterator it = scenarioDataMap.begin(), end = scenarioDataMap.end(); it != end; ++it)
                {
                    sessionList.push_back(it->first);
                }

                if (!sessionList.empty())
                {
                    TRACE_LOG("[MatchmakingScenarioManager].onUserSessionExtinction(): Canceling "<< sessionList.size() << " scenarios owned by extinct user session " << userSessionId << ".");
                }

                MatchmakingScenarioIdList::iterator curIter = sessionList.begin();
                MatchmakingScenarioIdList::iterator endIter = sessionList.end();
                for (; curIter != endIter; ++curIter)
                {
                    cancelScenario(*curIter, true);
                }
            }
        }
    }

    void MatchmakingScenarioManager::onLocalUserSessionImported(const UserSessionMaster& userSession)
    {
        UserSessionMMStateDataPtr stateData = userSession.getCustomStateTdf<UserSessionMMStateData>(GameManagerSlave::COMPONENT_ID);
        if (stateData != nullptr)
        {
            MatchmakingScenarioDataByIdMap& scenarioDataMap = stateData->getMatchmakingScenarioDataByIdMap();
            for (MatchmakingScenarioDataByIdMap::iterator it = scenarioDataMap.begin(), end = scenarioDataMap.end(); it != end; ++it)
            {
                MatchmakingScenarioDataPtr scenarioData = it->second;

                // If the scenario name is found, initialize a scenario:
                ScenarioConfigByNameMap::const_iterator curScenarioConfig =  mScenarioConfigByNameMap.find(scenarioData->getScenarioRequest().getScenarioName());
                if (curScenarioConfig == mScenarioConfigByNameMap.end())
                {
                    ERR_LOG("[MatchmakingScenarioManager].onLocalUserSessionImported() - Client requested non-existent scenario: " << scenarioData->getScenarioRequest().getScenarioName() << ".");
                    continue;
                }

                // Create the Scenario: 
                ScenarioVariantsMap& scenarioVariantsMap = curScenarioConfig->second->mScenarioVariantsMap;
                ScenarioVariantsMap::const_iterator variantItr = scenarioVariantsMap.find(scenarioData->getScenarioVariant());
                if (variantItr == scenarioVariantsMap.end())
                {
                    ERR_LOG("[MatchmakingScenarioManager].onLocalUserSessionImported() - Client requested non-existent scenario variant " << scenarioData->getScenarioVariant()
                        << " on scenario: " << scenarioData->getScenarioRequest().getScenarioName() << ".");
                    continue;
                }
                MatchmakingScenario* newScenario = BLAZE_NEW MatchmakingScenario(scenarioData, variantItr->second, *this);  // Non-Blocking
                mScenarioByIdMap[it->first] = newScenario;
            }
        }
    }

    void MatchmakingScenarioManager::onLocalUserSessionExported(const UserSessionMaster& userSession)
    {
        UserSessionMMStateDataPtr stateData = userSession.getCustomStateTdf<UserSessionMMStateData>(GameManagerSlave::COMPONENT_ID);
        if (stateData != nullptr)
        {
            MatchmakingScenarioDataByIdMap& scenarioDataMap = stateData->getMatchmakingScenarioDataByIdMap();
            for (MatchmakingScenarioDataByIdMap::iterator it = scenarioDataMap.begin(), end = scenarioDataMap.end(); it != end; ++it)
            {
                mScenarioByIdMap.erase(it->first);
            }
        }
    }

    BlazeRpcError MatchmakingScenarioManager::validateMaxActiveMMScenarios(UserSessionId userSessionId) const
    {
        if (mComponent->getConfig().getMatchmakerSettings().getMaxActiveSessionsPerUserSession() > 0)
        {
            UserSessionMasterPtr userSession = gUserSessionMaster->getLocalSession(userSessionId);
            if (userSession != nullptr)
            {
                UserSessionMMStateDataPtr stateData = userSession->getCustomStateTdf<UserSessionMMStateData>(GameManagerSlave::COMPONENT_ID);
                if (stateData != nullptr)
                {
                    size_t sessionCount = stateData->getMatchmakingScenarioDataByIdMap().size();
                    if (sessionCount >= mComponent->getConfig().getMatchmakerSettings().getMaxActiveSessionsPerUserSession())
                    {
                        if (sessionCount > 0)
                        {
                            const auto& scenarioDataItr = stateData->getMatchmakingScenarioDataByIdMap().begin();
                            const auto scenarioId = scenarioDataItr->first;
                            const auto& scenarioData = *(scenarioDataItr->second);
                            WARN_LOG("[MatchmakingScenarioManager].validateMaxActiveMMScenarios: Too many scenarios (" << sessionCount << ") are active for user session id(" << userSessionId << "), max allowed is (" << mComponent->getConfig().getMatchmakerSettings().getMaxActiveSessionsPerUserSession() << "), Error=" << ErrorHelp::getErrorName(GAMEMANAGER_ERR_MATCHMAKING_EXCEEDED_MAX_REQUESTS) << ". Example scenario(" << scenarioId << " -> " << scenarioData << ")");
                        }
                        else
                        {
                            WARN_LOG("[MatchmakingScenarioManager].validateMaxActiveMMScenarios: Too many scenarios (" << sessionCount << ") are active for user session id(" << userSessionId << "), max allowed is (" << mComponent->getConfig().getMatchmakerSettings().getMaxActiveSessionsPerUserSession() << "), Error=" << ErrorHelp::getErrorName(GAMEMANAGER_ERR_MATCHMAKING_EXCEEDED_MAX_REQUESTS));
                        }
                        return GAMEMANAGER_ERR_MATCHMAKING_EXCEEDED_MAX_REQUESTS;
                    }
                }
            }
        }

        return ERR_OK;
    }

    BlazeRpcError MatchmakingScenarioManager::cancelScenario(MatchmakingScenarioId scenarioId, bool skipUserSessionCheck)
    {
        ScenarioByIdMap::iterator iter = mScenarioByIdMap.find(scenarioId);
        if (iter == mScenarioByIdMap.end())
        {
            TRACE_LOG("[MatchmakingScenarioManager].cancelScenario(): Cannot find scenario id ("<< scenarioId << ") to be canceled.");
            return GAMEMANAGER_ERR_INVALID_SCENARIO_ID;
        }


        MatchmakingScenarioRef scenario = iter->second;

        // check permission (scenario owner), and cancel the sessions
        if (skipUserSessionCheck == false && UserSession::getCurrentUserSessionId() != scenario->getHostUserSessionId())
        {
            // error: current context doesn't own the matchmaking scenario they're trying to cancel...
            TRACE_LOG("[MatchmakingScenarioManager].cancelScenario(): Unable to cancel matchmaking scenario " << scenarioId << 
                      " - scenario owned by another user ( attempted user: " << UserSession::getCurrentUserSessionId() << ", owning user: " << scenario->getHostUserSessionId() << ")...");
            return Blaze::GAMEMANAGER_ERR_NOT_SCENARIO_OWNER;
        }
        return scenario->cancelSessions();
    }

    bool MatchmakingScenarioManager::validatePreconfig(const GameManagerServerPreconfig& config) const
    {
        StartMatchmakingRequest validationRequest;

        // Verify that everything in the rule_attributes file is valid: 
        EA::TDF::TdfFactory& tdfFactory = EA::TDF::TdfFactory::get();
        ScenarioRuleAttributeMap::const_iterator curRule = config.getRuleAttributeMap().begin();
        ScenarioRuleAttributeMap::const_iterator endRule = config.getRuleAttributeMap().end();
        for (; curRule != endRule; ++curRule)
        {
            const RuleName& ruleName = curRule->first;
            ScenarioRuleAttributeTdfMemberMapping::const_iterator curAttr = curRule->second->begin();
            ScenarioRuleAttributeTdfMemberMapping::const_iterator endAttr = curRule->second->end();
            for (; curAttr != endAttr; ++curAttr)
            {
                // Check that the value can be parsed by the Tdf system: 
                EA::TDF::TdfGenericReference criteriaRef(validationRequest.getCriteriaData());
                EA::TDF::TdfGenericReference criteriaAttr;
                const char8_t* tdfName = curAttr->second->getName();
                if (!tdfFactory.getTdfMemberReference(criteriaRef, tdfName, criteriaAttr))
                {
                    ERR_LOG("[MatchmakingScenarioManager].validatePreconfig: Unable to get TdfMemberReference for rule "<< ruleName.c_str() << ", attribute " << curAttr->first.c_str() << 
                            ", member location: '" << tdfName <<"'.  Check if this value has changed its name or location. " );
                    return false;
                }
            }
        }

        return true;
    }

    bool MatchmakingScenarioManager::preconfigure(const GameManagerServerPreconfig& config)
    {
        // Load the rule attributes, associate them in EATDF:
        EA::TDF::TdfFactory& tdfFactory = EA::TDF::TdfFactory::get();
        ScenarioRuleAttributeMap::const_iterator curRule = config.getRuleAttributeMap().begin();
        ScenarioRuleAttributeMap::const_iterator endRule = config.getRuleAttributeMap().end();
        for (; curRule != endRule; ++curRule)
        {
            const auto* ruleName = curRule->first.c_str();
            ScenarioRuleAttributeTdfMemberMapping::const_iterator curAttr = curRule->second->begin();
            ScenarioRuleAttributeTdfMemberMapping::const_iterator endAttr = curRule->second->end();
            for (; curAttr != endAttr; ++curAttr)
            {
                const auto* attrName = curAttr->first.c_str();
                const auto* tdfName = curAttr->second->getName();
                if (!tdfFactory.registerTypeName(ruleName, attrName, tdfName))
                {
                    // Failures: 
                    // Improper ruleName format (only alpha-numeric, existing rule name?)
                    // Improper attrName format (only alpha-numeric)
                    // unable to lookup data in criteria tdf
                    ERR_LOG("[MatchmakingScenarioManager].preconfigure: Failed to register type name for Rule: " << ruleName <<
                        ", attr: " << attrName << ", tdf name: " << tdfName);
                    return false;
                }
                TRACE_LOG("[MatchmakingScenarioManager].preconfigure: Registered type name- Rule: " << ruleName << 
                          ", attr: " << attrName << ", tdf name: " << tdfName );
            }
        }

        return true;
    }

    bool MatchmakingScenarioManager::configure(const GameManagerServerConfig& configTdf)
    {
        // Map the mm settings (these can change, so preconfiging them wouldn't really work)
        MatchmakingServerConfig mmSettings = configTdf.getMatchmakerSettings();
        if (Matchmaker::MatchmakingConfig::registerMultiInputValues(mmSettings, mComponent->getPreconfig().getRuleAttributeMap()) == false)
        {
            WARN_LOG("[MatchmakingScenarioManager].configure(): Failed to register multi input values for config.");
            return false;
        }

        if (!mPropertyManager.onConfigure(configTdf.getProperties()))
        {
            WARN_LOG("[MatchmakingScenarioManager].configure(): PropertyManager is unable to configure correctly.");
            return false;
        }

        const ScenariosConfig& config = configTdf.getScenariosConfig();

        // iterate over the scenarios, and get them loaded:
        ScenarioMap::const_iterator curScenario = config.getScenarios().begin();
        ScenarioMap::const_iterator endScenario = config.getScenarios().end();
        for (; curScenario != endScenario; ++curScenario)
        {
            MatchmakingScenarioConfigInfo* newScenarioConfig = BLAZE_NEW MatchmakingScenarioConfigInfo(curScenario->first, this);
            mScenarioConfigByNameMap[curScenario->first] = newScenarioConfig;
            if (!newScenarioConfig->configure(config))
            {
                WARN_LOG("[MatchmakingScenarioManager].configure(): Failed to load config for scenario ("<< curScenario->first << ").");
                return false;
            }
        }

        if (!hashScenarioConfiguration(configTdf))
        {
            WARN_LOG("[MatchmakingScenarioManager].configure(): Failed to hash config for scenario ("<< curScenario->first << ").");
        }

        populateTemplateToPropertyListMap(configTdf);
        mConfig = &config;
        return true;
    }

    EA::TDF::TdfHashValue MatchmakingScenarioManager::getScenarioRuleAttributesHash(ScenarioRuleAttributes& scenarioRuleAttributes)
    {
        EA::TDF::TdfHashValue hash = EA::StdC::kCRC32InitialValue;
        ScenarioRuleAttributes::const_iterator itr = scenarioRuleAttributes.begin();
        ScenarioRuleAttributes::const_iterator end = scenarioRuleAttributes.end();
        for (; itr != end; ++itr)
        {
            ExpandedRuleName expandedRuleName = itr->first;
            ScenarioAttributeMapping::const_iterator scenarioAttrMapItr = itr->second->begin();
            ScenarioAttributeMapping::const_iterator scenarioAttrMapEnd = itr->second->end();
            for (; scenarioAttrMapItr != scenarioAttrMapEnd ; ++scenarioAttrMapItr)
            {
                ScenarioAttributeTdfMemberName scenarioAttributeTdfMemberName = scenarioAttrMapItr->first;
                EA::TDF::TdfHashValue scenarioAttrMapItrHash = 0;
                scenarioAttrMapItr->second->computeHash(scenarioAttrMapItrHash);

                hash = EA::StdC::CRC32(scenarioAttributeTdfMemberName.c_str(), strlen(scenarioAttributeTdfMemberName), hash, false);
                hash = EA::StdC::CRC32(&scenarioAttrMapItrHash, sizeof(scenarioAttrMapItrHash), hash, false);
            }
            hash = EA::StdC::CRC32(expandedRuleName.c_str(), strlen(expandedRuleName), hash, false);
        }
        return hash;
    }

    bool MatchmakingScenarioManager::hashScenarioConfiguration(const GameManagerServerConfig& config)
    {
        eastl::vector<ScenarioConfigInfo*>* updateScenarioConfigInfoDBList = BLAZE_NEW eastl::vector<ScenarioConfigInfo*>();

        EA::TDF::TdfHashValue globalRuleHash = EA::StdC::kCRC32InitialValue;
        ScenarioRuleMap::const_iterator globalRuleMapItr = config.getScenariosConfig().getGlobalRules().begin();
        ScenarioRuleMap::const_iterator globalRuleMapEnd = config.getScenariosConfig().getGlobalRules().end();
        for (; globalRuleMapItr != globalRuleMapEnd; ++globalRuleMapItr)
        {
            ScenarioCustomRuleName scenarioCustomRuleName = globalRuleMapItr->first;
            EA::TDF::TdfHashValue ruleAttrHash = getScenarioRuleAttributesHash(*globalRuleMapItr->second);
            
            globalRuleHash = EA::StdC::CRC32(&ruleAttrHash, sizeof(ruleAttrHash), globalRuleHash, false);
            globalRuleHash = EA::StdC::CRC32(scenarioCustomRuleName.c_str(), strlen(scenarioCustomRuleName), globalRuleHash, false);
        }

        const ScenarioRuleMap& scenarioRuleMap = config.getScenariosConfig().getScenarioRuleMap();

        const ScenarioMap& scenarioMap = config.getScenariosConfig().getScenarios();
        ScenarioMap::const_iterator itr = scenarioMap.begin();
        ScenarioMap::const_iterator end = scenarioMap.end();
        for (; itr != end; ++itr)
        {
            const ScenarioName scenarioName = itr->first;
            const ScenarioConfig& scenarioConfig = *(itr->second);

            EA::TDF::TdfHashValue scenarioHash = EA::StdC::kCRC32InitialValue;

            int64_t scenarioDuration = scenarioConfig.getTotalDuration().getMicroSeconds();
            scenarioHash = EA::StdC::CRC32(&scenarioDuration, sizeof(scenarioDuration), scenarioHash, false);
            scenarioHash = EA::StdC::CRC32(scenarioName.c_str(), strlen(scenarioName), scenarioHash, false);
            scenarioHash = EA::StdC::CRC32(&globalRuleHash, sizeof(globalRuleHash), scenarioHash, true);

            if (scenarioConfig.getVariants().empty())
            {
                // Use all subSessions for this scenario
                const SubSessionConfigMap& subSessionConfigMap = scenarioConfig.getSubSessions();
                SubSessionConfigMap::const_iterator subSessionConfigMapItr = subSessionConfigMap.begin();
                SubSessionConfigMap::const_iterator subSessionConfigMapEnd = subSessionConfigMap.end();
                for (; subSessionConfigMapItr != subSessionConfigMapEnd; ++subSessionConfigMapItr)
                {
                    computeScenarioHash(subSessionConfigMapItr->first, subSessionConfigMapItr->second, scenarioRuleMap, scenarioHash);
                }
                updateScenarioConfigInfo(scenarioName, scenarioHash, scenarioConfig.getDefaultVariant(), updateScenarioConfigInfoDBList);
            }
            else
            {
                EA::TDF::TdfHashValue cacheHash = scenarioHash;

                // compute hash for each variant
                VariantsMap::const_iterator curSession = scenarioConfig.getVariants().begin();
                VariantsMap::const_iterator endSession = scenarioConfig.getVariants().end();
                for (; curSession != endSession; ++curSession)
                {
                    scenarioHash = cacheHash; // reset hash for each variant
                    const ScenarioVariantName& scenarioVariant = curSession->first;

                    SubSessionNameList& subSessionNameList = curSession->second->getSubSession();
                    SubSessionNameList::const_iterator curSubSession = subSessionNameList.begin();
                    SubSessionNameList::const_iterator endSubSession = subSessionNameList.end();
                    for (; curSubSession != endSubSession; ++curSubSession)
                    {
                        SubSessionName subsession = *curSubSession;
                        SubSessionConfigMap::const_iterator it = scenarioConfig.getSubSessions().find(subsession);
                        if (it != scenarioConfig.getSubSessions().end())
                        {
                            computeScenarioHash(it->first, it->second, scenarioRuleMap, scenarioHash);
                        }
                    }
                    updateScenarioConfigInfo(scenarioName, scenarioHash, scenarioVariant, updateScenarioConfigInfoDBList);
                }
            }
        }

        if (!updateScenarioConfigInfoDBList->empty())
        {
            Fiber::CreateParams params;
            params.namedContext = "MatchmakingScenarioManager::updateScenarioConfigInDB";
            gFiberManager->scheduleCall<MatchmakingScenarioManager, eastl::vector<ScenarioConfigInfo*>*>(this, &MatchmakingScenarioManager::updateScenarioConfigInDB, updateScenarioConfigInfoDBList, params);
        }
        else
        {
            delete updateScenarioConfigInfoDBList;
        }

        return true;
    }
    
    bool MatchmakingScenarioManager::loadScenarioConfigInfoFromDB()
    {
        DbConnPtr conn = gDbScheduler->getLagFreeReadConnPtr(mComponent->getDbId());
        if (conn == nullptr)
        {
            WARN_LOG("[MatchmakingScenarioManager].loadScenarioConfigInfoFromDB: Unable obtain database connection to fetch scenario configurations from db");
            return false;
        }

        QueryPtr query = DB_NEW_QUERY_PTR(conn);
        query->append("SELECT `scenario_hash`, `scenario_name`, `scenario_variant`, `scenario_version`, UNIX_TIMESTAMP(`configuration_time`) FROM `gm_scenario_configuration`");
        DbResultPtr dbResult;
        BlazeRpcError error = conn->executeQuery(query, dbResult);
        if (error == DB_ERR_OK)
        {
            for (DbResult::const_iterator itr = dbResult->begin(), end = dbResult->end(); itr != end; ++itr)
            {
                const DbRow* row = *itr;
                ScenarioConfigInfo* scenarioConfigInfo = BLAZE_NEW ScenarioConfigInfo;
                scenarioConfigInfo->mHash = row->getUInt((uint32_t)0);
                scenarioConfigInfo->mName = row->getString(1);
                scenarioConfigInfo->mVariant = row->getString(2);
                scenarioConfigInfo->mVersion = row->getUInt(3);
                scenarioConfigInfo->mConfigurationTime = row->getUInt64(4);

                ScenarioConfigInfoByVariantMap& configInfoByVariantMap = mActiveScenarioConfigInfoMapByName[scenarioConfigInfo->mName];
                configInfoByVariantMap[scenarioConfigInfo->mVariant] = scenarioConfigInfo;
            }
        }
        else
        {
            WARN_LOG("[MatchmakingScenarioManager].loadScenarioConfigInfoFromDB: Failed to fetch scenario config information from gm_scenario_configuration, " << getDbErrorString(error));
            return false;
        }
        return true;
    }

    void MatchmakingScenarioManager::updateScenarioConfigInDB(eastl::vector<ScenarioConfigInfo*>* updateScenarioConfigList)
    {
        DbConnPtr conn = gDbScheduler->getConnPtr(mComponent->getDbId());
        if (conn == nullptr)
        {
            WARN_LOG("[MatchmakingScenarioManager].updateScenarioConfigInDB: Unable obtain database connection to update scenario/variant version & hash value");
            delete updateScenarioConfigList;
            return;
        }

        QueryPtr query = DB_NEW_QUERY_PTR(conn);
        query->append("INSERT INTO `gm_scenario_configuration` (`scenario_hash`, `scenario_name`, `scenario_variant`, `scenario_version`) VALUES ");
        eastl::vector<ScenarioConfigInfo*>::const_iterator itr = updateScenarioConfigList->begin();
        eastl::vector<ScenarioConfigInfo*>::const_iterator endItr = updateScenarioConfigList->end();
        for (; itr != endItr; ++itr)
        {
            ScenarioConfigInfo* scenarioConfigInfo = *itr;
            if (scenarioConfigInfo != nullptr)
            {
                const char8_t* scenarioVariantStr = scenarioConfigInfo->mVariant;
                query->append("($u, '$s', '$s', $d),", scenarioConfigInfo->mHash, scenarioConfigInfo->mName.c_str(), scenarioVariantStr, scenarioConfigInfo->mVersion);
            }
        }
        query->trim(1); //trim the trailing comma

        query->append(" ON DUPLICATE KEY UPDATE `scenario_hash`=VALUES(scenario_hash), `scenario_version`=VALUES(scenario_version);");

        BlazeRpcError result;
        if ((result = conn->executeQuery(query)) != ERR_OK)
        {
            FATAL_LOG("[MatchmakingScenarioManager].updateScenarioConfigInDB: Failed to update gm_scenario_configuration, " << getDbErrorString(result));
            delete updateScenarioConfigList;
            return;
        }

        DB_QUERY_RESET(query);

        // Load DB to ensure the correct configuration_time is set for updated scenarios
        query->append("SELECT `scenario_name`, `scenario_variant`, UNIX_TIMESTAMP(`configuration_time`) FROM `gm_scenario_configuration` WHERE `scenario_name` IN (");
        itr = updateScenarioConfigList->begin();
        for (; itr != endItr; ++itr)
        {
            ScenarioConfigInfo* scenarioConfigInfo = *itr;
            if (scenarioConfigInfo != nullptr)
            {
                query->append("'$s',", scenarioConfigInfo->mName.c_str());
            }
        }
        query->trim(1);
        query->append(")");

        query->append(" AND `scenario_variant` IN (");
        itr = updateScenarioConfigList->begin();
        for (; itr != endItr; ++itr)
        {
            ScenarioConfigInfo* scenarioConfigInfo = *itr;
            if (scenarioConfigInfo != nullptr)
            {
                const char8_t* scenarioVariantStr = scenarioConfigInfo->mVariant;
                query->append("'$s',", scenarioVariantStr);
            }
        }
        query->trim(1);
        query->append(");");

        DbResultPtr dbResult;
        BlazeRpcError error = conn->executeQuery(query, dbResult);
        if (error == DB_ERR_OK)
        {
            for (DbResult::const_iterator resultItr = dbResult->begin(), resultEnd = dbResult->end(); resultItr != resultEnd; ++resultItr)
            {
                const DbRow* row = *resultItr;
                
                const ScenarioName& scenarioName = row->getString((uint32_t)0);
                ScenarioVariantsConfigInfoByNameMap::iterator it = mActiveScenarioConfigInfoMapByName.find(scenarioName);
                if (it != mActiveScenarioConfigInfoMapByName.end())
                {
                    ScenarioConfigInfoByVariantMap& configInfoByVariantMap = it->second;
                    const char8_t* variantName = row->getString(1);
                    ScenarioConfigInfo* scenarioConfigInfo = configInfoByVariantMap[variantName]; // get configInfo based on variant
                    if (scenarioConfigInfo != nullptr)
                    {
                        scenarioConfigInfo->mConfigurationTime = row->getUInt64(2); //update timestamp
                    }
                }

                ScenarioConfigByNameMap::iterator scenarioConfigItr = mScenarioConfigByNameMap.find(scenarioName);
                if (scenarioConfigItr != mScenarioConfigByNameMap.end())
                {
                    scenarioConfigItr->second->mConfigurationTimestamp = row->getUInt64(2);
                }
            }
        }
        else
        {
            WARN_LOG("[MatchmakingScenarioManager].updateScenarioConfigInDB: Failed to fetch scenario config information from gm_scenario_configuration, " << getDbErrorString(error));
        }

        delete updateScenarioConfigList;
    }

    void MatchmakingScenarioManager::computeScenarioHash(const SubSessionName& subSessionName, const SubSessionConfig* subSessionConfig, const ScenarioRuleMap &scenarioRuleMap, EA::TDF::TdfHashValue& scenarioHash)
    {
        EA::TDF::TdfHashValue subSessionHash;
        subSessionConfig->computeHash(subSessionHash);

        ScenarioRuleNameList::const_iterator subSessionRuleNameListItr = subSessionConfig->getRulesList().begin();
        ScenarioRuleNameList::const_iterator subSessionRuleNameListEnd = subSessionConfig->getRulesList().end();
        for (; subSessionRuleNameListItr != subSessionRuleNameListEnd; ++subSessionRuleNameListItr)
        {
            const ScenarioCustomRuleName* scenarioCustomRuleName = subSessionRuleNameListItr;
            ScenarioRuleMap::const_iterator it = scenarioRuleMap.find(*scenarioCustomRuleName);
            if (it != scenarioRuleMap.end())
            {
                EA::TDF::TdfHashValue ruleHash = getScenarioRuleAttributesHash(*it->second);

                subSessionHash = EA::StdC::CRC32(&ruleHash, sizeof(ruleHash), subSessionHash, false);
                subSessionHash = EA::StdC::CRC32(scenarioCustomRuleName->c_str(), strlen(*scenarioCustomRuleName), subSessionHash, false);
            }
        }

        subSessionHash = EA::StdC::CRC32(subSessionName.c_str(), strlen(subSessionName), subSessionHash, false);
        scenarioHash = EA::StdC::CRC32(&subSessionHash, sizeof(subSessionHash), scenarioHash, false);
    }

    void MatchmakingScenarioManager::updateScenarioConfigInfo(const ScenarioName& scenarioName, EA::TDF::TdfHashValue& scenarioHash, const ScenarioVariantName& variant, eastl::vector<ScenarioConfigInfo*>* updateScenarioConfigInfoDBList)
    {
        ScenarioConfigInfo* scenarioConfigInfo = nullptr;
        ScenarioVariantsConfigInfoByNameMap::iterator scenarioConfigInfoMapByNameItr = mActiveScenarioConfigInfoMapByName.find(scenarioName);
        if (scenarioConfigInfoMapByNameItr != mActiveScenarioConfigInfoMapByName.end())
        {
            ScenarioConfigInfoByVariantMap& configInfoByVariantMap = scenarioConfigInfoMapByNameItr->second;
            ScenarioConfigInfoByVariantMap::iterator configInfoByVariantItr = configInfoByVariantMap.find(variant);
            // Scenario exists, check if hash is different.
            if (configInfoByVariantItr != configInfoByVariantMap.end())
            {
                scenarioConfigInfo = configInfoByVariantItr->second;
                if (scenarioConfigInfo->mHash != scenarioHash)
                {
                    // New hash, update version number - add to list of scenarios to update in db.
                    scenarioConfigInfo->mHash = scenarioHash;
                    scenarioConfigInfo->mVersion++;

                    updateScenarioConfigInfoDBList->push_back(scenarioConfigInfo);
                }
            }
            else
            {
                // New variant, set up scenarioConfigInfo
                scenarioConfigInfo = BLAZE_NEW ScenarioConfigInfo();
                scenarioConfigInfo->mHash = scenarioHash;
                scenarioConfigInfo->mName = scenarioName;
                scenarioConfigInfo->mVariant = variant;

                scenarioConfigInfo->mVersion = 1;

                configInfoByVariantMap[variant] = scenarioConfigInfo;

                updateScenarioConfigInfoDBList->push_back(scenarioConfigInfo);
            }
        }
        else
        {
            // New Scenario, set up scenarioConfigInfo
            scenarioConfigInfo = BLAZE_NEW ScenarioConfigInfo();
            scenarioConfigInfo->mHash = scenarioHash;
            scenarioConfigInfo->mName = scenarioName;
            scenarioConfigInfo->mVariant = variant;

            scenarioConfigInfo->mVersion = 1;

            ScenarioConfigInfoByVariantMap& configInfoByVariantMap = mActiveScenarioConfigInfoMapByName[scenarioName];
            configInfoByVariantMap[variant] = scenarioConfigInfo;

            // add to list of new scenarios, to be added to db.
            updateScenarioConfigInfoDBList->push_back(scenarioConfigInfo);
        }

        // On (re)configure, scenarioConfigByNameMap is cleared. Set the hash, variant and version again for future scenarioMatchmakeRequests.
        ScenarioConfigByNameMap::iterator scenarioConfigByNameMapItr = mScenarioConfigByNameMap.find(scenarioName);
        if (scenarioConfigByNameMapItr != mScenarioConfigByNameMap.end() && scenarioConfigInfo != nullptr)
        {
            ScenarioVariantsMap &scenarioVariantsMap = scenarioConfigByNameMapItr->second->mScenarioVariantsMap;
            ScenarioVariantsMap::const_iterator itr = scenarioVariantsMap.find(scenarioConfigInfo->mVariant);
            if (itr != scenarioVariantsMap.end())
            {
                itr->second->mScenarioHash = scenarioConfigInfo->mHash;
                itr->second->mVariant = scenarioConfigInfo->mVariant;
                itr->second->mVersion = scenarioConfigInfo->mVersion;
            }            
            scenarioConfigByNameMapItr->second->mConfigurationTimestamp = scenarioConfigInfo->mConfigurationTime.getMicroSeconds();
        }
    }

    bool MatchmakingScenarioManager::reconfigure(const GameManagerServerConfig& configTdf)
    {
        TRACE_LOG("[MatchmakingScenarioManager] Starting MatchmakingScenarioManager reconfiguration.");

        // Cancel all existing sessions (if the session is in the process of being created, this would wait for the session to finish before canceling it).
        cancelAllScenarios();
        clearScenarioConfigs();

        if (!configure(configTdf))
        {
            ERR_LOG("[MatchmakingScenarioManager] Unexpected problem with MatchmakingScenarioManager::configure (should always return true). Please update your configuration settings and retry.");
            return false;
        }
        
        populateTemplateToPropertyListMap(configTdf);

        TRACE_LOG("[MatchmakingScenarioManager] MatchmakingScenarioManager reconfiguration complete");
        return true;
    }

    void MatchmakingScenarioManager::checkForAttrNameOverlap(eastl::map<eastl::string, const EA::TDF::TypeDescription*>& scenarioAttrToTypeDesc, const char* attrName, const EA::TDF::TypeDescription* typeDesc, ConfigureValidationErrors& validationErrors) const
    {
        if (attrName == nullptr || attrName[0] == '\0')
        {
            return;
        }

        eastl::map<eastl::string, const EA::TDF::TypeDescription*>::const_iterator iter = scenarioAttrToTypeDesc.find(attrName);
        if (iter == scenarioAttrToTypeDesc.end())
        {
            scenarioAttrToTypeDesc[attrName] = typeDesc;
        }
        else
        {
            if (!EA::TDF::TdfGenericConst::canTypesConvert(*iter->second, *typeDesc))
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].checkForAttrNameOverlap: Mismatch found for attribute: " << attrName << 
                        ", (" << typeDesc->getFullName()  << " vs. " << iter->second->getFullName() << ".  Types cannot be converted between each other.";
                validationErrors.getErrorMessages().push_back(strBuilder.get());
            }
        }
    }

    bool isVariantRecursive(const ScenarioVariantName& variantName, eastl::set<eastl::string>& variantRecursionSet, const ScenarioConfig& scenarioConfig)
    {
        VariantsMap::const_iterator varIter = scenarioConfig.getVariants().find(variantName);
        if (scenarioConfig.getVariants().find(variantName) == scenarioConfig.getVariants().end())
        {
            // Variant was in the recursion set, so we had already seen it. (Indicates recursion)
            return true;
        }

        const ScenarioVariantConfig* variantDetail = varIter->second;
        ScenarioVariantNameList::const_iterator curSubVariant = variantDetail->getSubVariantOf().begin();
        ScenarioVariantNameList::const_iterator endSubVariant = variantDetail->getSubVariantOf().end();
        for (; curSubVariant != endSubVariant; ++curSubVariant)
        {
            // Check that they exist:
            if (isVariantRecursive(*curSubVariant, variantRecursionSet, scenarioConfig))
            {
                return true;
            }
        }

        variantRecursionSet.insert(variantName.c_str());
        return false;
    }

    bool MatchmakingScenarioManager::validateConfig(const ScenariosConfig& config, const MatchmakingServerConfig& mmSettings, const GameManagerServerConfig* gameManagerConfigTdf, const GameManagerServerPreconfig& preConfig, ConfigureValidationErrors& validationErrors) const
    {
        // Clear the existing multi associations, and add the new ones
        if (Matchmaker::MatchmakingConfig::registerMultiInputValues(mmSettings, preConfig.getRuleAttributeMap()) == false)
        {
            WARN_LOG("[MatchmakingScenarioManager].validateConfig: Failed to register multi input values for config.");
            return false;
        }

        if (gameManagerConfigTdf != nullptr) // can only validate on game manager, but thats enough
        {
            mPropertyManager.validateConfig(gameManagerConfigTdf->getProperties(), validationErrors);

            // Validate that all global filters are known:
            for (auto& filter : config.getGlobalFilters())
            {
                if (gameManagerConfigTdf->getFilters().find(filter) == gameManagerConfigTdf->getFilters().end())
                {
                    StringBuilder strBuilder;
                    strBuilder << "[MatchmakingScenarioManager].validateConfig:  Global filter(" << filter << "), does not exist in filter map.  Check the config files and ensure all global filters match valid filter names.";
                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                }
            }

            // Validate filter map  (*Requires Properties to be known)  (PACKER_TODO - Why is Scenarios doing this?  Shouldn't this be handled by the PropertyFilter itself?)
            mPropertyManager.validateFilters(gameManagerConfigTdf->getProperties(), gameManagerConfigTdf->getFilters(), validationErrors);
        }

        AttributeToTypeDescMap scenarioAttrToTypeDesc;

        // For cg template
        CreateGameRequest templateValidationRequest;
        EA::TDF::TdfGenericReference cgReqRef(templateValidationRequest);

        StartMatchmakingRequest validationRequest;
        EA::TDF::TdfGenericReference matchmakingReqRef(validationRequest);
        EA::TDF::TdfGenericReference criteriaRef(validationRequest.getCriteriaData());
        EA::TDF::TdfGenericReference createGameRef(validationRequest.getGameCreationData());

        // Validate that all Global InputSanitizers exist:
        if (gameManagerConfigTdf != nullptr) // can only validate on game manager, but thats enough
        {
            for (const auto& curSanitizerName : config.getGlobalInputSanitizers())
            {
                if (gameManagerConfigTdf->getInputSanitizers().find(curSanitizerName) == gameManagerConfigTdf->getInputSanitizers().end())
                {
                    // Scenario references input sanitizer that doesn't exist:
                    StringBuilder strBuilder;
                    strBuilder << "[MatchmakingScenarioManager].validateConfig: Attempting to use unknown Sanitizer: " << curSanitizerName << "  in Scenario Global InputSanitizers list.";
                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                }
            }
        }

        // Validate Global Attributes:
        {
            StringBuilder errorPrefix;
            errorPrefix << "[MatchmakingScenarioManager].validateConfig: Global attribute: "; 
            validateTemplateAttributeMapping(config.getGlobalAttributes(), scenarioAttrToTypeDesc, matchmakingReqRef, validationErrors, errorPrefix.get());
        }
        
        // Validate the Global Rules:
        typedef eastl::map<eastl::string, eastl::set<eastl::string> > RuleAttributeMappingHelper;
        RuleAttributeMappingHelper globalRuleAttributesStuff;

        ScenarioRuleMap::const_iterator curGlobalRule = config.getGlobalRules().begin();
        ScenarioRuleMap::const_iterator endGlobalRule = config.getGlobalRules().end();
        for (; curGlobalRule != endGlobalRule; ++curGlobalRule)
        {        
            if (curGlobalRule->second->size() != 1)
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].validateConfig: Global Rule: " << curGlobalRule->first.c_str() << 
                       ", has " << ( (curGlobalRule->second->size() > 1) ? "more" : "less") <<
                       " than one rule set currently. Custom rule name mappings must be one-to-one with the rule.";
                validationErrors.getErrorMessages().push_back(strBuilder.get());
            }

            ScenarioRuleAttributes::const_iterator ruleAttributes = curGlobalRule->second->begin();

            {
                StringBuilder errorPrefix;
                errorPrefix << "[MatchmakingScenarioManager].validateConfig: Global Rule: " << curGlobalRule->first.c_str() << " ";
                validateTemplateAttributeMapping(*ruleAttributes->second, scenarioAttrToTypeDesc, criteriaRef, validationErrors, errorPrefix.get(), ruleAttributes->first.c_str());
            }


            ScenarioAttributeMapping::const_iterator curRuleAttr = ruleAttributes->second->begin();
            ScenarioAttributeMapping::const_iterator endRuleAttr = ruleAttributes->second->end();
            for (; curRuleAttr != endRuleAttr; ++curRuleAttr)
            {
                globalRuleAttributesStuff[ruleAttributes->first.c_str()].insert(curRuleAttr->first.c_str());
            }
        }

        // Validate the Non-global Rules:
        ScenarioRuleMap::const_iterator curScenarioRule = config.getScenarioRuleMap().begin();
        ScenarioRuleMap::const_iterator endScenarioRule = config.getScenarioRuleMap().end();
        for (; curScenarioRule != endScenarioRule; ++curScenarioRule)
        {        
            if (curScenarioRule->second->size() != 1)
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].validateConfig: Rule: " << curScenarioRule->first.c_str() << 
                       ", has " << ( (curScenarioRule->second->size() > 1) ? "more" : "less") <<
                       " than one rule set currently. Custom rule name mappings must be one-to-one with the rule.";
                validationErrors.getErrorMessages().push_back(strBuilder.get());
                continue;
            }

            ScenarioRuleAttributes::const_iterator ruleAttributes = curScenarioRule->second->begin();
            {
                StringBuilder errorPrefix;
                errorPrefix << "[MatchmakingScenarioManager].validateConfig: Rule: " << curScenarioRule->first.c_str() << " ";
                validateTemplateAttributeMapping(*ruleAttributes->second, scenarioAttrToTypeDesc, criteriaRef, validationErrors, errorPrefix.get(), ruleAttributes->first.c_str());
            }
        }

        // Validate the Scenarios themselves: 
        ScenarioMap::const_iterator curScenario = config.getScenarios().begin();
        ScenarioMap::const_iterator endScenario = config.getScenarios().end();
        for (; curScenario != endScenario; ++curScenario)
        {
            const ScenarioName& scenarioName = curScenario->first;
            const ScenarioConfig& scenarioConfig = *curScenario->second;
            // Check that the scenario's name isn't too long:
            if (scenarioName.length() >= MAX_SCENARIONAME_LEN)
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario Name: " << scenarioName.c_str() << 
                        " has length (" << scenarioName.length() << ") >= MAX_SCENARIONAME_LEN (" << MAX_SCENARIONAME_LEN <<
                        "). This would prevent the scenario from being used, because the string name couldn't be sent from the client.";
                validationErrors.getErrorMessages().push_back(strBuilder.get());
                continue;
            }

            if (scenarioConfig.getSubSessions().size() < 1)
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << 
                       ", has less than one subsession set currently. Scenario must have at least one subsession currently.";
                validationErrors.getErrorMessages().push_back(strBuilder.get());
                continue;
            }

            if (scenarioConfig.getSubSessions().size() > config.getScenarioSubsessionLimit())
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << 
                       ", has more subsessions than the current subsession limit. ( " << 
                    scenarioConfig.getSubSessions().size()<<" > "<<config.getScenarioSubsessionLimit()<<
                       " ) If needed, increase the subsession limit (ScenarioSubsessionLimit).";
                validationErrors.getErrorMessages().push_back(strBuilder.get());
                continue;
            }

            // Validate that all InputSanitizers exist:
            if (gameManagerConfigTdf != nullptr) // can only validate on game manager, but thats enough
            {
                for (const auto& curSanitizerName : scenarioConfig.getInputSanitizers())
                {
                    if (gameManagerConfigTdf->getInputSanitizers().find(curSanitizerName) == gameManagerConfigTdf->getInputSanitizers().end())
                    {
                        // Scenario references input sanitizer that doesn't exist:
                        StringBuilder strBuilder;
                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Attempting to use unknown Input Sanitizer: " << curSanitizerName << "  in Scenario " << scenarioName.c_str();
                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                    }
                }
            }

            // Check scenario variants
            bool foundCriteria = false;
            const char8_t* defaultVariant = scenarioConfig.getDefaultVariant();
            if (!scenarioConfig.getVariants().empty())
            {
                VariantsMap::const_iterator varItr = scenarioConfig.getVariants().begin();
                VariantsMap::const_iterator varEnd = scenarioConfig.getVariants().end();
                if (scenarioConfig.getVariants().find(defaultVariant) == varEnd)
                {
                    StringBuilder strBuilder;
                    strBuilder << "[MatchmakingScenarioManager].validateConfig: Default variant " << defaultVariant << " does not exist in variants map from scenario " << scenarioName.c_str();
                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                    return false;
                }

                for (; varItr != varEnd; ++varItr)
                {
                    const ScenarioVariantName& scenarioVariantName = varItr->first;
                    const ScenarioVariantConfig* variantDetail = varItr->second;
                    const SubSessionNameList& subSessionNameList = variantDetail->getSubSession();
                    if (subSessionNameList.empty())
                    {
                        StringBuilder strBuilder;
                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Subsession list is empty in Variant " << scenarioVariantName << " , scenario " << scenarioName.c_str();
                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                        continue;
                    }

                    SubSessionNameList::const_iterator curSession = subSessionNameList.begin();
                    SubSessionNameList::const_iterator endSession = subSessionNameList.end();
                    for (; curSession != endSession; ++curSession)
                    {
                        SubSessionName subsession = *curSession;
                        SubSessionConfigMap::const_iterator it = scenarioConfig.getSubSessions().find(subsession);
                        if (it == scenarioConfig.getSubSessions().end())
                        {
                            StringBuilder strBuilder;
                            strBuilder << "[MatchmakingScenarioManager].validateConfig: Subsession " << subsession << " listed in variant " << scenarioVariantName << " is not defined in scenario " << scenarioName.c_str();
                            validationErrors.getErrorMessages().push_back(strBuilder.get());
                            continue;
                        }
                    }

                    // Subvariants need to have criteria specified:
                    if (!variantDetail->getSubVariantOf().empty() && variantDetail->getCriteria()[0] == '\0')
                    {
                        StringBuilder strBuilder;
                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Variant " << scenarioVariantName << " in scenario " << scenarioName.c_str() << " is a subvariant, but is missing criteria data";
                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                        continue;
                    }

                    if (variantDetail->getCriteria()[0] != '\0')
                    {
                        foundCriteria = true;
                    }

                    // Verify that my sub-variants exist, and aren't recursive:  (If they don't it doesn't actually hurt anything, but it's probably a typo so we just return an error)
                    eastl::set<eastl::string> variantRecursionSet;
                    variantRecursionSet.insert(scenarioVariantName.c_str());
                    
                    ScenarioVariantNameList::const_iterator curSubVariant = variantDetail->getSubVariantOf().begin();
                    ScenarioVariantNameList::const_iterator endSubVariant = variantDetail->getSubVariantOf().end();
                    for (; curSubVariant != endSubVariant; ++curSubVariant)
                    {
                        // Check that they exist:
                        if (scenarioConfig.getVariants().find(*curSubVariant) == scenarioConfig.getVariants().end())
                        {
                            StringBuilder strBuilder;
                            strBuilder << "[MatchmakingScenarioManager].validateConfig: SubVariant named " << curSubVariant->c_str() << " parent to variant " << scenarioVariantName << " does not exist for scenario " << scenarioName.c_str();
                            validationErrors.getErrorMessages().push_back(strBuilder.get());
                            return false;
                        }

                        if (isVariantRecursive(*curSubVariant, variantRecursionSet, scenarioConfig))
                        {
                            StringBuilder strBuilder;
                            strBuilder << "[MatchmakingScenarioManager].validateConfig: SubVariant named " << curSubVariant->c_str() << " parent to variant " << scenarioVariantName << " causes a recursion in scenario " << scenarioName.c_str();
                            validationErrors.getErrorMessages().push_back(strBuilder.get());
                            return false;
                        }
                    }
                }
            }
            if (!foundCriteria && scenarioConfig.getTriggerId()[0] != '\0')
            {
                StringBuilder strBuilder;
                strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario " << scenarioName.c_str() << " has a Trigger Id set, but is missing variant criteria that would use the lookup data.  Add something like criteria = \"testGroup == 'testA'\" to one of your variants. (Where testA is the return from the EM system.)" ;
                validationErrors.getErrorMessages().push_back(strBuilder.get());
                return false;
            }

            TimeValue totalDur = scenarioConfig.getTotalDuration();

            SubSessionConfigMap::const_iterator curSubSession = scenarioConfig.getSubSessions().begin();
            SubSessionConfigMap::const_iterator endSubSession = scenarioConfig.getSubSessions().end();
            for (; curSubSession != endSubSession; ++curSubSession)
            {
                const SubSessionName& subSessionName = curSubSession->first;
                TimeValue startTime = curSubSession->second->getSessionStartTime();
                TimeValue endTime = curSubSession->second->getSessionEndTime();
                
                if (subSessionName.length() >= MAX_SCENARIONAME_LEN)
                {
                    StringBuilder strBuilder;
                    strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario Name: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() <<
                        " has length (" << subSessionName.length() << ") >= MAX_SCENARIONAME_LEN (" << MAX_SCENARIONAME_LEN <<
                        "). This would prevent the scenario from being used, because the string name couldn't be sent from the client.";
                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                    continue;
                }


                if (totalDur == 0 && endTime == 0)
                {
                    StringBuilder strBuilder;
                    strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() <<
                        " has an invalid session time setup.  Total Time and SubSession End Time are both 0.  One of these must be set or the subsession's duration is invalid.";
                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                }

                // Check durations:
                if ((totalDur != 0 && (startTime > totalDur)) ||
                    (endTime != 0 && (startTime > endTime)))
                {
                    StringBuilder strBuilder;
                    strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                            " has an invalid session time setup. Times should be: Start Time ( "<< startTime.getMillis() << " ) <= Total Duration ( " << totalDur.getMillis()  << 
                            " ) && Start Time <= End Time ( " << endTime.getMillis() << " ).";
                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                }

                // can only validate on game manager for packer
                if (gameManagerConfigTdf != nullptr)
                {
                    // Validate that properties used by the filters do not overlap:  (This shouldn't be in Scenarios code - it should be in PropertyFilter code)
                    eastl::hash_set<eastl::string> propertiesInUse;

                    // Use the combined global list and per-subsession Filter list:
                    auto filterList = config.getGlobalFilters();
                    filterList.insert(filterList.begin(), curSubSession->second->getFiltersList().begin(), curSubSession->second->getFiltersList().end());
                    for (auto& filterName : filterList)
                    {
                        auto filterItr = gameManagerConfigTdf->getFilters().find(filterName.c_str());
                        if (filterItr == gameManagerConfigTdf->getFilters().end())
                        {
                            StringBuilder strBuilder;
                            strBuilder << "[MatchmakingScenarioManager].validateConfig:  Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                                     " is using Unknown filter(" << filterName << ") in ";
                            validationErrors.getErrorMessages().push_back(strBuilder.get());
                        }
                        else
                        {
                            // Insert the value into the list of properties in use, and return 
                            auto ret = propertiesInUse.insert(filterItr->second->getGameProperty());
                            if (ret.second == false)
                            {
                                StringBuilder strBuilder;
                                strBuilder << "[MatchmakingScenarioManager].validateConfig:  Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                                    " uses filter(" << filterName.c_str() << ") references property(" << ret.first->c_str() << "), already referenced.  All filters in scenarios must reference non-overlapping properties.";
                                validationErrors.getErrorMessages().push_back(strBuilder.get());
                            }
                        }
                    }
        

                    // Packer Validation:
                    bool isPackerSubsession = false;
                    auto& createGameTemplatesCfgMap = gameManagerConfigTdf->getCreateGameTemplatesConfig().getCreateGameTemplates();
                    auto itr = createGameTemplatesCfgMap.find(curSubSession->second->getCreateGameTemplate());
                    
                    if (itr != createGameTemplatesCfgMap.end())
                    {
                        isPackerSubsession = (itr != createGameTemplatesCfgMap.end() && !itr->second->getPackerConfig().getQualityFactors().empty());
                    }

                    if (isPackerSubsession) //MM session rule for Packer
                    {
                        if (curSubSession->second->getMatchmakingSettings().getSessionMode().getBits() == 0)
                        {
                            curSubSession->second->getMatchmakingSettings().getSessionMode().setCreateGame();
                            curSubSession->second->getMatchmakingSettings().getSessionMode().setFindGame();
                        }
                        else if (curSubSession->second->getMatchmakingSettings().getSessionMode().getFindGame())
                        {
                            StringBuilder strBuilder;
                            strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() <<
                                " has set matchmaking sessionMode to FindGame. Allowed modes for Packer are - CreateGame or [] (empty to enable both).";
                            validationErrors.getErrorMessages().push_back(strBuilder.get());
                        }
                    }
                    else if (curSubSession->second->getMatchmakingSettings().getSessionMode().getBits() == 0) // Check that a mode is set for legacy MM scenario
                    {
                        StringBuilder strBuilder;
                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() <<
                            " has not set a matchmaking sessionMode.";
                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                    }
                }

                // Check that all of the rules listed actually exist: 
                RuleAttributeMappingHelper subsessionRuleList;

                ScenarioRuleNameList::const_iterator curRuleName = curSubSession->second->getRulesList().begin();
                ScenarioRuleNameList::const_iterator endRuleName = curSubSession->second->getRulesList().end();
                for (; curRuleName != endRuleName; ++curRuleName)
                {
                    ScenarioRuleMap::const_iterator curScenarioRuleTemp = config.getScenarioRuleMap().find(*curRuleName);
                    if (curScenarioRuleTemp == config.getScenarioRuleMap().end())
                    {
                        StringBuilder strBuilder;
                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                            " is using an unknown rule: " << curRuleName->c_str() << ".";
                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                    }
                    else
                    {
                        // Check that the rule attributes in use don't overlap any of the global (or other) rules
                        ScenarioRuleAttributes::const_iterator ruleAttributes = curScenarioRuleTemp->second->begin();
                        if (ruleAttributes != curScenarioRuleTemp->second->end())
                        {
                            RuleName ruleName = ruleAttributes->first;

                            ScenarioAttributeMapping::const_iterator curRuleAttr = ruleAttributes->second->begin();
                            ScenarioAttributeMapping::const_iterator endRuleAttr = ruleAttributes->second->end();
                            for (; curRuleAttr != endRuleAttr; ++curRuleAttr)
                            {
                                ScenarioAttributeName attrName = curRuleAttr->first;

                                // See if the rule is already in use globally:
                                RuleAttributeMappingHelper::iterator globalIter = globalRuleAttributesStuff.find(ruleName.c_str());
                                if (globalIter == globalRuleAttributesStuff.end() || 
                                    globalIter->second.find(attrName.c_str()) == globalIter->second.end())
                                {
                                    RuleAttributeMappingHelper::iterator iterBlah = subsessionRuleList.find(ruleName.c_str());
                                    if (iterBlah == subsessionRuleList.end() || 
                                        iterBlah->second.find(attrName.c_str()) == iterBlah->second.end())
                                    {
                                        subsessionRuleList[ruleName.c_str()].insert(attrName.c_str());
                                    }
                                    else
                                    {
                                        StringBuilder strBuilder;
                                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                                            " has overlapping rules for rulename: " << ruleName.c_str() << " attrName: "<< attrName.c_str() <<".";
                                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                                    }
                                }
                                else
                                {
                                    StringBuilder strBuilder;
                                    strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                                        " overlap a global rule for rulename: " << ruleName.c_str() << " attrName: "<< attrName.c_str() <<".";
                                    validationErrors.getErrorMessages().push_back(strBuilder.get());
                                }
                            }
                        }
                    }
                }

                // Verify all create game attributes:
                {
                    StringBuilder errorPrefix;
                    errorPrefix << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << ", Create game attribute ";
                    validateTemplateAttributeMapping(curSubSession->second->getCreateGameAttributes(), scenarioAttrToTypeDesc, createGameRef, validationErrors, errorPrefix.get());
                }

                // Validate CG Template:
                const char8_t* templateName = curSubSession->second->getCreateGameTemplate();
                if (templateName[0] != '\0' && gameManagerConfigTdf != nullptr)
                {
                    CreateGameTemplateMap::const_iterator templateIter = gameManagerConfigTdf->getCreateGameTemplatesConfig().getCreateGameTemplates().find(templateName);
                    if (templateIter == gameManagerConfigTdf->getCreateGameTemplatesConfig().getCreateGameTemplates().end())
                    {
                        StringBuilder strBuilder;
                        strBuilder << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << 
                                " Create Game Template used does not exist: " << templateName << ".";
                        validationErrors.getErrorMessages().push_back(strBuilder.get());
                    }
                    else
                    {
                        // Verify that the attribute types used in the template do not conflict with any of the attributes used: 
                        // (Technically, we only need to check for conflicts with the elements in the CreateGameData, rather than the whole request, but making that delineation is non-trivial.)
                        {
                            StringBuilder errorPrefix;
                            errorPrefix << "[MatchmakingScenarioManager].validateConfig: Scenario: " << scenarioName.c_str() << ", SubSession: " << subSessionName.c_str() << ", Template: " << templateName << " ";
                            validateTemplateAttributeMapping(templateIter->second->getAttributes(), scenarioAttrToTypeDesc, cgReqRef, validationErrors, errorPrefix.get());
                        }
                    }
                }
            }
        }

        return (validationErrors.getErrorMessages().size() == 0);
    }

    const char8_t* MatchmakingScenarioManager::getGlobalScenarioAttributeNameByTdfMemberName(const char8_t* memberName) const
{
        const ScenarioAttributeMapping::const_iterator globalAttribIter = mConfig->getGlobalAttributes().find(memberName);
        if (globalAttribIter != mConfig->getGlobalAttributes().end())
        {
            return globalAttribIter->second->getAttrName();
        }

        return nullptr;
    }

    void MatchmakingScenarioManager::removeScenario(MatchmakingScenarioId scenarioId)
    {
        UserGroupId groupId;
        ScenarioByIdMap::const_iterator iter = mScenarioByIdMap.find(scenarioId);
        if (iter != mScenarioByIdMap.end())
        {
            TRACE_LOG("[MatchmakingScenarioManager].removeScenario: erasing scenario(" << scenarioId << ").");
            groupId = iter->second->getScenarioData()->getScenarioRequest().getPlayerJoinData().getGroupId(); // cache group id
            iter->second->removeMMScenarioForUser();
            mScenarioByIdMap.erase(iter);   // erase() invalidates the iterator
        }

        if (groupId != EA::TDF::OBJECT_ID_INVALID)
        {
            RedisResponsePtr resp;
            RedisError rErr = mComponent->callRemoveMMId(groupId, scenarioId, resp);
            if (rErr != REDIS_ERR_OK)
            {
                ERR_LOG("[MatchmakingScenarioManager].removeScenario(): failed to removal MM scenario id(" << scenarioId << ") for userGroupId(" << groupId.toString() 
                    << "). RedisError: " << RedisErrorHelper::getName(rErr));
            }
        }  
    }


    void MatchmakingScenarioManager::clearScenarios()
    {
        mScenarioByIdMap.clear();
    }
    
    void MatchmakingScenarioManager::clearScenarioConfigs()
    {
        // Safe ptr will take care of the deletes once the owning scenarios are gone..........
        mScenarioConfigByNameMap.clear();
    }
    
    void MatchmakingScenarioManager::clearActiveScenarioConfigInfoMap()
    {
        ScenarioVariantsConfigInfoByNameMap::iterator curIter = mActiveScenarioConfigInfoMapByName.begin();
        ScenarioVariantsConfigInfoByNameMap::iterator endIter = mActiveScenarioConfigInfoMapByName.end();
        for (; curIter != endIter; ++curIter)
        {
            ScenarioConfigInfoByVariantMap::iterator it = curIter->second.begin();
            ScenarioConfigInfoByVariantMap::iterator end = curIter->second.end();
            for (; it != end; ++it)
            {
                delete it->second;
            }
        }
        mActiveScenarioConfigInfoMapByName.clear();
    }

    void MatchmakingScenarioManager::cancelAllScenarios()
    {
        // Make a temporary copy of the Scenario Map, so that we don't have to worry about potentially invalidated iterators:
        ScenarioByIdMap tempCopy(mScenarioByIdMap);

        ScenarioByIdMap::iterator curIter = tempCopy.begin();
        ScenarioByIdMap::iterator endIter = tempCopy.end();
        for (; curIter != endIter; ++curIter)
        {
            MatchmakingScenarioRef scenario = curIter->second;
            scenario->cancelSessions();
        }
    }

    void MatchmakingScenarioManager::onNotifyMatchmakingFailed(const NotifyMatchmakingFailed& notifyMatchmakingFailed)
    {
        ScenarioByIdMap::iterator iter = mScenarioByIdMap.find(notifyMatchmakingFailed.getScenarioId());
        if (iter != mScenarioByIdMap.end())
        {
            MatchmakingScenarioRef scenario = iter->second;
            scenario->onNotifyMatchmakingFailed(notifyMatchmakingFailed);
        }
    }

    // Finished is ONLY used to track the last MatchmakingSuccessResult (for group users) 
    // Success is handed via NotifyMatchmakingSessionConnectionValidated, failure via onNotifyMatchmakingFailed.
    void MatchmakingScenarioManager::onNotifyMatchmakingFinished(const NotifyMatchmakingFinished& notifyMatchmakingFinished)
    {
        ScenarioByIdMap::iterator iter = mScenarioByIdMap.find(notifyMatchmakingFinished.getScenarioId());
        if (iter != mScenarioByIdMap.end())
        {
            MatchmakingScenarioRef scenario = iter->second;
            scenario->onNotifyMatchmakingFinished(notifyMatchmakingFinished);
        }
    }

    void MatchmakingScenarioManager::onNotifyMatchmakingAsyncStatus(const NotifyMatchmakingAsyncStatus& data)
    {
        // Single session case - Just send immediately 
        getComponent().sendNotifyMatchmakingAsyncStatusToUserSessionById(data.getUserSessionId(), &data);

        // Multi-session case - 
        // Add the notification to the session
        // Wait for all active session to async status set (Need to run this check when a session leaves too)
        // Aggregate all statuses, and then send them out
    }

    void MatchmakingScenarioManager::onNotifyMatchmakingPseudoSuccess(const NotifyMatchmakingPseudoSuccess& notifyMatchmakingDebugged)
    {
        ScenarioByIdMap::iterator iter = mScenarioByIdMap.find(notifyMatchmakingDebugged.getScenarioId());
        if (iter != mScenarioByIdMap.end())
        {
            MatchmakingScenarioRef scenario = iter->second;
            scenario->onNotifyMatchmakingPseudoSuccess(notifyMatchmakingDebugged);
        }
    }

    void MatchmakingScenarioManager::onNotifyMatchmakingSessionConnectionValidated(const NotifyMatchmakingSessionConnectionValidated& data)
    {
        // Unfortunately, this doesn't really indicate that the MM was a success, just that we connected and are in the process of doing the tedious QoS checks.
        ScenarioByIdMap::iterator iter = mScenarioByIdMap.find(data.getScenarioId());
        if (iter != mScenarioByIdMap.end())
        {
            MatchmakingScenarioRef scenario = iter->second;
            scenario->onNotifyMatchmakingSessionConnectionValidated(data);
        }
    }

    void MatchmakingScenarioManager::addAttributeMapping(ScenarioAttributeMapping* attrMapping, const ScenarioAttributeMapping& scenarioAttributeMapping)
    {
        ScenarioAttributeMapping::const_iterator curAttr = scenarioAttributeMapping.begin();
        ScenarioAttributeMapping::const_iterator endAttr = scenarioAttributeMapping.end();
        for (; curAttr != endAttr; ++curAttr)
        {
            ScenarioAttributeMapping::iterator iter = attrMapping->find(curAttr->first);
            if (iter == attrMapping->end())
            {
                ScenarioAttributeDefinition* attrDef = attrMapping->allocate_element();
                curAttr->second->copyInto(*attrDef);
                (*attrMapping)[curAttr->first] = attrDef;
            }
            else
            {
                curAttr->second->copyInto(*(iter->second));
            }
        }
    }

    void MatchmakingScenarioManager::addAttributeDefinition(TemplateAttributeDescriptionMapping* attrDefinitionMapping, const ScenarioAttributeMapping& scenarioAttributeMapping, bool includeDebugAttributes)
    {
        for (auto& scenarioAttribute : scenarioAttributeMapping)
        {
            if (!includeDebugAttributes && scenarioAttribute.second->getDebugOnly())
            {
                // Silently omit debug attribute
                continue;
            }

            TemplateAttributeDescriptionMapping::iterator iter = attrDefinitionMapping->find(scenarioAttribute.second->getAttrName());
            if (iter == attrDefinitionMapping->end())
            {
                const EA::TDF::TypeDescriptionBitfieldMember* bfMember = nullptr;
                const EA::TDF::TypeDescription* typeDesc = EA::TDF::TdfFactory::get().getTypeDesc(scenarioAttribute.first.c_str(), &bfMember);
                if (typeDesc)
                {
                    auto* attrDef = attrDefinitionMapping->allocate_element();
                    attrDef->setIsOptional(scenarioAttribute.second->getIsOptional());
                    attrDef->setAttrTdfId(typeDesc->getTdfId());
                    scenarioAttribute.second->getDefault().copyInto(attrDef->getDefault());
                    (*attrDefinitionMapping)[scenarioAttribute.second->getAttrName()] = attrDef;
                }
            }
        }
    }

    void MatchmakingScenarioManager::addAttributeTdfDefinition(TemplateAttributeDescriptionMapping* attrDefinitionMapping, const TemplateAttributeTdfMapping& tdfAttributeMapping, bool includeDebugAttributes)
    {
        for (auto& tdfMapping : tdfAttributeMapping)
        {
            auto& tdfName = tdfMapping.first;
            for (auto& attrMapping : *tdfMapping.second)
            {
                auto& memberName = attrMapping.first;

                if (!includeDebugAttributes && attrMapping.second->getDebugOnly())
                {
                    // Silently omit debug attribute
                    continue;
                }

                TemplateAttributeDescriptionMapping::iterator iter = attrDefinitionMapping->find(attrMapping.second->getAttrName());
                if (iter == attrDefinitionMapping->end())
                {
                    const EA::TDF::TypeDescription* typeDesc = EA::TDF::TdfFactory::get().getTypeDesc(tdfName, memberName);
                    if (typeDesc)
                    {
                        auto* attrDef = attrDefinitionMapping->allocate_element();
                        attrDef->setIsOptional(attrMapping.second->getIsOptional());
                        attrDef->setAttrTdfId(typeDesc->getTdfId());
                        attrMapping.second->getDefault().copyInto(attrDef->getDefault());
                        (*attrDefinitionMapping)[attrMapping.second->getAttrName()] = attrDef;
                    }
                }
            }
        }
    }

    BlazeRpcError MatchmakingScenarioManager::getScenarioAttributesConfig(GetScenariosAttributesResponse& response)
    {
        // For each config, get the info:
        ScenarioConfigByNameMap::iterator curIter = mScenarioConfigByNameMap.begin();
        ScenarioConfigByNameMap::iterator endIter = mScenarioConfigByNameMap.end();
        for (; curIter != endIter; ++curIter)
        {
            ScenarioAttributeMapping* attrMapping = response.getScenarioAttributes().allocate_element();
            response.getScenarioAttributes()[curIter->first] = attrMapping;

            ScenarioVariantsMap::const_iterator varItr = curIter->second->mScenarioVariantsMap.begin();
            ScenarioVariantsMap::const_iterator varEnd = curIter->second->mScenarioVariantsMap.end();
            for (; varItr != varEnd; ++varItr)
            {
                MatchmakingScenarioVariantConfigInfo::SessionConfigList::iterator curSession = varItr->second->mScenarioSessionConfigList.begin();
                MatchmakingScenarioVariantConfigInfo::SessionConfigList::iterator endSession = varItr->second->mScenarioSessionConfigList.end();
                for (; curSession != endSession; ++curSession)
                {
                    // Add the Rule attributes: (Global and local)
                    addAttributeMapping(attrMapping, (*curSession)->mScenarioAttributeMapping);

                    // Add the Create Game attributes:
                    addAttributeMapping(attrMapping, (*curSession)->mSubSessionConfig->getCreateGameAttributes());

                    // Add the CG Template Attributes:
                    const char8_t* templateName = (*curSession)->mSubSessionConfig->getCreateGameTemplate();
                    if (templateName[0] != '\0')
                    {
                        CreateGameTemplateMap::const_iterator templateIter = getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().find(templateName);
                        if (templateIter != getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().end())
                        {
                            // Again, this includes attributes that may not be needed for the CG request, but we include them anyways. 
                            addAttributeMapping(attrMapping, templateIter->second->getAttributes());
                        }
                    }

                }
            }

            // Add the global attributes:
            addAttributeMapping(attrMapping, mConfig->getGlobalAttributes());
        }

        return ERR_OK;
    }
    
    BlazeRpcError MatchmakingScenarioManager::getScenariosAndAttributes(GetScenariosAndAttributesResponse& response)
    {
        const auto& inputSanitizerConfig = getComponent().getConfig().getInputSanitizers();
        const auto& filtersConfig = getComponent().getConfig().getFilters();
        const bool includeDebugAttributes = UserSession::isCurrentContextAuthorized(Blaze::Authorization::PERMISSION_START_DEBUG_MATCHMAKING_SCENARIO, true);
        for (auto& scenarioConfig : mScenarioConfigByNameMap)
        {
            auto* attrDescriptionMapping = response.getScenarioAttributeDescriptions().allocate_element();
            response.getScenarioAttributeDescriptions()[scenarioConfig.first] = attrDescriptionMapping;
            for (auto& scenarioVariantConfig : scenarioConfig.second->mScenarioVariantsMap)
            {
                for (auto& sessionConfig : scenarioVariantConfig.second->mScenarioSessionConfigList)
                {
                    // Add the Rule attributes: (Global and local)
                    addAttributeDefinition(attrDescriptionMapping, sessionConfig->mScenarioAttributeMapping, includeDebugAttributes);

                    // Add Global & Local Sanitizers attributes:
                    SanitizerNameList sanitizersToApply = mConfig->getGlobalInputSanitizers();
                    sanitizersToApply.insert(sanitizersToApply.end(), scenarioConfig.second->mScenarioConfig->getInputSanitizers().begin(), scenarioConfig.second->mScenarioConfig->getInputSanitizers().end());
                    for (const auto& sanitizerName : sanitizersToApply)
                    {
                        const auto& sanitizerConfig = inputSanitizerConfig.find(sanitizerName);
                        if (sanitizerConfig != inputSanitizerConfig.end())
                            addAttributeTdfDefinition(attrDescriptionMapping, sanitizerConfig->second->getSanitizer(), includeDebugAttributes);
                    }

                    // Add Global & Local Filters attributes:
                    MatchmakingFilterList filtersToApply = mConfig->getGlobalFilters();
                    filtersToApply.insert(filtersToApply.end(), sessionConfig->mSubSessionConfig->getFiltersList().begin(), sessionConfig->mSubSessionConfig->getFiltersList().end());
                    for (const auto& filterName : filtersToApply)
                    {
                        const auto& filterConfig = filtersConfig.find(filterName);
                        if (filterConfig != filtersConfig.end())
                            addAttributeTdfDefinition(attrDescriptionMapping, filterConfig->second->getRequirement(), includeDebugAttributes);
                    }


                    // Add the Create Game attributes:
                    addAttributeDefinition(attrDescriptionMapping, sessionConfig->mSubSessionConfig->getCreateGameAttributes(), includeDebugAttributes);


                    // Add the CG Template Attributes:
                    const char8_t* templateName = sessionConfig->mSubSessionConfig->getCreateGameTemplate();
                    if (templateName[0] != '\0')
                    {
                        CreateGameTemplateMap::const_iterator templateIter = getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().find(templateName);
                        if (templateIter != getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().end())
                        {
                            // Again, this includes attributes that may not be needed for the CG request, but we include them anyways. 
                            addAttributeDefinition(attrDescriptionMapping, templateIter->second->getAttributes(), includeDebugAttributes);

                        }
                    }

                }
            }

            addAttributeDefinition(attrDescriptionMapping, mConfig->getGlobalAttributes(), includeDebugAttributes);
        }

        return ERR_OK;
    }

    BlazeRpcError MatchmakingScenarioManager::getScenarioDetails(GetScenarioDetails& response) const
    {
        // For each config, get the info:
        ScenarioConfigByNameMap::const_iterator itr = mScenarioConfigByNameMap.begin();
        ScenarioConfigByNameMap::const_iterator endItr = mScenarioConfigByNameMap.end();
        for (; itr!=endItr; ++itr)
        {
            const MatchmakingScenarioConfigInfo* matchmakingScenarioConfigInfo = itr->second;

            // loop each scenario variant config
            ScenarioVariantsMap::const_iterator varItr = matchmakingScenarioConfigInfo->mScenarioVariantsMap.begin();
            ScenarioVariantsMap::const_iterator varEnd = matchmakingScenarioConfigInfo->mScenarioVariantsMap.end();
            for (; varItr != varEnd; ++varItr)
            {
                ScenarioVariantDetailsMap* scenarioVariantDetailsMap = response.getScenarioDetailsMap().allocate_element();
                ScenarioVersionDetailsMap* scenarioVersionDetailsMap = scenarioVariantDetailsMap->allocate_element();
                ScenarioDetails* scenarioDetails = scenarioVersionDetailsMap->allocate_element();

                scenarioDetails->setHash(varItr->second->mScenarioHash);
                scenarioDetails->setTimeout(varItr->second->getTotalDurationFromConfig().getSec());
                scenarioDetails->setConfigurationDate(matchmakingScenarioConfigInfo->mConfigurationTimestamp);

                SubSessionDetailsMap& subSessionDetailsMap = scenarioDetails->getSubSessionDetailsMap();

                eastl::list<MatchmakingSubSessionConfigInfo*>::const_iterator subSessionItr = varItr->second->mScenarioSessionConfigList.begin();
                eastl::list<MatchmakingSubSessionConfigInfo*>::const_iterator subSessionEnd = varItr->second->mScenarioSessionConfigList.end();
                for (; subSessionItr != subSessionEnd; ++subSessionItr)
                {
                    SubSessionDetails* subSessionDetails = subSessionDetailsMap.allocate_element();
                    const MatchmakingSubSessionConfigInfo* matchmakingSubSessionConfigInfo = *subSessionItr;
                    subSessionDetails->setStartTime(matchmakingSubSessionConfigInfo->mSubSessionConfig->getSessionStartTime().getSec());
                    subSessionDetails->setEndTime(matchmakingSubSessionConfigInfo->mSubSessionConfig->getSessionEndTime().getSec());

                    subSessionDetailsMap[matchmakingSubSessionConfigInfo->mSubSessionName] = subSessionDetails;
                }

                (*scenarioVersionDetailsMap)[varItr->second->mVersion] = scenarioDetails;
                (*scenarioVariantDetailsMap)[varItr->first] = scenarioVersionDetailsMap;
                response.getScenarioDetailsMap()[matchmakingScenarioConfigInfo->mScenarioName] = scenarioVariantDetailsMap;
            }
        }

        return ERR_OK;
    }

    BlazeRpcError MatchmakingScenarioManager::fillInSubMasterRequest(StartMatchmakingInternalRequest& masterRequest,
        MatchmakingCriteriaError &errorResponse, const InetAddress& callerNetworkAddress, const OverrideUserSessionInfoPtr overrideUserSessionInfo,
        // FIFA SPECIFIC CODE START
        bool& hasBadReputation, UserIdentificationList& groupUserIds, bool bByPassBlockList)
        // FIFA SPECIFIC CODE END
    {
        StartMatchmakingRequest &masterBaseRequest = masterRequest.getRequest();

        bool indirectMatchmakingAttempt = true;
        for (auto& playerData : masterBaseRequest.getPlayerJoinData().getPlayerDataList())
        {
            if (playerData->getUser().getBlazeId() == UserSession::getCurrentUserBlazeId())
            {
                indirectMatchmakingAttempt = false;
                break;
            }
        }

        // find and add each user session id to session id list (this adds all logged in sessions)
        BlazeRpcError blazeErr = ValidationUtils::userIdListToJoiningInfoList(masterBaseRequest.getPlayerJoinData(), groupUserIds, masterRequest.getUsersInfo(), &mComponent->getExternalSessionUtilManager(), indirectMatchmakingAttempt);
        if (blazeErr != Blaze::ERR_OK)
        {
            return blazeErr;
        }

        // don't allow anything except the public participant slots:
        SlotType badSlotType = masterBaseRequest.getPlayerJoinData().getDefaultSlotType();
        for (PerPlayerJoinDataList::const_iterator curPlayer = masterBaseRequest.getPlayerJoinData().getPlayerDataList().begin(); 
             curPlayer != masterBaseRequest.getPlayerJoinData().getPlayerDataList().end(); ++curPlayer)
        {
            SlotType slotType = (*curPlayer)->getSlotType();
            if (slotType != INVALID_SLOT_TYPE && slotType!= SLOT_PUBLIC_PARTICIPANT)
                badSlotType = slotType;
        }

        if (badSlotType != SLOT_PUBLIC_PARTICIPANT)
        {
            char8_t msg[MatchmakingCriteriaError::MAX_ERRMESSAGE_LEN];
            blaze_snzprintf(msg, sizeof(msg), "Unsupported SlotType \"%s\" requested. Only SLOT_PUBLIC_PARTICIPANT is supported.", SlotTypeToString(badSlotType));
            errorResponse.setErrMessage(msg);
            return GAMEMANAGER_ERR_INVALID_MATCHMAKING_CRITERIA;
        }

        // set up override UED
        UserSessionInfo* ownerUserSessionInfoPtr = getHostSessionInfo(masterRequest.getUsersInfo());
        if (ownerUserSessionInfoPtr == nullptr)
        {
            char8_t msg[MatchmakingCriteriaError::MAX_ERRMESSAGE_LEN];
            blaze_snzprintf(msg, sizeof(msg), "Missing host user session for Scenario request.");
            errorResponse.setErrMessage(msg);
            return GAMEMANAGER_ERR_MISSING_PRIMARY_LOCAL_PLAYER;
        }

        UserSessionInfo& ownerUserSessionInfo = *ownerUserSessionInfoPtr;
        if (overrideUserSessionInfo != nullptr)
        {
            // this is an all-or-nothing operation, we replace the owner user session info with the contents of the override, if provided.
            // copy UED
            overrideUserSessionInfo->getDataMap().copyInto(ownerUserSessionInfo.getDataMap());
            // qos info
            overrideUserSessionInfo->getQosData().copyInto(ownerUserSessionInfo.getQosData());


            // ping site info
            ownerUserSessionInfo.setBestPingSiteAlias(overrideUserSessionInfo->getBestPingSiteAlias());
            overrideUserSessionInfo->getLatencyMap().copyInto(ownerUserSessionInfo.getLatencyMap());
            ownerUserSessionInfo.setLatitude(overrideUserSessionInfo->getLatitude());
            ownerUserSessionInfo.setLongitude(overrideUserSessionInfo->getLatitude());
            ownerUserSessionInfo.setCountry(overrideUserSessionInfo->getCountry());
            ownerUserSessionInfo.setTimeZone(overrideUserSessionInfo->getTimeZone());
            ownerUserSessionInfo.setISP(overrideUserSessionInfo->getISP());
        }

        // This adds in all non-logged in users:
        mComponent->populateExternalPlayersInfo(masterBaseRequest.getPlayerJoinData(),
            groupUserIds,
            masterRequest.getUsersInfo(),
            ownerUserSessionInfo.getExternalAuthInfo().getCachedExternalSessionToken());

        // Set up master request's roles map for all the reserved list players
        for (UserJoinInfoList::const_iterator itr = masterRequest.getUsersInfo().begin();
            itr != masterRequest.getUsersInfo().end(); ++itr)
        {
            if (!(*itr)->getIsOptional())
                continue;

            // for MM, all external players are added over to the same common regular role join roster too:
            // this simplifies MM's role criteria, rules, and capacity checks. Unlike GM create/joins, where the external players
            // joins are optional, in MM they're required to be considered in all role checks together with non-external players.
            externalRoleRosterEntryToNonExternalRoster((*itr)->getUser().getUserInfo(),
                masterBaseRequest.getPlayerJoinData());
        }

        // note for create/reset game (unlike join game), we need to process the reputations here for the external ids too
        // as they're used to determine whether we need to allow any reputation in the game settings below.
        if (!gUserSessionManager->isReputationDisabled())
        {
            hasBadReputation = GameManagerSlaveImpl::updateAndCheckUserReputations(masterRequest.getUsersInfo());

            // the rep check can override our UED override if present, so update as needed.
            if (overrideUserSessionInfo != nullptr)
            {
                bool ownerSessionHasBadReputation = ownerUserSessionInfo.getHasBadReputation();
                bool overrideHasBadReputation = ReputationService::ReputationServiceUtil::userHasPoorReputation(overrideUserSessionInfo->getDataMap());;
                // only overwrite if there's a mismatch; otherwise poor/good rep is due to some other member of the MM session.
                if (ownerSessionHasBadReputation != overrideHasBadReputation)
                {
                    ownerUserSessionInfo.setHasBadReputation(overrideHasBadReputation);
                    hasBadReputation = overrideHasBadReputation;
                }
            }
        }

        if (indirectMatchmakingAttempt)
        {
            // For indirect matchmaking, this is where we set the OwnerUserSessionInfo, since the user info isn't sent up as part of the request.
            BlazeRpcError result = ValidationUtils::setJoinUserInfoFromSession(masterRequest.getOwnerUserSessionInfo(), *gCurrentUserSession, &mComponent->getExternalSessionUtilManager());
            if (result != ERR_OK)
                return result;
        }
        else
        {
            // Normal matchmaking just copies the host's information into the OwnerUserSessionInfo (since the owner is the host normally):
            ownerUserSessionInfo.copyInto(masterRequest.getOwnerUserSessionInfo());
        }


        ConnectUtil::setExternalAddr(masterBaseRequest.getCommonGameData().getPlayerNetworkAddress(), callerNetworkAddress);

        // set external IP info for CG NAT checking.
        if ((gCurrentLocalUserSession->getPeerInfo() == nullptr) || !gCurrentLocalUserSession->getPeerInfo()->isRealPeerAddressResolved())
        {
            // if the leader isn't resolved, we don't bother checking, and just tell the master that we can't tell if the users in the session are behind the same firewall
            masterRequest.getUserSessionIpInformation().setAreAllSessionIpsResolved(false);
        }
        else
        {
            // we check everyone's external IP and build our external IP list; again, if any member of the MM session is unresolved, we early-out.
            UserSessionsToExternalIpMap &userSessionsToExternalIpMap = masterRequest.getUserSessionIpInformation().getUserSessionsToExternalIpMap();

            // Insert the non-optional members:
            for (UserJoinInfoList::const_iterator itr = masterRequest.getUsersInfo().begin(), end = masterRequest.getUsersInfo().end(); itr != end; ++itr)
            {
                if ((*itr)->getIsOptional())
                {
                    continue;
                }

                UserSessionMasterPtr userSession = gUserSessionMaster->getLocalSession((*itr)->getUser().getSessionId());
                if (userSession == nullptr || (userSession->getPeerInfo() == nullptr) || !userSession->getPeerInfo()->isRealPeerAddressResolved())
                {
                    // if we can't check all the IPs, we're not going to continue
                    masterRequest.getUserSessionIpInformation().setAreAllSessionIpsResolved(false);
                    break;
                }

                uint32_t externalIp = userSession->getPeerInfo()->getRealPeerAddress().getIp();
                userSessionsToExternalIpMap.insert(eastl::make_pair((*itr)->getUser().getSessionId(), externalIp));
            }
        }

        // Fill in the additional block list information:
        // FIFA SPECIFIC CODE START
        BlazeRpcError errResult = ERR_OK;
        if(!bByPassBlockList)
        {
            errResult = fillBlockList(masterRequest, errorResponse);
        }
        // FIFA SPECIFIC CODE END

        if (Blaze::ERR_OK != errResult)
        {
            ERR_LOG("[MatchmakingScenarioManager].fillInSubMasterRequest: (Block List): " << errorResponse.getErrMessage());
            // continue processing, failing to obtain the block list won't interrupt matchmaking.
        }

        return ERR_OK;
    }
    /*! ************************************************************************************************/
    /*! \brief send a matchmaking request to a matchmaking slave
        
        \param[in] request - the matchmaking request to issue 
        \param[out] response - rpc response from StartMatchmakingInternalRpc
        \param[out] error - error response object, if needed
        \param[in] callerNetworkAddress - the network address from the connection that called the RPC
        \param[in] scenarioSession - includes usersession info (including UED) to use as a replacement for values in gCurrentUsersession
        \param[in] instanceId - MM slave instance to send the request to (all subsessions must go to the same slave)
        \param[in] subMasterRequest - partially filled out master request with data that is shared between subsessions
        \param[in] hasBadReputation - does the user have a bad reputation
        \return ERR_OK if successful
    ***************************************************************************************************/
    Blaze::BlazeRpcError MatchmakingScenarioManager::startMatchmaking(const StartMatchmakingRequest &request, StartMatchmakingInternalResponse &response, 
        MatchmakingCriteriaError &error, const InetAddress& callerNetworkAddress, MatchmakingScenarioSession& scenarioSession, 
        const StartMatchmakingInternalRequest* subMasterRequest /*= nullptr*/, bool hasBadReputation /*= false*/, uint32_t sessionSeq)
    {
        auto overrideUserSessionInfo = scenarioSession.getOverrideUserSessionInfo();

        bool indirectMatchmakingAttempt = (subMasterRequest != nullptr) && (!ValidationUtils::isUserSessionInList(UserSession::getCurrentUserSessionId(), subMasterRequest->getUsersInfo()));

        // request only has CriteriaData, GameCreationData, and SessionData in all cases, otherwise check subMasterRequest:
        if (subMasterRequest == nullptr && !indirectMatchmakingAttempt)
        {
            // for non-scenario matchmaking, we check the total number of MM sessions active. 
            // Scenario matchmaking tests concurrent scenarios in the RPC command class.
            // This allows for configuration to limit a user to a single concurrent MM request, but allow for a scenario creating multiple sub-sessions
            BlazeRpcError validateError = mComponent->validateMaxActiveMMSessions(UserSession::getCurrentUserSessionId());
            if (validateError != Blaze::ERR_OK)
            {
                error.setErrMessage((StringBuilder() << "Max active Matchmaking sessions validation failed. " << ErrorHelp::getErrorDescription(validateError)).c_str());
                return validateError;
            }
        }

        // Invalid request.
        GameEntryType entryType = (subMasterRequest != nullptr) ? subMasterRequest->getRequest().getPlayerJoinData().getGameEntryType() : request.getPlayerJoinData().getGameEntryType();
        if (entryType == GAME_ENTRY_TYPE_CLAIM_RESERVATION)
        {
            error.setErrMessage((StringBuilder() << "Invalid game entry type.").c_str());
            return GAMEMANAGER_ERR_INVALID_GAME_ENTRY_TYPE;
        }

        BlazeRpcError authErr = ERR_OK;
        if (request.getSessionData().getPseudoRequest())
        {
            if (!UserSession::isCurrentContextAuthorized(Authorization::PERMISSION_START_DEBUG_MATCHMAKING_SCENARIO))
                authErr = ERR_AUTHORIZATION_REQUIRED;
        }
        else if (indirectMatchmakingAttempt)
        {
            if (!UserSession::isCurrentContextAuthorized(Authorization::PERMISSION_START_INDIRECT_MATCHMAKING_SESSION))
                authErr = ERR_AUTHORIZATION_REQUIRED;
        }
        else if ( (!UserSession::isCurrentContextAuthorized(Authorization::PERMISSION_START_MATCHMAKING_SESSION) 
            && ( (request.getSessionData().getSessionMode().getCreateGame() && !UserSession::isCurrentContextAuthorized(Authorization::PERMISSION_START_MATCHMAKING_SESSION_CREATE_GAME))
            || (request.getSessionData().getSessionMode().getFindGame() && !UserSession::isCurrentContextAuthorized(Authorization::PERMISSION_START_MATCHMAKING_SESSION_FIND_GAME)))))
        {
            authErr = ERR_AUTHORIZATION_REQUIRED;
        }
        if (authErr == ERR_AUTHORIZATION_REQUIRED)
        {
            error.setErrMessage((StringBuilder() << "Authorization required.").c_str());
            return authErr;
        }

        StartMatchmakingInternalRequest internalRequest;
        if (subMasterRequest != nullptr)
        {
            // subMasterRequest allows us to skip the user lookup code since player join data should match for each subsession.
            subMasterRequest->copyInto(internalRequest);

            // We still need to update the unique portions of the request (the criteria):
            request.getCriteriaData().copyInto(internalRequest.getRequest().getCriteriaData());
            request.getGameCreationData().copyInto(internalRequest.getRequest().getGameCreationData());
            internalRequest.getRequest().getCommonGameData().setGameType(request.getCommonGameData().getGameType()); // set the game type from the template (if no template, defaults to GAME_TYPE_GAMESESSION)
            request.getSessionData().copyInto(internalRequest.getRequest().getSessionData());
        }
        else
        {  
            // Non-Scenarios Flow:
            request.copyInto(internalRequest.getRequest());

            StartMatchmakingRequest &masterBaseRequest = internalRequest.getRequest();
            ValidationUtils::insertHostSessionToPlayerJoinData(masterBaseRequest.getPlayerJoinData(), gCurrentLocalUserSession);

            UserIdentificationList groupUserIds;
            // validate group existence & membership
            BlazeRpcError blazeErr = ValidationUtils::loadGroupUsersIntoPlayerJoinData(masterBaseRequest.getPlayerJoinData(), groupUserIds, *mComponent);
            if (blazeErr != Blaze::ERR_OK)
            {
                error.setErrMessage((StringBuilder() << "group existence and membership validation failed. " << ErrorHelp::getErrorDescription(blazeErr)).c_str());
                return blazeErr;
            }

            // FIFA SPECIFIC CODE START
            bool byPassBlockList = false;

            /**
              * HACK - FIFA 17 Post Launch - apoon - Oct 18th 2016
              * The below hacking change is implemented to by pass the block list for FUT Champion
              * On Xbox One, player can block another user to avoid playing against selected player
              * This feature allows FUT Champion user to selective pick who not to match up with, 
              * which defeat the fairness nature of the competitive game mode
              */
            {
                const char8_t* gameModeAttrName = "Gamemode_Name";
                const char8_t* gameModesName[] = {"fut_online_champions", "fut_online_tour"};

                Collections::AttributeMap::const_iterator gameModeNameAttrib = request.getGameCreationData().getGameAttribs().find(gameModeAttrName);

                for(unsigned int i=0; i< (sizeof(gameModesName) / sizeof(char8_t*)); i++)
                {
                    if(blaze_strncmp(gameModeNameAttrib->second.c_str(), gameModesName[i], strlen(gameModesName[i])) == 0)
                    {
                        byPassBlockList = true;
                        break;
                    }
                }
            }
            // FIFA SPECIFIC CODE END

            // Fill in all the parts of the master request that are the same for each subsession:
            blazeErr = fillInSubMasterRequest(internalRequest, error, callerNetworkAddress, overrideUserSessionInfo, hasBadReputation, groupUserIds);
            if (blazeErr != Blaze::ERR_OK)
            {
                return blazeErr;
            }

            internalRequest.setTotalUsersOnline(mGMCensusData.getNumOfLoggedSession());
            internalRequest.setTotalUsersInGame(mGMCensusData.getNumOfJoinedPlayer());
            internalRequest.setTotalUsersInMatchmaking(mGMCensusData.getNumOfMatchmakingUsers());

        }

        if (!gUserSessionManager->isReputationDisabled())
        {
            if (hasBadReputation
                && (!internalRequest.getRequest().getGameCreationData().getGameSettings().getAllowAnyReputation()
                    || (internalRequest.getRequest().getCriteriaData().getReputationRulePrefs().getReputationRequirement() != MUST_ALLOW_ANY_REPUTATION)))
            {
                // poor rep user, force MUST_ALLOW_ANY_REPUTATION
                mComponent->incrementTotalRequestsUpdatedForReputation();
                internalRequest.getRequest().getCriteriaData().getReputationRulePrefs().setReputationRequirement(MUST_ALLOW_ANY_REPUTATION);
                TRACE_LOG("[MatchmakingScenarioManager].startMatchmaking: User " << UserSession::getCurrentUserBlazeId()
                    << " attempted to enter matchmaking game with poor reputation, had to set ReputationRule to use '" <<
                    ReputationRequirementToString(internalRequest.getRequest().getCriteriaData().getReputationRulePrefs().getReputationRequirement()) << "'.");
                // not really needed, since this will be set properly by finalization voting.
                internalRequest.getRequest().getGameCreationData().getGameSettings().setAllowAnyReputation();
            }
        }

        // Special handling to resolve BlazeObjectIds to BlazeIds, for CG on master
        BlazeRpcError errResult = playersRulesUserSetsToBlazeIds(internalRequest.getRequest().getCriteriaData(), error);
        if (Blaze::ERR_OK != errResult)
        {
            ERR_LOG("[MatchmakingScenarioManager].startMatchmaking: " << error.getErrMessage());
            return errResult;
        }

        // set up mm Qos criteria
        if (request.getPlayerJoinData().getGameEntryType() == GAME_ENTRY_TYPE_DIRECT)
        {
            internalRequest.getQosCriteria().clear();

            ConnectionCriteria *connectionCriteria = internalRequest.getQosCriteria().allocate_element();
            // The net topology is only set for CG requests (request.getSessionData().getSessionMode().getCreateGame()), otherwise it just defaults to CSPH
            internalRequest.getQosCriteria().insert(eastl::make_pair(request.getGameCreationData().getNetworkTopology(), connectionCriteria)); 

            const PlayerQosValidationDataPtr qosValidationData = mComponent->getMatchmakingQosCriteriaForUser(UserSession::getCurrentUserSessionId(), request.getGameCreationData().getNetworkTopology());
            if (qosValidationData != nullptr)
            {
                connectionCriteria->getAvoidGameIdList().assign(qosValidationData->getAvoidedGameList().begin(), qosValidationData->getAvoidedGameList().end());
                connectionCriteria->getAvoidPlayerIdList().assign(qosValidationData->getAvoidedPlayerList().begin(), qosValidationData->getAvoidedPlayerList().end());
                connectionCriteria->setFailedConnectionAttempts(qosValidationData->getFailureCount());
                connectionCriteria->setTier(qosValidationData->getCriteriaTier());
            }
        }

        // Stash off the potential external session name and correlation id for create mode for assigning to a new game or for find mode,
        // if joining the game's first user with external sessions access (e.g. pre-host-inject games), it'll init game's correlation id on master.
        // Note: UUID generator for external session names here should have sufficient ids for realistically unreachable number of mm requests over title's lifetime.
        BlazeRpcError sessErr = initRequestExternalSessionData(internalRequest.getGameExternalSessionData(), 
            internalRequest.getRequest().getGameCreationData().getExternalSessionIdentSetup(), request.getCommonGameData().getGameType(),
            internalRequest.getUsersInfo(), mComponent->getConfig().getGameSession(), mComponent->getExternalSessionUtilManager(), *mComponent);
        if (sessErr != ERR_OK && internalRequest.getGameExternalSessionData().getJoinInitErr().getFailedOnAllPlatforms())
        {
            error.setErrMessage((StringBuilder() << "External session request data initialization failed. " << ErrorHelp::getErrorDescription(sessErr)).c_str());
            return sessErr;
        }

        
        /////////////////////////////////////////////////////////////////////////////////////
        // Ensure that the role information is set up correctly
        EntryCriteriaError pjdRoleErr;
        errResult = fixupPlayerJoinDataRoles(internalRequest.getRequest().getPlayerJoinData(), false, mComponent->getLogCategory(), &pjdRoleErr);
        if (errResult != ERR_OK)
        {
            error.setErrMessage(pjdRoleErr.getFailedCriteria());
            return errResult;
        }

        // Sort the UserJoinInfoList list based on the number of roles each player desires
        // This will aid in reducing MM failures by placing more permissive players
        // into the game last
        UserRoleCounts<UserJoinInfoPtr> userJoinInfoRoleCounts;

        // Build an index mapping that we can sort. Once sorted, we can switch around the
        // the UserJoinInfo objects in the masterRequest
        UserJoinInfoList &userJoinList = internalRequest.getUsersInfo();
        if (userJoinList.size() > 1) // No need to sort if there's only one user
        {
            const PerPlayerJoinDataList &ppJoinDataList = internalRequest.getRequest().getPlayerJoinData().getPlayerDataList();
            for (auto& userJoinInfo : userJoinList)
            {
                // Give all players a default value for the number of roles
                // We give them one role, even if roles aren't being used, as this doesn't matter for sorting purposes
                // (Either roles aren't being used and thus everyone will have the same role count or they are being used
                // and everyone gets the default role)
                size_t roleCount = 1;
                UserRoleCount<UserJoinInfoPtr> userRoleCount = eastl::make_pair(userJoinInfo, roleCount);
                for (const auto& ppJoinData : ppJoinDataList)
                {
                    UserIdentification joiningUserId;
                    UserInfo::filloutUserIdentification(userJoinInfo->getUser().getUserInfo(), joiningUserId);
                    if (areUserIdsEqual(ppJoinData->getUser(), joiningUserId))
                    {
                        // Special case to handle players desiring ANY role
                        if (ppJoinData->getRoles().empty() && blaze_stricmp(ppJoinData->getRole(), PLAYER_ROLE_NAME_ANY) == 0)
                            userRoleCount.second = SIZE_MAX;
                        else if (!ppJoinData->getRoles().empty())
                            userRoleCount.second = ppJoinData->getRoles().size();
                        break;
                    }
                }
                userJoinInfoRoleCounts.push_back(userRoleCount);
            }

            eastl::sort(userJoinInfoRoleCounts.begin(), userJoinInfoRoleCounts.end(), UserRoleCountComparator<UserJoinInfoPtr>());

            auto it = userJoinList.begin();
            auto end = userJoinList.end();
            auto countIt = userJoinInfoRoleCounts.cbegin();
            auto countEnd = userJoinInfoRoleCounts.cend();
            for (; it != end && countIt != countEnd; ++it, ++countIt)
            {
                *it = (*countIt).first;
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////


        // This logic will be done on the PackerMaster using the PlatformFilter if Packer is in use:
        if (!scenarioSession.getIsPackerSession())
        {
            // Crossplay validation check:  (Overrides for Crossplay settings are not available for Scenarios)
            bool isCrossplayEnabled = false;
            auto& platformRuleCriteria = internalRequest.getRequest().getCriteriaData().getPlatformRuleCriteria();
            errResult = ValidationUtils::validateRequestCrossplaySettings(isCrossplayEnabled, userJoinList, request.getSessionData().getSessionMode().getCreateGame(),
                internalRequest.getRequest().getGameCreationData(), getComponent().getConfig().getGameSession(),
                platformRuleCriteria.getClientPlatformListOverride(), platformRuleCriteria.getCrossplayMustMatch());
            if (errResult != ERR_OK)
            {
                error.setErrMessage((StringBuilder() << "Crossplay enabled user attempted to create a game with invalid settings. " << ErrorHelp::getErrorDescription(errResult)).c_str());
                ERR_LOG("[MatchmakingScenarioManager].startMatchmaking:  Crossplay enabled user attempted to create a game with invalid settings.  Unable to just disable crossplay to fix this.");
                return errResult;
            }

            // Set a platform restriction for the default use case where a CP user was trying to create a CP Enabled Game, but something forced it to be CP disabled.
            if (!isCrossplayEnabled)
            {
                platformRuleCriteria.setCrossplayMustMatch(true);
            }
        }

        BlazeError err = ERR_OK;
        auto sessionId = scenarioSession.getSessionId();
        EA_ASSERT_MSG(sessionId != INVALID_MATCHMAKING_SESSION_ID, "MatchmakingSessionId must be set already!");
        internalRequest.setMatchmakingSessionId(sessionId);
        auto currentUserSessionId = UserSession::getCurrentUserSessionId();
        if (scenarioSession.getIsPackerSession())
        {
            // Packer flow
            auto* gamepackerMaster = getGamePackerMaster();
            if (gamepackerMaster == nullptr)
            {
                ERR_LOG("[MatchmakingScenarioManager].getGamePackerMaster: Unable to resolve gamepacker master.");
                return ERR_SYSTEM;
            }

            GameManager::StartPackerSessionRequest packerReq;
            GameManager::StartPackerSessionResponse packerResp;
            GameManager::StartPackerSessionError packerErr;
            packerReq.setPackerSessionId(sessionId);
            packerReq.setPackerSessionSequence(sessionSeq);
            packerReq.setInternalRequest(internalRequest);

            // PACKER_TODO: Consider having the start session request sent to master encompass *all* the sub-sessions in one payload. In fact in the future the master shall represent the sub-sessions within the matchmaking session as individual storage fields within the session's master storage record. This is a natural fit because all the sub-sessions need to reside on the same sliver.
            mComponent->incMMSessionReqForUser(currentUserSessionId);
            err = gamepackerMaster->startPackerSession(packerReq, packerResp, packerErr);
            if (err == ERR_OK)
            {
                auto* internalResp = packerResp.getInternalResponse();
                if (internalResp)
                    internalResp->copyInto(response);
            }
            else
            {
                // PACKER_TODO: translate from packer error codes to corresponding mm error codes
                ERR_LOG("[MatchmakingScenarioManager].startMatchmaking: Failed to start packer session(" << sessionId << ") for userSessionId(" << currentUserSessionId << "), err(" << err << ")");
                auto* internalErr = packerErr.getInternalError();
                if (internalErr)
                    internalErr->copyInto(error);
            }
            mComponent->decMMSessionReqForUser(currentUserSessionId);
            if (err == Blaze::ERR_OK)
            {
                EA_ASSERT(response.getStartMatchmakingResponse().getSessionId() == internalRequest.getMatchmakingSessionId());
                mComponent->addMMSessionForUser(currentUserSessionId, sessionId);
            }
        }
        else
        {
            // Legacy flow
            auto* matchmakerComponent = getMatchmakerSlave();
            if (matchmakerComponent == nullptr)
            {
                ERR_LOG("[MatchmakingScenarioManager].startMatchmaking: Unable to resolve matchmaker component.");
                return ERR_SYSTEM;
            }
            mComponent->incMMSessionReqForUser(currentUserSessionId);
            err = matchmakerComponent->startMatchmakingInternal(internalRequest, response, error);
            mComponent->decMMSessionReqForUser(currentUserSessionId);
            if (err == Blaze::ERR_OK)
            {
                EA_ASSERT(response.getStartMatchmakingResponse().getSessionId() == internalRequest.getMatchmakingSessionId());
                // update matchmaker's load status
                mComponent->updateMatchmakingSlaveStatus(response.getMatchmakingStatus());
                mComponent->addMMSessionForUser(currentUserSessionId, sessionId);
            }
        }

        return convertMatchmakingComponentErrorToGameManagerError(err.code);
    }

    /*! ************************************************************************************************/
    /*! \brief Resolve original criteria's UserSet inputs to member blaze ids and add them to the master
        criteria's blaze id lists. Works around fact UserSets are n/a on master, for create game MM.
    ***************************************************************************************************/
    BlazeRpcError MatchmakingScenarioManager::playersRulesUserSetsToBlazeIds(MatchmakingCriteriaData& criteriaData, MatchmakingCriteriaError& err)
    {
        AvoidPlayersRuleCriteria& avoidRuleCriteria = criteriaData.getAvoidPlayersRuleCriteria();
        if (Blaze::ERR_OK != Matchmaker::PlayersRule::userSetsToBlazeIds(avoidRuleCriteria.getAvoidListIds(),
            avoidRuleCriteria.getAvoidList(), avoidRuleCriteria.getClassName(), err))
        {
            return Blaze::GAMEMANAGER_ERR_INVALID_MATCHMAKING_CRITERIA;
        }

        PreferredPlayersRuleCriteria& preferRuleCriteria = criteriaData.getPreferredPlayersRuleCriteria();
        if (Blaze::ERR_OK != Matchmaker::PlayersRule::userSetToBlazeIds(preferRuleCriteria.getPreferredListId(),
            preferRuleCriteria.getPreferredList(), preferRuleCriteria.getClassName(), err))
        {
            return Blaze::GAMEMANAGER_ERR_INVALID_MATCHMAKING_CRITERIA;
        }

        return Blaze::ERR_OK;
    }

    BlazeRpcError MatchmakingScenarioManager::fillBlockList(StartMatchmakingInternalRequest& masterRequest, MatchmakingCriteriaError& err) const
    {
        // Xbox only:
        if ((!gController->isPlatformHosted(xone) && !gController->isPlatformHosted(xbsx)) || !mComponent->getConfig().getMatchmakerSettings().getIsXblBlockPlayersRuleEnabled())
        {
            return ERR_OK;
        }
        // Mock testing of XBL block lists is not currently supported
        const ExternalSessionUtil* util = mComponent->getExternalSessionUtilManager().getUtil(xone);
        if (!util)
            util = mComponent->getExternalSessionUtilManager().getUtil(xbsx);//either platform
        if (!util || util->isMockPlatformEnabled())
        {
            return ERR_OK;
        }
        return Matchmaker::XblBlockPlayersRule::fillBlockList(masterRequest.getUsersInfo(), masterRequest.getXblAccountIdBlockList(), err);
    }

    InstanceId MatchmakingScenarioManager::selectMatchmakerInstance(const MatchmakingSessionMode& sessionMode) const
    {
        const Blaze::Matchmaker::MatchmakerSlave* matchmakerComponent = getMatchmakerSlave();
        if (matchmakerComponent == nullptr)
        {
            ERR_LOG("[MatchmakingScenarioManager].selectMatchmakerInstance: Unable to resolve matchmaker component.");
            return INVALID_INSTANCE_ID;
        }

        MatchmakingShardingInformation &shardingInfo = mComponent->getMatchmakingShardingInformation();
        const MatchmakingServerConfig &serverConfig = mComponent->getConfig().getMatchmakerSettings();

        Component::InstanceIdList allInstances;
        matchmakerComponent->getComponentInstances(allInstances, false, false);

        // a find-game only session will shard across the full set of MM slaves
        // if create game is enabled, we have to track how many active instances exist.
        uint32_t matchmakerShardCount = allInstances.size();

        if (matchmakerShardCount == 0)
        {
            ERR_LOG("[MatchmakingScenarioManager].selectMatchmakerInstance: No matchmaker instances found to shard to.");
            return INVALID_INSTANCE_ID;
        }

        // On the off chance that a matchmaking slave went down, make sure we adjust the active count to match
        if (matchmakerShardCount < shardingInfo.mActiveMatchmakerCount)
        {
            shardingInfo.mActiveMatchmakerCount = matchmakerShardCount;
        }

        // Track instances based on CPU state
        Component::InstanceIdList overloadedInstances;
        Component::InstanceIdList normalInstances;

        // Sum up the CPU utilization across all active matchmaking instances
        uint32_t totalCpu = 0;
        uint32_t counter = 0;
        for (auto& itr : allInstances) 
        {
            // break early if CG session and we have gone through all the active shards
            // FG loops through every instance to account for CPU (which seems odd, because the FG CPU will effect CG once we get to it...)
            if (sessionMode.getCreateGame())
            {
                if (counter >= shardingInfo.mActiveMatchmakerCount)
                    break;
            }

            uint32_t cpu = 0;
            InstanceIdToStatusMap::const_iterator statusIter = shardingInfo.mStatusMap.find(itr);
            if(statusIter == shardingInfo.mStatusMap.end())
            {
                // add the instance, the status will be updated the next time we get notified from the slaves.
                MatchmakingStatus& newStatus = shardingInfo.mStatusMap[itr];
                newStatus.setInstanceId(itr);
                newStatus.setCpuUtilization(0);
                newStatus.setNumSessions(0);
            }
            else
            {
                cpu = statusIter->second.getCpuUtilization();
            }

            if (cpu >= serverConfig.getCpuUtilizationOverloadThreshold())
            {
                overloadedInstances.push_back(itr);
            }
            else
            {
                normalInstances.push_back(itr);
            }

            totalCpu += cpu;
            ++counter;
        }

        // for create game, we expand our pool based on CPU utilization because we try to concentrate the MM sessions together 
        if (sessionMode.getCreateGame())
        {
            if ( ( 
                ((totalCpu / shardingInfo.mActiveMatchmakerCount) > serverConfig.getCpuUtilizationShardingThreshold())
                || (!overloadedInstances.empty() && !normalInstances.empty() && ((totalCpu / normalInstances.size()) > serverConfig.getCpuUtilizationShardingThreshold()))
                )
                && (shardingInfo.mActiveMatchmakerCount < matchmakerShardCount) )
            {
                INFO_LOG("[MatchmakingScenarioManager].selectMatchmakerInstance: increasing shards. Total cpu: " << totalCpu
                    << ", active shards: " << shardingInfo.mActiveMatchmakerCount
                    << ", normal shards: " << normalInstances.size()
                    << ", overload shards: " << overloadedInstances.size()
                );

                // add new instance to average list, we're assuming that the newly activated instance isn't an outlier
                normalInstances.push_back(allInstances[shardingInfo.mActiveMatchmakerCount]);
                ++shardingInfo.mActiveMatchmakerCount;
            }
            else if ( shardingInfo.mActiveMatchmakerCount > 1
                && (totalCpu / shardingInfo.mActiveMatchmakerCount) < serverConfig.getCpuUtilizationRecoupShardingThreshold()
                && (totalCpu / (shardingInfo.mActiveMatchmakerCount-1)) <= serverConfig.getCpuUtilizationShardingThreshold() 
                && overloadedInstances.empty())
            {
                if ((TimeValue::getTimeOfDay() - shardingInfo.mLastRecoupTime) > serverConfig.getRecoupShardWaitPeriod())
                {
                    // Note we only contract if we are both currently operating under the low usage threshold AND shrinking the cluster
                    // will not immediately push us right back over the high threshold to avoid ping-ponging
                    // we also won't contract if there are currently any overloaded instances
                    INFO_LOG("[MatchmakingScenarioManager].selectMatchmakerInstance: decreasing shards.  Total cpu: " << totalCpu 
                        << ", active shards: " << shardingInfo.mActiveMatchmakerCount
                        << ", normal shards: " << normalInstances.size()
                        << ", overload shards: " << overloadedInstances.size()
                    );

                    --shardingInfo.mActiveMatchmakerCount;
                    normalInstances.pop_back();
                    shardingInfo.mLastRecoupTime = TimeValue::getTimeOfDay();
                }
            }
        }

        Component::InstanceIdList* shardInstances = &allInstances;
        // pool size is average instance count, unless all instances are above the overload threshold, or 'overloaded' outnumber 'normal' instances
        if (normalInstances.empty())
        {
            // if this happens, we've run out of mm slaves to expand to. We need more capacity.
            // We will just select randomly from all instances
            matchmakerShardCount = shardingInfo.mActiveMatchmakerCount;
        }
        else
        {
            matchmakerShardCount = normalInstances.size();
            shardInstances = &normalInstances;
        }


        Component::InstanceIdList::iterator iItr = shardInstances->begin();
        int shardNum = Blaze::Random::getRandomNumber(matchmakerShardCount);
        eastl::advance(iItr, shardNum);
        return *iItr;
    }

    void MatchmakingScenarioManager::populateTemplateToPropertyListMap(const GameManagerServerConfig& config)
    {
        mTemplateToPropertyListMap.clear();
        for (auto& scenarioItr : config.getScenariosConfig().getScenarios())
        {
            for (auto& subsessionItr : scenarioItr.second->getSubSessions())
            {
                auto* createGameTemplateName = subsessionItr.second->getCreateGameTemplate();
                if (createGameTemplateName[0] != '\0')
                {
                    auto ret = mTemplateToPropertyListMap.insert(createGameTemplateName);
                    auto& propertyList = ret.first->second;

                    auto allFilters = subsessionItr.second->getFiltersList(); // intentionally copy
                    for (auto& globalFilter : config.getScenariosConfig().getGlobalFilters())
                        allFilters.push_back(globalFilter);

                    for (auto& filter : allFilters)
                    {
                        auto filterDefItr = config.getFilters().find(filter);
                        if (filterDefItr != config.getFilters().end())
                        {
                            auto* gameProperty = filterDefItr->second->getGameProperty();
                            // TODO: add case insensitive compare
                            if (eastl::find(propertyList.begin(), propertyList.end(), gameProperty) == propertyList.end())
                            {
                                propertyList.push_back(gameProperty);
                            }
                        }
                    }

                }
            }
        }
    }

    MatchmakingScenario::MatchmakingScenario(MatchmakingScenarioId scenarioId, const StartMatchmakingScenarioRequest& request, 
        MatchmakingScenarioVariantConfigInfoRef config, MatchmakingScenarioManager& owner, const OverrideUserSessionInfo *overrideUserSessionInfo)
            : mOverrideUserSessionInfo(nullptr),
            mManager(owner),
            mConfigInfoRef(config),
            mTrackingTag(""),
            mScenarioData(BLAZE_NEW MatchmakingScenarioData())
    {
        mScenarioData->setScenarioId(scenarioId);
        request.copyInto(mScenarioData->getScenarioRequest());
        if (overrideUserSessionInfo != nullptr)
        {
            mOverrideUserSessionInfo = OverrideUserSessionInfoPtr(overrideUserSessionInfo->clone());
        }
        mIsStartingSessions = false;
        mIsCancellingSessions = false;
        mShouldCancelSessions = false;
        mIsScenarioFinished = false;
        mScenarioData->setResults(MatchmakingScenarioData::FAILURE);
        mScenarioData->setHostBlazeId(INVALID_BLAZE_ID);
        mScenarioData->setHostUserSessionId(UserSession::getCurrentUserSessionId());
        mScenarioData->setMatchmakingSuccessResult(SUCCESS_CREATED_GAME);

        mScenarioData->setScenarioVariant(config->mVariant);

        initializeOwnedSessions();
    }

    MatchmakingScenario::MatchmakingScenario(MatchmakingScenarioDataPtr& scenarioData, MatchmakingScenarioVariantConfigInfoRef config, MatchmakingScenarioManager& owner) :
        mOverrideUserSessionInfo(nullptr),
        mManager(owner),
        mConfigInfoRef(config),
        mTrackingTag(""),
        mScenarioData(scenarioData)
    {
        mIsStartingSessions = false;
        mIsCancellingSessions = false;
        mShouldCancelSessions = false;
        mIsScenarioFinished = false;

        initializeOwnedSessions();
    }

    MatchmakingScenario::~MatchmakingScenario()
    {
        MatchmakingScenarioSessionList::iterator curIter = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::iterator endIter = mOwnedSessions.end();
        for (; curIter != endIter; ++curIter)
        {
            delete (*curIter);
        }
        mOwnedSessions.clear();
    }

    void MatchmakingScenario::initializeOwnedSessions()
    {
        // Create all of the scenario sessions:
        MatchmakingScenarioVariantConfigInfo::SessionConfigList::const_iterator curInfo = getConfigInfo().mScenarioSessionConfigList.begin();
        MatchmakingScenarioVariantConfigInfo::SessionConfigList::const_iterator endInfo = getConfigInfo().mScenarioSessionConfigList.end();
        for (; curInfo != endInfo; ++curInfo)
        {
            // Verify that the Subsession has the required attributes before creating: 
            bool allAttributesFound = true;
            ScenarioAttributeList::const_iterator curAttr = (*curInfo)->mSubSessionConfig->getSkipSubSessionIfNotSetAttributes().begin();
            ScenarioAttributeList::const_iterator endAttr = (*curInfo)->mSubSessionConfig->getSkipSubSessionIfNotSetAttributes().end();
            for (; curAttr != endAttr; ++curAttr)
            {
                if (mScenarioData->getScenarioRequest().getScenarioAttributes().find(*curAttr) == mScenarioData->getScenarioRequest().getScenarioAttributes().end())
                {
                    TRACE_LOG("[MatchmakingScenario]: Missing attribute "<< curAttr->c_str() << " for scenario id (" << mScenarioData->getScenarioId() << "), subsession (" << (*curInfo)->mSubSessionName.c_str() << "). Skipping subsession.");
                    allAttributesFound = false;
                    break;
                }
            }

            if (allAttributesFound)
            {
                MatchmakingScenarioSessionDataPtr sessionDataPtr;
                MatchmakingScenarioSessionDataByIdMap::iterator dataIt = mScenarioData->getOwnedSessions().begin();
                MatchmakingScenarioSessionDataByIdMap::iterator dataEnd = mScenarioData->getOwnedSessions().end();
                for (; dataIt != dataEnd; ++dataIt)
                {
                    if (blaze_strcmp(dataIt->second->getSubSessionName(), (*curInfo)->mSubSessionName.c_str()) == 0)
                    {
                        sessionDataPtr = dataIt->second;
                        break;
                    }
                }
                mOwnedSessions.push_back(BLAZE_NEW MatchmakingScenarioSession(**curInfo, *this, sessionDataPtr));
            }
        }

        // Randomize the order of the Subsessions:
        // This is needed to ensure that create game sub-sessions are not completed in the order set in the scenario.cfg.
        eastl::random_shuffle(mOwnedSessions.begin(), mOwnedSessions.end(), Random::getRandomNumber);
    }

    void MatchmakingScenario::sendNotifyRemoteMatchmakingStartedToGroup()
    {
        GameManager::NotifyRemoteMatchmakingStarted sessionStartedNotification;
        sessionStartedNotification.setMMSessionId(INVALID_MATCHMAKING_SESSION_ID);  
        sessionStartedNotification.setMMScenarioId(mScenarioData->getScenarioId());
        
        sessionStartedNotification.getRemoteUserInfo().setInitiatorId(mScenarioData->getHostBlazeId());
        sessionStartedNotification.getRemoteUserInfo().setAssociatedUserGroupId(mScenarioData->getScenarioRequest().getPlayerJoinData().getGroupId());

        UserSessionIdList::const_iterator userSessionIdIter = mScenarioData->getGroupUserSessionIdList().begin();
        UserSessionIdList::const_iterator userSessionIdEnd = mScenarioData->getGroupUserSessionIdList().end();
        for (; userSessionIdIter != userSessionIdEnd; ++userSessionIdIter)
        {
            UserSessionId currentSessionId = (*userSessionIdIter);
            sessionStartedNotification.setUserSessionId(currentSessionId);
            getComponent().sendNotifyRemoteMatchmakingStartedToUserSessionById(currentSessionId, &sessionStartedNotification);
        }
    }

    void MatchmakingScenario::sendNotifyRemoteMatchmakingEndedToGroup(GameManager::MatchmakingResult result)
    {
        GameManager::NotifyRemoteMatchmakingEnded sessionEndedNotification;
        sessionEndedNotification.setMMSessionId(INVALID_MATCHMAKING_SESSION_ID);  
        sessionEndedNotification.setMMScenarioId(mScenarioData->getScenarioId());

        sessionEndedNotification.getRemoteUserInfo().setInitiatorId(mScenarioData->getHostBlazeId());
        sessionEndedNotification.getRemoteUserInfo().setAssociatedUserGroupId(mScenarioData->getScenarioRequest().getPlayerJoinData().getGroupId());

        sessionEndedNotification.setMatchmakingResult(result);        

        UserSessionIdList::const_iterator userSessionIdIter = mScenarioData->getGroupUserSessionIdList().begin();
        UserSessionIdList::const_iterator userSessionIdEnd = mScenarioData->getGroupUserSessionIdList().end();
        for (; userSessionIdIter != userSessionIdEnd; ++userSessionIdIter)
        {
            UserSessionId currentSessionId = (*userSessionIdIter);
            sessionEndedNotification.setUserSessionId(currentSessionId);
            getComponent().sendNotifyRemoteMatchmakingEndedToUserSessionById(currentSessionId, &sessionEndedNotification);
        }
    }

    BlazeRpcError MatchmakingScenario::setupAndStartSessions(StartMatchmakingScenarioResponse& response, MatchmakingCriteriaError& critErr, const InetAddress& callerNetworkAddress, UserIdentificationList& groupUserIds, CallerProperties& callerSourceProperties)
    {
        if (mOwnedSessions.empty())
        {
            ERR_LOG("[MatchmakingScenario].setupAndStartSessions(): Scenario id (" << mScenarioData->getScenarioId() << ") is removed due to not own any subsession.");
            mManager.removeScenario(mScenarioData->getScenarioId());
            return ERR_SYSTEM;
        }

        if (mIsStartingSessions)
        {
            return ERR_SYSTEM;
        }
        mIsStartingSessions = true;

        BlazeRpcError errRet = ERR_OK;

#ifdef TARGET_arson    
        // Special Total Duration override logic used by Arson:
        auto attr = mScenarioData->getScenarioRequest().getScenarioAttributes().find("$ARSON_TOTAL_DURATION");
        if (attr != mScenarioData->getScenarioRequest().getScenarioAttributes().end())
        {
            attr->second->convertToResult(mTotalDurationOverride);
            TRACE_LOG("[MatchmakingScenario].setupAndStartSessions:  Override of total duration to (" << getTotalDuration().getMillis() << " ms).");
        }
#endif

        // Build the data shared among subsessions: 
        bool hasBadReputation = false;
        StartMatchmakingInternalRequest masterRequest;

        // PACKER_TODO: eventually we should selectively prune this set since packer doesn't use legacy rule attributes...
        // send the scenario attributes up with the internal requests
        
        // Update Source Properties: 
        callerSourceProperties.mMatchmakingRequest = &masterRequest;
        //mScenarioData->getScenarioRequest().getScenarioAttributes().copyInto(callerSourceProperties.scenarioAttributes());// PACKER_TODO: shallow copy

        mScenarioData->getScenarioRequest().getScenarioAttributes().copyInto(masterRequest.getScenarioAttributes());

        mScenarioData->getScenarioRequest().getPlayerJoinData().copyInto(masterRequest.getRequest().getPlayerJoinData());
        mScenarioData->getScenarioRequest().getCommonGameData().copyInto(masterRequest.getRequest().getCommonGameData());
        masterRequest.setScenarioTimeoutDuration(getTotalDuration());
        masterRequest.setTrackingTag(getTrackingTag());


        masterRequest.setTotalUsersOnline(mManager.getGameManagerCensusData().getNumOfLoggedSession());
        masterRequest.setTotalUsersInGame(mManager.getGameManagerCensusData().getNumOfJoinedPlayer());
        masterRequest.setTotalUsersInMatchmaking(mManager.getGameManagerCensusData().getNumOfMatchmakingUsers());
        

        PropertyNameList globalProperties;
        mConfigInfoRef->getGlobalScenarioPropertiesUsed(globalProperties);
        mManager.getPropertyManager().convertProperties(callerSourceProperties, globalProperties, masterRequest.getMatchmakingPropertyMap());

        // Apply any global attributes to the PJD and CommonGameData before using them:
        errRet = mConfigInfoRef->applyGlobalAttributes(mScenarioData->getScenarioRequest().getScenarioAttributes(), masterRequest.getMatchmakingPropertyMap(), masterRequest.getRequest(), critErr);
        if (errRet == ERR_OK)
        {
            errRet = mManager.fillInSubMasterRequest(masterRequest, critErr, callerNetworkAddress, mOverrideUserSessionInfo, hasBadReputation, groupUserIds);
        }

        if (errRet == ERR_OK)
        {
            // OwnerUserSessionInfo is not set until fillInSubMasterRequest is called above.
            lookupDedicatedServerOverrideGameId(callerSourceProperties, masterRequest.getOwnerUserSessionInfo().getUserInfo().getId(), masterRequest, getManager().getDedicatedServerOverrideMap());

            mScenarioData->setHostBlazeId(masterRequest.getOwnerUserSessionInfo().getUserInfo().getId()); // getHostSessionInfo(masterRequest.getUsersInfo()).getUserInfo().getId());

            // Cache GroupUserSessionIdList:  (Since we don't hold onto the master request)
            UserJoinInfoList::const_iterator userJoinInfoIter = masterRequest.getUsersInfo().begin();
            UserJoinInfoList::const_iterator userJoinInfoEnd = masterRequest.getUsersInfo().end();
            for (; userJoinInfoIter != userJoinInfoEnd; ++userJoinInfoIter)
            {
                UserSessionId currentSessionId = (*userJoinInfoIter)->getUser().getSessionId();
                if (currentSessionId != mScenarioData->getHostUserSessionId())
                {
                    mScenarioData->getGroupUserSessionIdList().push_back(currentSessionId);
                }

                (*userJoinInfoIter)->getScenarioInfo().setScenarioName(getConfigInfo().getScenarioName());
                (*userJoinInfoIter)->getScenarioInfo().setScenarioVariant(getConfigInfo().mVariant);
                (*userJoinInfoIter)->getScenarioInfo().setScenarioVersion(getConfigInfo().mVersion);
                mScenarioData->getScenarioRequest().getScenarioAttributes().copyInto((*userJoinInfoIter)->getScenarioInfo().getScenarioAttributes());
                (*userJoinInfoIter)->setOriginatingScenarioId(mScenarioData->getScenarioId());
            }

            // Send off a notification to each member of the team that actually exists (indicating that a scenario is starting):
            sendNotifyRemoteMatchmakingStartedToGroup();

            InstanceId commonInstanceId = INVALID_INSTANCE_ID; // Common instance id used for all legacy sub-sessions common to a single scenario id because currently they are created via individual requests but must go to the same instance.
            SliverId commonSliverId = INVALID_SLIVER_ID; // Common sliver id used for all sub-sessions common to a single scenario id because currently they are created via individual requests but must go to the same instance.

            // first scan through all sessions to find out if any of them use the packer, and reserve a common sliverId
            for (auto& ownedSession : mOwnedSessions)
            {
                if (ownedSession->getIsPackerSession())
                {
                    commonSliverId = GetSliverIdFromSliverKey(getScenarioId());
                    if (commonSliverId == INVALID_SLIVER_ID)
                    {
                        ERR_LOG("[MatchmakingScenario].setupAndStartSessions: Failed to obtain a sliver id.");
                        errRet = ERR_SYSTEM;
                        goto cancelSessions;
                    }
                }
                else
                {
                    if (commonInstanceId == INVALID_INSTANCE_ID)
                    {
                        commonInstanceId = mManager.selectMatchmakerInstance(getConfigInfo().mCombinedSessionMode);
                        if (commonInstanceId == INVALID_SLIVER_ID)
                        {
                            ERR_LOG("[MatchmakingScenario].setupAndStartSessions: Failed to obtain a instance id.");
                            errRet = ERR_SYSTEM;
                            goto cancelSessions;
                        }
                    }
                }
                
                if (commonSliverId != INVALID_SLIVER_ID && commonInstanceId != INVALID_INSTANCE_ID)
                    break; // stop iterating because we are done assigning common
            }

            for (uint32_t i = 0, numSessions = (uint32_t)mOwnedSessions.size(); i < numSessions; ++i)
            {
                auto* curSession = mOwnedSessions[i];
                uint64_t uniqueIdBase = 0;
                auto idType = Blaze::GameManager::MATCHMAKER_IDTYPE_SESSION;
                errRet = gUniqueIdManager->getId(Blaze::Matchmaker::MatchmakerSlave::COMPONENT_ID, (uint16_t)idType, uniqueIdBase, SLIVER_KEY_BASE_MIN);
                if (errRet != Blaze::ERR_OK)
                {
                    ERR_LOG("[MatchmakingScenario].setupAndStartSessions: couldn't get matchmaking session Id, got error '" << ErrorHelp::getErrorName(errRet) << "'.");
                    goto cancelSessions;
                }
                MatchmakingSessionId sessionId = BuildSliverKey(commonSliverId, uniqueIdBase); // Needed to ensure uniqueness because legacy mm sessions and packer sessions both share id space
                if (!curSession->getIsPackerSession())
                {
                    sessionId = BuildInstanceKey64(commonInstanceId, sessionId); //set the id so it routes to this instance in legacy(non sliver) sharding mode
                }
                curSession->setSessionId(sessionId);
                
                auto sessionSeq = numSessions - i - 1;
                BlazeRpcError err = curSession->start(response, critErr, callerNetworkAddress, masterRequest, hasBadReputation, sessionSeq, callerSourceProperties);    // Blocking
                if (err != ERR_OK)
                {
                    errRet = err;
                    break;
                }

                if (curSession->isFinished())
                {
                    // The session may have finished while we were waiting in start() above, don't insert it in this case
                    continue;
                }
                
                EA_ASSERT_MSG(curSession->getSessionId() != INVALID_MATCHMAKING_SESSION_ID, "Invalid matchmaking session id!"); // TODO: Remove this assert

                mScenarioData->getOwnedSessions()[curSession->getSessionId()] = curSession->getSessionData();
            }
        }

cancelSessions:
        mIsStartingSessions = false;
        if (errRet != ERR_OK || mShouldCancelSessions)
        {
            cancelSessions();  // Blocking
            return errRet;
        }

        // It's possible for a Scenario to complete instantly, before this function returns.  (Because it was waiting in start())
        // If the Scenario had active subsessions, then it would attempt to cancel them before finishing, which would hit the above code. (Canceling is delayed during startup.)  
        // But, if there was only a single subsession, then it would not hit the cancel code, and would just finish the Scenario.
        // This check prevents us from adding the Scenario Redis data, if the Scenario was already finished. 
        if (areAllSessionsComplete() == false)
        {
            upsertMMScenarioForUser();
        }

        return ERR_OK;
    }

    // Special version for Arson override support:
    TimeValue MatchmakingScenario::getTotalDuration() const
    { 
        return (mTotalDurationOverride == 0) ? getConfigInfo().getTotalDurationFromConfig() : mTotalDurationOverride;
    }

    void MatchmakingScenario::deleteIfUnreferenced(bool clearRefs)
    {
        // When the last reference is destroyed, we use this to clear the reference:
        if (clearRefs)
            clear_references();

        if (is_unreferenced())
            delete this;
    }

    void MatchmakingScenarioVariantConfigInfo::deleteIfUnreferenced(bool clearRefs)
    {
        // When the last reference is destroyed, we use this to clear the reference:
        if (clearRefs)
            clear_references();

        if (is_unreferenced())
            delete this;
    }

    void MatchmakingScenarioConfigInfo::deleteIfUnreferenced(bool clearRefs)
    {
        // When the last reference is destroyed, we use this to clear the reference:
        if (clearRefs)
            clear_references();

        if (is_unreferenced())
            delete this;
    }

    void MatchmakingScenario::upsertMMScenarioForUser(bool allowInsert)
    {
        UserSessionMasterPtr userSession = gUserSessionMaster->getLocalSession(mScenarioData->getHostUserSessionId());
        if (userSession != nullptr)
        {
            UserSessionMMStateDataPtr stateData = userSession->getCustomStateTdf<UserSessionMMStateData>(GameManagerSlave::COMPONENT_ID);
            if (stateData == nullptr)
                stateData = BLAZE_NEW UserSessionMMStateData();

            MatchmakingScenarioDataByIdMap& dataByIdMap = stateData->getMatchmakingScenarioDataByIdMap();
            if (!allowInsert && (dataByIdMap.find(mScenarioData->getScenarioId()) == dataByIdMap.end()))
            {
                // The caller didn't want to allow an insert (a.k.a only wants to update an existing entry), but there isn't an entry.  So, early out.
                return;
            }
            TRACE_LOG("[MatchmakingScenario].upsertMMScenarioForUser: upserting scenario id(" << mScenarioData->getScenarioId() << ") for usersession(" << mScenarioData->getHostUserSessionId() << "), BlazeId(" << mScenarioData->getHostBlazeId() << ").");

            // Update or insert new entry.
            dataByIdMap[mScenarioData->getScenarioId()] = mScenarioData;

            // Now, inform the framework about the change, and let it handle the rest.
            userSession->upsertCustomStateTdf(GameManagerSlave::COMPONENT_ID, *stateData);
        }
    }

    void MatchmakingScenario::removeMMScenarioForUser()
    {
        UserSessionMasterPtr userSession = gUserSessionMaster->getLocalSession(mScenarioData->getHostUserSessionId());
        if (userSession != nullptr)
        {
            UserSessionMMStateDataPtr stateData = userSession->getCustomStateTdf<UserSessionMMStateData>(GameManagerSlave::COMPONENT_ID);
            if (stateData != nullptr)
            {
                stateData->getMatchmakingScenarioDataByIdMap().erase(mScenarioData->getScenarioId());
                userSession->upsertCustomStateTdf(GameManagerSlave::COMPONENT_ID, *stateData);
            }
        }
        else
        {
            TRACE_LOG("[MatchmakingScenario].removeMMScenarioForUser: usersession N/A, not removing scenario id(" << mScenarioData->getScenarioId() << ") for usersession(" << mScenarioData->getHostUserSessionId() << "), BlazeId(" << mScenarioData->getHostBlazeId() << ").");
        }
    }

    bool MatchmakingScenario::areAllSessionsComplete()
    {
        MatchmakingScenarioSessionList::const_iterator curSession = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::const_iterator endSession = mOwnedSessions.end();
        for (; curSession != endSession; ++curSession)
        {
            // We only check for sessions that are incomplete:
            if (!(*curSession)->isFinished())
            {
                return false;
            }
        }
        return true;
    }


    void MatchmakingScenario::onNotifyMatchmakingPseudoSuccess(const NotifyMatchmakingPseudoSuccess& notifyMatchmakingDebugged)
    {
        MatchmakingSessionId sessionId = notifyMatchmakingDebugged.getSessionId();
        mPseudoResults.setScenarioId(mScenarioData->getScenarioId());
        mPseudoResults.setScenarioName(getConfigInfo().mOwner->mScenarioName);
        mPseudoResults.setScenarioVersion(getConfigInfo().mVersion);
        mPseudoResults.setScenarioVariant(getConfigInfo().mVariant);
        mPseudoResults.setScenarioTimeoutDuration(getTotalDuration());
        
        mScenarioData->setResults(MatchmakingScenarioData::PSEUDO_SUCCESS);

        MatchmakingScenarioSessionList::const_iterator curSession = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::const_iterator endSession = mOwnedSessions.end();
        for (; curSession != endSession; ++curSession)
        {
            if (sessionId == (*curSession)->getSessionId())
            {
                notifyMatchmakingDebugged.copyInto(*mPseudoResults.getPseudoSuccessList().pull_back());
                TRACE_LOG("[MatchmakingScenario].onNotifyMatchmakingPseudoSuccess(): PseudoSuccess for scenario id (" << mScenarioData->getScenarioId() << "), subsession (" << (*curSession)->getSessionName().c_str() << ") .");
                break;
            }
        }

        // Success is false because multiple pseudo results may be pending:
        onSessionFinished(false, sessionId);
    }

    void MatchmakingScenario::onNotifyMatchmakingFailed(const NotifyMatchmakingFailed& notifyMatchmakingFailed)
    {
        MatchmakingSessionId sessionId = notifyMatchmakingFailed.getSessionId();
        MatchmakingScenarioSessionList::const_iterator curSession = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::const_iterator endSession = mOwnedSessions.end();
        for (; curSession != endSession; ++curSession)
        {
            if (sessionId == (*curSession)->getSessionId())
            {
                TRACE_LOG("[MatchmakingScenario].onNotifyMatchmakingFailed(): Failure for scenario id (" << mScenarioData->getScenarioId() << "), subsession (" << (*curSession)->getSessionName().c_str() << ") .");
            }
        }

        notifyMatchmakingFailed.copyInto(mFailureResults);

        bool success = false;
        switch (mFailureResults.getMatchmakingResult())
        {
        case SUCCESS_CREATED_GAME:
        case SUCCESS_JOINED_NEW_GAME:
        case SUCCESS_JOINED_EXISTING_GAME:
        case SUCCESS_PSEUDO_CREATE_GAME:
        case SUCCESS_PSEUDO_FIND_GAME:
            success = true;
            break;
        default:
            success = false;
            break;
        }
        
        onSessionFinished(success, mFailureResults.getSessionId());
    }

    void MatchmakingScenario::onNotifyMatchmakingFinished(const NotifyMatchmakingFinished& notifyMatchmakingFinished)
    {
        // Finished is ONLY used to track the last MatchmakingSuccessResult (for group users) 
        // Success is handed via NotifyMatchmakingSessionConnectionValidated, failure via onNotifyMatchmakingFailed.
        switch (notifyMatchmakingFinished.getMatchmakingResult())
        {
        case SUCCESS_CREATED_GAME:
        case SUCCESS_JOINED_NEW_GAME:
        case SUCCESS_JOINED_EXISTING_GAME:
        case SUCCESS_PSEUDO_CREATE_GAME:
        case SUCCESS_PSEUDO_FIND_GAME:
            mScenarioData->setMatchmakingSuccessResult(notifyMatchmakingFinished.getMatchmakingResult());
            break;
        default:
            break;
        }

        // We have to set this value to false, so that we don't add Scenario finished data before the Scenarios all start (can happen due to startup failure)
        // because then the scenario count would never be decremented.  
        // (Order goes:  MM Sub-Session startup -> Session Startup failure (sends finished notify) -> (send startMMSession RPC response) -> other sessions are canceled early, no scenario added)
        upsertMMScenarioForUser(false);
    }

    void MatchmakingScenario::onNotifyMatchmakingSessionConnectionValidated(const NotifyMatchmakingSessionConnectionValidated& data)
    {
        MatchmakingSessionId sessionId = data.getSessionId();
        MatchmakingScenarioSessionList::const_iterator curSession = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::const_iterator endSession = mOwnedSessions.end();
        for (; curSession != endSession; ++curSession)
        {
            if (sessionId == (*curSession)->getSessionId())
            {
                TRACE_LOG("[MatchmakingScenario].onNotifyMatchmakingSessionConnectionValidated(): validated for scenario id (" << mScenarioData->getScenarioId() << "), subsession (" << (*curSession)->getSessionName().c_str() << "), mmSessionId(" << sessionId << "), dispatchFinished(" << (data.getDispatchSessionFinished() ? "true":"false") << "), qosValidationPerformed(" << (data.getQosValidationPerformed() ? "true" : "false") << ").");
            }
        }

        if (data.getDispatchSessionFinished())
        {
            data.copyInto(mSuccessResults);

            onSessionFinished(true, mSuccessResults.getSessionId());
        }
    }

    void MatchmakingScenario::onSessionFinished(bool success, MatchmakingSessionId sessionId)
    {
        // Check all list: 
        bool foundSession = false;
        MatchmakingScenarioSessionList::const_iterator curSession = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::const_iterator endSession = mOwnedSessions.end();
        for (; curSession != endSession; ++curSession)
        {
            if (sessionId == (*curSession)->getSessionId())
            {
                foundSession = true;
                (*curSession)->finish();
                break;
            }
        }
        TRACE_LOG("[MatchmakingScenario].onSessionFinished: scenario(" << mScenarioData->getScenarioId() << ") found(" << (foundSession ? "true" : "false") << "), success(" << (success ? "true" : "false") << "), for usersession(" << getHostUserSessionId() << "), blazeId(" << mScenarioData->getHostBlazeId() << "), allSessionsComplete(" << (areAllSessionsComplete() ? "true" : "false") << ").");

        if (foundSession && success)
        {
            mScenarioData->setResults(MatchmakingScenarioData::SUCCESS);
            finishScenario();

            // if the result was a success, we need to cancel the other sessions: 
            if (!areAllSessionsComplete())
            {
                cancelSessions();   
            }
        }
        else if (areAllSessionsComplete())
        {
            finishScenario();
        }
        else
        {
            StringBuilder sb;
            sb << "sessionId:" << sessionId;
            sb << ", curSessionIds: (";
            for (auto& s : mOwnedSessions)
            {
                sb << s->getSessionId() << " -> " << *(s->getSessionData());
            }
            sb << ")";

            WARN_LOG("[MatchmakingScenario].onSessionFinished: Unhandled case scenario(" << mScenarioData->getScenarioId() << ") found(" << (foundSession ? "true" : "false") << "), success(" << (success ? "true" : "false") << "), for usersession(" << getHostUserSessionId() << "), blazeId(" << mScenarioData->getHostBlazeId() << "), allSessionsComplete(" << (areAllSessionsComplete() ? "true" : "false") << "), additionalInfo: " << sb.get());
        }

        upsertMMScenarioForUser(false);
    }

    void MatchmakingScenario::finishScenario()
    {
        // Respond with the current results of the scenario:
        if (!mIsScenarioFinished)
        {
            mIsScenarioFinished = true;

            switch (mScenarioData->getResults())
            {
            case MatchmakingScenarioData::PSEUDO_SUCCESS:
                getComponent().sendNotifyMatchmakingScenarioPseudoSuccessToUserSessionById(getHostUserSessionId(), &mPseudoResults);
                if (!mPseudoResults.getPseudoSuccessList().empty())
                {
                    // Just send the results from one of the subsessions:
                    sendNotifyRemoteMatchmakingEndedToGroup(mPseudoResults.getPseudoSuccessList().back()->getMatchmakingResult());
                }
                break;
            case MatchmakingScenarioData::SUCCESS:
                if (GameManager::bypassNetworkTopologyQosValidation(mSuccessResults.getConnectionValidatedResults().getNetworkTopology()))
                {
                    TRACE_LOG("[MatchmakingScenario].finishScenario: Deliberately bypass connection validation notification for scenario(" << mScenarioData->getScenarioId() << ") for usersession(" << getHostUserSessionId() << "), blazeId(" << mScenarioData->getHostBlazeId() << "), network topology(" << GameNetworkTopologyToString(mSuccessResults.getConnectionValidatedResults().getNetworkTopology()) << ") does not require it.");
                }
                else
                {
                    getComponent().sendNotifyMatchmakingSessionConnectionValidatedToUserSessionById(getHostUserSessionId(), &mSuccessResults);
                }
                // Unfortunately, we don't have the last success value because we don't track via on onNotifyMatchmakingFinished
                sendNotifyRemoteMatchmakingEndedToGroup(mScenarioData->getMatchmakingSuccessResult());
                break;
            case MatchmakingScenarioData::FAILURE:
                // onSessionFinished == failure (mFailureResults is valid)
                mFailureResults.setScenarioId(mScenarioData->getScenarioId());
                mFailureResults.setUserSessionId(getHostUserSessionId());
                if (mFailureResults.getMatchmakingResult() == SUCCESS_CREATED_GAME ||
                    mFailureResults.getMatchmakingResult() == SUCCESS_JOINED_NEW_GAME ||
                    mFailureResults.getMatchmakingResult() == SUCCESS_JOINED_EXISTING_GAME ||
                    mFailureResults.getMatchmakingResult() == SUCCESS_PSEUDO_CREATE_GAME ||
                    mFailureResults.getMatchmakingResult() == SUCCESS_PSEUDO_FIND_GAME)
                {
                    mFailureResults.setMatchmakingResult(SESSION_TERMINATED);
                }

                getComponent().sendNotifyMatchmakingFailedToUserSessionById(getHostUserSessionId(), &mFailureResults);
                sendNotifyRemoteMatchmakingEndedToGroup(mFailureResults.getMatchmakingResult());
                break;
            }
        }

        // Add the scenario to the removal list, once all sessions are completed: 
        if (areAllSessionsComplete() && !mIsCancellingSessions)
        {
            Fiber::CreateParams params;
            params.namedContext = "MatchmakingScenarioManager::removeScenario";
            gFiberManager->scheduleCall<MatchmakingScenarioManager, MatchmakingScenarioId>(&mManager, &MatchmakingScenarioManager::removeScenario, mScenarioData->getScenarioId(), params);
        }
    }

    void MatchmakingScenarioSession::finish()
    {
        mSessionData->setSessionState(MatchmakingScenarioSessionData::FINISHED);
    }

    MatchmakingScenarioSession::MatchmakingScenarioSession(const MatchmakingSubSessionConfigInfo& config, MatchmakingScenario& owner, MatchmakingScenarioSessionDataPtr sessionData) :
        mScenarioOwner(owner),
        mConfigInfo(config),
        mSessionData(sessionData)
    {
        if (mSessionData == nullptr)
        {
            mSessionData = BLAZE_NEW MatchmakingScenarioSessionData();
            mSessionData->setSessionId(INVALID_MATCHMAKING_SESSION_ID);
            mSessionData->setSubSessionName(config.mSubSessionName);
            mSessionData->setSessionState(MatchmakingScenarioSessionData::INITIALIZED);
            mSessionData->setError(ERR_OK);
        }
    }

    MatchmakingScenarioSession::~MatchmakingScenarioSession()
    {
        mSessionData->setSessionState(MatchmakingScenarioSessionData::FINISHED);
        mSessionData->setError(ERR_CANCELED);
    }

    BlazeRpcError MatchmakingScenarioSession::start(StartMatchmakingScenarioResponse& response, MatchmakingCriteriaError& critErr, const InetAddress& callerNetworkAddress,
                                                    StartMatchmakingInternalRequest& masterRequest, bool hasBadReputation, uint32_t sessionSeq, CallerProperties& callerSourceProperties)
    {
        if (mSessionData->getSessionState() != MatchmakingScenarioSessionData::INITIALIZED)
        {
            ERR_LOG("[MatchmakingScenarioSession].start: Attempting to start session " << mConfigInfo.mSubSessionName.c_str() << 
                    " that is already in started for scenario " << mScenarioOwner.getConfigInfo().getScenarioName().c_str() << " (" << mScenarioOwner.mScenarioData->getScenarioId() << ").");
            return ERR_SYSTEM;
        }
        mSessionData->setSessionState(MatchmakingScenarioSessionData::STARTING);

        // Convert all properties to the format TdfMapping expected: 
        PropertyNameList propertiesUsed;
        mConfigInfo.getScenarioPropertiesUsed(propertiesUsed);
        mScenarioOwner.mManager.getPropertyManager().convertProperties(callerSourceProperties, propertiesUsed, masterRequest.getMatchmakingPropertyMap());

        StartMatchmakingRequest request;
        BlazeRpcError err = mConfigInfo.createStartMatchmakingRequest(getScenarioRequest().getScenarioAttributes(), masterRequest.getMatchmakingPropertyMap(), request, masterRequest, critErr);   // Non-Blocking
        if (err != ERR_OK)
        {
            ERR_LOG("[MatchmakingScenarioSession].start: Error ("<< critErr.getErrMessage() <<") occurred with matchmaking scenario.");
            mSessionData->setSessionState(MatchmakingScenarioSessionData::FINISHED);
            return err;
        }

        // Update the properties that are set based on the subsession/applied attributes.
        fillInSubsessionCallerProperties(callerSourceProperties, masterRequest); 

        // Update the properties used for the subsession, based on the values that have been applied:   
        mConfigInfo.getFilterPropertiesUsed(propertiesUsed);
        mConfigInfo.getPackerPropertiesUsed(propertiesUsed);
        mConfigInfo.mOwner->getGlobalFilterPropertiesUsed(propertiesUsed);
        callerSourceProperties.mGameCreationData = (&request.getGameCreationData());
        mScenarioOwner.mManager.getPropertyManager().convertProperties(callerSourceProperties, propertiesUsed, masterRequest.getMatchmakingPropertyMap());

        // Disable various global filters depending on the Properties used
        // PACKER_TODO:  Standardize the Property disable logic so that we don't have to use logic like this.   (Example:  bool disableFilterIfValueMissing - If filter mapping fails, disable filter.)
        disableFiltersHack(callerSourceProperties, mScenarioOwner.mManager.getPropertyManager(), masterRequest);
        
        // Update the Game Properties required by the Packer. 
        PropertyNameList gamePropertiesUsed;
        for (const auto& curProperty : mScenarioOwner.mManager.getPropertyManager().getRequiredPackerGameProperties())
        {
            gamePropertiesUsed.push_back(curProperty.c_str());
        }

        PropertyDataSources gameProperties;
        gameProperties.mGameCreationData = &request.getGameCreationData();
        gameProperties.mMatchmakingRequest = &masterRequest; // Couple values are set here, like "
        mScenarioOwner.mManager.getPropertyManager().convertProperties(gameProperties, gamePropertiesUsed, masterRequest.getMatchmakingPropertyMap());

        // Convert old Xbox session params to new params (for back compat). Do after applying attributes above
        oldToNewExternalSessionIdentificationParams(request.getGameCreationData().getExternalSessionTemplateName(), nullptr, nullptr, nullptr, request.getGameCreationData().getExternalSessionIdentSetup());

#ifdef TARGET_arson    
        // Special case for override of Timeout: (Normally this is set once, but here we need to redo it)
        if (mScenarioOwner.getTotalDuration() > request.getSessionData().getStartDelay())
        {
            request.getSessionData().setSessionDuration(mScenarioOwner.getTotalDuration() - request.getSessionData().getStartDelay());
        }
#endif

        // Ultimately, this logic gathers the gameProperties used by the Filters, and set WME_UNSET_HASH on the Packer, if the filter does not set a value itself. 
        auto* gameTemplateName = mConfigInfo.mSubSessionConfig->getCreateGameTemplate();
        if (gameTemplateName[0] != '\0')
        {
            auto& templateToPropertyListMap = getScenario().getManager().getTemplateToPropertyListMap();
            auto propertyListItr = templateToPropertyListMap.find(mConfigInfo.mSubSessionConfig->getCreateGameTemplate());
            if (propertyListItr == templateToPropertyListMap.end())
            {
                ERR_LOG("[MatchmakingScenarioSession].start: Missing template property mapping for template (" << mConfigInfo.mSubSessionConfig->getCreateGameTemplate() << ").");
                return ERR_SYSTEM;
            }
            propertyListItr->second.copyInto(masterRequest.getMatchmakingPropertyList());
        }
        
        StartMatchmakingInternalResponse startMMResponse;
        err = mScenarioOwner.mManager.startMatchmaking(request, startMMResponse, critErr, callerNetworkAddress, 
                                                       *this, &masterRequest, hasBadReputation, sessionSeq);    // Blocking
        if (err != ERR_OK)
        {
            ERR_LOG("[MatchmakingScenarioSession].start: Error ("<< critErr.getErrMessage() <<") occurred with matchmaking scenario.");
            mSessionData->setSessionState(MatchmakingScenarioSessionData::FINISHED);
            return err;
        }
        
        response.setEstimatedTimeToMatch(startMMResponse.getEstimatedTimeToMatch());
        response.setScid(startMMResponse.getStartMatchmakingResponse().getScid());
        response.setExternalSessionTemplateName(startMMResponse.getStartMatchmakingResponse().getExternalSessionTemplateName());
        response.setExternalSessionName(startMMResponse.getStartMatchmakingResponse().getExternalSessionName());
        response.setExternalSessionCorrelationId(startMMResponse.getStartMatchmakingResponse().getExternalSessionCorrelationId());
        
        // It's possible that we finished the session before startMatchmaking, in which case we don't want to change the state:
        if (mSessionData->getSessionState() != MatchmakingScenarioSessionData::FINISHED)
        {
            mSessionData->setSessionState(MatchmakingScenarioSessionData::ACTIVE);
        }
        return err;
    }

    BlazeRpcError MatchmakingScenario::cancelSessions()
    {
        mShouldCancelSessions = true;

        // Early out if the sessions are still starting (handle after they're all done):
        if (mIsStartingSessions || mIsCancellingSessions || areAllSessionsComplete())
        {
            if (areAllSessionsComplete())
            {
                Fiber::CreateParams params;
                params.namedContext = "MatchmakingScenarioManager::removeScenario";
                gFiberManager->scheduleCall<MatchmakingScenarioManager, MatchmakingScenarioId>(&mManager, &MatchmakingScenarioManager::removeScenario, mScenarioData->getScenarioId(), params);
            }            
            return ERR_OK;
        }
        mIsCancellingSessions = true;

        // Spawn a helper thread because we can't sit around waiting for all the cancel commands to complete on the same thread. 
        MatchmakingScenarioRef scenarioRef(this);
        Fiber::CreateParams params;
        params.namedContext = "MatchmakingScenarioManager::cancelSessionsFiber";
        gFiberManager->scheduleCall<MatchmakingScenario, BlazeRpcError, MatchmakingScenarioRef>(this, &MatchmakingScenario::cancelSessionsFiber, scenarioRef, nullptr, params);

        return ERR_OK;
    }
    BlazeRpcError MatchmakingScenario::cancelSessionsFiber(MatchmakingScenarioRef scenarioRef)
    {
        BlazeRpcError retErr = ERR_OK;

        MatchmakingScenarioSessionList::iterator curIter = mOwnedSessions.begin();
        MatchmakingScenarioSessionList::iterator endIter = mOwnedSessions.end();
        for (; curIter != endIter; ++curIter)
        {
            // This is a blocking call, but we won't start any new sessions after this point:
            BlazeRpcError err = (*curIter)->cancel();
            if (err != ERR_OK)
                retErr = err;
        }

        mIsCancellingSessions = false;
        if (areAllSessionsComplete())
        {
            finishScenario();
        }

        return retErr;
    }

    BlazeRpcError MatchmakingScenarioSession::cancel()
    {
        BlazeRpcError err = ERR_OK;
        // If the session is active, try to cancel via the RPC command (which may fail):
        if (mSessionData->getSessionState() == MatchmakingScenarioSessionData::ACTIVE && mSessionData->getSessionId() != INVALID_MATCHMAKING_SESSION_ID)
        {
            mSessionData->setSessionState(MatchmakingScenarioSessionData::CANCELLING);

            // Super user privilege needed or cancel will fail:
            UserSession::SuperUserPermissionAutoPtr superPtr(true);
            // This won't actually cancel the session if the join is already in progress.
            if (getIsPackerSession())
            {
                auto* gamepackerMaster = mScenarioOwner.getManager().getGamePackerMaster();
                if (gamepackerMaster == nullptr)
                {
                    ERR_LOG("[MatchmakingScenarioManager].getGamePackerMaster: Unable to resolve gamepacker master.");
                    return ERR_SYSTEM;
                }

                RpcCallOptions callopts;
                callopts.ignoreReply = true;
                CancelPackerSessionRequest packerReq;
                packerReq.setPackerSessionId(mSessionData->getSessionId());

                err = gamepackerMaster->cancelPackerSession(packerReq, callopts);  // We call the internal version of the command to avoid the need for a user session. 
                if (err == ERR_OK)
                {
                    // Technically, we could be completing matchmaking at the time of the cancel (hence MATCHMAKER_ERR_UNKNOWN_MATCHMAKING_SESSION_ID)
                    mSessionData->setSessionState(MatchmakingScenarioSessionData::FINISHED);
                }
                else
                {
                    ERR_LOG("[MatchmakingScenarioSession].cancel: An unexpected error (" << ErrorHelp::getErrorName(err) << ") occurred while attempting to cancel the scenario session. This indicates a scenario leak.");
                }
            }
            else
            {
                Blaze::Matchmaker::MatchmakerSlave* matchmakerComponent = getMatchmakerSlave();
                if (matchmakerComponent == nullptr)
                {
                    ERR_LOG("[MatchmakingScenarioSession].cancel: Unable to resolve matchmaker component.");
                    return ERR_SYSTEM;
                }

                CancelMatchmakingInternalRequest cancelRequest;
                cancelRequest.setMatchmakingSessionId(mSessionData->getSessionId());
                cancelRequest.setOwnerUserSessionId(mScenarioOwner.getHostUserSessionId());

                err = matchmakerComponent->cancelMatchmakingInternal(cancelRequest);  // We call the internal version of the command to avoid the need for a user session. 
                if (err == ERR_OK || err == MATCHMAKER_ERR_UNKNOWN_MATCHMAKING_SESSION_ID)
                {
                    // Technically, we could be completing matchmaking at the time of the cancel (hence MATCHMAKER_ERR_UNKNOWN_MATCHMAKING_SESSION_ID)
                    mSessionData->setSessionState(MatchmakingScenarioSessionData::FINISHED);
                }
                else
                {
                    ERR_LOG("[MatchmakingScenarioSession].cancel: An unexpected error (" << ErrorHelp::getErrorName(err) << ") occurred while attempting to cancel the scenario session. This indicates a scenario leak.");
                }
            }
        }

        return err;
    }

    const SubSessionName& MatchmakingScenarioSession::getSessionName() const
    { 
        return mConfigInfo.mSubSessionName; 
    }

    bool MatchmakingScenarioSession::getIsPackerSession() const
    {
        // PACKER_TODO: Code that determines whether a mm session is a packer session should be the same on both core slave and matchmaker side... See: MatchmakingSession::getCreateGameTemplateName() && MatchmakingSession::MatchmakingSession::initCreateGameRequest()
        bool isPackerSession = false;
        const auto& componentConfig = mScenarioOwner.getComponent().getConfig();
        const auto& scenariosMap = componentConfig.getScenariosConfig().getScenarios();
        auto& scenarioName = mScenarioOwner.getConfigInfo().getScenarioName();
        auto scenarioCfgItr = scenariosMap.find(scenarioName);
        if (scenarioCfgItr != scenariosMap.end())
        {
            auto subsessionCfgItr = scenarioCfgItr->second->getSubSessions().find(getSessionName());
            if (subsessionCfgItr != scenarioCfgItr->second->getSubSessions().end())
            {
                auto* createGameTemplateName = subsessionCfgItr->second->getCreateGameTemplate();
                const auto createGameTemplateItr = componentConfig.getCreateGameTemplatesConfig().getCreateGameTemplates().find(createGameTemplateName);
                if (createGameTemplateItr != componentConfig.getCreateGameTemplatesConfig().getCreateGameTemplates().end())
                {
                    const auto& packerConfig = createGameTemplateItr->second->getPackerConfig();
                    isPackerSession = !packerConfig.getQualityFactors().empty();
                }
            }
        }
        return isPackerSession;
    }

    MatchmakingScenarioConfigInfo::MatchmakingScenarioConfigInfo(const ScenarioName& scenarioName, const MatchmakingScenarioManager* manager) :
        mScenarioName(scenarioName),
        mConfigurationTimestamp(0),
        mOverallConfig(nullptr),
        mScenarioConfig(nullptr),
        mScenarioVariantsMap(BlazeStlAllocator("mScenarioVariantsMap", GameManagerSlave::COMPONENT_MEMORY_GROUP)),
        mScenarioManager(manager)
    {}

    MatchmakingScenarioConfigInfo::~MatchmakingScenarioConfigInfo()
    {
        clearScenarioVariants();
    }

    void MatchmakingScenarioConfigInfo::clearScenarioVariants()
    {
        mScenarioVariantsMap.clear();        
    }

    bool MatchmakingScenarioConfigInfo::configure(const ScenariosConfig& config)
    {
        clearScenarioVariants();

        ScenarioMap::const_iterator scenarioIter = config.getScenarios().find(mScenarioName);
        if (scenarioIter == config.getScenarios().end())
        {
            ERR_LOG("[MatchmakingScenarioConfigInfo].configure: Scenario named " << mScenarioName.c_str() << " does not exist.");
            return false;
        }
        mOverallConfig = &config;
        mScenarioConfig = scenarioIter->second;

        mTotalDuration = mScenarioConfig->getTotalDuration();

        const char8_t* defaultVariant = mScenarioConfig->getDefaultVariant();
        if (mScenarioConfig->getVariants().empty())
        {
            // Use all subSessions for this scenario            
            MatchmakingScenarioVariantConfigInfo* newSessionConfig = BLAZE_NEW MatchmakingScenarioVariantConfigInfo(defaultVariant, mScenarioManager, this);

            mScenarioVariantsMap[defaultVariant] = newSessionConfig;
            if (!newSessionConfig->configure(config))
            {
                ERR_LOG("[MatchmakingScenarioConfigInfo].configure: Error occurred while configuring scenario.");
                return false;
            }
        }
        else
        {
            VariantsMap::const_iterator curVariant = mScenarioConfig->getVariants().begin();
            VariantsMap::const_iterator endVariant = mScenarioConfig->getVariants().end();
            if (mScenarioConfig->getVariants().find(defaultVariant) == endVariant)
            {
                ERR_LOG("[MatchmakingScenarioConfigInfo].configure: Default variant " << defaultVariant << " does not exist in variants map from scenario " << mScenarioName);
                return false;
            }

            // iterate over the variants, and get them loaded:
            for (; curVariant != endVariant; ++curVariant)
            {
                const ScenarioVariantName& scenarioVariantName = curVariant->first;
                const ScenarioVariantConfig* variantDetail = curVariant->second;
                if (variantDetail->getSubSession().empty())
                {
                    ERR_LOG("[MatchmakingScenarioConfigInfo].configure: SubSessions for scenario variant " << scenarioVariantName << " in scenario " << mScenarioName << " is empty.");
                    return false;
                }

                MatchmakingScenarioVariantConfigInfo* newSessionConfig = BLAZE_NEW MatchmakingScenarioVariantConfigInfo(scenarioVariantName, mScenarioManager, this);
                mScenarioVariantsMap[scenarioVariantName.c_str()] = newSessionConfig;
                if (!newSessionConfig->configure(config))
                {
                    ERR_LOG("[MatchmakingScenarioConfigInfo].configure: Error occurred while configuring scenario variant " << scenarioVariantName
                        << ", in scenario " << mScenarioName << ".");
                    return false;
                }
            }

            // populate user variants map
            mScenarioConfig->getUserVariants().copyInto(mUserByVariantMap);
        }
        return true;
    }

    MatchmakingScenarioVariantConfigInfo::MatchmakingScenarioVariantConfigInfo(const ScenarioVariantName& variant, const MatchmakingScenarioManager* manager, const MatchmakingScenarioConfigInfo* owner) :
        mVariant(variant),
        mScenarioHash(EA::StdC::kCRC32InitialValue),
        mVersion(0),
        mIsSubVariant(false),
        mCriteriaExpression(nullptr),
        mOwner(owner),
        mScenarioVariantConfig(nullptr),
        mOverallConfig(nullptr),
        mScenarioManager(manager)
    {
    }

    MatchmakingScenarioVariantConfigInfo::~MatchmakingScenarioVariantConfigInfo()
    {
        clearSessionConfigs();
        delete mCriteriaExpression;
    }

    void MatchmakingScenarioVariantConfigInfo::clearSessionConfigs()
    {
        SessionConfigList::iterator curIter = mScenarioSessionConfigList.begin();
        SessionConfigList::iterator endIter = mScenarioSessionConfigList.end();
        for (; curIter != endIter; ++curIter)
        {
            delete (*curIter);
        }
        mScenarioSessionConfigList.clear();
    }

    bool MatchmakingScenarioVariantConfigInfo::configure(const ScenariosConfig& config)
    {
        clearSessionConfigs();
        
        mOverallConfig = mOwner->mOverallConfig;

        const char8_t* scenarioName = getScenarioName();
        ScenarioMap::const_iterator scenarioIter = config.getScenarios().find(scenarioName);
        if (scenarioIter == config.getScenarios().end())
        {
            ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Scenario named " << scenarioName << " does not exist.");
            return false;
        }

        mSubVariants.clear();
        mIsSubVariant = false;
        mScenarioVariantConfig = nullptr;

        const ScenarioConfig* scenarioConfig = scenarioIter->second;
        if (scenarioConfig->getVariants().empty())
        {
            // No Variants Set -  Use all subsessions by default
            SubSessionConfigMap::const_iterator curSession = scenarioConfig->getSubSessions().begin();
            SubSessionConfigMap::const_iterator endSession = scenarioConfig->getSubSessions().end();
            for (; curSession != endSession; ++curSession)
            {
                MatchmakingSubSessionConfigInfo* newSessionConfig = BLAZE_NEW MatchmakingSubSessionConfigInfo(curSession->first, this);
                mScenarioSessionConfigList.push_back(newSessionConfig);
                if (!newSessionConfig->configure(config))
                {
                    ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Error occurred while configuring subSession in variant " << mVariant 
                        << " for scenario " << scenarioName);
                    return false;
                }

                mCombinedSessionMode.getBits() |= newSessionConfig->mRequest.getSessionData().getSessionMode().getBits();
            }
        }
        else
        {
            // Variants are used: 
            VariantsMap::const_iterator variantIter = scenarioConfig->getVariants().find(mVariant);
            if (variantIter == scenarioConfig->getVariants().end())
            {
                ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Variant named " << mVariant.c_str() << " does not exist for scenario " << scenarioName);
                return false;
            }

            mScenarioVariantConfig = variantIter->second;
            mIsSubVariant = !mScenarioVariantConfig->getSubVariantOf().empty();

            // Verify that my sub-variants exist:  (If they don't it doesn't actually hurt anything, but it's probably a typo so we just return an error)
            {
                ScenarioVariantNameList::const_iterator curSubVariant = mScenarioVariantConfig->getSubVariantOf().begin();
                ScenarioVariantNameList::const_iterator endSubVariant = mScenarioVariantConfig->getSubVariantOf().end();
                for (; curSubVariant != endSubVariant; ++curSubVariant)
                {
                    // Check that they exist:
                    if (scenarioConfig->getVariants().find(*curSubVariant) == scenarioConfig->getVariants().end())
                    {
                        ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: SubVariant named " << curSubVariant->c_str() << " parent to variant " << mVariant.c_str() << " does not exist for scenario " << scenarioName);
                        return false;
                    }
                }
            }

            // Get a list of all variants that count me as a parent:
            VariantsMap::const_iterator curVariant = scenarioConfig->getVariants().begin();
            VariantsMap::const_iterator endVariant = scenarioConfig->getVariants().end();
            for (; curVariant != endVariant; ++curVariant)
            {
                ScenarioVariantNameList::const_iterator curSubVariant = curVariant->second->getSubVariantOf().begin();
                ScenarioVariantNameList::const_iterator endSubVariant = curVariant->second->getSubVariantOf().end();
                for (; curSubVariant != endSubVariant; ++curSubVariant)
                {
                    if (*curSubVariant == mVariant)
                    {
                        mSubVariants.push_back(curVariant->first);
                    }
                }
            }

            // iterate over the owning sessions, and get them loaded:
            SubSessionNameList& subSessionNameList = variantIter->second->getSubSession();
            if (subSessionNameList.empty())
            {
                ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Subsession list is empty in Variant " << mVariant
                    << " , scenario " << scenarioName);
                return false;
            }

            SubSessionNameList::const_iterator curSession = subSessionNameList.begin();
            SubSessionNameList::const_iterator endSession = subSessionNameList.end();
            for (; curSession != endSession; ++curSession)
            {
                SubSessionName subsession = *curSession;
                SubSessionConfigMap::const_iterator it = scenarioConfig->getSubSessions().find(subsession);
                if (it == scenarioConfig->getSubSessions().end())
                {
                    ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Subsession " << subsession << " listed in variant " << mVariant 
                        << " is not defined in scenario " << scenarioName);
                    return false;
                }

                MatchmakingSubSessionConfigInfo* newSessionConfig = BLAZE_NEW MatchmakingSubSessionConfigInfo(subsession, this);
                mScenarioSessionConfigList.push_back(newSessionConfig);
                if (!newSessionConfig->configure(config))
                {
                    ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Error occurred while configuring subSession in variant " << mVariant
                        << " for scenario " << scenarioName);
                    return false;
                }

                mCombinedSessionMode.getBits() |= newSessionConfig->mRequest.getSessionData().getSessionMode().getBits();
            }



            // We do the criteria creation/check last so that the subsessions will be available for getAttr() to use and lookup data. 
            if (!createCriteriaExpression())
            {
                ERR_LOG("[MatchmakingScenarioVariantConfigInfo].configure: Unable to parse/create criteria for Variant " << mVariant
                    << " , scenario " << scenarioName);
                return false;
            }
        }

        return true;
    }

    void MatchmakingScenarioVariantConfigInfo::getGlobalFilterPropertiesUsed(PropertyNameList& outProperties) const
    {
        const auto& filtersConfig = mScenarioManager->getComponent().getConfig().getFilters();

        for (const auto& curFilterName : mOverallConfig->getGlobalFilters())
        {
            const auto filterConfig = filtersConfig.find(curFilterName);
            if (filterConfig == filtersConfig.end())
            {
                ERR_LOG("getGlobalFilterPropertiesUsed: Filter " << curFilterName << " no longer exists.");
                return;
            }

            for (auto& tdfMapping : filterConfig->second->getRequirement())
            {
                for (auto& attrMapping : *tdfMapping.second)
                {
                    if (!attrMapping.second->getPropertyNameAsTdfString().empty())
                    {
                        outProperties.insertAsSet(attrMapping.second->getPropertyName());
                    }
                }
            }
        }
    }
    void MatchmakingScenarioVariantConfigInfo::getGlobalScenarioPropertiesUsed(PropertyNameList& outProperties) const
    {
        // Global Attributes:
        for (const auto& attrMapping : mOverallConfig->getGlobalAttributes())
        {
            if (!attrMapping.second->getPropertyNameAsTdfString().empty())
            {
                outProperties.insertAsSet(attrMapping.second->getPropertyName());
            }
        }

        // Get the properties from each rule value:
        for (const auto& ruleIter : mOverallConfig->getGlobalRules())
        {
            // Custom name, then the real name:
            for (const auto& customNameMap : *ruleIter.second)
            {
                for (const auto& attrMapping : *customNameMap.second)
                {
                    if (!attrMapping.second->getPropertyNameAsTdfString().empty())
                    {
                        outProperties.insertAsSet(attrMapping.second->getPropertyName());
                    }
                }
            }
        }
    }

    void MatchmakingScenarioVariantConfigInfo::resolveCriteriaVariable(const char8_t* nameSpace, const char8_t* name, Blaze::ExpressionValueType type,
        const void* context, Blaze::Expression::ExpressionVariableVal& val)
    {
        // Info needs to persist until the criteria is done evaluating:
        VariantCriteriaCheckInfo* info = (VariantCriteriaCheckInfo*)(context);

        val.intVal = 0;
        if (blaze_stricmp(name, "pmr") == 0)
        {
            bool found = false;
            val.floatVal = 0;
            const GameManagerCensusData& censusData = info->mVariantInfo->mOwner->mScenarioManager->getGameManagerCensusData();

            auto& scenarioCensusData = censusData.getMatchmakingCensusData().getScenarioMatchmakingData();
            ScenarioMatchmakingCensusDataMap::const_iterator scenarioCensusDataItr = scenarioCensusData.find(info->mVariantInfo->getScenarioName());
            if (scenarioCensusDataItr != scenarioCensusData.end())
            {
                const auto& pmrByPingsite = scenarioCensusDataItr->second->getPlayerMatchmakingRatePerPingsiteGroup().find(info->mHostUserInfo->getBestPingSiteAlias());
                if (pmrByPingsite != scenarioCensusDataItr->second->getPlayerMatchmakingRatePerPingsiteGroup().end())
                {
                    const auto& pmrByGroup = pmrByPingsite->second->find(info->mRequest->getCommonGameData().getDelineationGroup());
                    if (pmrByGroup != pmrByPingsite->second->end())
                    {
                        val.floatVal = pmrByGroup->second;
                        found = true;
                    }
                }

                // If the value was not found, attempt to use the global data instead:
                if (!found)
                {
                    val.floatVal = scenarioCensusDataItr->second->getGlobalPlayerMatchmakingRate();
                }
            }
            // else if the stats are missing, just assume it's 0.
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: pmr value looked up as " << val.floatVal << " for scenario " << info->mVariantInfo->getScenarioName() << " ping site " << info->mHostUserInfo->getBestPingSiteAlias());
            return;
        }
        else if (blaze_stricmp(name, "ttm") == 0)
        {
            const GameManagerCensusData& censusData = info->mVariantInfo->mOwner->mScenarioManager->getGameManagerCensusData();
            
            auto& scenarioCensusData = censusData.getMatchmakingCensusData().getScenarioMatchmakingData();
            ScenarioMatchmakingCensusDataMap::const_iterator scenarioCensusDataItr = scenarioCensusData.find(info->mVariantInfo->getScenarioName());
            if (scenarioCensusDataItr != scenarioCensusData.end())
            {
                auto& pingSiteCensusData = scenarioCensusDataItr->second->getEstimatedTimeToMatchPerPingsiteGroup();
                auto ttmByPingsite = pingSiteCensusData.find(info->mHostUserInfo->getBestPingSiteAlias());
                if (ttmByPingsite != pingSiteCensusData.end())
                {
                    const auto& ttmByGroup = ttmByPingsite->second->find(info->mRequest->getCommonGameData().getDelineationGroup());
                    if (ttmByGroup != ttmByPingsite->second->end())
                    {
                        val.intVal = ttmByGroup->second.getMicroSeconds();
                    }
                }

                // If the value was not found, attempt to use the global data instead:
                if (val.intVal == 0)
                {
                    val.intVal = scenarioCensusDataItr->second->getGlobalEstimatedTimeToMatch().getMicroSeconds();
                }
            }
            // else if the stats are missing, just assume it's 0.
                
           
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: ttm value looked up as " << val.intVal << " for scenario " << info->mVariantInfo->getScenarioName() << " ping site " << info->mHostUserInfo->getBestPingSiteAlias());
            return;
        }
        else if (blaze_stricmp(name, "testGroup") == 0)
        {
            val.stringVal = info->mRecoGroup->c_str();
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: testGroup value looked up as " << val.stringVal);
            return;
        }
        else if (blaze_stricmp(name, "groupSize") == 0)
        {
            val.intVal = info->mRequest->getPlayerJoinData().getPlayerDataList().size();
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: groupSize value looked up as " << val.intVal);
            return;
        }
        else if (blaze_stricmp(name, "hostPingSite") == 0)
        {
            val.stringVal = info->mHostUserInfo->getBestPingSiteAlias();
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: hostPingSite value looked up as " << val.stringVal);
            return;
        }
        else if (blaze_stricmp(name, "hostBlazeId") == 0)
        {
            val.intVal = info->mHostUserInfo->getUserInfo().getId();
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: hostBlazeId value looked up as " << val.intVal);
            return;
        }
        else if (blaze_stricmp(name, "time") == 0)
        {
            val.intVal = EA::TDF::TimeValue::getTimeOfDay().getMicroSeconds();
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: time value looked up as " << val.intVal);
            return;
        }
        else if (blaze_stricmp(name, "weekday") == 0)
        {
            TimeValue curTime = EA::TDF::TimeValue::getTimeOfDay();
            uint32_t timeVal = 0;
            TimeValue::getGmTimeComponents(curTime, nullptr, nullptr, &timeVal, nullptr, nullptr, nullptr, nullptr);
            val.intVal = (int64_t)timeVal;
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: weekday value looked up as " << val.intVal);
            return;
        }
        else if (blaze_stricmp(name, "hour") == 0)
        {
            TimeValue curTime = EA::TDF::TimeValue::getTimeOfDay();
            uint32_t timeVal = 0;
            TimeValue::getGmTimeComponents(curTime, nullptr, nullptr, nullptr, &timeVal, nullptr, nullptr, nullptr);
            val.intVal = (int64_t)timeVal;
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: hour value looked up as " << val.intVal);
            return;
        }
        else if (blaze_stricmp(name, "minute") == 0)
        {
            TimeValue curTime = EA::TDF::TimeValue::getTimeOfDay();
            uint32_t timeVal = 0;
            TimeValue::getGmTimeComponents(curTime, nullptr, nullptr, nullptr, nullptr, &timeVal, nullptr, nullptr);
            val.intVal = (int64_t)timeVal;
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: minute value looked up as " << val.intVal);
            return;
        }
        else if (blaze_stricmp(name, "protocolVersion") == 0)
        {
            val.stringVal = info->mRequest->getCommonGameData().getGameProtocolVersionString();
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: protocolVersion value looked up as " << val.stringVal);
            return;
        }
        else if (blaze_stricmp(name, "platform") == 0)
        {
            val.stringVal = ClientPlatformTypeToString(info->mHostUserInfo->getUserInfo().getPlatformInfo().getClientPlatform());
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: platform value looked up as " << val.stringVal);
            return;
        }

        info->mResolveError = true;
        BLAZE_ERR_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaVariable: Unexpected value '" << nameSpace << " " << name << "' requested in criteria.");
    }

    void MatchmakingScenarioVariantConfigInfo::resolveCriteriaValueType(const char8_t* nameSpace, const char8_t* name, void* context, Blaze::ExpressionValueType& type)
    {
        if (blaze_stricmp(name, "pmr") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_FLOAT;
            return;
        }
        else if (blaze_stricmp(name, "ttm") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "testGroup") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_STRING;
            return;
        }
        else if (blaze_stricmp(name, "groupSize") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "hostPingSite") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_STRING;
            return;
        }
        else if (blaze_stricmp(name, "hostBlazeId") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "time") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "weekday") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "hour") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "minute") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_INT;
            return;
        }
        else if (blaze_stricmp(name, "protocolVersion") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_STRING;
            return;
        }
        else if (blaze_stricmp(name, "platform") == 0)
        {
            type = Blaze::EXPRESSION_TYPE_STRING;
            return;
        }

        BLAZE_ERR_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].resolveCriteriaValueType: Unexpected value '" << nameSpace << " " << name << "' requested in criteria.");
    }

    class FunctionExpressionIsAttrSet : public FunctionExpression
    {                                                                                       
    public:                                                                                 
        FunctionExpressionIsAttrSet(char8_t* functionName, ExpressionArgumentList& args)
            : FunctionExpression(functionName, args)
        {
            mType = EXPRESSION_TYPE_INT;
            if (args.getArgumentList().size() != 1)
            {
                BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionIsAttrSet] Only takes 1 string Arg (ex. isAttrSet('GAME_MODE') ), not " << args.getArgumentList().size() << " arguments");
                ++mErrorCount;
            }

            ArgumentList::const_iterator iter = args.getArgumentList().begin();
            const Expression* arg = *iter;
            if (!arg->isString())
            {
                BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionIsAttrSet] Argument must evaluate to a string.");
                ++mErrorCount;
            }
        }
        ~FunctionExpressionIsAttrSet() override {}
        int64_t evalInt(ResolveVariableCb &cb, const void* context) const override
        {
            MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo* info = (MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo*)(context);
            char8_t argName[64] = "";
            (*mArgs.getArgumentList().begin())->evalString(cb, context, argName, sizeof(argName));
            int64_t returnVal = (info->mRequest->getScenarioAttributes().find(argName) != info->mRequest->getScenarioAttributes().end()) ? 1 : 0;
            BLAZE_SPAM_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionIsAttrSet].evalInt: isAttrSet value calculated as " << returnVal << " for argument " << argName);
            return returnVal;
        }
        float_t evalFloat(ResolveVariableCb &cb, const void* context) const override
        {
            return float_t(evalInt(cb, context));
        }
        bool isConst() const override { return false; }
    };

    class FunctionExpressionHostUEDValue : public FunctionExpression
    {
    public:
        FunctionExpressionHostUEDValue(char8_t* functionName, ExpressionArgumentList& args)
            : FunctionExpression(functionName, args)
        {
            mType = EXPRESSION_TYPE_INT;
            if (args.getArgumentList().size() != 1)
            {
                BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionHostUEDValue]: Only takes 1 string or int Arg (ex. hostUEDValue('stats_skillA') or hostUEDValue(10) ), not " << args.getArgumentList().size() << " arguments");
                ++mErrorCount;
            }

            ArgumentList::const_iterator iter = args.getArgumentList().begin();
            const Expression* arg = *iter;
            if (!arg->isString() && !arg->isInt())
            {
                BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionHostUEDValue]: Argument must evaluate to a string or int.");
                ++mErrorCount;
            }
        }
        ~FunctionExpressionHostUEDValue() override {}
        int64_t evalInt(ResolveVariableCb &cb, const void* context) const override
        {
            UserExtendedDataKey dataKey = 0;
            if ((*mArgs.getArgumentList().begin())->isString())
            {
                char8_t argName[64] = "";
                (*mArgs.getArgumentList().begin())->evalString(cb, context, argName, sizeof(argName));
                if (!gUserSessionManager->getUserExtendedDataKey(argName, dataKey))
                {
                    BLAZE_SPAM_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionHostUEDValue].evalInt: hostUedValue value missing (can't lookup key string). Used 0 instead.");
                    return 0;
                }
            }
            else if ((*mArgs.getArgumentList().begin())->isInt())
            {
                dataKey = (UserExtendedDataKey)(*mArgs.getArgumentList().begin())->evalInt(cb, context);
            }

            MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo* info = (MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo*)(context);
            auto uedIter = info->mHostUserInfo->getDataMap().find(dataKey);
            if (uedIter == info->mHostUserInfo->getDataMap().end())
            {
                BLAZE_SPAM_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionHostUEDValue].evalInt: hostUedValue value missing. Used 0 instead.");
                return 0;
            }

            BLAZE_SPAM_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionHostUEDValue].evalInt: hostUedValue value calculated as " << uedIter->second);
            return uedIter->second;
        }
        float_t evalFloat(ResolveVariableCb &cb, const void* context) const override
        {
            return float_t(evalInt(cb, context));
        }
        bool isConst() const override { return false; }
    };

    class FunctionExpressionGetAttr : public FunctionExpression
    {
    public:
        FunctionExpressionGetAttr(char8_t* functionName, ExpressionArgumentList& args)
            : FunctionExpression(functionName, args)
        {
            mType = EXPRESSION_TYPE_STRING;

            if (args.getArgumentList().size() != 1)
            {
                BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionGetAttr]: Only takes 1 string or int Arg (ex. getAttr('GAME_MODE')), not " << args.getArgumentList().size() << " arguments");
                ++mErrorCount;
            }

            ArgumentList::const_iterator iter = args.getArgumentList().begin();
            const Expression* arg = *iter;
            if (!arg->isString())
            {
                BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionGetAttr]: Argument must evaluate to a string.");
                ++mErrorCount;
            }
        }
        ~FunctionExpressionGetAttr() override {}
        int64_t evalInt(ResolveVariableCb &cb, const void* context) const override
        {
            if ((*mArgs.getArgumentList().begin())->isString())
            {
                char8_t argName[64] = "";
                (*mArgs.getArgumentList().begin())->evalString(cb, context, argName, sizeof(argName));

                MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo* info = (MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo*)(context);
                const auto& scenarioAttr = info->mRequest->getScenarioAttributes().find(argName);
                if (scenarioAttr != info->mRequest->getScenarioAttributes().end())
                {
                    int64_t outValue = 0;
                    if (scenarioAttr->second->convertToResult(outValue))
                        return outValue;
                }
                BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionGetAttr]: warning: attribute(" << argName << ") not evaluatable, returning 0.");
            }
            return 0;
        }
        float_t evalFloat(ResolveVariableCb &cb, const void* context) const override
        {
            if ((*mArgs.getArgumentList().begin())->isString())
            {
                char8_t argName[64] = "";
                (*mArgs.getArgumentList().begin())->evalString(cb, context, argName, sizeof(argName));

                MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo* info = (MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo*)(context);
                const auto& scenarioAttr = info->mRequest->getScenarioAttributes().find(argName);
                if (scenarioAttr != info->mRequest->getScenarioAttributes().end())
                {
                    float outValue = 0;
                    if (scenarioAttr->second->convertToResult(outValue))
                        return outValue;
                }
                BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionGetAttr]: warning: attribute(" << argName << ") not evaluatable, returning 0.");
            }

            return 0;
        }
        int32_t evalString(ResolveVariableCb &cb, const void* context, char8_t* buf, int32_t bufLen) const override
        {
            if ((*mArgs.getArgumentList().begin())->isString())
            {
                char8_t argName[64] = "";
                (*mArgs.getArgumentList().begin())->evalString(cb, context, argName, sizeof(argName));

                MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo* info = (MatchmakingScenarioVariantConfigInfo::VariantCriteriaCheckInfo*)(context);
                const auto& scenarioAttr = info->mRequest->getScenarioAttributes().find(argName);
                if (scenarioAttr != info->mRequest->getScenarioAttributes().end())
                {
                    EA::TDF::TdfString outValue;
                    if (scenarioAttr->second->convertToResult(outValue))
                        return blaze_snzprintf(buf, bufLen, outValue.c_str());
                }
                BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[FunctionExpressionGetAttr]: warning: attribute(" << argName << ") not evaluatable, returning 0.");
            }

            if (bufLen > 0)
                buf[0] = '\0';

            return 0;
        }
        bool isConst() const override { return false; }
    };

    void MatchmakingScenarioVariantConfigInfo::resolveCriteriaFunctions(char8_t* functionName, class Blaze::ExpressionArgumentList& args, void* context, Blaze::Expression*& outNewExpression)
    {
        if (blaze_stricmp(functionName, "isAttrSet") == 0)
        {
            outNewExpression = (Blaze::Expression*)(BLAZE_NEW FunctionExpressionIsAttrSet(functionName, args));
        }
        else if (blaze_stricmp(functionName, "hostUedValue") == 0)
        {
            outNewExpression = (Blaze::Expression*)(BLAZE_NEW FunctionExpressionHostUEDValue(functionName, args));
        }
        else if (blaze_stricmp(functionName, "getAttr") == 0)
        {
            outNewExpression = (Blaze::Expression*)(BLAZE_NEW FunctionExpressionGetAttr(functionName, args));
        }
    }

    bool MatchmakingScenarioVariantConfigInfo::createCriteriaExpression()
    {
        // If we don't have criteria, skip this logic:
        if (mScenarioVariantConfig == nullptr || mScenarioVariantConfig->getCriteria()[0] == '\0')
        {
            if (mCriteriaExpression != nullptr)
            {
                delete mCriteriaExpression;
                mCriteriaExpression = nullptr;
            }
            return true;
        }

        // Setup and call lex and yacc to parse the derived formula into a hierarchy of expressions
        static BlazeLexer::LexResolveTypeCb typeCb(&MatchmakingScenarioVariantConfigInfo::resolveCriteriaValueType);
        static BlazeLexer::LexResolveFunctionCb functionCb(&MatchmakingScenarioVariantConfigInfo::resolveCriteriaFunctions);

        BlazeLexer lexer(mScenarioVariantConfig->getCriteria(), (void*)this, typeCb, &functionCb);
        blazeparse(&lexer);

        // Pull the resulting expression back out of the lexer object (though the expression objects
        // are generated by yacc, the lexer is an object that we own here so it also serves as a
        // general purpose data passing mechanism)
        Blaze::Expression* expression = lexer.getExpression();
        if (expression == nullptr)
        {
            BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].createCriteriaExpression: encountered a grammatical error while parsing scenario variant criteria expression: " << mScenarioVariantConfig->getCriteria());
            return false;
        }
        else if (expression->getErrorCount() > 0)
        {
            BLAZE_WARN_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].createCriteriaExpression: encountered  encountered (" << expression->getErrorCount() << ") errors while parsing scenario variant criteria expression: " << mScenarioVariantConfig->getCriteria());
            delete expression;
            return false;
        }

        if (mCriteriaExpression != nullptr)
        {
            // destroy the old one because we must be re-configuring
            // wait until this point because we don't want to wipe the old until we know the new one is valid
            delete mCriteriaExpression;
        }

        mCriteriaExpression = expression;
        return true;
    }

    bool MatchmakingScenarioVariantConfigInfo::checkCriteria(VariantCriteriaCheckInfo& info) const
    {
        static Expression::ResolveVariableCb resolveCriteriaVariableCb(&MatchmakingScenarioVariantConfigInfo::resolveCriteriaVariable);
        if (mCriteriaExpression != nullptr)
        {
            info.mResolveError = false;
            info.mVariantInfo = this;
            int64_t eval = mCriteriaExpression->evalInt(resolveCriteriaVariableCb, &info);
            if (info.mResolveError == false)
            {
                BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].checkCriteria: Evaluation for criteria of variant " << mVariant.c_str() << " returned " << eval );
                return eval != 0;
            }
        }
        else
        {
            BLAZE_TRACE_LOG(BlazeRpcLog::matchmaker, "[MatchmakingScenarioVariantConfigInfo].checkCriteria: Missing criteria for variant " << mVariant.c_str());
        }

        return false;
    }

    EA::TDF::TimeValue MatchmakingScenarioVariantConfigInfo::getTotalDurationFromConfig() const
    {
        // Iterate over all subsessions, use the greatest session end time, or total duration:
        EA::TDF::TimeValue endTime = mOwner->mTotalDuration;

        for (auto& curSession : mScenarioSessionConfigList)
        {
            EA::TDF::TimeValue subsessionEndTime = curSession->mSubSessionConfig->getSessionEndTime();
            if (subsessionEndTime > endTime)
                endTime = subsessionEndTime;
        }

        return endTime;
    }

    MatchmakingSubSessionConfigInfo::MatchmakingSubSessionConfigInfo(const SubSessionName& subSessionName, const MatchmakingScenarioVariantConfigInfo* owner) :
        mSubSessionName(subSessionName),
        mOwner(owner),
        mOverallConfig(nullptr),
        mSubSessionConfig(nullptr)
    {}

    bool MatchmakingSubSessionConfigInfo::configure(const ScenariosConfig& config)
    {
        mOverallConfig = mOwner->mOverallConfig;

        // Verify that owner really exists (probably not needed)

        const char8_t* scenarioName = getScenarioName();
        ScenarioMap::const_iterator scenarioIter = config.getScenarios().find(scenarioName);
        if (scenarioIter == config.getScenarios().end())
        {
            ERR_LOG("[MatchmakingSubSessionConfigInfo].configure: Scenario named " << scenarioName << " does not exist.");
            return false;
        }

        const ScenarioConfig* scenarioConfig = scenarioIter->second;
        const SubSessionConfigMap& subSessions = scenarioConfig->getSubSessions();
        if (subSessions.find(mSubSessionName) == subSessions.end())
        {
            ERR_LOG("[MatchmakingSubSessionConfigInfo].configure: Scenario subsession named " << mSubSessionName.c_str() << " does not exist.");
            return false;
        }

        mSubSessionConfig = subSessions.find(mSubSessionName)->second;

        if (!addGlobalAndScenarioRules(config))
        {
            return false;//logged
        }

        // Copy the Basic config, fill out the start delay & duration:
        mSubSessionConfig->getMatchmakingSettings().copyInto(mRequest.getSessionData());
        
        // Session End Time is used by default.  If unset then the total duration is used instead.
        EA::TDF::TimeValue endTime = mSubSessionConfig->getSessionEndTime();
        if (endTime == 0)
        {
            endTime = scenarioConfig->getTotalDuration();
        }

        // Invalid Time Settings:
        if (mSubSessionConfig->getSessionStartTime() > endTime)
        {
            ERR_LOG("[MatchmakingSubSessionConfigInfo].configure: Session start time ("<< mSubSessionConfig->getSessionStartTime().getMillis() <<" ms)  is after session end time ("
                    << endTime.getMillis() <<" ms) for Scenario " << scenarioName <<" Subsession " << mSubSessionName.c_str() << ".");
            return false;
        }

        EA::TDF::TimeValue startTime = mSubSessionConfig->getSessionStartTime();
        EA::TDF::TimeValue sessionDuration = endTime - mSubSessionConfig->getSessionStartTime();
        mRequest.getSessionData().setSessionDuration(sessionDuration);
        mRequest.getSessionData().setStartDelay(startTime);

        if (config.getStartSubsessionsDecayed())
            mRequest.getSessionData().setStartingDecayAge(startTime);
        else
            mRequest.getSessionData().setStartingDecayAge(0);

        return true;
    }

    void MatchmakingSubSessionConfigInfo::getScenarioPropertiesUsed(PropertyNameList& outProperties) const
    {
        // Get the properties from each rule value:
        for (const auto& curRuleName : mSubSessionConfig->getRulesList())
        {
            const auto& ruleIter = mOverallConfig->getScenarioRuleMap().find(curRuleName);
            if (ruleIter == mOverallConfig->getScenarioRuleMap().end())
            {
                // Using a rule that doesn't exist anymore
                ERR_LOG("[MatchmakingSubSessionConfigInfo].addGlobalAndScenarioRules: Unable to find rule named " << curRuleName.c_str()
                    << " for Scenario " << getScenarioName() << " subsession " << mSubSessionName.c_str() << ".");
                return;
            }

            // Custom name, then the real name:
            for (const auto& customNameMap : *ruleIter->second)
            {
                for (const auto& attrMapping : *customNameMap.second)
                {
                    if (!attrMapping.second->getPropertyNameAsTdfString().empty())
                    {
                        outProperties.insertAsSet(attrMapping.second->getPropertyName());
                    }
                }
            }
        }

        // Get the Properties for each CG template / Packer Config:
        // PACKER_TODO:  Have to revise this somehow.  Properties that come from PackerSilo/Packer are inaccessible here, but will be available later. 
        if (!mSubSessionConfig->getCreateGameTemplateAsTdfString().empty())
        {
            CreateGameTemplateMap::const_iterator templateIter = mOwner->mScenarioManager->getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().find(mSubSessionConfig->getCreateGameTemplate());
            if (templateIter == mOwner->mScenarioManager->getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().end())
            {
                ERR_LOG("[MatchmakingSubSessionConfigInfo].addGlobalAndScenarioRules: Unable to find rule named " << mSubSessionConfig->getCreateGameTemplate()
                    << " for Scenario " << getScenarioName() << " subsession " << mSubSessionName.c_str() << ".");

                return;
            }

            CreateGameTemplate& templateConfig = (*templateIter->second);
            for (const auto& attrMapping : templateConfig.getAttributes())
            {
                if (!attrMapping.second->getPropertyNameAsTdfString().empty())
                {
                    outProperties.insertAsSet(attrMapping.second->getPropertyName());
                }
            }

            // This might not make sense, since the packer config likely depends on properties from the Filters

            // PACKER_TODO - Implement this after revising the packer config to use TdfMapping. 
//            for (const auto& qualityFactor : templateConfig.getPackerConfig().getQualityFactors())
//            {
//            }
        }
    }
    
    void MatchmakingSubSessionConfigInfo::getFilterPropertiesUsed(PropertyNameList& outProperties) const
    {
        const auto& filtersConfig = mOwner->mScenarioManager->getComponent().getConfig().getFilters();

        // Local PropertyFilters:
        for (const auto& curFilterName : mSubSessionConfig->getFiltersList())
        {
            const auto filterConfig = filtersConfig.find(curFilterName);
            if (filterConfig == filtersConfig.end())
            {
                ERR_LOG("getFilterPropertiesUsed: Filter " << curFilterName << " no longer exists.");
                return;
            }

            for (auto& tdfMapping : filterConfig->second->getRequirement())
            {
                for (auto& attrMapping : *tdfMapping.second)
                {
                    if (!attrMapping.second->getPropertyNameAsTdfString().empty())
                    {
                        outProperties.insertAsSet(attrMapping.second->getPropertyName());
                    }
                }
            }
        }
    }

    void MatchmakingSubSessionConfigInfo::getPackerPropertiesUsed(PropertyNameList& outProperties) const
    {
        // Packer Config Properties: 
        const auto& cgTemplatesConfig = mOwner->mScenarioManager->getComponent().getConfig().getCreateGameTemplatesConfig();

        const char8_t* templateName = mSubSessionConfig->getCreateGameTemplate();
        if (templateName[0] != '\0')
        {
            // Hardcoded requirement for all Packer instances:  (To hold PlayerIds)
            // PACKER_TODO:  In the future, it may make sense to put all the relevant UserSessionInfo values into Properties. 
            outProperties.insertAsSet(PropertyManager::PROPERTY_PLAYER_PARTICIPANT_IDS);

            CreateGameTemplateMap::const_iterator templateIter = cgTemplatesConfig.getCreateGameTemplates().find(templateName);
            if (templateIter != cgTemplatesConfig.getCreateGameTemplates().end())
            {
                // Get the Properties that will be required for the Players that are used in the Packer configs: 
                mOwner->mScenarioManager->getPropertyManager().configGamePropertiesPropertyNameList(templateIter->second->getPackerConfig(), outProperties);
            }
        }
    }

    bool MatchmakingSubSessionConfigInfo::addGlobalAndScenarioRules(const ScenariosConfig& config)
    {
        // Collect the global/other attributes:
        ScenarioRuleMap::const_iterator curGlobalRule = config.getGlobalRules().begin();
        ScenarioRuleMap::const_iterator endGlobalRule = config.getGlobalRules().end();
        for (; curGlobalRule != endGlobalRule; ++curGlobalRule)
        {
            if (!addRule(*curGlobalRule->second))
            {
                // Invalid config
                ERR_LOG("[MatchmakingSubSessionConfigInfo].addGlobalAndScenarioRules: Unable to add global rule " << curGlobalRule->first.c_str()
                    << " for Scenario " << getScenarioName() << " subsession " << mSubSessionName.c_str() << ".");
                return false;
            }
        }

        // Add the SubSession Attributes:
        ScenarioRuleNameList::const_iterator curSessionRule = mSubSessionConfig->getRulesList().begin();
        ScenarioRuleNameList::const_iterator endSessionRule = mSubSessionConfig->getRulesList().end();
        for (; curSessionRule != endSessionRule; ++curSessionRule)
        {
            ScenarioRuleMap::const_iterator ruleIter = config.getScenarioRuleMap().find(*curSessionRule);
            if (ruleIter == config.getScenarioRuleMap().end())
            {
                // Using a rule that doesn't exist anymore
                ERR_LOG("[MatchmakingSubSessionConfigInfo].addGlobalAndScenarioRules: Unable to find rule named " << curSessionRule->c_str()
                    << " for Scenario " << getScenarioName() << " subsession " << mSubSessionName.c_str() << ".");
                return false;
            }

            if (!addRule(*ruleIter->second))
            {
                // Invalid config
                ERR_LOG("[MatchmakingSubSessionConfigInfo].addGlobalAndScenarioRules: Unable to add rule " << curSessionRule->c_str()
                    << " for Scenario " << getScenarioName() << " subsession " << mSubSessionName.c_str() << ".");
                return false;
            }
        }

        return true;
    }

    bool MatchmakingSubSessionConfigInfo::addRule(const ScenarioRuleAttributes& ruleAttributes)
    {
        EA::TDF::TdfFactory& tdfFactory = EA::TDF::TdfFactory::get();
        ScenarioRuleAttributes::const_iterator curRule = ruleAttributes.begin();
        ScenarioRuleAttributes::const_iterator endRule = ruleAttributes.end();
        for (; curRule != endRule; ++ curRule)
        {
            ScenarioAttributeMapping::const_iterator curRuleAttr = curRule->second->begin();
            ScenarioAttributeMapping::const_iterator endRuleAttr = curRule->second->end();
            for (; curRuleAttr != endRuleAttr; ++ curRuleAttr)
            {
                // Lookup the name: 
                const char8_t* mappedValue = nullptr;
                if (!tdfFactory.lookupTypeName(curRule->first.c_str(), curRuleAttr->first.c_str(), mappedValue, true))
                {
                    // Unable to lookup mapped value:
                    ERR_LOG("[MatchmakingSubSessionConfigInfo].addRule: Unable to lookup type for Rule: " << curRule->first.c_str() 
                            << " type: " << curRuleAttr->first.c_str()
                            << " for Scenario " << getScenarioName() <<" subsession " << mSubSessionName.c_str() << ".");
                    return false;
                }

                TRACE_LOG("[MatchmakingSubSessionConfigInfo].addRule: Found type(" << mappedValue << ") for Rule: " << curRule->first.c_str()
                    << " type: " << curRuleAttr->first.c_str() << ", attrName: " << curRuleAttr->second->getAttrName()
                    << " for Scenario " << getScenarioName() << " subsession " << mSubSessionName.c_str() << ".");

                EA::TDF::TdfGenericReference refValue;
                EA::TDF::TdfString stringValue = mappedValue;
                EA::TDF::TdfGenericReferenceConst refKey(stringValue);
                if (!mScenarioAttributeMapping.insertKeyGetValue(refKey, refValue))
                {
                    // Value is already mapped:
                    ERR_LOG("[MatchmakingSubSessionConfigInfo].addRule: Data value already exists for value: " << mappedValue << " Rule: " << curRule->first.c_str() 
                            << " for Scenario " << getScenarioName() <<" subsession " << mSubSessionName.c_str() << ".");
                    return false;
                }

                refValue.setValue(EA::TDF::TdfGenericReferenceConst(curRuleAttr->second));
            }
        }

        return true;
    }
    
    BlazeRpcError MatchmakingScenarioVariantConfigInfo::applyGlobalAttributes(const ScenarioAttributes& clientAttributes, const PropertyNameMap& clientProperties, StartMatchmakingRequest& outRequest, MatchmakingCriteriaError &outErr) const
    {
        const char8_t* failingAttr = "";
        StringBuilder componentDescription;
        componentDescription << "In MatchmakingScenarioVariantConfigInfo::applyGlobalAttributes for scenario "<< getScenarioName().c_str();
        BlazeRpcError finalResult = applyTemplateAttributes(EA::TDF::TdfGenericReference(outRequest), mOverallConfig->getGlobalAttributes(), clientAttributes, clientProperties, failingAttr, componentDescription.get());
        if (finalResult != ERR_OK)
        {
            char8_t msg[MatchmakingCriteriaError::MAX_ERRMESSAGE_LEN];
            blaze_snzprintf(msg, sizeof(msg), "Unable to apply default from config for the attribute \"%s\" in scenario \"%s\", sub session \"%s\".", failingAttr, getScenarioName().c_str(), "(Global)");
            outErr.setErrMessage(msg);
                
            // Switch from the TEMPLATE error, to the SCENARIO one:
            finalResult = (finalResult == GAMEMANAGER_ERR_INVALID_TEMPLATE_ATTRIBUTE) ? GAMEMANAGER_ERR_INVALID_SCENARIO_ATTRIBUTE : GAMEMANAGER_ERR_MISSING_SCENARIO_ATTRIBUTE;
        }
        return finalResult;
    }

    BlazeRpcError MatchmakingSubSessionConfigInfo::createStartMatchmakingRequest(const ScenarioAttributes& clientAttributes, const PropertyNameMap& clientProperties, StartMatchmakingRequest& outRequest,
        StartMatchmakingInternalRequest& masterRequest, MatchmakingCriteriaError &outErr) const
    {
        // Note: We don't currently check for unused attributes, just missing ones.
        mRequest.copyInto(outRequest);
        StringBuilder componentDescription;
        componentDescription << "In MatchmakingSubSessionConfigInfo::createStartMatchmakingRequest for scenario " << getScenarioName().c_str()<< " and subsession " << mSubSessionName.c_str();

        BlazeRpcError finalResult = ERR_OK;
        const char8_t* failingAttr = "";
        if (mSubSessionConfig && mOverallConfig)
        {
            CreateGameRequest cgReq;

            // Update the CG Template information:
            const char8_t* templateName = mSubSessionConfig->getCreateGameTemplate();
            bool isPackerTemplate = false;
            if (templateName[0] != '\0')
            {
                masterRequest.setCreateGameTemplateName(templateName);

                CreateGameTemplateMap::const_iterator templateIter = mOwner->mScenarioManager->getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().find(templateName);
                if (templateIter == mOwner->mScenarioManager->getComponent().getConfig().getCreateGameTemplatesConfig().getCreateGameTemplates().end())
                {
                    char8_t msg[MatchmakingCriteriaError::MAX_ERRMESSAGE_LEN];
                    blaze_snzprintf(msg, sizeof(msg), "Unable to find Create Game Template \"%s\" for scenario \"%s\", sub session \"%s\".", templateName, getScenarioName().c_str(), mSubSessionName.c_str());
                    outErr.setErrMessage(msg);

                    return GAMEMANAGER_ERR_INVALID_TEMPLATE_NAME;
                }
        
                CreateGameTemplate& templateConfig = (*templateIter->second);
                isPackerTemplate = !templateConfig.getPackerConfig().getQualityFactors().empty();

                // Start with the Base + GameType: 
                templateConfig.getBaseRequest().copyInto(cgReq);          
                outRequest.getCommonGameData().setGameType(templateConfig.getBaseRequest().getCommonGameData().getGameType());          
                
                // Add in attribute data: 
                finalResult = applyTemplateAttributes(EA::TDF::TdfGenericReference(cgReq), templateConfig.getAttributes(), clientAttributes, clientProperties, failingAttr, componentDescription.get());
                if (finalResult == ERR_OK)
                {
                    // Copy over to real location: 
                    cgReq.getGameCreationData().copyInto(outRequest.getGameCreationData());

                    if (!templateConfig.getExternalDataSourceApiList().empty())
                    {
                        templateConfig.getExternalDataSourceApiList().copyInto(outRequest.getGameCreationData().getDataSourceNameList()); 
                    }

                    failingAttr = "";
                    
                    templateConfig.getFindDedicatedServerRulesMap().copyInto(masterRequest.getFindDedicatedServerRulesMap());

                    // overwrite desire value from template attributes
                    for (auto& attrib : cgReq.getDedicatedServerAttribs())
                    {
                        // Check if attribute exists in any matchmaking DS attrib rule
                        const DedicatedServerAttributeRuleServerConfigMap& configMap = mOwner->mScenarioManager->getComponent().getConfig().getMatchmakerSettings().getRules().getDedicatedServerAttributeRules();
                        for (const auto& configRule : configMap)
                        {
                            if (blaze_stricmp(configRule.second->getAttributeName(), attrib.first) == 0)
                            {
                                // If found, update find rules map
                                Blaze::GameManager::FindDedicatedServerRulesMap::iterator findItr = masterRequest.getFindDedicatedServerRulesMap().find(configRule.first);
                                if (findItr != masterRequest.getFindDedicatedServerRulesMap().end())
                                {
                                    findItr->second->setDesiredValue(attrib.second);
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    char8_t msg[MatchmakingCriteriaError::MAX_ERRMESSAGE_LEN];
                    blaze_snzprintf(msg, sizeof(msg), "Unable to apply value from config for the attribute \"%s\" in scenario \"%s\", sub session \"%s\".", failingAttr, getScenarioName().c_str(), mSubSessionName.c_str());
                    outErr.setErrMessage(msg);
                
                    // Switch from the TEMPLATE error, to the SCENARIO one:
                    return (finalResult == GAMEMANAGER_ERR_INVALID_TEMPLATE_ATTRIBUTE) ? GAMEMANAGER_ERR_INVALID_SCENARIO_ATTRIBUTE : GAMEMANAGER_ERR_MISSING_SCENARIO_ATTRIBUTE;
                }
            }

            // Use the external data sources API list for any games created by this scenario (if a CG template didn't provide one):
            if (!mOwner->mOwner->mScenarioConfig->getExternalDataSourceApiList().empty() && outRequest.getGameCreationData().getDataSourceNameList().empty())
            {
                mOwner->mOwner->mScenarioConfig->getExternalDataSourceApiList().copyInto(outRequest.getGameCreationData().getDataSourceNameList());
            }

            // We update the subsessions names for each user: 
            UserJoinInfoList::const_iterator userJoinInfoIter = masterRequest.getUsersInfo().begin();
            UserJoinInfoList::const_iterator userJoinInfoEnd = masterRequest.getUsersInfo().end();
            for (; userJoinInfoIter != userJoinInfoEnd; ++userJoinInfoIter)
            {
                (*userJoinInfoIter)->getScenarioInfo().setSubSessionName(mSubSessionName);

                // Override player reservation timeouts:
                (*userJoinInfoIter)->setPlayerReservationTimeout(mSubSessionConfig->getPlayerReservationTimeout());
            }

            // Apply the MM Criteria Template information (or build the Filters list):
            BlazeRpcError result1 = ERR_OK;
            if (isPackerTemplate)
            {
                // add the filters for this subsession
                masterRequest.getMatchmakingFilters().getMatchmakingFilterCriteriaMap().clear();

                // PACKER_TODO:  Pre-generate this list on startup/onReconfig, and update the ~3 places that do this logic:
                auto filterList = mOverallConfig->getGlobalFilters();
                filterList.insert(filterList.begin(), mSubSessionConfig->getFiltersList().begin(), mSubSessionConfig->getFiltersList().end());
                for (auto& filterName : filterList)
                {
                    // We only fill out the names of the Filters here, the filter criteria construction happens on the Packer. 
                    masterRequest.getMatchmakingFilters().getMatchmakingFilterCriteriaMap()[filterName] = masterRequest.getMatchmakingFilters().getMatchmakingFilterCriteriaMap().allocate_element();
                }

                // NOTE: Packer based requests ignore legacy MM rule based scenario attributes
                if (!mScenarioAttributeMapping.empty())
                {
                    TRACE_LOG("[MatchmakingSubSessionConfigInfo].createStartMatchmakingRequest: Packer-based create game template(" << templateName
                        << ") deliberately ignores the " << mScenarioAttributeMapping.size() << " attributes mapped to legacy MM rule criteria.");
                }
            }
            else
            {
                result1 = applyTemplateAttributes(EA::TDF::TdfGenericReference(outRequest.getCriteriaData()), mScenarioAttributeMapping, clientAttributes, clientProperties, failingAttr, componentDescription.get());
            }
            BlazeRpcError result2 = applyTemplateAttributes(EA::TDF::TdfGenericReference(outRequest.getGameCreationData()), mSubSessionConfig->getCreateGameAttributes(), clientAttributes, clientProperties, failingAttr, componentDescription.get());
            BlazeRpcError result3 = applyTemplateAttributes(EA::TDF::TdfGenericReference(outRequest), mOverallConfig->getGlobalAttributes(), clientAttributes, clientProperties, failingAttr, componentDescription.get());
            finalResult = (finalResult != ERR_OK) ? finalResult : ((result1 != ERR_OK) ? (result1) : ((result2 != ERR_OK) ? result2 : result3));

            if (finalResult != ERR_OK)
            {
                char8_t msg[MatchmakingCriteriaError::MAX_ERRMESSAGE_LEN];
                blaze_snzprintf(msg, sizeof(msg), "Unable to apply value from config for the attribute \"%s\" in scenario \"%s\", sub session \"%s\".", failingAttr, getScenarioName().c_str(), mSubSessionName.c_str());
                outErr.setErrMessage(msg);
                
                // Switch from the TEMPLATE error, to the SCENARIO one:
                finalResult = (finalResult == GAMEMANAGER_ERR_INVALID_TEMPLATE_ATTRIBUTE) ? GAMEMANAGER_ERR_INVALID_SCENARIO_ATTRIBUTE : GAMEMANAGER_ERR_MISSING_SCENARIO_ATTRIBUTE;
            }
        }
        return finalResult;
    }

} // namespace GameManager
} // namespace Blaze
