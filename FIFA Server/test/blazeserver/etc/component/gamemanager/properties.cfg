// USED BY BLAZE - DO NOT REMOVE THIS FILE
properties = {

    // (Dev Note:  This data isn't used directly.  It builds a mapping of PropertyName -> DataSource, and PropertyName -> TdfDerivedMap per-data source. )
    tdfDataSources = {
        "ReplicatedGameDataServer" = {
            "game.pingSite"   = "replicatedGameData.pingSiteAlias"
            "game.attributes" = "replicatedGameData.gameAttribs" 
            "game.id"         = "replicatedGameData.gameId" 

            "game.platforms"                    = "replicatedGameData.basePlatformList"
            "game.createTemplateName"           = "replicatedGameData.createGameTemplateName"
            "game.gameProtocolVersionString"    = "replicatedGameData.gameProtocolVersionString"

            "game.name"       = "replicatedGameData.gameName" 
            "game.settings"   = "replicatedGameData.gameSettings" 
            "game.state"      = "replicatedGameData.gameState" 
            "game.type"       = "replicatedGameData.gameType" 

            "game.geoLocation.latitude"  = "topologyHostUserInfo.latitude"
            "game.geoLocation.longitude" = "topologyHostUserInfo.longitude"

            "game.networkTopology"       = "replicatedGameData.networkTopology" 
        }

        // (Values used by packerOutputProperties must be set here)
        "GameCreationData" = {
            "game.attributes"           = "gameAttribs" 
            "game.participantCapacity"  = "slotCapacitiesMap[SLOT_PUBLIC_PARTICIPANT]"      // Technically just public partipant capacity, but private isn't available in matchmaking, and queue capacity can just be hardcoded.

            // "game.platforms"         - Game Platforms are tracked by PlatformFilter, so we don't have a "caller/game.platforms" to use here.

            "game.name"                 = "gameName"
            "game.settings"             = "gameSettings"
            // "game.state"             - Non applicable to non-created games.

            "game.networkTopology"      = "networkTopology"
            
            "caller.faction"            = "teamIds"
        }
       
       "StartMatchmakingInternalRequest" = {
           
           "caller.gameProtocolVersionString"   = "request.commonGameData.gameProtocolVersionString"
           "caller.createTemplateName"          = "createGameTemplateName"

           "game.type"                          = "request.commonGameData.gameType"
       }

        "ReplicatedGamePlayerServer" = {
            "players.attributes"        = "playerAttribs"
            "players.teamIndexes"       = "teamIndex"
            "players.userGroupIds"      = "userGroupId"
        }

        "PerPlayerJoinData" = {
            "players.attributes"        = "playerAttributes"
        }

        // Note:  The ReplicatedGamePlayerServer holds a UserSessionInfo, so we can get the same values there for active Games
        "UserSessionInfo" = {
            "players.uedValues"         = "dataMap"
            "players.pingSiteLatencies" = "latencyMap"
            "players.participantIds"    = "userInfo.id"
            "players.userSessionIds"    = "sessionId"
        }
    }

    // Properties that cannot be directly acessed from TDFs:
    derivedProperties = {
        // This is the full data driven parsing.  The simpler implementation is just to add some custom helper functions. 
        // "game.openToMatchmaking"    = "(game.players.count < game.totalCapacity) && (game.gameSettings[OpenToMatchmaking]) && (game.gameState == PRE_GAME || game.gameState == IN_GAME && game.gameSettings[JoinInProgressSupported])",
        "game.stateOpenToMatchmaking"  = "getGameStateOpenToMatchmaking()"

        // Simpler Option:  (Uses the ReplicatedGameData.mGameId internally)
        "game.version"              = "getRecordVersion()"

        "game.teamCount"            = "getTeamCount()"
        "game.teamCapacity"         = "getTeamCapacity()"
        "game.participantCapacity"  = "getParticipantCapacity()"
        "game.percentFull"          = "getGamePercentFull()"

        //"game.qualityFactorsHash"   = "getQualityFactorsHash()"
        "game.mode"                 = "getGameModeAttribute()"          // Accesses data from GameSession config for the GameMode attribute name.

        "game.ipAddress"            = "getGameIpAddress()"
        "game.port"                 = "getGameIpPort()"

        "caller.ipAddress"          = "getCallerIpAddress()"
        "caller.port"               = "getCallerIpPort()"

        "caller.leaderBestPingSite" = "getLeaderBestPingSite()"  // Although these values are all directly accessible from the UserSessionInfo TDF, this config doesn't provide a way to indicate if the caller or players list should be used for lookup. 
        "caller.geoLocation.latitude" = "getCallerLatitude()"
        "caller.geoLocation.longitude"= "getCallerLongitude()"


        // Player Roster:
        "players.participantCount"  = "getParticipantCount()"
    }

    // The following properties will automatically be sent to Packer, even if not referenced directly by the Packer config. 
    requiredPackerInputProperties = [
        "game.teamCount"
        "game.teamCapacity"
        "game.participantCapacity"
//        "players.participantIds"      // Player property, comes from a different source.
    ]

    // Properties that we get from GameBrowser for Players in ActiveGames:
    gameBrowserPackerProperties = [
        "game.id"
        "game.version"
        "players.userGroupIds"
        "players.teamIndexes"
        "players.participantIds"
        "players.userSessionIds"
    ]

    // The following properties will be outputted from Packer (to GameCreationData), if set in a PackerConfig
    packerOutputProperties = [
        "game.attributes"
        "game.participantCapacity"
    ]

    // Setup TemplateAttributeMaps, so that code can use fixed types, rather than treating the Properties as void* with magic casting. 
/*
    requiredPackerInputProperties = {
        "PackerGameTemplateData" = {
            "teamCount"            = {propertyName = "game.teamCount"}
            "teamCapacity"         = {propertyName = "game.teamCapacity"}
            "participantCapacity"  = {propertyName = "game.participantCapacity"}
        }
    }

    gameBrowserPackerProperties = {
        "PackerActiveGameData" = {
            "gameId"            = {propertyName = "game.id"}
            "gameVersion"       = {propertyName = "game.version"}
            "userGroupIds"      = {propertyName = "players.userGroupIds"}
            "teamIndexes"       = {propertyName = "players.teamIndexes"}
            "participantIds"    = {propertyName = "players.participantIds"}
            "userSessionIds"    = {propertyName = "players.userSessionIds"}
        }
    }
*/
}