/*************************************************************************************************/
/*!
    \file


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*************************************************************************************************/

/*************************************************************************************************/
/*!
    \class Connection

    This class defines a connection object which manages state and processing of requests for a
    given client.

*/
/*************************************************************************************************/

/*** Include Files *******************************************************************************/

#include <stdio.h>
#include "framework/blaze.h"
#include "framework/logger.h"
#include "framework/component/component.h"
#include "framework/connection/connectionmanager.h"
#include "framework/connection/connection.h"
#include "framework/connection/channel.h"
#include "framework/connection/inboundrpcconnection.h"
#include "framework/connection/socketchannel.h"
#include "framework/connection/endpoint.h"
#include "framework/connection/selector.h"
#include "framework/controller/controller.h"
#include "framework/controller/remoteinstance.h"
#include "framework/component/componentmanager.h"
#include "framework/component/message.h"
#include "framework/component/peerinfo.h"

#include "framework/protocol/rpcprotocol.h"
#include "framework/protocol/shared/fireframe.h"
#include "framework/protocol/shared/encoderfactory.h"
#include "framework/protocol/shared/restdecoder.h"

#include "framework/usersessions/usersession.h"
#include "framework/usersessions/usersessionmanager.h"

#include "framework/system/fiber.h"

#include "framework/util/locales.h"
#include "framework/tdf/controllertypes_server.h"
#include "blazerpcerrors.h"
#include "framework/component/blazerpc.h"
#include "framework/slivers/slivermanager.h"
#include "framework/component/inboundrpccomponentglue.h"

namespace Blaze
{

/*** Defines/Macros/Constants/Typedefs ***********************************************************/

FiberLocalWrappedPtr<SlaveSessionPtr, SlaveSession> InboundRpcConnection::smCurrentSlaveSession;


// NOTE: Needed because GCC complains about linking order between ClientInboundRpcConnection && Session
// and we don't want to mess around with link order dependencies generated by Nant.
//static const SessionId INVALID_SESSION_ID = Session::INVALID_SESSION_ID;

namespace Metrics
{
    namespace Tag
    {
        Metrics::TagInfo<RpcContext::WaitContext>* wait_context = BLAZE_NEW Metrics::TagInfo<RpcContext::WaitContext>("wait_context");
    }
}

/*** Public Methods ******************************************************************************/

InboundRpcConnection::InboundRpcConnection(ConnectionOwner& owner, ConnectionId ident, SocketChannel& channel, Blaze::Endpoint& endpoint, RatesPerIp *rateLimitCounter) :
    Connection(owner, ident, channel, endpoint),
    mRateLimitCounter(rateLimitCounter), // For non-trusted clients, the rate limit counter is used later to ensure that command rates do not exceed.
    mLastFiberLimitWarnLog(0),
    mConnectivityCheckTimer(INVALID_TIMER_ID),
    mConnectivityCheckInterval(10 * 1000 * 1000),
    mConnectivityCheckTimeout(5 * 1000 * 1000),
    mLastPingMsgNumForPeriodicChecks(0),
    mLastPingMsgNumForManualChecks(0),
    mExceededRpcFiberLimitDroppedCount(0),
    mExceededRpcFiberLimitPermittedCount(0),
    mIsResponsive(true),
    mAwaitingFirstPingReply(false),
    mPeerInfo(*this)
{
    mPeerInfo.setClientType(getProtocol().getDefaultClientType());
    mPeerInfo.setSupportsNotifications(getProtocol().supportsNotifications());
    mPeerInfo.setIgnoreInactivityTimeoutEnabled(getEndpoint().getIgnoreInactivityTimeoutEnabled());
    mPeerInfo.setCommandTimeout(getEndpoint().getCommandTimeout());
    mPeerInfo.setEndpointName(endpoint.getName());

    if (isTrustedPeer())
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].ctor: Ignoring rateLimitCounter because we are a trusted peer connection via mTLS.");
        
        endpoint.getRateLimiter().addMtlsVerifiedIp(getPeerAddress().getIp()); // add Ip address to the mTLS verified cache
        
        if (mRateLimitCounter != nullptr) // reset the rateLimitCounter in progress
        {
            mRateLimitCounter->mConnectionAttemptRate = 0;
            mRateLimitCounter->mLoggedConnectionLimitExceeded = false;
        }
        mRateLimitCounter = nullptr;
    }

    if (mRateLimitCounter != nullptr)
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].ctor: RateCounter(" << rateLimitCounter 
                        << "), connectionCount(" << (uint32_t)rateLimitCounter->mConnectionCount << ")");

        getEndpoint().getRateLimiter().incrementConnectionCount(*mRateLimitCounter);
    }
}

InboundRpcConnection::~InboundRpcConnection()
{
    // check before calling the function to avoid the log spam from destructor for non-connectivity enabled clients
    if (isConnectivityCheckingEnabled())
        disableConnectivityChecking();
}


// Based on ServerInboundRpcConnection::initRpcContext
void InboundRpcConnection::initLocalRpcContext(UserSessionId userSessionId, bool superUserPrivilege)
{
    smCurrentSlaveSession.copyFromCallingFiber();

    if (superUserPrivilege)
    {
        UserSession::pushSuperUserPrivilege();
    }

    if (UserSession::isValidUserSessionId(userSessionId))
    {
        UserSession::setCurrentUserSessionId(userSessionId);
    }
}

void InboundRpcConnection::processMessage(RawBufferPtr& incomingMessageBuffer)
{
    ConnectionSbFormat connInstanceStr(this);

    mPeerInfo.setTrustedClient(isTrustedPeer());

    RpcProtocol::Frame inFrame(mPeerInfo.getBaseLocale(), mPeerInfo.getBaseCountry(), getEndpoint().getEncoderType(), getEndpoint().getDecoderType());
    getProtocol().process(*incomingMessageBuffer.get(), inFrame, getDecoder());

    inFrame.requestIsSecure = (blaze_stricmp(getEndpoint().getChannelType(), "ssl") == 0);

    if (inFrame.isFaviconRequest)
    {
        completeRequest(SlaveSession::INVALID_SESSION_ID, INVALID_USER_SESSION_ID, inFrame, ERR_OK, INVALID_INSTANCE_ID, nullptr);
        return;
    }

    SlaveSessionId slaveSessionId = getOrCreateSlaveSessionId(inFrame);
    UserSessionId userSessionId = getOrAllocateUserSessionId(inFrame);

    if ((slaveSessionId == SlaveSession::INVALID_SESSION_ID) && (userSessionId == INVALID_USER_SESSION_ID))
    {
        BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Unable to get either a slave or user session id for msgNum " << inFrame.msgNum);
        completeRequest(slaveSessionId, userSessionId, inFrame, ERR_SYSTEM, INVALID_INSTANCE_ID, nullptr);
        return;
    }

    // set the real peer address if x-forwarded-for header was present in the incoming request headers
    if (inFrame.clientAddr.isResolved())
    {
        setRealPeerAddress(inFrame.clientAddr);
    }

    // update this connection's servicename if one is provided by the frame
    InboundRpcComponentGlue::updatePeerServiceName(mPeerInfo, inFrame.serviceName);
    ClientPlatformType servicePlatform = gController->getServicePlatform(mPeerInfo.getServiceName());

    LogContextWrapper& lcw = inFrame.logContext;
    InboundRpcComponentGlue::setLoggingContext(slaveSessionId, userSessionId, lcw.getDeviceId(), lcw.getPersonaName(), getRealPeerAddress(), lcw.getNucleusAccountId(), lcw.getPlatform() == INVALID ? servicePlatform : lcw.getPlatform());

    char8_t localeBuf[256];
    blaze_snzprintf(localeBuf, sizeof(localeBuf), "%c%c%c%c", LocaleTokenPrintCharArray(inFrame.locale));

    const CommandInfo* cmdInfo = nullptr;
    if (inFrame.messageType == RpcProtocol::MESSAGE)
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Received request: "
            "component=" << BlazeRpcComponentDb::getComponentNameById(inFrame.componentId) << "(" << SbFormats::Raw("0x%04x", inFrame.componentId)
            << ") command=" << ((inFrame.messageType == RpcProtocol::NOTIFICATION) ? "" : BlazeRpcComponentDb::getCommandNameById(inFrame.componentId, inFrame.commandId))
            << "(" << inFrame.commandId << ") type=" << inFrame.messageType << " msgNum=" << inFrame.msgNum << " userIndex=" << inFrame.userIndex
            << " size=" << ((int32_t) incomingMessageBuffer->datasize()) << " locale=" << localeBuf);

        Component* component = InboundRpcComponentGlue::getComponent(inFrame.componentId, getEndpoint().getBindType());
        if (component)
        {
            cmdInfo = component->getCommandInfo(inFrame.commandId); 
            if (cmdInfo != nullptr)
            {
                if (!isRpcAuthorized(*cmdInfo, *component, inFrame, incomingMessageBuffer, userSessionId))
                {
                    completeRequest(slaveSessionId, userSessionId, inFrame, ERR_AUTHORIZATION_REQUIRED, INVALID_INSTANCE_ID, nullptr);
                    return;
                }

                if (isOverloadingFibers(*cmdInfo, *component, inFrame))
                {
                    completeRequest(slaveSessionId, userSessionId, inFrame, ERR_COMMAND_FIBERS_MAXED_OUT, INVALID_INSTANCE_ID, nullptr);
                    return;
                }

                if (isWrongEndpoint(*cmdInfo, *component))
                {
                    completeRequest(slaveSessionId, userSessionId, inFrame, ERR_INVALID_ENDPOINT, INVALID_INSTANCE_ID, nullptr);
                    return;
                }

                if (gController->isShutdownPending())
                {
                    // The last few RPCs are finishing up, and then this instance will shutdown.
                    // Tell the caller ERR_UNAVAILABLE instead of possibly only partially executing their RPC.
                    completeRequest(slaveSessionId, userSessionId, inFrame, ERR_UNAVAILABLE, INVALID_INSTANCE_ID, nullptr);
                    return;
                }

                Message* msg = BLAZE_NEW Message(slaveSessionId, userSessionId, mPeerInfo, inFrame, incomingMessageBuffer, nullptr);
                mPeerInfo.setLocale(inFrame.locale); //reset when the command completes
                mPeerInfo.setCountry(inFrame.country);
                mOutstandingCommands.insert(inFrame.msgNum); //cleared when the command completes

                if (EA_UNLIKELY(gController->isShuttingDown()))
                {
                    BLAZE_ERR_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Scheduling new command fiber while this instance is shutting down for request: "
                        "component=" << BlazeRpcComponentDb::getComponentNameById(inFrame.componentId)
                        << " command=" << ((inFrame.messageType == RpcProtocol::NOTIFICATION) ? "" : BlazeRpcComponentDb::getCommandNameById(inFrame.componentId, inFrame.commandId))
                        << " type=" << inFrame.messageType << " msgNum=" << inFrame.msgNum << " userIndex=" << inFrame.userIndex);
                }

                Fiber::CreateParams fiberParams = InboundRpcComponentGlue::getCommandFiberParams(component->isLocal(), *cmdInfo, getEndpoint().getCommandTimeout(), getEndpoint().shouldSerializeRequests(), mProcessMessageFiberGroupId);

                //Decision time - can we just pass this guy through raw, or do we process it here?
                //Raw sends are for non-local components that don't have sharding keys and for things we don't need to reencode.
                bool sendRaw = (!component->isLocal() && !cmdInfo->useShardKey && getProtocol().supportsRaw());
                if (sendRaw)
                {
                    // decrement happens when processRawRequest completes
                    gSelector->scheduleFiberCall<InboundRpcConnection, Component&, const CommandInfo&, Message&>(this, &InboundRpcConnection::processRawRequest, *component, *cmdInfo, *msg, nullptr, fiberParams);
                }
                else
                {
                    // decrement happens when processRawRequest completes
                    gSelector->scheduleFiberCall<InboundRpcConnection, Component&, const CommandInfo&, Message&>(this, &InboundRpcConnection::processRequest, *component, *cmdInfo, *msg, nullptr, fiberParams);
                }
                
                if (InboundRpcComponentGlue::hasExceededCommandRate(getEndpoint().getRateLimiter(), mRateLimitCounter, *cmdInfo, false))
                {
                    BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: "
                        "Specific RPC rate limit of for command " << BlazeRpcComponentDb::getCommandNameById(inFrame.componentId, inFrame.commandId) << "(" << inFrame.commandId << ")" <<
                        " was exceeded for RateLimiter " << getEndpoint().getRateLimiter().getName());
                    
                    Fiber::sleep(RATE_LIMIT_GRACE_PERIOD * 1000 * 1000, "InboundRpcConnection command rate check squelch"); 
                }
            }
            else
            {             
                BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Could not find command (" << inFrame.commandId << ") for component " << component->getName());
                completeRequest(slaveSessionId, userSessionId, inFrame, ERR_COMMAND_NOT_FOUND, INVALID_INSTANCE_ID, nullptr);
            }
        }
        else
        {
            if (getOwner().isActive())
            {
                BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Component "
                          << BlazeRpcComponentDb::getComponentNameById(inFrame.componentId) << "(" << inFrame.componentId <<") not loaded for command " 
                          << BlazeRpcComponentDb::getCommandNameById(inFrame.componentId, inFrame.commandId) << "(" << inFrame.commandId << ")");
            }
            //Finish off the message with the correct error
            completeRequest(slaveSessionId, userSessionId, inFrame, ERR_COMPONENT_NOT_FOUND, INVALID_INSTANCE_ID, nullptr);
        }
    }
    else if (inFrame.messageType == RpcProtocol::PING)
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Received PING"
            << " type=" << inFrame.messageType << " msgNum=" << inFrame.msgNum <<  " userIndex=" << inFrame.userIndex
            << " locale=" << localeBuf);
        completeRequest(slaveSessionId, userSessionId, inFrame, ERR_OK, INVALID_INSTANCE_ID, nullptr);
    }
    else if (inFrame.messageType == RpcProtocol::PING_REPLY)
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Received PING_REPLY"
            << " type=" << inFrame.messageType << " msgNum=" << inFrame.msgNum << " userIndex=" << inFrame.userIndex
            << " locale=" << localeBuf);

        // We just received a PING_REPLY from the peer, so unblock anyone waiting on a connectivity check.
        // This will also schedule the next connectivity check, if periodic checking is enabled.
        signalConnectivityChecks(ERR_OK, inFrame.msgNum);
    }
    else
    {
        BLAZE_ERR_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Received unsupported message"
            " type=" << inFrame.messageType << " msgNum=" << inFrame.msgNum << " userIndex=" << inFrame.userIndex
            << " locale=" << localeBuf << ", cannot be handled.");
    }

    if (cmdInfo != nullptr)
    {
        //Check our overall rate limits
        if (InboundRpcComponentGlue::hasExceededCommandRate(getEndpoint().getRateLimiter(), mRateLimitCounter, *cmdInfo, true))
        {
            BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: "
                "Total RPC rate limit of (" << getEndpoint().getRateLimiter().getCommandRateLimit() << ") was exceeded for RateLimiter "
                << getEndpoint().getRateLimiter().getName());
        
            //sleep for the grace period before continuing to process
            Fiber::sleep(RATE_LIMIT_GRACE_PERIOD * 1000 * 1000, "InboundRpcConnection overall rate check squelch"); 
        }
    }

    //Clear the execution context for the next command
    smCurrentSlaveSession = nullptr;
    gLogContext->clear();
}

void InboundRpcConnection::processRequest(Component& component, const CommandInfo& cmdInfo, Message& message)
{
    CommandFiberTracker commandFiberTracker;

    gLogContext.copyFromCallingFiber();

    if (EA_UNLIKELY(gController->isShuttingDown()))
    {
        BLAZE_ERR_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].processRequest: Processing command fiber while this instance is shutting down for request: "
            "component=" << component.getComponentInfo().loggingName
            << " command=" << cmdInfo.loggingName
            << " msgNum=" << message.getMsgNum());
    }

    InboundRpcConnectionRpcContext rpcContext(cmdInfo, message);

    BlazeRpcError result = initRpcContext(rpcContext);
    if (result == ERR_OK)
    {
        rpcContext.mRequest = cmdInfo.createRequest("Rpc Request");
        rpcContext.mResponse = cmdInfo.createResponse("Rpc Response");
        rpcContext.mErrorResponse = cmdInfo.createErrorResponse("Rpc Error Response");

        if (rpcContext.mRequest != nullptr)
        {
            if (getDecoder().getType() == Decoder::REST)
            {
                RestDecoder& restDecoder = static_cast<RestDecoder&>(getDecoder());
                restDecoder.setRestResourceInfo(cmdInfo.restResourceInfo);
            }

            result = decodeTdf(message.getPayloadPtr(), *rpcContext.mRequest, message.getFrame().requestEncodingType);
            if (result != Blaze::ERR_OK)
            {        
                char8_t addr[256];
                addr[0] = '\0';
                BLAZE_ERR_LOG(component.getLogCategory(), "[InboundRpcConnection:" 
                    << ConnectionSbFormat(this) << "].processRequest: " << "Invalid/corrupted payload from "
                    << getRealPeerAddress().toString(addr, sizeof(addr))
                    << " for " << component.getComponentInfo().loggingName << "." 
                    << cmdInfo.loggingName << ", seqno=" << message.getMsgNum() << ", Decoder error= " << getDecoderErrorMessage());
            }
        }

        //Now make the call
        if (result == ERR_OK)
        {
            result = InboundRpcComponentGlue::processRequest(component, rpcContext, cmdInfo, message, rpcContext.mRequest, rpcContext.mResponse, rpcContext.mErrorResponse);
        }       
    }

    //Return the response
    completeRequest(message.getSlaveSessionId(), message.getUserSessionId(), message.getFrame(), result, rpcContext.mMovedTo, (result == ERR_OK ? rpcContext.mResponse : rpcContext.mErrorResponse));
}

void InboundRpcConnection::processRawRequest(Component& component, const CommandInfo& cmdInfo, Message& message)
{
    CommandFiberTracker commandFiberTracker;

    gLogContext.copyFromCallingFiber();

    if (EA_UNLIKELY(gController->isShuttingDown()))
    {
        BLAZE_ERR_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].processRawRequest: Processing command fiber while this instance is shutting down for request: "
            "component=" << component.getComponentInfo().loggingName
            << " command=" << cmdInfo.loggingName
            << " msgNum=" << message.getMsgNum());
    }

    InboundRpcConnectionRpcContext rpcContext(cmdInfo, message);

    BlazeRpcError result = initRpcContext(rpcContext);
    if (result == ERR_OK)
    {
        //Now make the call
        RpcCallOptions opts;
        opts.followMovedTo = false;
        opts.routeTo.setSliverIdentity(message.getFrame().sliverIdentity);
        result = component.sendRawRequest(cmdInfo, message.getPayloadPtr(), rpcContext.mResponseBuf, opts, &rpcContext.mMovedTo);
    }

    //Return the response
    completeRequestInternal(message.getSlaveSessionId(), message.getUserSessionId(), message.getFrame(), result, rpcContext.mMovedTo, nullptr, rpcContext.mResponseBuf.get());
}

bool InboundRpcConnection::isRpcAuthorized(const CommandInfo& cmdInfo, Component& component, RpcProtocol::Frame& inFrame, RawBufferPtr& incomingMessageBuffer, UserSessionId userSessionId)
{
    ConnectionSbFormat connInstanceStr(this);

    // Check if this RPC is authorized (in the RPC whitelist and not blacklisted) before executing
    ClientPlatformType platform = gController->getServicePlatform(mPeerInfo.getServiceName());
    if (!getEndpoint().isRpcAuthorized(platform, component.getId(), cmdInfo.commandId))
    {
        getEndpoint().incrementTotalRpcAuthorizationFailureCount();
        if (component.isLocal())
            component.asStub()->tickRpcAuthorizationFailureCount(mPeerInfo, cmdInfo);

        FixedString32 deviceId = InboundRpcComponentGlue::getCurrentUserSessionDeviceId(userSessionId);

        StringBuilder str;
        if (EA_UNLIKELY(Logger::isEnabled(Log::CONNECTION, Logging::TRACE, __FILE__, __LINE__)))
        {
            EA::TDF::TdfPtr req = cmdInfo.createRequest("Rpc Request");
            if (req != nullptr)
            {
                if (getDecoder().getType() == Decoder::REST)
                {
                    RestDecoder& restDecoder = static_cast<RestDecoder&>(getDecoder());
                    restDecoder.setRestResourceInfo(cmdInfo.restResourceInfo);
                }

                BlazeRpcError decodeErr = decodeTdf(incomingMessageBuffer, *req, inFrame.requestEncodingType);
                if (decodeErr == ERR_OK)
                {
                    str << "\nRequest: " << req;
                }
                else
                {
                    str << ". Unable to decode request due to: " << ErrorHelp::getErrorName(decodeErr) << ", Decoder error= " << getDecoderErrorMessage();
                }
            }
        }

        BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processRequest: Attempted to execute unauthorized RPC " <<
            component.getComponentInfo().loggingName << "/" << cmdInfo.loggingName << ". User's deviceId: " << deviceId.c_str() << str.get());

        return false;
    }

    return true;
}

bool InboundRpcConnection::isOverloadingFibers(const CommandInfo& cmdInfo, Component& component, RpcProtocol::Frame& inFrame)
{
    ConnectionSbFormat connInstanceStr(this);
    
    // make sure we're not overloading fibers.  However, framework level commands are always allowed.
    bool isFrameworkCommand = false;
    FixedString32 droppedOrPermitted;

    if (InboundRpcComponentGlue::hasReachedFiberLimit(inFrame.componentId, isFrameworkCommand, droppedOrPermitted))
    {
        if (isFrameworkCommand)
        {
            ++mExceededRpcFiberLimitPermittedCount;
            getEndpoint().incrementTotalExceededRpcFiberLimitPermitted();
        }
        else
        {
            ++mExceededRpcFiberLimitDroppedCount;
            getEndpoint().incrementTotalExceededRpcFiberLimitDropped();
        }

        if ((mLastFiberLimitWarnLog + getEndpoint().getFiberOverrunWarnLogInterval()) < TimeValue::getTimeOfDay())
        {
            BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: Concurrent command fibers (" << gFiberManager->getCommandFiberCount()
                << ") >= max (" << gFiberManager->getMaxCommandFiberCount() << ") " << droppedOrPermitted.c_str() << " RPC = (" << component.getComponentInfo().loggingName << ":" << cmdInfo.loggingName
                << ") total dropped RPCs (" << mExceededRpcFiberLimitDroppedCount << "), total permitted RPCs (" << mExceededRpcFiberLimitPermittedCount << ").");

            mLastFiberLimitWarnLog = TimeValue::getTimeOfDay();
        }

        // We always want to allow framework level RPCs, even if the command fiber count is > MaxCommandFiberCount (see https://eadpjira.ea.com/browse/GOS-30620)
        if (!isFrameworkCommand)
        {
            return true;
        }
    }

    return false;
}

bool InboundRpcConnection::isWrongEndpoint(const CommandInfo& cmdInfo, Component& component)
{
    ConnectionSbFormat connInstanceStr(this);
    
    // Internal commands need to be run on internal bound endpoints
    // (excluding internal endpoints used for external Envoy requests)
    if (cmdInfo.isInternalOnly && (!getEndpoint().getInternalCommandsAllowed()))
    {
        BLAZE_WARN_LOG(Log::CONNECTION, "[InboundRpcConnection:" << connInstanceStr << "].processMessage: An attempt to execute internal only RPC (" <<
            component.getComponentInfo().loggingName << ":" << cmdInfo.loggingName << ") on Externally accessible endpoint. Ignored.");

        return true;
    }

    return false;
}

void InboundRpcConnection::fillResponseFrame(UserSessionId userSessionId, BlazeRpcError error, InstanceId movedTo, const RpcProtocol::Frame& originalFrame, RpcProtocol::Frame& responseFrame)
{
    responseFrame = originalFrame;
    responseFrame.errorCode = error;
    responseFrame.movedTo = movedTo;
    responseFrame.setSessionKey(nullptr);
    if (originalFrame.messageType == RpcProtocol::PING)
        responseFrame.messageType = RpcProtocol::PING_REPLY;
    else
        responseFrame.messageType = (error == ERR_OK ? RpcProtocol::REPLY : RpcProtocol::ERROR_REPLY);
}


/*************************************************************************************************/
/*!
     \brief completeRequest
 
     Trigger the completion of processing a request.  The request object will be removed
     from the pending request map and deleted. 

     \param[in] sessionId - sessionId of the caller
     \param[in] frame - Frame to send.
     \param[in] tdf - Optional TDF to send.

     \return false if the request did not belong to this connection; true otherwise.
*/
/*************************************************************************************************/
void InboundRpcConnection::completeRequest(SlaveSessionId slaveSessionId, UserSessionId userSessionId, const RpcProtocol::Frame &originalFrame, BlazeRpcError err, InstanceId movedTo, const EA::TDF::Tdf *tdf)
{
    completeRequestInternal(slaveSessionId, userSessionId, originalFrame, err, movedTo, tdf, nullptr);
}

void InboundRpcConnection::completeRequestInternal(SlaveSessionId slaveSessionId, UserSessionId userSessionId, const RpcProtocol::Frame &originalFrame, BlazeRpcError err, InstanceId movedTo, const EA::TDF::Tdf *tdf, RawBuffer *passthroughBuf)
{
    // Remove the request from pending list
    mOutstandingCommands.erase(originalFrame.msgNum);

    // Confirm that this is our request
    if (!isClosed())
    {   
        //Get the buffer
        RawBufferPtr buffer;
        if (passthroughBuf != nullptr)
            buffer = passthroughBuf;
        else
            buffer = getBuffer();

        // Frame the response
        RpcProtocol::Frame responseFrame;
        fillResponseFrame(userSessionId, err, movedTo, originalFrame, responseFrame);

        //Encode any TDF we may have.  We always attempt to setup the encoder as the response type might be different than our "standard" type.  An internal 
        //check in setupEncoder ensures this doesn't thrash.
        if (tdf != nullptr)
        {
            setupEncoder(responseFrame.responseEncodingType);
        }

        getProtocol().framePayload(*buffer.get(), responseFrame, (int32_t)buffer->datasize(), getEncoder(), tdf);

        if (responseFrame.messageType == RpcProtocol::PING_REPLY)
        {
            BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].completeRequestCommon: Sending PING_REPLY"
                " type=" << responseFrame.messageType << " msgNum=" << responseFrame.msgNum << " ec=" 
                << ErrorHelp::getErrorName(static_cast<BlazeRpcError>(responseFrame.errorCode)) << "(" << responseFrame.errorCode << ")");
        }
        else
        {
            BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].completeRequestCommon: Sending response"
                " component=" << BlazeRpcComponentDb::getComponentNameById(responseFrame.componentId) 
                << "(" << SbFormats::Raw("0x%04x", responseFrame.componentId) << ") command=" 
                << BlazeRpcComponentDb::getCommandNameById(responseFrame.componentId, responseFrame.commandId) 
                << "(" << responseFrame.commandId << ") type=" << responseFrame.messageType << " msgNum=" << responseFrame.msgNum 
                << " ec=" << ErrorHelp::getErrorName(static_cast<BlazeRpcError>(responseFrame.errorCode)) << "(" << responseFrame.errorCode << ")");
        }

        // Queue response to output queue and then try and drain the queue
        queueOutputData(buffer);
        spliceOutputQueues(); //if we were blocking async notifications on the account of a conn finishing, allow those async notifications through now.
    }
    
    // Reset back to the base locale/country in case it had been overridden by this command
    mPeerInfo.setLocale(mPeerInfo.getBaseLocale());
    mPeerInfo.setCountry(mPeerInfo.getBaseCountry());

    // Special close after process logic
    if (originalFrame.transform == RpcProtocol::CONNECTION_CLOSE) 
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].completeRequestCommon: "
            << "Inbound frame specified closure, closing connection.");

        // initiate graceful closure on the connection
        gracefulClose();
    }
}

void InboundRpcConnection::sendNotification(Notification& notification)
{
    // Early out if the connection does not support notifications, or if it is already shutting down.
    if (isClosed() || !getProtocol().supportsNotifications() || getBlockingSocket().isShuttingDown())
        return;

    TdfEncoder& encoder = (notification.getOpts().encoder == nullptr ? getEncoder() : *notification.getOpts().encoder);

    RpcProtocol::Frame outFrame;
    outFrame.messageType = RpcProtocol::NOTIFICATION;
    outFrame.componentId = notification.getComponentId();
    outFrame.commandId = notification.getNotificationId();
    outFrame.msgNum = notification.getOpts().msgNum;
    outFrame.immediate = notification.getOpts().sendImmediately;
    outFrame.format = notification.getOpts().responseFormat;
    outFrame.context = notification.getOpts().context;

    int32_t userIndex = mPeerInfo.getUserIndexFromUserSessionId(outFrame.context);
    if (userIndex >= 0)
        outFrame.userIndex = userIndex;

    // Encode payload if one was provided
    RawBufferPtr payloadBuffer = notification.encodePayload(encoder, outFrame);

    BLAZE_TRACE_RPC_LOG(notification.getLogCategory(), "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].sendNotification: -> Notif " << (getBlockingSocket().isShuttingDown() ? "dropped" : "sent") << " "
        "[component=" << BlazeRpcComponentDb::getComponentNameById(outFrame.componentId) << "(" << SbFormats::Raw("0x%04x", outFrame.componentId) << "), "
        "type=" << BlazeRpcComponentDb::getNotificationNameById(outFrame.componentId, outFrame.commandId) << "(" << outFrame.commandId << "), "
        "seqno=" << outFrame.msgNum << ", "
        "context=" << SbFormats::HexLower(outFrame.context) << (outFrame.immediate ? ", immediate" : "") << ", "
        "userIndex=" << outFrame.userIndex << "]\n" << notification.getPayload().get());

    // NOTE: In addition to the sendImmediately flag, we want to queue the notification directly for output
    // if we are not serializing requests or we are not processing a message and there aren't any outstanding    
    bool queueDirectly = outFrame.immediate || getQueueDirectly();

    RawBufferPtr frameBuffer = getBuffer();

    getProtocol().framePayload((getProtocol().compressNotifications() ? *payloadBuffer : *frameBuffer), outFrame, (payloadBuffer ? (int32_t)payloadBuffer->datasize() : 0), encoder);
    queueOutputData(frameBuffer, payloadBuffer, queueDirectly);
}

bool InboundRpcConnection::getQueueDirectly() const 
{
    return !getEndpoint().shouldSerializeRequests() || !hasOutstandingCommands();
}

void InboundRpcConnection::setRateLimitCounter(RatesPerIp *rateLimitCounter)
{
    // Trusted Peers don't bother with RateLimits:
    if (isTrustedPeer())
    {
        return;
    }

    // If the existing rate-limit counter is the same as the new one, don't bother doing anything
    if (mRateLimitCounter != rateLimitCounter)
    {
        // if there was already a rate-limit counter assigned to this connection...
        if (mRateLimitCounter != nullptr)
        {
            // THEN make sure to decrement its mConnectionCount counter
            getEndpoint().getRateLimiter().decrementConnectionCount(*mRateLimitCounter);
        }

        // if this is a new rate limit counter for this connection...
        if (rateLimitCounter != nullptr)
        {
            // THEN make sure to increment its mConnectionCount counter
            getEndpoint().getRateLimiter().incrementConnectionCount(*rateLimitCounter);
        }

        mRateLimitCounter = rateLimitCounter;
    }
}

void InboundRpcConnection::close()
{
    Connection::close(); // call base close()

    while (!mConnectivityCheckWaiters.empty())
    {
        Fiber::EventHandle& eventHandle = mConnectivityCheckWaiters.front().eventHandle;
        Fiber::signal(eventHandle, ERR_DISCONNECTED);
    }

    if (mRateLimitCounter != nullptr)
    {
        BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].close: RateCounter(" 
                   << mRateLimitCounter << "), connectionCount(" << (uint32_t)mRateLimitCounter->mConnectionCount << ")");
            
        getEndpoint().getRateLimiter().decrementConnectionCount(*mRateLimitCounter);
        
        mRateLimitCounter = nullptr; // required because close() can be called *multiple* times for the same connection
    }
}

bool InboundRpcConnection::sendPing(uint32_t userIndex, const char8_t* token, uint32_t* msgNum /*= nullptr*/)
{
    if (!isConnected() || !getProtocol().supportsClientPing())
        return false;

    RawBufferPtr frameBuffer = getBuffer();

    RpcProtocol::Frame pingFrame;
    pingFrame.messageType = RpcProtocol::PING;
    pingFrame.msgNum = getProtocol().getNextSeqno();
    pingFrame.userIndex = userIndex;
    if (token != nullptr)
        pingFrame.setSessionKey(token);
    if (msgNum != nullptr)
        *msgNum = pingFrame.msgNum;

    getProtocol().framePayload(*frameBuffer.get(), pingFrame, 0, getEncoder());
    queueOutputData(frameBuffer, nullptr, true);

    BLAZE_TRACE_LOG(Log::CONNECTION, "[InboundRpcConnection:" << ConnectionSbFormat(this) << "].sendPing: "
        "Sent PING with msgId(" << pingFrame.msgNum << "), userIndex(" << pingFrame.userIndex << ")");

    return true;
}

// The determination of the 'responsiveness' of the client is governed
// by 2 values passed to this function:
//
// 1. interval - The interval of time between pings sent to the client.
// 2. timeout  - The duration of time before which the server must receive a ping reply
//               from the client.  If the server does not receive a ping reply from
//               the client within this duration of time, the client/connection is deemed
//               unresponsive.
//
// In the unlikely case of the 'timeout' value being greater than the 'interval' value,
// then the time between pings sent to the client may exceed the value specified by
// 'interval'.  This can happen in the case when the client does become unresponsive.  The
// server will not send another ping until it has either received a reply from the client,
// or the 'timeout' period has elapsed.  At which point, another ping will be sent immediately
// if 'interval' has already elapsed since the last ping.

void InboundRpcConnection::setConnectivityCheckSettings(TimeValue interval, TimeValue timeout)
{
    mConnectivityCheckInterval = interval;
    mConnectivityCheckTimeout = timeout;
}

// Enables periodic connectivity/responsiveness checking on this connection.
void InboundRpcConnection::enableConnectivityChecking()
{
    BLAZE_INFO_LOG(Log::CONNECTION, "InboundRpcConnection[" << ConnectionSbFormat(this) << "].enableConnectivityChecking: called with connection in (" << (mIsResponsive ? "responsive) state," : "unresponsive) state,")
        << " current connectivity checking status(" << (isConnectivityCheckingEnabled() ? "enabled" : "disabled") << "),"
        << " waiting for first ping reply (" << mAwaitingFirstPingReply << "),"
        << " UserSessionId(" << mPeerInfo.getUserSessionIdAtUserIndex(0) << ").");
    
    if (isConnectivityCheckingEnabled())
        return;

    mIsResponsive = true;
    onResponsivenessChanged();

    // Kick off the periodic connectivity checking
    mAwaitingFirstPingReply = true;
    doConnectivityCheck();
}

void InboundRpcConnection::disableConnectivityChecking()
{
    BLAZE_INFO_LOG(Log::CONNECTION, "InboundRpcConnection[" << ConnectionSbFormat(this) << "].disableConnectivityChecking: called with connection in (" << (mIsResponsive ? "responsive" : "unresponsive")
        << ") state, connectivity checking status(" << (isConnectivityCheckingEnabled() ? "enabled" : "disabled") << "),"
        << " waiting for first ping reply (" << mAwaitingFirstPingReply << "),"
        << " UserSessionId(" << mPeerInfo.getUserSessionIdAtUserIndex(0) << ").");

    if (!isConnectivityCheckingEnabled())
        return;

    gSelector->cancelTimer(mConnectivityCheckTimer);
    mConnectivityCheckTimer = INVALID_TIMER_ID;

    // If we are no longer going to check connectivity on this connection, we set it to be responsive (which is how a connection start). In other words, unless we can prove otherwise by actively checking the connection
    // for it's responsiveness, it should be considered responsive. 
    mIsResponsive = true;
    onResponsivenessChanged();
}

BlazeRpcError InboundRpcConnection::waitForConnectivityCheck(const TimeValue& absoluteTimeout)
{
    // If we're already closed, just early out
    if (isClosed())
        return ERR_DISCONNECTED;

    // Only sendPing() if there aren't already any outstanding manual connectivity checks waiting.
    if (mLastPingMsgNumForManualChecks == 0)
    {
        // Otherwise, go ahead and send the ping, and wait for a response (or timeout)
        sendPing(0, nullptr, &mLastPingMsgNumForManualChecks);
    }

    EventHandleNode waitHandle = Fiber::getNextEventHandle();
    mConnectivityCheckWaiters.push_back(waitHandle);
    BlazeRpcError error = Fiber::wait(waitHandle, "InboundRpcConnection::handleConnectivityCheck", absoluteTimeout);
    mConnectivityCheckWaiters.remove(waitHandle);

    return error;
}

void InboundRpcConnection::signalConnectivityChecks(BlazeRpcError error, uint32_t msgNum)
{
    // NOTE: msgNum==0 means that the connection was resumed, and so the client is responsive.

    // For this case, if an error is reported, we always want to signal any manual connectivity checkers.
    if ((error != ERR_OK) || (msgNum == 0) || (msgNum == mLastPingMsgNumForManualChecks))
    {
        // Reset the msgNum so another ping can be sent inside waitForConnectivityCheck().
        mLastPingMsgNumForManualChecks = 0;

        // Unblock all waiting fibers.  We use delaySignal() so that we don't have to worry about our iterators becoming invalid.
        EventHandleList::iterator it = mConnectivityCheckWaiters.begin();
        EventHandleList::iterator end = mConnectivityCheckWaiters.end();
        for ( ; it != end; ++it)
        {
            Fiber::delaySignal(it->eventHandle, error);
        }
    }

    // In this case, we only want to deal with a success scenario because we are just going to continue
    // advancing the automatic/periodic connectivity checking.  If an error has occurred, then we just
    // let the handleConnectivityCheckTimeout() method fire eventually.
    if ((error == ERR_OK) && ((msgNum == 0) || (msgNum == mLastPingMsgNumForPeriodicChecks)) && isConnectivityCheckingEnabled())
    {
        mLastPingMsgNumForPeriodicChecks = 0;

        // We received a reply, so cancel the 'timeout' callback
        gSelector->cancelTimer(mConnectivityCheckTimer);

        // Then, schedule the next connectivity check
        mConnectivityCheckTimer = gSelector->scheduleTimerCall(
            mNextConnectivityCheckTime,
            this, &InboundRpcConnection::doConnectivityCheck,
            "InboundRpcConnection::doConnectivityCheck");

        if (!mIsResponsive || mAwaitingFirstPingReply)
        {
            mAwaitingFirstPingReply = false;
            mIsResponsive = true;
            onResponsivenessChanged();
        }
    }
}

void InboundRpcConnection::doConnectivityCheck()
{
    // Cancel the timer if exists(unlikely) since we will schedule it again
    if (isConnectivityCheckingEnabled())
        gSelector->cancelTimer(mConnectivityCheckTimer);

    // Schedule the timeout for this PING.  We expect to receive a PING_REPLY within mConnectivityCheckTimeout duration.
    // If we do, then signalConnectivityChecks() will be called, which will cancel this timeout callback.
    mConnectivityCheckTimer = gSelector->scheduleTimerCall(
        TimeValue::getTimeOfDay() + mConnectivityCheckTimeout,
        this, &InboundRpcConnection::handleConnectivityCheckTimeout,
        "InboundRpcConnection::handleConnectivityCheckTimeout");

    // The next connectivity check 'time' is determined now, but will not actually be scheduled
    // with the selector until later.  Later being, after the PING_REPLY has been received,
    // or the PING_REPLY timeout period has elapsed.
    mNextConnectivityCheckTime = TimeValue::getTimeOfDay() + mConnectivityCheckInterval;

    sendPing(0, nullptr, &mLastPingMsgNumForPeriodicChecks);
}

void InboundRpcConnection::handleConnectivityCheckTimeout()
{
    if (isConnectivityCheckingEnabled())
        gSelector->cancelTimer(mConnectivityCheckTimer);

    // We're here because this callback was never cancelled by signalConnectivityChecks(), which means a reply was not
    // received within the mConnectivityCheckTimeout period.  Therefore, this connection is considered unresponsive.
    // Proceed by scheduling the next call to sendPing() via doConnectivityCheck(), which will check for responsiveness once again.
    mConnectivityCheckTimer = gSelector->scheduleTimerCall(
        mNextConnectivityCheckTime,
        this, &InboundRpcConnection::doConnectivityCheck,
        "InboundRpcConnection::doConnectivityCheck");

    if (mIsResponsive)
    {
        mIsResponsive = false;
        onResponsivenessChanged();
    }
}




ClientInboundRpcConnection::ClientInboundRpcConnection(ConnectionOwner& owner, ConnectionId ident, 
                                                       SocketChannel& channel, Blaze::Endpoint& endpoint, RatesPerIp *rateLimitCounter) 
    : InboundRpcConnection(owner, ident, channel, endpoint, rateLimitCounter)
    , mPerformGracefulClose(false)
    , mCloseTimer(INVALID_TIMER_ID)
{
    channel.setKeepAlive(isKeepAliveRequired());
    
    mPeerInfo.setListener(*this);
}

ClientInboundRpcConnection::~ClientInboundRpcConnection()
{
    gSelector->cancelTimer(mCloseTimer);
    EA_ASSERT(mPeerInfo.getAttachedUserSessionsCount() == 0);
    mPeerInfo.removeListener();
}

void ClientInboundRpcConnection::fillResponseFrame(UserSessionId userSessionId, BlazeRpcError error, InstanceId movedTo, const RpcProtocol::Frame& originalFrame, RpcProtocol::Frame& responseFrame)
{
    InboundRpcConnection::fillResponseFrame(userSessionId, error, movedTo, originalFrame, responseFrame);

    if (error == ERR_MOVED)
    {
        const RemoteServerInstance* remoteServerInstance = gController->getRemoteServerInstance(movedTo);
        if (remoteServerInstance != nullptr)
        {
            // A client address is considered "internal" if it is able to connect directly to this server's internal network interface.
            // An internal-only bound endpoint should only ever have internal clients.
            bool isInternalAddr = (getEndpoint().getBindType() == BIND_INTERNAL) ||
                getEndpoint().hasInternalNicAccess(getBlockingSocket().getChannel().getPeerAddress());

            remoteServerInstance->getAddressForEndpointType(
                isInternalAddr,
                responseFrame.movedToAddr,
                getEndpoint().getBindType(),
                getEndpoint().getChannelType(),
                getEndpoint().getEncoderName(),
                getEndpoint().getDecoderName());
        }
    }
    
    char8_t sessionKey[MAX_SESSION_KEY_LENGTH];
    mPeerInfo.getSessionKey(sessionKey, responseFrame.userIndex, userSessionId);
    if (sessionKey[0] != '\0')
        responseFrame.setSessionKey(sessionKey);
}

BlazeRpcError ClientInboundRpcConnection::initRpcContext(RpcContext& rpcContext)
{
    return InboundRpcComponentGlue::initRpcContext(rpcContext, mPeerInfo);
}

SlaveSessionId ClientInboundRpcConnection::getOrCreateSlaveSessionId(const RpcProtocol::Frame &inFrame)
{
    return BuildInstanceKey64(INVALID_INSTANCE_ID, getIdent());
}

UserSessionId ClientInboundRpcConnection::getOrAllocateUserSessionId(const RpcProtocol::Frame &inFrame)
{
    return mPeerInfo.getUserSessionId(inFrame.getSessionKey(), inFrame.userIndex);
}

bool ClientInboundRpcConnection::isKeepAliveRequired() const
{
    return getEndpoint().getTcpKeepAlive();
}

void ClientInboundRpcConnection::initiateGracefulClose()
{
    gracefulClose();
}

void ClientInboundRpcConnection::onResponsivenessChanged()
{
    if (!isConnectivityCheckingEnabled())
        return;

    Fiber::CreateParams fiberParams;
    fiberParams.groupId = mReadWriteLoopFiberGroupId;
    fiberParams.blocking = true;

    gSelector->scheduleFiberCall(this, &ClientInboundRpcConnection::onResponsivenessChangedInternal, "ClientInboundRpcConnection::onResponsivenessChangedInternal", fiberParams);
}

void ClientInboundRpcConnection::onResponsivenessChangedInternal()
{
    for (auto userSessionId : mPeerInfo.getUserSessionIds())
    {
        UserSessionMasterPtr localUserSession = gUserSessionMaster->getLocalSession(userSessionId);
        if (localUserSession != nullptr)
            localUserSession->handleConnectivityChange();
    }
}



void ClientInboundRpcConnection::close()
{
    if ((mCloseReason == DISCONNECTTYPE_USERSESSION_MIGRATING) && (mPeerInfo.getAttachedUserSessionsCount() != 0))
    {
        // We get here because close() was called due to some process/fiber noticing that the client has closed the connection
        // a moment before his UserSession is being migrated.  This is a very rare timing scenario, so we log a warning so that if this
        // begins to happen all the time, then it would be useful information but it can certainly happen.
        BLAZE_WARN_LOG(Log::CONNECTION, "ClientInboundRpcConnection.close: Ignoring call to close() while there are still " << mPeerInfo.getAttachedUserSessionsCount() << " UserSessions attached to this connection are being migrated. "
            "The connection will close once the UserSessions have been exported.");
        return;
    }

    if (mCloseReason == DISCONNECTTYPE_CLOSE_NORMAL && hasOutstandingCommands())
    {
        BLAZE_WARN_LOG(Log::CONNECTION, "ClientInboundRpcConnection.close: Ignoring call to close() while there are still outstanding commands. Rescheduling after command timeout.");
        
        if (mCloseTimer == INVALID_TIMER_ID) //If the timer is not already scheduled, schedule it.
            mCloseTimer = gSelector->scheduleFiberTimerCall(TimeValue::getTimeOfDay() + getEndpoint().getCommandTimeout(), this, &ClientInboundRpcConnection::close, "ClientInboundRpcConnection::close");
        
        return;
    }

    // cancel the timer in case ::close() is called by something else while we are waiting on the timer and we no longer have outstanding commands.
    if (mCloseTimer != INVALID_TIMER_ID)
        gSelector->cancelTimer(mCloseTimer);

    mCloseTimer = INVALID_TIMER_ID;

    InboundRpcConnection::close();

    if (gUserSessionMaster != nullptr)
    {
        if (mPeerInfo.canAttachToUserSession())
        {
            SliverPtr associatedSliver = gSliverManager->getSliverFromSliverKey(UserSessionsMaster::COMPONENT_ID, mPeerInfo.getConnectionGroupId());
            if (associatedSliver != nullptr)
            {
                Sliver::AccessRef priorityAccess;
                associatedSliver->getPriorityAccess(priorityAccess);

                UserSessionIdVectorSet sessionIds = mPeerInfo.getUserSessionIds();
                for (UserSessionIdVectorSet::iterator it = sessionIds.begin(), end = sessionIds.end(); it != end; ++it)
                {
                    if (priorityAccess.hasSliver())
                        gUserSessionMaster->destroyUserSession(*it, mCloseReason, mSocketError, FORCED_LOGOUTTYPE_INVALID);
                    else
                    {
                        // We couldn't get priority access! That means the sliver is actively being migrated, so we can't mess with anything
                        // to do with that sliver.  But, we still have to make sure we detach ourself from any UserSessions.
                        UserSessionMasterPtr userSession = gUserSessionMaster->getLocalSession(*it);
                        if (userSession != nullptr)
                            userSession->detachPeerInfo();
                    }
                }
            }
        }
    }
}

void ClientInboundRpcConnection::scheduleGracefulClose()
{
    mPerformGracefulClose = true;
}

void ClientInboundRpcConnection::onAllUsersRemoved()
{
    if (mPerformGracefulClose)
        gSelector->scheduleFiberCall(this, &ClientInboundRpcConnection::initiateGracefulClose, "ClientInboundRpcConnection::initiateGracefulClose");
}


ServerInboundRpcConnection::ServerInboundRpcConnection(ConnectionOwner& owner, ConnectionId ident, SocketChannel& channel, Blaze::Endpoint& endpoint, RatesPerIp* rateLimitCounter) : 
    InboundRpcConnection(owner, ident, channel, endpoint, rateLimitCounter),
    mSlaveSession(nullptr)
{
    mPeerInfo.setPeerAsServer();
}

void ServerInboundRpcConnection::close()
{
    if (mSlaveSession != nullptr)
    {
        // mSlaveSession was added to ConnectionManager's list of SlaveSessionPtrs immediately after it was created, so
        // its deletion will be handled by intrusive pointers. Since SlaveSessions are only removed from ConnectionManager's list
        // when the corresponding ServerInboundRpcConnection is closed, it is safe to assume that the SlaveSession is still in the 
        // list and thus that mSlaveSession is a valid pointer.

        // Set the connection to nullptr so that, if any code tries to send notifications to this SlaveSession during the
        // onSlaveSessionRemoved callbacks, the notification can be silently discarded.        
        mSlaveSession->mConnection = nullptr;

        BLAZE_INFO_LOG(Log::CONNECTION, "[ServerInboundRpcConnection:" << ConnectionSbFormat(this) << "].close: Connection closed.");
        gController->getConnectionManager().removeSlaveSession(*mSlaveSession);
        mSlaveSession = nullptr;
    }

    InboundRpcConnection::close(); // call parent close()
}

BlazeRpcError ServerInboundRpcConnection::initRpcContext(RpcContext& rpcContext)
{
    BlazeRpcError err = ERR_OK;
    smCurrentSlaveSession.copyFromCallingFiber();

    //Since we're a server connection, we can interpret the superUserPrivilege flag supplied in the RpcProtocol::Frame
    if (rpcContext.mMessage.getFrame().superUserPrivilege)
    {
        UserSession::pushSuperUserPrivilege();
    }

    UserSessionId userSessionId = rpcContext.mMessage.getUserSessionId();
    if (UserSession::isValidUserSessionId(userSessionId))
    {
        // Even if the user session is not required, if one was provided we want to wait to ensure that its data is propagated.
        {
            err = gUserSessionManager->waitForUserSessionExistence(userSessionId, getEndpoint().getCommandTimeout() / 2);
            if (err != ERR_OK)
            {
                // This should generally not happen, but it is technically possible, in the event when an RPC is issued for a usersession that
                // goes away before the usersession has a chance to be replicated to this instance, in this case waiting is fruitless but we need
                // to do so anyway because currently we have no quick way to validate whether a user session has logged out already.
                BLAZE_WARN_LOG(Log::CONNECTION, "[ServerInboundRpcConnection:" 
                    << ConnectionSbFormat(this) << "].initRpcContext: Failed to find user session = " 
                    << SbFormats::HexLower(userSessionId) << " existence after waiting for replication, error = " << ErrorHelp::getErrorName(err));
            }
        }

        if (err == ERR_OK)
            UserSession::setCurrentUserSessionId(userSessionId);
    }

    return err;
}

SlaveSessionId ServerInboundRpcConnection::makeSlaveSessionIdFromContext(uint64_t context) const
{
    InstanceId instanceId = GetInstanceIdFromInstanceKey64(context);
    if (instanceId != INVALID_INSTANCE_ID)
    {
        SlaveSessionId slaveSessionId = BuildInstanceKey64(instanceId, 0);

        // We make sure another session is not using this session id already.
        SlaveSessionPtr session = gController->getConnectionManager().getSlaveSessionByInstanceId(instanceId);
        if (session == nullptr)
            return slaveSessionId;

        BLAZE_TRACE_LOG(Log::CONNECTION, "[ServerInboundRpcConnection:" << ConnectionSbFormat(session->getConnection()) << "].makeSessionId: Slave session is already using "
            "session id(" << SbFormats::HexLower(session->getId()) << "), using conn ident to create session id for incoming session.");
    }

    // Use the connection identifier[0..64K] to generate the session id
    // (This case occurs frequently on the redirector slaves because they process RPCs
    // tagged with a context of session ids defined by 'foreign' Blaze clusters.
    // To disambiguate those 'foreign' slave sessions, we sub-tag them with the connection ident)
    return BuildInstanceKey64(instanceId, getIdent());
}

SlaveSessionId ServerInboundRpcConnection::getOrCreateSlaveSessionId(const RpcProtocol::Frame &inFrame)
{
    if (EA_UNLIKELY(mSlaveSession == nullptr))
    {
        if (inFrame.componentId != BlazeControllerSlave::COMPONENT_ID || inFrame.commandId != BlazeControllerSlave::CMD_INFO_GETINSTANCEINFO.commandId)
        {
            char addr[64];
            BLAZE_WARN_LOG(Log::CONNECTION, "[ServerInboundRpcConnection:" << ConnectionSbFormat(this) << "].getOrCreateSession: unexpected command "
                << BlazeRpcComponentDb::getComponentNameById(inFrame.componentId) << "::" << BlazeRpcComponentDb::getCommandNameById(inFrame.componentId, inFrame.commandId)
                << " (" << inFrame.componentId << "," << inFrame.commandId << ") from " << getPeerAddress().toString(addr, sizeof(addr)) << " -- closing connection");
            close();
            return SlaveSession::INVALID_SESSION_ID;
        }

        InstanceId instanceId = GetInstanceIdFromInstanceKey64(inFrame.context);

        // We can never allow more than one inbound server connection / slave session to exist, as we cleanup state based
        // on instance id when the session goes away, close the existing connection (if any) which will in turn clean up
        // the session and any state owned by the instance before proceeding to construct a new session
        SlaveSessionPtr oldSession = gController->getConnectionManager().getSlaveSessionByInstanceId(instanceId);
        if (oldSession != nullptr)
        {
            BLAZE_WARN_LOG(Log::CONNECTION, "[ServerInboundRpcConnection:" << ConnectionSbFormat(this) << "].getOrCreateSession: "
                " Closing old connection " << ConnectionSbFormat(oldSession->getConnection()) << " before creating new slave session");

            if (oldSession->getConnection() != nullptr)
                oldSession->getConnection()->close();
        }

        mSlaveSession = BLAZE_NEW SlaveSession(*this, makeSlaveSessionIdFromContext(inFrame.context));
        gController->getConnectionManager().addSlaveSession(*mSlaveSession);

        // Set peer name if the corresponding outbound connection has been done already
        const RemoteServerInstance* remoteInstance = gController->getRemoteServerInstance(instanceId);
        if ((remoteInstance != nullptr) && (mSlaveSession->getConnection() != nullptr))
            mSlaveSession->getConnection()->setPeerName(remoteInstance->getInstanceName());

        BLAZE_INFO_LOG(Log::CONNECTION, "[ServerInboundRpcConnection:" << ConnectionSbFormat(this) << "].getOrCreateSession: new session created");
    }

    smCurrentSlaveSession = mSlaveSession;
    return mSlaveSession->getId();
}

UserSessionId ServerInboundRpcConnection::getOrAllocateUserSessionId(const RpcProtocol::Frame &inFrame)
{
    // The only time a request to a ServerInboundRpcConnection is *not* a real UserSessionId context is when the remote server
    // is establishing a SlaveSession.  The very first RPC the remote server sends is BlazeController::getInstanceInfo().
    // This is the one command that carries the remote server's InstanceId in the RpcProtocol::Frame::context, rather than
    // the UserSessionId (valid or invalid).
    if (EA_UNLIKELY(inFrame.componentId == BlazeControllerSlave::COMPONENT_ID) &&
        EA_UNLIKELY(inFrame.commandId   == BlazeControllerSlave::CMD_INFO_GETINSTANCEINFO.commandId))
    {
        return INVALID_USER_SESSION_ID;
    }

    return inFrame.context;
}

} // Blaze

