// Originally based on NAnt - A .NET build tool
// Copyright (C) 2003-2018 Electronic Arts Inc.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// As a special exception, the copyright holders of this software give you 
// permission to link the assemblies with independent modules to produce 
// new assemblies, regardless of the license terms of these independent 
// modules, and to copy and distribute the resulting assemblies under terms 
// of your choice, provided that you also meet, for each linked independent 
// module, the terms and conditions of the license of that module. An 
// independent module is a module which is not derived from or based 
// on these assemblies. If you modify this software, you may extend 
// this exception to your version of the software, but you are not 
// obligated to do so. If you do not wish to do so, delete this exception 
// statement from your version. 
// 
// Electronic Arts (Frostbite.Team.CM@ea.com)

using System;
using System.IO;

using EA.Eaconfig.Backends.VisualStudio;
using EA.Eaconfig.Core;
using EA.FrameworkTasks.Functions;
using EA.FrameworkTasks.Model;

using NAnt.Core;
using NAnt.Core.Attributes;
using NAnt.Core.Util;

namespace EA.Eaconfig.Backends
{
	/// <summary>
	/// Visual Studio functions
	/// </summary>
	[FunctionClass("Visual Studio Functions")]
	public class VisualStudioFunctions : FunctionClassBase
	{
		/// <summary>
		/// Returns path to the solution file generated ty 'slnruntime', 'slntest', etc targets.
		/// </summary>
		/// <param name="project"></param>
		/// <param name="buildgroup">The name of the buildgroup: 'runtime', 'test', 'example', or 'tool'</param>
		/// <param name="generateSingleConfig">If true, solution names generated by single config targets 'slnruntime-generate-single-config', 'slntest-generate-single-config' is evaluated. Default is "false"</param>
		/// <param name="splitByGroupNames">If true returns solution names split by groups. During solution generation property 'eaconfig.build.split-by-group-names' used to turn this functionality on. Default is "false".</param>
		/// <returns>Full Path to the solution file name.</returns>
		[Function()]
		public static string GetSolutionFileName(Project project, BuildGroups buildgroup, bool generateSingleConfig = false, bool splitByGroupNames = false)
		{
			var templates = GeneratorTemplatesData.CreateGeneratorTemplateData(project, buildgroup);
			var location = Generator.GetGeneratedLocation(project, buildgroup, templates, generateSingleConfig, splitByGroupNames);

			return Path.Combine(location.Dir.Path, location.Name + ".sln");
		}

		/// <summary>
		/// Evaluates Visual Studio "Platform' name for the currently loaded configuration (${config}).
		/// </summary>
		/// <param name="project"></param>
		/// <returns>Name of the Visual Studio 'Platform'</returns>
		[Function()]
		public static string GetVisualStudioPlatformName(Project project)
		{
			return VSSolutionBase.GetVisualStudioPlatformName(project);
		}

		[Function()]
		public static string GetModuleProjectName(Project project, string module, BuildGroups buildGroup, string package)
		{
			// TODO copy pasta from ModuleGenerator - really need this to be a single code path, requires breaking change though
			// because we can't rely on Project being the same right now without some re-architecting
			string projectName = module;
			string template = project.GetPropertyValue(buildGroup.ToString ()+ "." + package + "." + module + ".gen.name.template")
							?? (project.GetPropertyValue(buildGroup.ToString() + "." + module + ".gen.name.template")
							?? project.GetPropertyValue(buildGroup.ToString() + ".gen.name.template"));

			string templatedName = MacroMap.Replace(template, "outputname", module, additionalErrorContext: " from property 'gen.name.template'");

			if (!String.IsNullOrEmpty(templatedName))
			{
				projectName = templatedName;
			}

			GeneratorTemplatesData templates = GeneratorTemplatesData.CreateGeneratorTemplateData(project, buildGroup);
			if (templates != null)
			{
				string filename = templates.ProjectFileNameTemplate.ReplaceTemplateParameters("gen.projectname.template", new string[,]
				{
					{ "%outputname%", module }
				});

				if (!String.IsNullOrEmpty(filename))
				{
					projectName = filename;
				}
			}
			return projectName;
		}

		[Function()]
		public static string GetModuleProjectDir(Project project, string module, BuildGroups buildGroup, string package)
		{
			// TODO copy pasta from ModuleGenerator - really beed this to be a single code path, requires breaking change though
			// because we can't rely on Project being the same right now without some re-architecting
			string buildDir = project.GetPropertyOrFail("package." + package + ".builddir");
			GeneratorTemplatesData templates = GeneratorTemplatesData.CreateGeneratorTemplateData(project, buildGroup);
			if (templates != null)
			{
				string config = project.GetPropertyOrFail("config");
				string outputDir = MacroMap.Replace
				(
					templates.ProjectDirTemplate,
					new MacroMap()
					{
						{ "outputdir", buildDir },
						{ "package.builddir", buildDir },
						{ "package.configbuilddir", Path.Combine(buildDir, config, "build") },
						{ "package.root", PackageFunctions.GetPackageRoot(project, package) },
						{ "package.name", package },
						{ "module.name", module }
					},
					additionalErrorContext: " from property 'gen.projectdir.template'"
				);

				if (!String.IsNullOrEmpty(outputDir))
				{
					buildDir = PathNormalizer.Normalize(outputDir);
				}
			}

			return buildDir;
		}
	}
}
