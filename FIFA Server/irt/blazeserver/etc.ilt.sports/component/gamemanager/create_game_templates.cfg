
//createGameTemplatesConfig = {

createGameTemplates = {
  
    "packerGameILT" = {

        // Set this to RESET_GAME if you want this to be a resetDedicatedServer request:
        createRequestType = "CREATE_GAME"     // Other options: CREATE_OR_JOIN_GAME (join based on persisted id), RESET_GAME // PACKER_TODO: Packer does not currently check this!
        
        // The Base Request is just a CreateGameRequest value.  It's provides a simple 'Base' for the request:
        baseRequest = {
            gameCreationData = { 
                networkTopology = "CLIENT_SERVER_PEER_HOSTED"
                voipNetwork = "VOIP_DISABLED"

                gameSettings = ["openToBrowsing",
                                "openToMatchmaking", 
                                "openToInvites", 
                                "openToJoinByPlayer",
                                "hostMigratable",
                                "joinInProgressSupported",     
                                "allowAnyReputation" ]

                // These capacity and teamIds settings are currently *required* for packerConfig to be able to reference game properties!
                // The packerConfig.qualityFactors are not currently able to obtain those values from the corresponding elements of the attributes={} map.
                slotCapacitiesMap = { SLOT_PUBLIC_PARTICIPANT = 4 } // PACKER_TODO: currently this is unvalidated vs maxPlayerCapacity!!!
                maxPlayerCapacity = 4 // NOTE: right now we can define the max game size to be whatever, and yet the packer will not validate that parties whose size exceeds the max player capacity are not to be considered in a given silo at all! We should build packer silos based on the understanding that capacity constraints matter, it simply doesn't make sense to attempt to fit a party of players that could exceed the capacity of the game.
                teamIds = [1,2] // two teams
             } 
        }

        // Attributes are (optionally) sent from the client, to configure the settings used:
        attributes = {
          // Note: only one attribute is currently provided for the create game settings:
            "CreateGameRequest.gameCreationData.gameAttribs[OSDK_gameMode]"   = { attrName = "GAME_MODE", default = "7" }
        }

        packerConfig = {
            qualityFactors = [
                { gameProperty="game.players", transform="size",
                    scoreShaper={ DefaultShaper={ bestValue={ propertyName="game.participantCapacity" }, viableValue={ propertyName="game.participantCapacity" }, worstValue=0 } } }

                { gameProperty="game.pingSite", transform="avg",
                    keys={ propertyName="caller.acceptedPingSites"}, scoringMap={ propertyName="players.pingSiteLatencies" },
                    scoreShaper={ DefaultShaper={ bestValue=0, viableValue=200, worstValue=10000, granularity=10 } } }

                //{ gameProperty="game.attributes[progress]", transform="avg",
                //    keys = { attrName = "DESIRED_PROGRESS_LIST" } // attribute defined in input sanitizer
                //    scoringMap={ default={ tdfid="map<string,float>", value = {"0"=0, "1"=1, "2"=2, "3"=2, "4"=2, "5"=2} } },
                //    scoreShaper={ DefaultShaper={ bestValue=0, viableValue=1, worstValue=2 } } }

                { gameProperty="game.teams.players.uedValues", transform="sum", teamMergeOp="MERGE_MIN_MAX_RATIO",
                    keys={ default="teamSkill" }, scoringMap={ propertyName="players.uedValues" },
                    scoreShaper={ DefaultShaper={ bestValue=1, viableValue=0, worstValue=0, granularity=0.1 } } }

                //{ gameProperty="game.players", transform = "size",                          scoreShaper={ DefaultShaper = { viableValue={propertyName = "game.participantCapacity" },   bestValue={propertyName = "game.participantCapacity" }, worstValue=0             } } }

                //{ goal = "minimize", gameProperty = "game.pingSiteLatenciesList[].avg", scoreShaper = { function = "range", viableValue = "200", maxValue = "10000", params = { "granularity" = "10" } } }

                //{ goal = "maximize", gameProperty = "game.teams.uedValue[teamSkill].sum", scoreShaper = { function = "ratio", viableValue = "0", maxValue = "1", params = {"granularity" = "0.1"} } }
                
                //{ gameProperty="game.teams.players", transform = "size.min",                scoreShaper={ DefaultShaper = { viableValue={propertyName = "game.teamCapacity" },   bestValue={propertyName = "game.teamCapacity" }                     } } }
            ]

            viableGameCooldownThreshold = "1s";
        }
    }


}
//}

