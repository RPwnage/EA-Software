/*! ************************************************************************************************/
/*!
    \file gamepacker_server.tdf


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

// Include for GameId
[headername="gamemanager/tdf/gamemanager.h"]
#include "gamemanager/gen/gamemanager.tdf"

namespace Blaze
{
namespace GameManager
{

typedef uint64_t PackerSessionId;
typedef uint64_t PackerSiloId;
typedef uint64_t PackerFinalizationJobId;

typedef int64_t PackerPlayerId;
typedef int64_t PackerPartyId;
typedef int64_t PackerGameId;

const PackerSessionId INVALID_PACKER_SESSION_ID = 0;
const PackerSiloId INVALID_PACKER_SILO_ID = 0;

enum GamePackerIdType
{
    GAMEPACKER_IDTYPE_SESSION, // reserved
    GAMEPACKER_IDTYPE_SCENARIO, // reserved
    GAMEPACKER_IDTYPE_PACKER_SILO,
    GAMEPACKER_IDTYPE_TEMPLATE_SILO,
    GAMEPACKER_IDTYPE_FINALIZATION_JOB
};

enum PackerFinalizationTrigger
{
    [description = "Viable game has exceeded its cooldown period."]
    COOLDOWN,
    [description = "At least one of the sessions in the game has expired."]
    DEADLINE,
    [description = "Game is ideal."]
    OPTIMAL
};

[ description = "Internal master scenario specific state common to all sibling packer sessions", tdfid = "hash", generateProto = false ]
class PackerScenarioData
{
    enum TerminationReason
    {
        SCENARIO_COMPLETED,
        SCENARIO_TIMED_OUT,
        SCENARIO_CANCELED,
        SCENARIO_OWNER_LEFT,
        SCENARIO_FAILED
    };

    [tag="stim", description="Scenario started timestamp."]
    TimeValue startedTimestamp;

    [tag="etim", description="Scenario expires timestamp."]
    TimeValue expiresTimestamp;

    [tag="ltim", description="Scenario locked timestamp."]
    TimeValue lockedTimestamp;

    [tag="lext", description="Scenario lock expiration timestamp."]
    TimeValue lockExpiresTimestamp;

    [tag="lock", description="Packer session id that locked this scenario for finalization.", default=0]
    uint64_t lockedForFinalizationByPackerSessionId;

    [tag="xtrn", description="External session name"]
    string(-1) externalSessionName;

    [tag="trsn"]
    TerminationReason terminationReason;

    [tag="pseq", description="When zero, all packer sessions are present"]
    int32_t packerSessionSequence;
};


[ description = "Internal master state of the packer session", tdfid = "hash", generateProto = false ]
class PackerSessionData
{
    [ description = "Internal master enum used to explicitly track the lifecycle of the packer session" ]
    enum SessionState
    {
        [description = "Ready to be assigned to a worker"]
        SESSION_AWAITING_ASSIGNMENT,
        [description = "Assigned to a worker"]
        SESSION_ASSIGNED,
        [description = "Suspended due to finalization lock collision. Resumed if suspending sibling session is unlocked or aborted."]
        SESSION_SUSPENDED,
        [description = "Waiting to be released by assigned worker. Used by master to flag the session as pending release."]
        SESSION_AWAITING_RELEASE,
        [description = "Delayed start."]
        SESSION_DELAYED,
        [description = "Session completed successfully."]
        SESSION_COMPLETED,
        [description = "Session was aborted due to error."]
        SESSION_ABORTED
    };

    [ description = "Internal master enum used to generate session outcome metric tags" ]
    enum SessionResult
    {
        [description = "Session completed successfully."]
        SUCCESS,
        [description = "Session failed game setup."]
        FAILED,
        [description = "Session timed out."]
        TIMED_OUT,
        [description = "Session was stopped due to client-initiated action (e.g. user explicitly canceled or logged out)."]
        CANCELED,
        [description = "Session was stopped due to server-initiated action (e.g. restart)."]
        TERMINATED,
        [description = "Session was stopped due to sibling session having completed."]
        ENDED
    };

    [tag="wrkr", description="Assigned worker id."]
    uint16_t assignedWorkerInstanceId;

    [tag="layr", description="Assigned layer id in the layer hierarchy."]
    int32_t assignedLayerId;

    [tag="stim", description="Tracks the time the session was started. Write once."]
    TimeValue startedTimestamp;

    [tag="atim", description="Tracks the last time the session was assigned to a worker. If assigned, acquiredTimestamp > releasedTimestamp."]
    TimeValue acquiredTimestamp;

    [tag="rtim", description="Tracks the last time the session was released by a worker (unlocked,migrated,aborted)."]
    TimeValue releasedTimestamp;

    [tag="utim", description="Tracks the last time the session received a status update from a worker."]
    TimeValue updatedStatusTimestamp;

    [tag="itim", description="Tracks the last time the session received a status update from a worker that improved its score."]
    TimeValue improvedScoreTimestamp;

    [tag="ptim", description="Tracks the time the owner requested the session to be released by assigned worker. If awaiting release, pendingReleaseTimestamp < releasedTimestamp."]
    TimeValue pendingReleaseTimestamp;
    
    [tag="udur", description="Total session time spent waiting to be acquired by a worker."]
    TimeValue unassignedDuration;

    [tag="sdur", description="Session duration, aka when to expire."]
    TimeValue sessionDuration; // PACKER_TODO: should get rid of this when we implement delayed start based on scenario start time, because its known from the request...

    [tag="rcou", description="Number of times session has been released by a worker (unlocked,migrated,aborted)."]
    uint64_t releaseCount;

    [tag="stat", description="This state is used to aid in robust handling of packer session transitions."]
    SessionState state;

    [tag="gqfs", description="Latest game quality factor scores"]
    list<float> gameFactorScores;

    [tag="gqus", description="Latest aggregate game quality score"]
    float gameQualityScore;
};

[ description = "", generateProto = false ]
class StartPackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;

    [tag="pssq"]
    uint32_t packerSessionSequence;

    [tag="ireq"]
    variable internalRequest;
};

[ description = "", generateProto = false ]
class StartPackerSessionResponse
{
    [tag="irsp"]
    variable internalResponse;
};

[ description = "", generateProto = false ]
class StartPackerSessionError
{
    [tag="ierr"]
    variable internalError;
};

[ description = "", generateProto = false ]
class CancelPackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;
};


[ description = "", generateProto = false ]
class WorkerObtainPackerSessionRequest
{
};

[ description = "", generateProto = false ]
class WorkerObtainPackerSessionResponse
{
    [tag="psid"]
    PackerSessionId packerSessionId;

    [tag="ddln", description="Absolute session completion deadline. NOTE: Deliberately non-relative to compensate for message lag time under load causing slave to schedule expiry too late."]
    TimeValue expiryDeadline;

    [tag="vers", description="Version of the master session data to enable efficient resync in case of disconnect."]
    uint64_t version;

    [tag="ireq"]
    variable internalRequest;
};

[ description = "", generateProto = false ]
class WorkerMigratePackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;
};

[ description = "", generateProto = false ]
class WorkerRelinquishPackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;
};

[ description = "Packer session has been successfully finalized into a game.", generateProto = false ]
class WorkerCompletePackerSessionRequest
{
    [tag="psid"]
    PackerSiloId packerSessionId;

    [tag="gaid"]
    GameId gameId;

    [tag="isid", description="Identifies packer session that initiated the finalization process. May belong to different packer master instance than packer session being completed in this request."]
    PackerSessionId initiatorPackerSessionId;

    [tag="gqfs", description="Final game quality factor scores"]
    list<float> gameFactorScores;

    [tag="gqus", description="Final aggregate game quality score"]
    float gameQualityScore;

    [tag="pins", description="PIN event to submit"]
    variable pinSubmission; // PINSubmission
};

[ description = "Packer session has been aborted due to error.", generateProto = false ]
class WorkerAbortPackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;

    [tag="isid", description = "Identifies packer session that initiated the finalization process. May belong to different packer master instance than packer session being completed in this request."]
    PackerSessionId initiatorPackerSessionId;
};

[ description = "", generateProto = false ]
class WorkerLockPackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;
};

[ description = "", generateProto = false ]
class WorkerUnlockPackerSessionRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;
};

[ description = "Request object", generateProto = false ]
class WorkerUpdatePackerSessionStatusRequest
{
    [tag="psid"]
    PackerSessionId packerSessionId;

    [tag="gqfs", description="Game factor scores resulting from the addition of the joining party"]
    list<float> gameFactorScores;

    [tag="gqus", description="Final aggregate game quality score"]
    float gameQualityScore;
};

[ description = "", generateProto = false ]
class WorkerLayerAssignmentRequest
{
    [tag="name", description = "Worker instance name. Needed because when the worker registers with the master the latter has often not yet received the remote server registration for it yet."]
    string(-1) instanceName;

    [tag="type", description = "Worker instance type name to used for Scenario Partitioning.  Needed because when the worker registers with the master the latter has often not yet received the remote server registration for it yet."]
    string(-1) instanceTypeName;

    [tag="slot", description = "Sequential slot number used by the master to idempotently compute the layer id."]
    uint32_t layerSlotId;

    [tag="vers", description = "Slot assignment version incremented at each slot version assignment in redis. Used by the master to discard slot assignment requests that may arrive out of order."]
    uint64_t layerSlotAssignmentVersion;
};

[ description = "", generateProto = false ]
class WorkerLayerAssignmentResponse
{
    [tag="vers", description = "Slot assignment version held by the master. When this does not match what the version in the request, this means the update was discarded and the caller should refresh its version."]
    uint64_t layerSlotAssignmentVersion;
};

[ description = "Internal worker enum used to explicitly track the cleanup reason of the packer session" ]
enum WorkerSessionCleanupReason
{
    [description = "Session successfully packed into game"]
    WORKER_SESSION_COMPLETED,

    [description = "Session exceeded non-viable time quantum"]
    WORKER_SESSION_MIGRATED,

    [description = "Session owner left before completion, session will be updated, reenter the worker hierarchy"]
    WORKER_SESSION_RELINQUISHED,

    [description = "Session scenario already finalizing, master will resume if finalization fails"]
    WORKER_SESSION_SUSPENDED,

    [description = "Session terminated by master (see PackerScenarioData::TerminationReason)"]
    WORKER_SESSION_TERMINATED,

    [description = "Session expired locally while attempting to finalize"]
    WORKER_SESSION_EXPIRED,

    [description = "Session placeholder swept during empty silo removal"]
    WORKER_SESSION_EMPTY_SILO_REMOVED,

    [description = "Session placeholder unpacked during active game removal"]
    WORKER_SESSION_ACTIVE_GAME_REMOVED,

    [description = "Session placeholder unpacked during active game update"]
    WORKER_SESSION_ACTIVE_GAME_UPDATED,

    [description = "Session creation failed due to internal error, see log"]
    WORKER_SESSION_CREATE_FAILED,

    [description = "Session finalization failed due to internal error, see log"]
    WORKER_SESSION_FINALIZE_FAILED
};

// Notifications

[ description = "", generateProto = false ]
class NotifyWorkerPackerSessionAvailable
{
    [tag="inst", description = "Owner instance id."]
    uint16_t instanceId;

    [tag="acnt"]
    uint32_t availableSessionsCount;
};

[ description = "Session change. Future: will be replaced by per/mmSession storage manager subscription", generateProto = false ]
class NotifyWorkerPackerSessionRelinquish
{
    [tag="psid"]
    PackerSessionId packerSessionId;

    [tag="vers", description="Version of the master session data to enable efficient resync in case of disconnect."]
    uint64_t version;
};

[ description = "Session termination. Future: will be replaced by per/mmSession storage manager subscription", generateProto = false ]
class NotifyWorkerPackerSessionTerminated
{
    [tag="psid"]
    PackerSessionId packerSessionId;

    [tag="trsn"]
    PackerScenarioData::TerminationReason terminationReason;
};

[ description = "Request object", generateProto = false ]
class GetPackerMetricsRequest
{
    [tag="ikey"]
    string(-1) metricsInfoKey;
};

[ description = "Response object", generateProto = false ]
class GetPackerMetricsResponse
{
    [ description = "", generateProto = false ]
    class MetricsInfo
    {
        [tag="mmap"]
        list<string(-1)> metrics;
    };

    [tag="imap"]
    map<string(-1),MetricsInfo> metricsInfo;
};

[ description = "", generateProto = false ]
class PackerSiloCreated
{
    [tag="psid", description="Packer silo id."]
    PackerSiloId createdPackerSiloId;

    [tag="pstm", description="Name of the game template which contains the packer config for this packer silo."]
    string(-1) gameTemplateName;

    [tag="pscs", description="List of condition = value pairs used to create the packer silo."]
    string(-1) packerSiloConditions;

    [tag="scor", description="List of GQFs used by the game template."]
    string(-1) gameQualityFactors;
};

[ description = "", generateProto = false ]
class PackerSiloDestroyed
{
    [tag="psid", description="Packer silo id."]
    PackerSiloId destroyedPackerSiloId;

    [tag="tpa", description="Total number of parties to have been added to the packer silo during it's lifetime."]
    uint64_t totalParties;

    [tag="tpl", description="Total number of players to have been added to the packer silo during it's lifetime."]
    uint64_t totalPlayers;

    [tag="tga", description="Total number of games created by the packer silo during it's lifetime."]
    uint64_t totalGames;

    [tag="tpae", description="Total number of parties evicted from games by the packer silo during it's lifetime."]
    uint64_t totalPartiesEvicted;

    [tag="tple", description="Total number of players evicted from games by the packer silo during it's lifetime."]
    uint64_t totalPlayersEvicted;

    [tag="tta", description="life time duration of packer silo"]
    TimeValue totalTimeAlive;
};

[ description = "", generateProto = false ]
class PackerSiloTotals
{
    [tag="tpro", description="Total new provisional parties. Tracks parties associated with packer sessions."]
    uint64_t totalNewProvisionalParties;

    [tag="tpla", description="Total new placeholder parties. Tracks immutable groups of members in active games."]
    uint64_t totalNewPlaceholderParties;
};


[ description = "", generateProto = false ]
class PackerSiloPartyAdded
{
    typedef map<string(-1), int64_t> PropertyValueMap;

    class Player
    {
        [tag="plid", description="Id of player."]
        PackerPlayerId playerId;

        [tag="prop", description="Map of player property values used by the packer to evaluate game quality factors."]
        PropertyValueMap properties;
    };

    [tag="paid", description="Id of party being added to the packer silo. This is the matchmaking session id."]
    PackerPartyId addedPartyId;

    [tag="pasi", description="Packer silo id."]
    PackerSiloId packerSiloId;

    [tag="pspl", description="Total packer silo players."]
    uint64_t packerSiloPlayers;

    [tag="pspa", description="Total packer silo parties."]
    uint64_t packerSiloParties;

    [tag="psga", description="Total packer silo games."]
    uint64_t packerSiloGames;

    [tag="pvgc", description="Total packer silo viable games."]
    uint64_t packerSiloViableGames;

    [tag="plrs", description="Player information used by the packer."]
    list<Player> players;
};

[ description = "", generateProto = false ]
class PackerSiloPartyRemoved
{
    [tag="paid", description="Id of party being removed from the packer silo. This is the matchmaking session id."]
    PackerPartyId removedPartyId;

    [tag="pasi", description="Packer silo id."]
    PackerSiloId packerSiloId;

    [tag="pavi", description="Number of times party was evicted from a provisional game."]
    uint64_t partyEvictions;

    [tag="prre", description="Removal reason for party from packer silo id. Reasons: completed, migrated, mutated, removed, expired, repack."]
    string(-1) partyRemovalReason;

    [tag="slim", description="Realative to creation time."]
    TimeValue lastImprovedTime;

    [tag="spla", description="Total packer silo players."]
    uint64_t packerSiloPlayers;

    [tag="spar", description="Total packer silo parties."]
    uint64_t packerSiloParties;

    [tag="sgam", description="Total packer silo games."]
    uint64_t packerSiloGames;

    [tag="svga", description="Total packer silo viable games."]
    uint64_t packerSiloViableGames;
};

[ description = "", generateProto = false ]
class PackerGamePartyAdded
{
    [tag="paid", description="Party id of party being added to game."]
    PackerPartyId joinedPartyId;

    [tag="pgid", description="Game id"]
    PackerGameId packerGameId;

    [tag="psid", description="Packer silo id."]
    PackerSiloId packerSiloId;

    [tag="gqfs", description="Factor scores for game."]
    list<float> gameFactorScores;

    [tag="gsco", description="Scalar game score."]
    float gameScore;

    [tag="psto", description="Silo snapshot."]
    PackerSiloTotals siloTotals;
};

[ description = "", generateProto = false ]
class PackerGamePartyEvicted
{
    [tag="paed", description="Party id of party evicted from game."]
    PackerPartyId evictedPartyId;
    
    [tag="paer", description="Party id of party that caused the eviction."]
    PackerPartyId evictorPartyId;

    [tag="pgid", description="Game id"]
    PackerGameId packerGameId;

    [tag="psid", description="Packer silo id."]
    PackerSiloId packerSiloId;
};

/*
// Additional future tracing events

[ description = "", generateProto = false ]
class PackerGamePartyExpired
{
    [tag="paid", description="Party id of party expired from game."]
    PackerPartyId expiredPartyId;

    [tag="pgid", description="Game id"]
    PackerGameId packerGameId;

    [tag="psid", description="Packer silo id."]
    PackerSiloId packerSiloId;

    [tag="pstg", description="Expired in stage.(e.g: reap, finalize)"]
    string(-1) expireStage;
};

[ description = "", generateProto = false ]
class PackerGamePartyUnpacked
{
    [tag="paid", description="Party id of party unpacked from game."]
    PackerPartyId unpackedPartyId;

    [tag="pgid", description="Game id"]
    PackerGameId packerGameId;

    [tag="psid", description="Packer silo id."]
    PackerSiloId packerSiloId;
};
*/

[ description = "", generateProto = false ]
class PackerGameCompleted
{
    [ description = "", generateProto = false ]
    class Party
    {
        [tag="arid", description=""]
        PackerPartyId partyId;
        [tag="idx", description=""]
        uint32_t teamIndex;
        [tag="timw", description="Relative time since creation in microseconds"]
        int64_t waitTime;
        [tag="timi", description="Relative time since creation in microseconds"]
        int64_t lastImprovedTime;
    };

    [tag="pgid", description="Game id."]
    PackerGameId completedGameId;

    [tag="pjid", description="Finalization job id."]
    PackerFinalizationJobId finJobId;

    [tag="psid", description="Packer silo id."]
    PackerSiloId packerSiloId;

    [tag="gqfs", description="Factor scores for game."]
    list<float> gameFactorScores;

    [tag="gsco", description="Scalar game score."]
    float gameScore;
    
    [tag="part", description=""]
    list<Party> parties;

    [tag="play", description=""]
    list<PackerPlayerId> playerIds;

    [tag="evpa", description="Number of party evictions from game."]
    uint64_t evictedParties;

    [tag="evpl", description="Number of player evictions from game."]
    uint64_t evictedPlayers;

    [tag="tila", description="Relative to totalTime"]
    uint64_t lastImprovedTime;

    [tag="tovt", description="Relative to totalTime"]
    uint64_t totalViableTime;

    [tag="toti", description="Total time since creation"]
    uint64_t totalTime;

    [tag="psto", description="Silo snapshot."]
    PackerSiloTotals siloTotals;
};

// PACKER_TODO: use this as a trace event
[ description = "Issued for each party when game has been finalized", generateProto = false ]
class PackerFinalizationJobStarted
{
    [tag="fjid", description="Finalization job id."]
    PackerFinalizationJobId finJobId;

    [tag="fjmd", description="Finalization job mode. (e.g: found_game, create_game, create_game_privileged, create_game_reset_ds, etc."]
    string(-1) finJobMode;
};

// PACKER_TODO: use this as a trace event
[ description = "Issued for each party when game has been finalized", generateProto = false ]
class PackerFinalizationJobCompleted
{
    [tag="fjid", description="Finalization job id."]
    PackerFinalizationJobId finJobId;

    [tag="rslt", description="Finalization job result. success, fail_resume, fail_abort"]
    string(-1) result;
};


// status and metrics types


typedef map<uint64_t, uint64_t> FreqByPercentileMap;
typedef map<string(64), FreqByPercentileMap> FactorScoresByPercentileMap;

[ description = "", generateProto = false ]
class HistogramPackerMetrics
{
    [tag="scor", description="Histogram representation of factor scores (in percent format) for successfully created games."]
    FactorScoresByPercentileMap factorScoresByPercentileForSuccessfulGames;

    [tag="ssor", description="Histogram representation of factor scores (in percent format) for all games."]
    FactorScoresByPercentileMap factorScoresByPercentileForGames;

    [tag="vtim", description="Histogram representation of time spent in viable games by parties."]
    FreqByPercentileMap timeSpentInViableGamesByParties;

    [tag="vstm", description="Histogram representation of time spent in viable games by parties who ended up in a game."]
    FreqByPercentileMap timeSpentInViableGamesBySuccessfulParties;

    [tag="timp", description="Histogram representation of time spent in the packer by parties."]
    FreqByPercentileMap timeSpentInPackerByParties;

    [tag="tisp", description="Histogram representation of time spent in packer games by parties who ended up in a game."]
    FreqByPercentileMap timeSpentInPackerBySuccessfulParties;

    [tag="evap", description="Histogram representation of number of times evicted by parties."]
    FreqByPercentileMap evictionCountByParties;

    [tag="evsp", description="Histogram representation of number of times evicted by parties who ended up in a game."]
    FreqByPercentileMap evictionCountBySuccessfulParties;
};

typedef map<string(-1), HistogramPackerMetrics> GameTemplatePackerMetrics;

[ description = "", generateProto = false ]
class GetDetailedPackerMetricsResponse
{
    [tag="gpme", description="Map of histogram metrics per game template"]
    GameTemplatePackerMetrics gameTemplatePackerMetrics;
};


} // GameManager
} // Blaze



