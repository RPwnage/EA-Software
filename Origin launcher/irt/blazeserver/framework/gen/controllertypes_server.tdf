[headername="framework/tdf/frameworkconfigtypes_server.h"]
#include "framework/gen/frameworkconfigtypes_server.tdf"

[headername="framework/tdf/frameworkconfigdefinitions_server.h"]
#include "framework/gen/frameworkconfigdefinitions_server.tdf"

[headername="framework/tdf/frameworkredistypes_server.h"]
#include "framework/gen/frameworkredistypes_server.tdf"

// TODO: Disabling proto generation because of circular import caused by Blaze::Redirector namespace
[headername="redirector/tdf/redirectortypes.h", includeProto=false]
#include "redirector/gen/redirectortypes.tdf"

[headername="framework/tdf/transaction_server.h"]
#include "framework/gen/transaction_server.tdf"

[headername="framework/tdf/censusdatatype.h"]
#include "framework/gen/censusdatatype.tdf"

[headername="framework/tdf/userdefines.h"]
#include "framework/gen/userdefines.tdf"

// TODO: Disabling proto generation because of circular import caused by Blaze::Event namespace
[headername="framework/tdf/eventtypes_server.h", includeProto=false]
#include "framework/gen/eventtypes_server.tdf"

[headername="framework/tdf/storage_server.h"]
#include "framework/gen/storage_server.tdf"

namespace Blaze
{

typedef list<uint16_t> InstanceIdList;

const char8_t* DB_INSTANCE_NAME = "dbInstanceName";

// TODO: Disabling proto generation because of circular import caused by Blaze::Redirector::ServerEndpointInfo
[generateProto=false]
class ServerInstanceInfo
{
    [generateProto=false]
    class EndpointInfo
    {
        [tag="port"] uint16_t mPort;
        [tag="iadr"] uint32_t mIntAddress;
        [tag="eadr"] uint32_t mExtAddress;
        [tag="prot"] string(128) mProtocol;
        [tag="enc"]  string(128) mEncoder;
        [tag="dec"]  string(128) mDecoder;
    };
    typedef map<string(128), ComponentId, ignorecase> ComponentMap;

    [tag="id"] uint16_t instanceId;
    [tag="type"] string(128) instanceType;
    [tag="inst"] string(128) instanceName;
    [tag="typi"] uint8_t instanceTypeIndex;
    [tag="rgid"] uint64_t registrationId;
    [tag="cmpt"] ComponentMap components;
    [tag="enpt"] EndpointInfo internalEndpoint;
    [tag="impa"] ServerConfig::ServiceImpact serviceImpact;
    [tag="iplu"] bool immediatePartialLocalUserReplication;
    [tag="idrn"] bool isDraining;
    [tag="strt"] TimeValue mStartupTime;

    typedef list<Blaze::Redirector::ServerEndpointInfo> ServerEndpointInfoList;
    [tag="ndps"] ServerEndpointInfoList endpointInfoList;
};

class GetServerConfigRequest
{
    [tag="base", description="Base name of the server instance"] string(128) mBaseName;
};

// TODO: Proto generation is disabled for BootConfig
[generateProto=false]
class GetServerConfigResponse
{
    [tag="cfg", description="The boot configuration of the config master.", allowref=true]
    BootConfig mMasterBootConfig;
};

// TODO: Proto generation is disabled for ServerInstanceInfo
[generateProto=false]
class GetInstanceInfoResponse
{
    [tag="info"] ServerInstanceInfo instanceInfo;
};

class CheckClusterMembershipRequest
{
    [tag="inst"] uint16_t instanceId;
    [tag="name"] string(128) instanceName;
    [tag="rgid"] uint64_t registrationId;
    [tag="port"] uint16_t internalPort;
    [tag="iadr"] uint32_t internalAddress;
};

typedef map<string(128),uint64_t, ignorecase> ErrorCountMap;
class CommandMetricInfo
{
    [tag="comp"] uint16_t mComponent;
    [tag="cmd"]  uint16_t mCommand;
    [tag="cmpn"] ComponentName mComponentName;
    [tag="cmdn"] string(64) mCommandName;
    [tag="cnt"]  uint64_t mCount;
    [tag="csuc"] int64_t mSuccessCount;
    [tag="cfil"] int64_t mFailCount;
    [tag="fcnt"] uint64_t mAuthorizationFailureCount;
    [tag="ttim"] int64_t mTotalTime;
    [tag="gctm"] int64_t mGetConnTime;
    [tag="txct"] uint64_t mTxnCount;
    [tag="dbct"] uint64_t mQueryCount;
    [tag="mdct"] uint64_t mMultiQueryCount;
    [tag="pstc"] uint64_t mPreparedStatementCount;
    [tag="dbtm"] int64_t mQueryTime;
    [tag="dbst"] int64_t mQuerySetupTimeOnThread;
    [tag="dbet"] int64_t mQueryExecutionTimeOnThread;
    [tag="dbcu"] int64_t mQueryCleanupTimeOnThread;
    

    [tag="cpu", default=0, description="time spent in a fiber, in microseconds"]
    int64_t mFiberTime;
    
    [tag="err", description="tally of errors returned"] 
    ErrorCountMap mErrorCountMap;
};

class ComponentMetricsRequest
{
    [tag="comp"] uint16_t mComponentId;
    [tag="cmd"]  uint16_t mCommandId;
};

class ComponentMetricsResponse
{
    [tag="comp"] list<CommandMetricInfo> mMetrics;
};

class OutboundConnMgrStatus
{
    [tag="host"] string(256) mHost;
    [tag="port"] uint16_t mPort;
    [tag="tcon"] uint32_t mTotalConnections;
    [tag="acon"] uint32_t mActiveConnections;
    [tag="pcon"] uint32_t mPeakConnections;
    [tag="mcon"] uint32_t mMaxConnections;
    [tag="tout"] uint64_t mTotalTimeouts;
};

class ComponentStatus
{
    [tag="id"]   uint16_t mComponentId;
    [tag="name"] ComponentName mComponentName;
    [tag="st"]   string(64) mState;
    typedef map<string(128),string(1024)> InfoMap ;
    typedef map<ProductName, InfoMap, ignorecase> InfoByProductName;
    typedef map<ServiceName, InfoMap, ignorecase> InfoByServiceName;
    typedef map<string(CLIENT_VERSION_MAX_LENGTH), InfoMap, ignorecase> InfoByClientVersion;
    [tag="info"] InfoMap mInfo;
    [tag="pinf"] InfoByProductName mInfoByProductName;
    [tag="sinf"] InfoByProductName mInfoByServiceName;
    [tag="vinf"] InfoByClientVersion mInfoByClientVersion;
    [tag="rlod", default=false] bool mIsReloadableComponent;
};

class ServerVersion
{
    [tag="vers"] string(128) mVersion;
    [tag="time"] string(64) mBuildTime;
    [tag="loc"]  string(256) mBuildLocation;
    [tag="btgt"] string(256) mBuildTarget;
    [tag="p4"]   string(256) mP4DepotLocation;
    [tag="msrc"] uint32_t mModifiedSourceFiles;
};

class DbInstancePoolStatus
{
    [tag="host"] string(256) mHost;
    [tag="port"] uint16_t mPort;
    [tag="user"] string(64) mUser;
    [tag="tcon"] uint32_t mTotalConnections;
    [tag="acon"] uint32_t mActiveConnections;
    [tag="pcon"] uint32_t mPeakConnections;
    [tag="tacn"] uint32_t mTotalAvailableConnections;
    [tag="sqlc"] bool mSquelching;
    [tag="dran"] bool mDraining;
    [tag="terr"] uint64_t mTotalErrors;
    [tag="tq"] uint64_t mTotalQueries;
    [tag="tmq"] uint64_t mTotalMultiQueries;
    [tag="tps"] uint64_t mTotalPreparedStatementQueries;
    [tag="tcmt"] uint64_t mTotalCommits;
    [tag="trb"] uint64_t mTotalRollbacks;
    [tag="qta"] int64_t mQueryTimeAverageMs;
    [tag="qtd"] int64_t mQueryTimeDeviationMs;
    [tag="qtba"] int64_t mQueryTimeBaselineAverageMs;
    [tag="qtbd"] int64_t mQueryTimeBaselineDeviationMs;
    [tag="qtca"] int64_t mTotalQueryTimeThresholdCrosses;
};

class DbConnPoolStatus
{
    [tag="name"] string(256) mName;
    [tag="db"]   string(256) mDatabase;
    [tag="mstr"] DbInstancePoolStatus mMaster;
    [tag="qfms"] uint32_t mQueuedFibersMaster;
    [tag="qfsl"] uint32_t mQueuedFibersSlaves;
    [tag="slav"] list<DbInstancePoolStatus> mSlaves;
    [tag="thrd"] bool mUsingDbThreads;
};

class DatabaseStatus
{
    [tag="tthr"] uint32_t mTotalWorkerThreads;
    [tag="athr"] uint32_t mActiveWorkerThreads;
    [tag="pthr"] uint32_t mPeakWorkerThreads;
    [tag="pool"] map<uint32_t, DbConnPoolStatus> mConnectionPools;
};

class ConnectionStatus
{
    [tag="id"]   int32_t mIdent;
    [tag="addr"] string(64) mAddress;
    [tag="port"] uint16_t mPort;
    [tag="padr"] string(64) mPeerAddress;
    [tag="pprt"] uint16_t mPeerPort;
    [tag="prot"] string(32) mProtocol;
    [tag="enc"]  string(32) mEncoder;
    [tag="dec"]  string(32) mDecoder;
    [tag="rebt"] uint64_t mRecvBytes;
    [tag="rect"] uint64_t mRecvCount;
    [tag="sebt"] uint64_t mSendBytes;
    [tag="sect"] uint64_t mSendCount;
    [tag="oqsz"] uint32_t mOutputQueueSize;
    [tag="oqbt"] uint32_t mOutputQueueBytes;
};

class EndpointStatus
{
    [tag="name"] string(128) mName;
    [tag="type"] string(32) mType;
    [tag="port"] uint16_t mPort;
    [tag="conu"] uint32_t mConnectionNum;
    [tag="mcnu"] uint32_t mMaxConnectionNum;
    [tag="hwcu"] uint32_t mHighWatermarks;
    [tag="hwtt"] uint64_t mTotalHighWatermarks;
    [tag="hwdc"] uint64_t mTotalHighWatermarkDisconnects;
    [tag="trcn"] uint64_t mTotalResumedConnections;
    [tag="trcf"] uint64_t mTotalResumedConnectionsFailed;
    [tag="fcnt"] uint64_t mTotalRpcAuthorizationFailureCount;
    [tag="rbt"]  uint64_t mTotalRecvBytes;
    [tag="sbt"]  uint64_t mTotalSendBytes;
};

class GrpcEndpointStatus
{
    [tag="name"] string(128) mName;
    [tag="port"] uint16_t mPort;
    [tag="conu"] uint32_t mConnectionNum; // This is currently approximate as grpc census support is not implemented in the grpc library for C++ stack. 
    [tag="mcnu"] uint32_t mMaxConnectionNum;
    [tag="fcnt"] uint64_t mTotalRpcAuthorizationFailureCount;
    [tag="numu"] uint64_t mNumUnaryRpcs;
    [tag="nums"] uint64_t mNumServerStreamingRpcs;
    [tag="numc"] uint64_t mNumClientStreamingRpcs;
    [tag="numb"] uint64_t mNumBidiStreamingRpcs;
};

class ConnectionManagerStatus
{
    [tag="cnt"] uint32_t mConnectionCount;
    [tag="rbt"] uint64_t mTotalRecvBytes;
    [tag="rct"] uint64_t mTotalRecvCount;
    [tag="sbt"] uint64_t mTotalSendBytes;
    [tag="sct"] uint64_t mTotalSendCount;
    [tag="ifle"] uint64_t mInboundTotalRpcFiberLimitExceededDropped;
    [tag="iflp"] uint64_t mInboundTotalRpcFiberLimitExceededPermitted;
    
    [tag="rjet", default=0, description="The total number of connections rejected due to exceeding maxConnection limit."] 
    uint64_t mTotalRejectMaxInboundConnections;
    
    [tag="trml", default=0, description="The total number of connections rejected due to exceeding Rate Limit."]
    uint64_t mTotalRejectMaxRateLimitInboundConnections;

    [tag="edrn"] map<string(64), uint32_t> mEndpointDrainStatus;
    [tag="edps"] list<EndpointStatus> mEndpointsStatus;
};

class GrpcManagerStatus
{
    [tag="cnt"] uint32_t mConnectionCount;
    [tag="ifle"] uint64_t mInboundTotalRpcFiberLimitExceededDropped;
    [tag="iflp"] uint64_t mInboundTotalRpcFiberLimitExceededPermitted;
    
    [tag="rjet", default=0, description="The total number of connections rejected due to exceeding maxConnection limit."] 
    uint64_t mTotalRejectMaxInboundConnections;
    
    [tag="edps"] list<GrpcEndpointStatus> mGrpcEndpointsStatus;
};

class SelectorStatus
{
    [tag="tqct"] int64_t mTimerQueueTasks;
    [tag="tqti"] int64_t mTimerQueueTime;
    [tag="tqsz"] int64_t mTimerQueueSize;
    [tag="jqct"] int64_t mJobQueueTasks;
    [tag="jqti"] int64_t mJobQueueTime;
    [tag="nepo"] int64_t mNetworkPolls;
    [tag="neta"] int64_t mNetworkTasks;
    [tag="neti"] int64_t mNetworkTime;
    [tag="nppo"] int64_t mNetworkPriorityPolls;
    [tag="npta"] int64_t mNetworkPriorityTasks;
    [tag="npti"] int64_t mNetworkPriorityTime;
    [tag="sele"] int64_t mSelects;
    [tag="wake"] int64_t mWakes;
};

class MemoryStatus
{    
    class Stats
    {
        [tag="used", description="Amount of memory in use"] uint64_t mUsedMemory;
        [tag="max", description="Max amount of memory ever in use"] uint64_t mMaxUsedMemory;
        [tag="core", description="Amount of core memory available"] uint64_t mAllocatedCoreMemory;   
    };

    class AllocatorStatus
    {
        [tag="id", description="Unique id of the allocator"] uint32_t mId;
        [tag="name", description="Descriptive name of this allocator"] string(32) mName;
        [tag="stat", description="Memory stats for this allocator"] Stats mStats;
    };

    [tag="totl", description="Memory totals for the server as a whole."] Stats mTotals;
    [tag="allc", description="List of statuses for all allocators."] list<AllocatorStatus> mPerAllocatorStats;
    
    [tag="prrm", description="Resident memory for process as reported by system."] uint64_t mProcessResidentMemory;   
};

[description="Class that describes the current timing information stored on a per-fiber basis"]
class FiberManagerStatus
{
    class FiberPoolInfo
    {
        [tag="ufz"] uint32_t mUsedFiberListSize;
        [tag="npf"] uint32_t mNumPooledFibers;
        [tag="mxpf"] uint32_t mMaxPooledFibers;
        [tag="stkz"] uint32_t mStackSize;
    };
    [tag="flst"] list<FiberPoolInfo> mFiberPoolInfoList;
    
    [tag="smsz"] uint32_t mUsedSemaphoreMapSize;
    [tag="smul"] uint32_t mUnusedSemaphoreListSize;
    [tag="smid"] uint64_t mSemaphoreIdCounter;
    
    [tag="pscu"] uint32_t mCpuUsageForProcessPercent;
};

typedef map<string(256),string(1024)> CommandLineArgs;

class ComponentStatusRequest
{
    [tag="name"] ComponentName mComponentName;
};

class HttpServiceStatus
{
    [tag="cmgr"] OutboundConnMgrStatus connMgrStatus;

    typedef map<uint32_t, uint64_t> ErrorCodeCountMap;  
    class CommandErrorCodes
    {
        [tag="cmd"] string(128) command;
        [tag="errc"] ErrorCodeCountMap errorCodeCountMap;
    };

    typedef list<CommandErrorCodes> CommandErrorCodeList;
    [tag="cerr"] CommandErrorCodeList commandErrorCodeList;
    
};
typedef map<string(128),HttpServiceStatus, ignorecase> HttpServiceStatusMap;

class OutboundGrpcServiceStatus
{
    [tag="rcnt", description="The number of active outbound gRPC objects"]
    uint64_t mCurrentRpcCount;

    [tag="sreq", description="The number of successful requests made to this service. For streaming RPCs that make multiple requests, this will count each request sent."]
    uint64_t mRequestsSent;

    [tag="freq", description="The number of failed requests made to this service."]
    uint64_t mRequestsFailed;

    [tag="srsp", description="The number of successful responses recevied from this service."]
    uint64_t mResponsesReceived;

    [tag="frsp", description="The number of failed responses recevied from this service."]
    uint64_t mResponsesFailed;
};
typedef map<string(256), OutboundGrpcServiceStatus> OutboundGrpcServiceStatusMap;

[description="Class to track metrics for the logger."]
class LoggerMetrics
{
    typedef map<string(32), uint64_t> LevelsMetricsMap;

    [tag="cnts"] map<string(256), LevelsMetricsMap> categories;

    class BehaviourMetrics
    {
        [tag="fnam", description="The filename of the log entry (as recorded by the __FILE__ preprocessor macro)."]
        string(1024) filename;

        [tag="line", description="The line number of the log entry (as recorded by the __LINE__ preprocessor macro)."]
        int32_t lineNum;

        [tag="supp", description="Number of times this entry has been suppressed."]
        uint64_t suppressions;

        [tag="pin", description="Number of times this entry has been logged."]
        uint64_t pinned;

        [tag="core", description="Number of times this entry has triggered a core file generation."]
        uint64_t cores;
    };

    [tag="bhvr", description="Metric for the configured log entry behaviours."]
    list<BehaviourMetrics> behaviours;
};

// TODO: Disabling proto generation because of circular import caused by Blaze::Event::EventManagerStatus
[description="Class that describes the current timing information stored on a per-fiber basis", generateProto=false]
class ServerStatus
{
    [generateProto=false]
    class RpcLatency
    {
        [tag="tola"] int64_t mTotalLatency;
        [tag="topi"] int64_t mTotalPingCount;
    };
    [tag="vers"] ServerVersion mVersion;
    [tag="iid"]  uint16_t mInstanceId;
    [tag="inam"] string(64) mInstanceName;
    [tag="isid"] SlaveSessionId mInstanceSessionId;
    [tag="clst"] list<ComponentStatus> mComponents;
    [tag="stim"] string(64) mStartupTime;
    [tag="stmp"] uint64_t mUptime;
    [tag="ctim"] string(64) mConfigReloadTime;
    [tag="cfgt"] uint64_t mConfigUptime;
    [tag="db"]   DatabaseStatus mDatabase;
    [tag="rdis"] RedisDatabaseStatus mRedisDatabase;
    [tag="conn"] ConnectionManagerStatus mConnectionManager;
    [tag="grpc"] GrpcManagerStatus mGrpcManagerStatus;
    [tag="sele"] SelectorStatus mSelector;
    [tag="mem"]  MemoryStatus mMemory;
    [tag="fmgr"] FiberManagerStatus mFiberManagerStatus;
    [tag="evnt"] Blaze::Event::EventManagerStatus mEventManagerStatus;
    [tag="insv"] bool mInService;
    [tag="pid"] uint32_t mProcessId;
    [tag="http"] HttpServiceStatusMap mHttpServiceStatus;
    [tag="outg"] OutboundGrpcServiceStatusMap mOutboundGrpcServiceStatus;
    [tag="cwd"] string(256) mCurrentWorkingDirectory;
    [tag="args"] CommandLineArgs mCommandLineArgs;
    [tag="user"] string(64) mProcessOwner;
    [tag="dnsp"] PersonaNamespace mDefaultNamespace;
    [tag="adns"] PersonaNamespaceList mAdditionalNamespaces;  // DEPRECATED
    [tag="sslv"] string(64) mSslVersion;

    typedef map<string(128),string(1024)> DrainInfoMap ;
    [tag="drai"] DrainInfoMap mDrainInfoMap;

    [tag="logm"] LoggerMetrics mLoggerMetrics;
};

[description="Class that describes the current timing information stored on a per-fiber basis"]
class FiberTimings
{
    [tag="totl", description="Total CPU time taken by the server, in microseconds."]
    uint64_t mTotalCpuTime;
    
    [tag="main", description="CPU time taken by the main selector fiber."]
    uint64_t mMainFiberCpuTime;

    [tag="fmap", description="Fiber task counts and timings by name."]
    map<string(64), FiberAccountingEntry, ignorecase> mFiberMetrics;

    [tag="bcot", description="The number of times cpu budget check has ran."]
    uint64_t mCpuBudgetCheckCount;
    
    [tag="bect", description="The number of times cpu budget has been exceeded."]
    uint64_t mCpuBudgetExceededCount;
};

typedef map<string(512), DbQueryAccountingInfo, ignorecase> DbQueryAccountingInfos;

[description="Class that describes the statistics information of all executed db queries"]
class DbQueryMetrics
{
    [tag="qaim", description="A map of query statistics"]
    DbQueryAccountingInfos mDbQueryAccountingInfos;
};

[ description="Parameters required for a component to upgrade its schema." ]
class RunDbMigInfo
{
    [tag="nam", description="The name of the component"] ComponentName mComponentName;
    [tag="ver", description="Version to change to"] uint32_t mVersion;
    [tag="cver", default=0, description="Content version to change to"] uint32_t mContentVersion;
    [tag="dbpt", description="Ids of the per-platform DB configs to run DBMig on."] DbIdByPlatformTypeMap mDbIdByPlatformType;
    [tag="ddes", description="Indicate that the instance has dbdestructive flag set."] bool mDbDestructive;
};

class SetComponentStateRequest
{
    enum Action
    {
        [description="Disable the component."]   ENABLE,
        [description="Enable the component."]    DISABLE
    };
    [tag="name"] ComponentName mComponentName;
    [tag="actn"] Action mAction;
    [tag="err"] uint32_t mErrorCode;
};

class SetServiceStateRequest
{
    [tag="svc", default=true] bool mInService;
};

typedef string(128) ConfigFeature;
typedef list<ConfigFeature> ConfigFeatureList;

class ConfigRequest
{
    [tag="feat", description="The name of the feature."]
    ConfigFeature mFeature;
    [tag="lfs", description="Retrieve configuration from staging map."]
    bool mLoadFromStaging;
    [tag="lpre", default=false, description="Retrieve preconfiguration (optional)."]
    bool mLoadPreconfig;
};

class ConfigResponse
{
    [tag="data"]
    string(8388608) mConfigData;
    
    [tag="odat"]
    string(8388608) mOverrideConfigData;
};

typedef string(256) ValidationErrorMessage;

class ConfigureValidationErrors
{
    [tag="attr",description="A list of errors flagged when validating the feature's configuration."]
    list<ValidationErrorMessage> errorMessages;
    [tag="ctdf",description="The configuration TDF that failed validation."]
    variable configTdf;
};

typedef map<ConfigFeature, ConfigureValidationErrors, ignorecase> ConfigureValidationFailureMap;

class ReconfigureRequest
{
    [tag="list", description="List of features to be reconfigured(e.g.: framework, messaging, gamemanager, ...). Empty list means reconfigure all features."]
    ConfigFeatureList mFeatures;
    [tag="vonl", default=false, description="Only performs configuration validation if true and skips actual reconfiguration."]
    bool mValidateOnly;
};

class ReconfigureErrorResponse
{
    [tag="verr",description="Errors while validating configurations for the reconfigure request."]
    ConfigureValidationFailureMap validationErrorMap;
};

class DumpCoreFileRequest
{   
    [tag="csze", description="Maximum size of core file allowed.", details="Defines the maximum Linux core file size.   If zero, core file size is unlimited."]
    uint64_t maxFileSize;

    [tag="cprf", default="core", description="Core filename prefix.", details="Defines the Linxux core file name prefix (no longer in use, obsolete param provided only to avoid breaking Gos CC compatibility temporarily."]
    string(32) fileNamePrefix;
};

class PreparedForReconfigureRequest
{
    [tag="verr", allowref="true", description="Errors while validating configurations for the reconfigure request.  If empty, succeeded"]
    ConfigureValidationFailureMap validationErrorMap;        
};

class PrepareForReconfigureCompleteNotification
{
    [tag="verr",description="Errors while validating configurations for the reconfigure request.  If empty, succeeded"]
    ConfigureValidationFailureMap validationErrorMap;    
    [tag="valo",description="If true restores target slave to active state.  Set if not continuing reconfiguration."]
    bool restoreToActive;
};

class PrepareForReconfigureNotification
{
    [tag="list", description="List of features to be prepared for reconfiguration(e.g.: framework, messaging, rooms, ...)."]
    ConfigFeatureList mFeatures;
};

class ReconfigureNotification
{
    [tag="list", description="List of features to be reconfigured(e.g.: framework, messaging, rooms, ...)."]
    ConfigFeatureList mFeatures;
    [tag="finl", description="Marks this notification as final enabling the recipient to resume endpoints.."]
    bool mFinal;
};

class ReconfigurableFeatures
{
    [tag="list", description="List of reconfigurable features (e.g.: framework, messaging, rooms, ...)."]
    ConfigFeatureList mFeatures;
};

class DrainRequest
{
    enum DrainTarget
    {
        [description="Drain only local server instance"]
        DRAIN_TARGET_LOCAL,
        [description="Drain all server instances"]
        DRAIN_TARGET_ALL,
        [description="Drain a list of server instances"]
        DRAIN_TARGET_LIST
    };

    [tag="trgt", description="What to drain", default=DRAIN_TARGET_LOCAL]
    DrainTarget mTarget;
    
    typedef list<uint16_t> InstanceIdList;

    [tag="inst", description="If target specified DRAIN_TARGET_LIST, drain the instances in this list."] 
    InstanceIdList mInstanceIdList;

    [tag="time", default="0s", description="Timeout value for this drain.  Only applicable when draining to shutdown.  When timeout expires, server will shutdown. (Default to 0s, which means no timeout)"]
    TimeValue mTimeout;
    
    typedef map<ClientType, uint32_t> ThresholdByClientType;
    [tag="minu", description="Minimum local user sessions threshold for this drain.  Only applicable when draining to shutdown.  Will be ignored for MASTER instances as no user sessions are local to MASTERs.  When local user sessions are below the thresholds for the specified client types, server will shutdown."]
    ThresholdByClientType mLocalUserThresholdByClientType;
};




enum ShutdownReason
{
    [description="Null shutdown reason"]
    SHUTDOWN_NONE,
    [description="Server shutdown normally - invoked by user action. Drains the server first."] 
    SHUTDOWN_NORMAL,
    [description="Server shutdown during startup."] 
    SHUTDOWN_BOOTSTRAP_ERROR,
    [description="DEPRECATED - Server process shut down after drained of users."] 
    SHUTDOWN_DRAINED,
    [description="Server shutdown to be restarted - invoked by user action"]
    SHUTDOWN_REBOOT
};


enum ShutdownTarget
{
    [description="Shutdown only local server instance"]
    SHUTDOWN_TARGET_LOCAL,
    [description="Shutdown all server instances"]
    SHUTDOWN_TARGET_ALL,
    [description="Shutdown a list of server instances"]
    SHUTDOWN_TARGET_LIST
};

class ShutdownRequest
{
    typedef list<uint16_t> InstanceIdList;

    [tag="reas", description="(DEPRECATED - replaced by mRestart) Shutdown reason", default=SHUTDOWN_NORMAL]
    ShutdownReason mReason;

    [tag="trgt", description="Shutdown target", default=SHUTDOWN_TARGET_LOCAL]
    ShutdownTarget mTarget;

    [tag="lint", description="List of instance IDs to shutdown if target is list (SHUTDOWN_TARGET_LIST); otherwise, ignored"]
    InstanceIdList mInstanceIds;

    [tag="rtrt", default=false, description="Whether we want the monitor to restart us once we're done shutting down"]
    bool mRestart;    
};

class ControllerStateChangeNotification
{
    [tag="inst", description="Id of remote instance this notification pertains to."]
    uint16_t mInstanceId;

    [tag="drn", description="Whether or not this instance is draining."]
    bool mIsDraining;
};

class InstanceLoadChangeNotification
{
    [tag="inst", description="Id of remote instance this notification pertains to."]
    uint16_t mInstanceId;

    [tag="syld", description="System load percentage(kernel %)."]
    uint32_t mSystemLoad;

    [tag="told", description="Total load percentage(kernel % + user %)."]
    uint32_t mTotalLoad;
};

[tdfid = "hash"]
class ServerEvent
{
    [tag="vers"] ServerVersion mVersion;
    [tag="iid"]  uint16_t mInstanceId;
    [tag="inam"] string(64) mInstanceName;
    [tag="isid"] SlaveSessionId mInstanceSessionId;
    [tag="snam"] ServiceNameList mServiceNames;
};

class FetchComponentConfigurationRequest
{
    [tag="feat", description="The name of the feature."]
    ConfigFeatureList mFeatures;
};

typedef map<ConfigFeature, variable, ignorecase> ConfigurationMap;
class FetchComponentConfigurationResponse
{
    [tag="ctdf",description="The configuration TDF pair to feature."]
    ConfigurationMap mConfigTdfs;
};

class StartRemoteTransactionRequest
{
    [tag="cpid"] ComponentId mComponentId;
    [tag="cstd"] uint64_t mCustomData;
    [tag="time"] TimeValue mTimeout;
};

class StartRemoteTransactionResponse
{
    [tag="trid"] TransactionContextId mTransactionId;
};

class CompleteRemoteTransactionRequest
{
    [tag="cpid"] ComponentId mComponentId;
    [tag="trid"] TransactionContextId mTransactionId;
    [tag="cmit"] bool mCommitTransaction;
};

typedef string(256) MemGroupIdName;
typedef string(2048) MemAllocContext;

class MemTrackerInfo
{
    [tag="mgrp", description="Case insensitive name of the allocation memory group."]
    MemGroupIdName mMemGroup;

    [tag="mcxt", description="Case insensitive context string associated with the allocation."]
    MemAllocContext mContext;
};

class MemTrackerOpt
{
    [tag="mgrp", description="Case insensitive name of the allocation memory group."]
    MemGroupIdName mMemGroup;

    [tag="mcxt", description="Case insensitive context string associated with the allocation."]
    MemAllocContext mContext;

    [tag="stck", description="Controls stack tracking setting."] 
    bool mEnableStackTracking;
};

class MemTrackerStatus
{
    typedef list<string(2048)> StackTraceList;

    [tag="mcxt", description="Case insensitive context string associated with the allocation."]
    MemAllocContext mContext;

    [tag="mgrp", description="Case insensitive name of the allocation memory group."]
    MemGroupIdName mMemGroup;

    [tag="acnt", description="Total number of outstanding allocations associated with this tracker."]
    int64_t mAllocCount;

    [tag="abyt", description="Total volume of outstanding allocated bytes associated with this tracker."]
    int64_t mAllocBytes;

    [tag="stck", description="Case insensitive context string associated with the allocation."]
    StackTraceList mStackTrace;
};


class ConfigureMemoryMetricsRequest
{    
    [tag="opts", description="List of per-allocation-site memory tracking options."] 
    list<MemTrackerOpt> mTrackerOpts;
};

class ConfigureMemoryMetricsResponse
{    
    [tag="opts", description="List of currently active per-allocation-site memory tracking options."] 
    list<MemTrackerOpt> mTrackerOpts;
};

class GetMemoryMetricsRequest
{
    enum SortOrder
    {
        ALLOC_BYTES,
        ALLOC_COUNT
    };

    [tag="list", description="List of per-allocation-site memory trackers to query for status. When empty: match all, when tracker context is empty, match all trackers in MemGroup."]
    list<MemTrackerInfo> mTrackers;

    [tag="topn", description="Limit allocation trackers to top N by total size in descending order. When 0: match all.", default=100]
    uint32_t mTopN;

    [tag="sort", description="Determine ordering of returned results.", default=ALLOC_BYTES]
    SortOrder mSortBy;

    [tag="misz", description="Filter allocation trackers by minimum size. When 0: match all.", default=1]
    int64_t mMinSize;

    [tag="hsta", description="Filter allocation trackers w/wo stack trace.", default=false]
    bool mHasStack;

    [tag="cura", description="Filter allocation trackers by current or total allocations. When false: use totals.", default=true]
    bool mCurrentAlloc;
};

class GetMemoryMetricsResponse
{    
    [tag="list", description="List of memory tracker status objects that matched the query."]
    list<MemTrackerStatus> mMatchedTrackers;
};

class GetCensusDataProvidersResponse
{    
    [tag="cdpl", description="List of components registered as Census Data providers."]
    CensusDataComponentIds mComponentIds;
};

class GetCensusDataForComponentsRequest
{
    [tag="cdps", description="List of component ids of components to fetch census data from."]
    CensusDataComponentIds mComponentIds;
};

typedef map<ComponentId, variable> CensusDataByComponent;

class GetCensusDataForComponentsResponse
{
    [tag="cdpc", description="Census data list."]
    CensusDataByComponent mCensusDataByComponent;
};

class GetConnMetricsRequest
{    
    const uint32_t CONN_RESULT_LIMIT = 300;
    [tag="mval", description="IP OR IP:Port OR PeerName: configMaster/mmSlave1"]
    string(128) mMatchValue;

    [tag="obnd", description="Filter inbound/outbound.", default=true]
    bool mIsOutbound;

    [tag="limt", description="Limit the number of connections returned.", default=CONN_RESULT_LIMIT]
    uint32_t mLimit;
};

class GetConnMetricsResponse
{
    typedef list<ConnectionStatus> ConnStatusList;
    [tag="ocon", description="Metrics of all connections matching the given criteria."] 
    ConnStatusList mConnections;
};

[description="Class that describes the outbound metrics entry for a single resource pattern string"]
class OutboundMetricsEntry
{
    [tag="rsrc", description="Resource pattern string"]
    OutboundResourcePattern mResourcePattern;

    [tag="time", description="threshold response time value that will trigger a WARN log entry to be logged when exceeded"]
    TimeValue mThreshold;
 
    [tag="size", description="Bucket size"]
    TimeValue mBucketSize;
 
    [tag="cnts", description="Response time metrics counts"]
    list<uint64_t> mCounts;

    [tag="ttim", description="Total time"]
    TimeValue mTotalTime;
};

typedef list<OutboundMetricsEntry> OutboundMetricsList;
typedef map<OutboundTransactionType, OutboundMetricsList> OutboundMetricsMap;
 
[description="Class that describes outbound metrics returned by getOutboundMetrics() RPC"]
class OutboundMetrics
{
    [tag="mmap", description="Metrics map of OutboundTransactionType to the metrics"]
    OutboundMetricsMap mOutboundMetricsMap;
};

[description="Contains the server instance's drain related status."]
class DrainStatus
{
    [tag="dran", description="whether instance is draining."]
    bool mIsDraining;

    [tag="insv", description="whether instance is in-service. Note: Load balancers should wait for restarted instances to be in-service before assigning clients to them."]
    bool mInService;
};

typedef map<string(512), uint32_t, ignorecase> PSUMap;
[description="Contains local user session counts mapped by client type and geoip data (country, timezone, and, optionally, ISP)."]
class GetPSUResponse
{
    [tag="psum"] PSUMap mPSUMap;
};

[description="Indicates whether to include ISP data in an RPC response."]
class GetMetricsByGeoIPDataRequest
{
    [tag="isp", default=true] bool mIncludeISP;
};

[description="Represent the values associated with a metrics timer."]
class MetricTimerValue
{
    [tag="sum"] uint64_t sum;
    [tag="cnt"] uint64_t count;
    [tag="min"] uint64_t min;
    [tag="max"] uint64_t max;
    [tag="avg"] uint64_t avg;
};

[description="Represent the different possible values for a metric value"]
union MetricValue
{
    [tag="valu"] uint64_t value;
    [tag="tmr"] MetricTimerValue timer;
};

enum MetricType { METRIC_GAUGE, METRIC_COUNTER, METRIC_TIMER, INVALID_METRIC_TYPE };

[description="Representation of a metric name/value pair"]
class Metric
{
    [tag="name"] string(256) name;
    [tag="tags"] MetricTagList tags;
    [tag="type"] MetricType type;
    [tag="valu"] MetricValue value;
};

class GetMetricsResponse
{
    [tag="m"] list<Metric> metrics;
};

class GetMetricsRequest
{
    [tag="filt"] MetricFilterList filters;
};

typedef list<string(256)> MetricTagNameList;

[description="Representation of a metric definition"]
class MetricInfo
{
    [tag="tags"] MetricTagNameList tags;
    [tag="type"] MetricType type;
};

class GetMetricsSchemaResponse
{
    [tag="m"] map<string(256), MetricInfo> metrics;
};

class AuditLogEntry
{
    [tag="aid", description="The internal id for this audit log entry. This value is ignored by enable and disable audit logging."]
    uint64_t mAuditId;
    
    [tag="bid", description="The blazeId associated with this audit log entry."]
    BlazeId mBlazeId;

    [tag="did", description="The deviceId associated with this audit log entry."]
    string(UNIQUE_DEVICE_ID_MAX) mDeviceId;

    [tag="ip", description="The IP address associated with this audit log entry."]
    string(32) mIpAddress;
    
    [tag="pnam", description="The persona name associated with this audit log entry."]
    string(MAX_PERSONA_LENGTH) mPersona;

    [tag="naid", description="The Nucleus Account Id associated with this audit log entry."]
    AccountId mNucleusAccountId;

    [tag="plat", description="The platform associated with this audit log entry."]
    ClientPlatformType mPlatform;

    [tag="name", description="The filename of the audit log. By default, this will be a concatenation of all set AuditLogEntry fields (except AuditId)."]
    string(256) mFilename;
};
typedef list<AuditLogEntry> AuditLogEntryList;

[description="Specifies which users, devices, and IP address to turn audit logging on or off"]
class UpdateAuditLoggingRequest
{   
    [tag="alst", description="The list of audit log entries to update."]
    AuditLogEntryList mAuditLogEntries;
};

class GetAuditsResponse
{
    [tag="alst", description="The list of current audit log entries."]
    AuditLogEntryList mAuditLogEntries;
};

}
