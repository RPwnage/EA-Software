[headername="bytevault/tdf/bytevault_base.h"]
#include "bytevault/gen/bytevault_base.tdf"

namespace Blaze
{
namespace ByteVault
{

class UpsertAdminRequest
{
    [tag="admn", description="Email address of admin user", printFormat="hash"]
    AdminEmail mAdminEmail;

    [tag="map", description="Admin type list per context for this admin user"]
    AdminTypeListByContextMap mAdminTypeListByContextMap;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

typedef map<ActionType, Permission> PermissionByActionTypeMap;

class PermissionByActionType
{
    [tag="perm", description="Permissions per action type"]
    PermissionByActionTypeMap mPermissionByActionTypeMap;
};

typedef map<AdminType, PermissionByActionType> PermissionsByAdminTypeMap;

class PermissionsByAdminType
{
    [tag="perm", description="Permissions per admin type"]
    PermissionsByAdminTypeMap mPermissionsByAdminTypeMap;
};

class GetAdminRequest
{
    [tag="admn", description="Email address of admin user", printFormat="hash"]
    AdminEmail mAdminEmail;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class GetAdminResponse
{
    [tag="map", description="Admin type list per context for this admin user"]
    AdminTypeListByContextMap mAdminTypeListByContextMap;

    [tag="perm", description="Permissions per admin type for this admin user"]
    PermissionsByAdminTypeMap mPermissionsByAdminTypeMap;
};

class UpsertAdminResponse
{
    [tag="rcre", description="Resource created"]
    bool mResourceCreated;
 
    [tag="type", description="The upserted Admin"]
    GetAdminResponse mAdmin;
};

class UpsertContextRequest
{
    [tag="ctxt", description="Name of the context to create if it doesn't exist, or update if it does exist"]
    ContextName mContext;

    [tag="labl", description="Label that this context belongs to"]
    LabelName mLabel;

    [tag="desc", description="Description of this context"]
    Description mDescription;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;

    [tag="vers", description="Version of this context. Version number is incremented with each update when autoIncrementVersion is set to true.", default=0]
    uint32_t mVersion;
};

class UpsertContextResponse
{
    [tag="rcre", description="Resource created"]
    bool mResourceCreated;
 
    [tag="ctxt", description="The upserted Context"]
    Context mContext;
};

class GetContextsRequest
{
    [tag="ctxt", description="Name of the context to fetch or leave blank to fetch all contexts"]
    ContextName mContext;

    [tag="mxrc", description="Maximum count of results to return.  Defaults to 50.", default=50]
    uint32_t mMaxResultCount;

    [tag="offs", description="Offset into results array to begin response array with.  Defaults to 0.", default=0]
    uint32_t mOffset;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class GetContextsResponse
{
    [tag="list", description="The list of contexts matching the request criteria"]
    list<Context> mContexts;
};

class DeleteContextRequest
{
    [tag="ctxt", description="Name of the context to delete"]
    ContextName mContext;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class UpsertCategoryRequest
{
    [tag="ctxt", description="Name of the context to create this category in"]
    ContextName mContext;

    [tag="cat", description="Name of the category"]
    CategoryName mCategoryName;

    [tag="desc", description="Description of this category"]
    Description mDescription;

    [tag="trst", description="List of inet filters that make up our trust settings"]
    NetworkFilterConfig mTrustedSources;

    [tag="conf", description="Configuration of this category"]
    CategorySettings mConfiguration;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class UpsertCategoryResponse
{
    [tag="rcre", description="Resource created"]
    bool mResourceCreated;
 
    [tag="cat", description="The upserted Category"]
    Category mCategory;
};

class GetCategoriesRequest
{
    [tag="ctxt", description="Name of the context to fetch categories from"]
    ContextName mContext;

    [tag="cat", description="Name of the category to fetch or leave blank to fetch all categories"]
    CategoryName mCategoryName;

    [tag="mxrc", description="Maximum count of results to return.  Defaults to 50.", default=50]
    uint32_t mMaxResultCount;

    [tag="offs", description="Offset into results array to begin response array with.  Defaults to 0.", default=0]
    uint32_t mOffset;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class GetCategoriesResponse
{
    [tag="list", description="The list of categories matching the request criteria"]
    list<Category> mCategories;
};

class DeleteCategoryRequest
{
    [tag="ctxt", description="Name of the context that the category belongs to"]
    ContextName mContext;

    [tag="cat", description="Name of the category to delete"]
    CategoryName mCategoryName;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class UpsertRecordRequest
{
    [tag="addr", description="The address of the record.  Must be filled in completely to identify a single record.  Cannot be used to perform bulk insert/updates."]
    RecordAddress mRecordAddress;

    [tag="load", description="The payload of this record"]
    RecordPayload mPayload;

    [tag="subr", description="False if the existing record payload should be replaced; true if sub-record update of the existing payload is expected"]
    bool mSubrecordUpdate;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class UpsertRecordResponse
{
    [tag="rcin", description="Record info for inserted record"]
    UpsertRecordInfo mRecord;

    [tag="rcre", description="Resource created"]
    bool mResourceCreated;

    [tag="loc", description="The location for the payload of this record"]
    string(-1) mLocation;

    [tag="rmot", description="True if this resource is a remote resource"]
    bool mIsRemoteResource;
};

class GetRecordRequest
{
    [tag="addr", description="The address of the record.  Context and category must be supplied.  At least one of owner or record name needs to be supplied as well."]
    RecordAddress mRecordAddress;

    [tag="subr", description="Subrecord name to return only a specific sub-record from the record payload (the name can be dotted)"]
    string(512) mSubrecord;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class GetRecordResponse
{
    [tag="crea", description="The creation time of this record"]
    TimeValue mCreation;

    [tag="updt", description="The last update time of this record"]
    TimeValue mLastUpdate;

    [tag="load", description="The payload of this record"]
    RecordPayload mPayload;

    [tag="rmot", description="True if this resource is a remote resource"]
    bool mIsRemoteResource;

    [tag="loc", description="The location for the payload of this record"]
    string(-1) mLocation;
};

class HeadRecordResponse
{
    [tag="crea", description="The creation time of this record"]
    TimeValue mCreation;

    [tag="updt", description="The last update time of this record"]
    TimeValue mLastUpdate;

    [tag="mime", description="The MIME content type of the payload data"]
    ContentType mContentType;

    [tag="size", description="The size of the record payload"]
    uint32_t mPayloadSize;

    [tag="rmot", description="True if this resource is a remote resource"]
    bool mIsRemoteResource;

    [tag="loc", description="The location for the payload of this record"]
    string(-1) mLocation;
};

class GetHistoryRecordResponse
{
    [tag="crea", description="The creation time of this record"]
    TimeValue mCreation;

    [tag="updt", description="The last update time of this record"]
    TimeValue mLastUpdate;

    [tag="load", description="The payload of this record"]
    RecordPayload mPayload;

    [tag="rmot", description="True if this resource is a remote resource"]
    bool mIsRemoteResource;

    [tag="loc", description="The location for the payload of this record"]
    string(-1) mLocation;
    
    [tag="arch", description="Boolean flag indicating whether this history record was manually archived"]
    bool mArchived;
};

class HeadHistoryRecordResponse
{
    [tag="crea", description="The creation time of this record"]
    TimeValue mCreation;

    [tag="updt", description="The last update time of this record"]
    TimeValue mLastUpdate;

    [tag="mime", description="The MIME content type of the payload data"]
    ContentType mContentType;

    [tag="size", description="The size of the record payload"]
    uint32_t mPayloadSize;

    [tag="rmot", description="True if this resource is a remote resource"]
    bool mIsRemoteResource;

    [tag="loc", description="The location for the payload of this record"]
    string(-1) mLocation;

    [tag="arch", description="Boolean flag indicating whether this history record was manually archived"]
    bool mArchived;
};

class GetRecordInfoRequest
{
    [tag="addr", description="The address of the record.  Context and category must be supplied.  At least one of owner or record name needs to be supplied as well."]
    RecordAddress mRecordAddress;

    [tag="mxrc", description="Maximum count of results to return.  Defaults to 50.", default=50]
    uint32_t mMaxResultCount;

    [tag="offs", description="Offset into results array to begin response array with.  Defaults to 0.", default=0]
    uint32_t mOffset;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};
 
class GetRecordInfoResponse
{
    [tag="list", description="Array of results"]
    list<RecordInfo> mRecords;

    [tag="totl", description="Total number of matching results without limitations of max number of results to return and the offset"]
    uint32_t mTotalCount;
};

class GetHistoryRecordInfoResponse
{
    [tag="list", description="Array of results"]
    list<HistoryRecordInfo> mRecords;

    [tag="totl", description="Total number of matching results without limitations of max number of results to return and the offset"]
    uint32_t mTotalCount;
};

class DeleteRecordRequest
{
    [tag="addr", description="The address of the record"]
    RecordAddress mRecordAddress;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class ArchiveRecordsRequest
{
    [tag="ctxt", description="The context of the record"]
    ContextName mContext;

    [tag="cat", description="The category of the record"]
    CategoryName mCategoryName;

    [tag="name", description="The name of the record"]
    RecordName mRecord;

    [tag="ownr", description="List of owner's records to delete"]
    UserList mOwners;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class DeleteHistoryRecordRequest
{
    [tag="addr", description="The address of the record"]
    RecordAddress mRecordAddress;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;

    [tag="last", description="The last update time of the record as there could be multiple history payloads for a specific record address"]
    TimeValue mLastUpdateTime;
};

class GetHistoryRecordRequest
{
    [tag="addr", description="The address of the record. Context and category must be supplied. At least one of owner or record name needs to be supplied as well."]
    RecordAddress mRecordAddress;

    [tag="last", description="The last update time of the record as there could be multiple history payloads for a specific record address"]
    TimeValue mLastUpdateTime;

    [tag="subr", description="Subrecord name to return only a specific sub-record from the record payload"]
    RecordName mSubrecord;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class GetAdminChangeHistoryRequest
{
    [tag="admn", description="Email address of specific admin's change history to fetch. Leave blank for all admins.", printFormat="hash"]
    AdminEmail mAdminEmail;

    [tag="type", description="Type of admin change action to filter admin change history by. Use INVALID_ACTION_TYPE for all actions."]
    ActionType mAction;

    [tag="ctxt", description="Name of the context affected by historic actions to filter admin change history by. Leave blank for all contexts."]
    ContextName mContext;

    [tag="cat", description="Name of the category affected by historic actions to filter admin change history by. Only works in conjunction with context."]
    CategoryName mCategoryName;

    [tag="rec", description="The name of the record affected by historic actions to filter admin change history by. Only works in conjunction with context and category."]
    RecordName mRecordName;

    [tag="strt", description="Epoch time of start date for change history interval to fetch. If 0, then start range is earliest (least recent)."]
    TimeValue mStartDate;

    [tag="end", description="Epoch time of end date for change history interval to fetch. If 0, then end range is latest (most recent)."]
    TimeValue mEndDate;

    [tag="mxrc", description="Maximum count of results to return. Defaults to 50.", default=50]
    uint32_t mMaxResultCount;

    [tag="offs", description="Offset into results array to begin response array with. Defaults to 0.", default=0]
    uint32_t mOffset;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class AdminChangeEvent
{
    [tag="type", description="Type of admin change action"]
    ActionType mActionType;

    [tag="admn", description="Email address of admin user", printFormat="hash"]
    AdminEmail mAdminEmail;

    [tag="ip", description="IP address of the admin user"]
    string(256) mAdminIp;

    [tag="time", description="Timestamp of change event"]
    TimeValue mTimestamp;

    [tag="ctxt", description="Name of the context."]
    ContextName mContext;

    [tag="cat", description="Name of the category."]
    CategoryName mCategoryName;

    [tag="befr", description="Before change"]
    variable mBefore;

    [tag="aftr", description="After change"]
    variable mAfter;
};

class GetAdminChangeHistoryResponse
{
    [tag="list", description="List of AdminChangeEvent that match the filtering criteria"]
    list<AdminChangeEvent> mAdminChangeEventList;
};

class GetDataRatesRequest
{
    [tag="ctxt", description="Optional context to get rates for. Empty context means all"]
    ContextName mContext;
    
    [tag="cat", description="Option category to get rates for. Empty category means all categories. Ignored if context is empty"]
    CategoryName mCategoryName;

    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class DataRates
{
    [tag="irat", description="The number of record bytes that have been uploaded"]
    uint64_t mBytesIn;
    
    [tag="orat", description="The number of record bytes that have been fetched"]
    uint64_t mBytesOut;
    
    [tag="uavg", description="The average size of uploaded records"]
    uint64_t mAverageUpsertRecordSize;

    [tag="umin", description="The minimum size of uploaded records"]
    uint64_t mMinimumUpsertRecordSize;

    [tag="umax", description="The maximum size of uploaded records"]
    uint64_t mMaximumUpsertRecordSize;
    
    [tag="unmr", description="The number of records uploaded records"]
    uint32_t mNumOfUpsertRecords;

    [tag="gavg", description="The average size of fetched records"]
    uint64_t mAverageGetRecordSize;

    [tag="gmin", description="The minimum size of fetched records"]
    uint64_t mMinimumGetRecordSize;

    [tag="gmax", description="The maximum size of fetched records"]
    uint64_t mMaximumGetRecordSize;
    
    [tag="gnmr", description="The number of records fetched records"]
    uint32_t mNumOfGetRecords;
};

typedef map<CategoryName, DataRates> DataRatesPerCategory;
typedef map<ContextName, DataRatesPerCategory> DataRatesPerCategoryPerContext;

class GetDataRatesResponse
{
    [tag="rate", description="Overall bytevault data rates across all contexts and categories"]
    DataRates mDataRates;

    [tag="ratm", description="Map of bytevault data rates, broken down by category and context"]
    DataRatesPerCategoryPerContext mDataRatesPerCategoryPerContext;
};

typedef map<string(128), uint32_t> CountsPerErrorCodeMap;
typedef map<string(128), CountsPerErrorCodeMap> ErrorCountsPerCommandMap;
typedef map<CategoryName, ErrorCountsPerCommandMap> CommandErrorsPerCategoryMap;
typedef map<ContextName, CommandErrorsPerCategoryMap> CategoryCommandErrorsPerContextMap;

class GetErrorRatesRequest
{
    [tag="ctxt", description="Optional context to get rates for. Empty context means all"]
    ContextName mContext;

    [tag="cat", description="Option category to get rates for. Empty category means all categories. Ignored if context is empty"]
    CategoryName mCategoryName;
    
    [tag="auth", description="Authentication credentials"]
    AuthenticationCredentials mAuthCredentials;
};

class GetErrorRatesResponse
{
    [tag="ratm", description="Map of bytevault errors, broken down by category, context, and RPC"]
    CategoryCommandErrorsPerContextMap mErrorsPerCategoryPerContext;
};

}
}

