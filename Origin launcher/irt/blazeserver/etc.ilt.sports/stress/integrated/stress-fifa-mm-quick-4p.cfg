// Configuration file for the stress tester
//
// Define the connection and protocol parameters
connection-info = {
    protocol = fire2
    encoder = heat2
    decoder = heat2

    // Total number of connections to use
    num-connections = #NUM_CONNECTIONS#

    // Control whether SSL is used or not
    secure = #STRESS_SECURE#
}

//
//This following block controls how instances are started up.
//
startup = {
    //Number of instances to start up in a given pass
    //A block size of 0 will start all instances simultaneously
    
    // parser does not allow expressions in variable value 
    #define SERVER_NUCLEUS_POOL_SIZE_TIMES_INT #SERVER_NUCLEUS_POOL_SIZE# * 4
    block-size = #SERVER_NUCLEUS_POOL_SIZE_TIMES_INT#

    //Delay between starting instances in milliseconds
    instance-delay = #CONN_INSTANCE_DELAY#

    //Delay between starting blocks in milliseconds
    // parser does not allow expressions in variable value 
    #define SERVER_NUCLEUS_POOL_SIZE_INT #SERVER_NUCLEUS_POOL_SIZE# * 4 * #CONN_INSTANCE_DELAY#
    block-delay = #SERVER_NUCLEUS_POOL_SIZE_INT#
}

// 
// Define the account/authentication parameters used for account creation and authentication
// 
#include "../etc.ilt.sports/stress/stress-account.cfg"

// 
// Define the list of stress modules that will be instantiated
// 
modules = [ matchmaker ]

// 
// Define how the available instances/connections are distributed amongst the different modules
// 
distribution = {
    matchmaker = 1.0
}

#if PLATFORM == "common"
// define the distribution of platform types for available instances/connections used in shared cluster testing
platform-distribution = {
    pc = 0.2
    ps4 = 0.4
    xone = 0.3
    steam = 0.1
}
#else
// define the specification of platform type for available instances/connections used in single platform testing
platform-specification = {
    platform = "#PLATFORM#"
}
#endif

#define MM_CLUB_BASE_FACTOR 30
#define MM_CLUB_BASE_RATE 1000
#define MM_CLUB_DELAY MM_CLUB_BASE_RATE*MM_CLUB_BASE_FACTOR
#define MM_CLUB_GM_LIFESPAN 600*MM_CLUB_BASE_RATE
#define MM_CLUB_GM_LIFECPAN_CYCLES MM_CLUB_GM_LIFESPAN/MM_CLUB_DELAY

#ifndef MM_DURATION
#define MM_DURATION "short"
#endif

#if (MM_DURATION == "short")
#define MM_TIMEOUT_DURATION_MS 45000
#define FUT_SKILL_RATING_FIT_THRESHOLD "OSDK_matchRelax"
#define FUT_SKILL_RATING_RULE_FREQUENCY 0
#elif (MM_DURATION == "medium")
#define MM_TIMEOUT_DURATION_MS 4500000
#define FUT_SKILL_RATING_FIT_THRESHOLD "mediumDurationRelax"
#define FUT_SKILL_RATING_RULE_FREQUENCY 100
#endif

// 
// Configuration data specific to the dummy module
// 
matchmaker = {
    useScenarios = #USE_SCENARIOS#
    pingPeriod_ms = #PING_PERIOD_MS#
    inactivityTimeout_ms = #INACTIVITY_TIMEOUT_MS#
    useServerQosSettings = #USE_SERVER_QOS#

    // Define the number of milliseconds between RPC calls
    delay= #MM_CLUB_DELAY#
    login = true
    logout = false
    opt_in_chance = 100
    delay_per_trial = 0
    num_execs_per_trial = 1000


    // define the delay before starting matchmaking
    matchmakerDelay= #MM_CLUB_BASE_RATE#
    legacyReports = false
    // legacyGameTypeId = 9 // club type
    
    // the chance that a user will log out during execute
    logoutChance = 0
    
    // Define which action to execute
    // action = noop
    action = findOrCreateGameSession

    // matchmaking session timeout in MS
    matchmakingTimeout = #MM_TIMEOUT_DURATION_MS#
    // game state durations in MS
    initStateDurationMs = 1000
    preGameStateDurationMs = 5000
    inGameStateDurationMs = #MM_CLUB_GM_LIFESPAN#
    inGameStateDeviationMs = 1000
    
    minPlayersForInGameTransition = 5 // minimum number of players before host transitions to IN_GAME
    
    // roles
    // setup below mimics FIFA OTP 22-players, up to 10 fielders and up to 1 goalie.
    roleSettings = [
     { roleName = "forward",    capacity = 6, chance = 30, roleEntryCriteria = "" },
     { roleName = "midfielder", capacity = 5, chance = 30, roleEntryCriteria = "" },
     { roleName = "defender",   capacity = 6, chance = 30, roleEntryCriteria = "" }, 
     { roleName = "goalie",     capacity = 1,  chance = 10, roleEntryCriteria = "" }
    ]
    multiRoleEntryCriteria = "forward+midfielder+defender<=10"      // Just uses a default name, 

    // predefined rule preferences
    joiningTeamIdPossibleValues = [ANY_TEAM_ID]    
    requestedTeamIdPossibleValues = [ANY_TEAM_ID]
    teamCount = 2
    
    // game protocol version rule
    // disabling game protocol version rule is part of the game manager configuration
    useRandomizedGameProtocolVersionString = false
    // if false, use this game protocol version string for matchmaking
    gameProtocolVersionString = FIFA11_1.00
    gameNetworkTopology = CLIENT_SERVER_DEDICATED
    
    // Game size rule type to use new slot based rules
    sizeRule = TEAM_SIZE_AND_PLAYER_SLOT_RULES
    
    // player count rule
    playerCountRuleRangeList = ILT_4v4_matchRelax // for 4v4 we want to give it a chance to match 20 player game, or decay x2 times (like FIFA14) before matching any.
    minValuePlayerCountRuleLowerBound = 5 // for 4v4, we only want to match a game that will have 4 players + someone else
    minValuePlayerCountRuleSeed = 1
    maxValuePlayerCountRuleLowerBound = 22
    maxValuePlayerCountRuleSeed = 0
    // this is the percentage of the difference between min & max player count to use as the desired player count
    desiredValuePlayerCountRulePercent = 100

    // total player slots rule
    totalPlayerSlotsRuleRangeList = OSDK_matchExact
    minTotalPlayerSlotsLowerBound = 22
    minTotalPlayerSlotsSeed = 0
    maxTotalPlayerSlotsLowerBound = 22
    maxTotalPlayerSlotsSeed = 0
    desiredTotalPlayerSlotsPercent = 100
    
    // team ued balance rule
    teamUEDBalanceRuleName = "teamSkillSumBalanceRule"
    teamUEDBalanceRuleRangeListName = "matchAny"

    // UED values for each user, used in TeamUEDBalanceRule tests
    clientUED = [
        {
            key = 1,
            minValue = 0,
            maxValue = 10000
        }
    ]

    
    // game size rule
    // comment out threshold name to disable rule
    // Possible values for NHL:
    // OSDK_matchAny   = [0:0.0]
    // OSDK_matchExact = [0:1.0]
    // OSDK_matchRelax = [0:1.0, 1:0.5]
    // maxPlayerCountSeed, adds random value between 0 and seed-1
    // minPlayerCountSeed, adds random value between 0 and seed-1
    // maxPlayerCount, the lowerbound max desired size (added with random value between 0 and seed-1)
    // minPlayerCount, the lowerbound min desired size (added with random value between 0 and seed-1)
    gameSizeMinFitThresholdName = OSDK_matchAny
    minPlayerCount = 2
    minPlayerCountSeed = 1
    maxPlayerCount = 22
    maxPlayerCountSeed = 1
    // this is the percentage of the difference between min & max player count to use as the desired player count
    desiredGameSizePercent = 100
    
    // ranked game rule
    // possible values
    // OSDK_matchExact = [0:1.0]
    // OSDK_matchAny = [0:0.0]
    rankedGameFitThresholdName = OSDK_matchExact
    unrankedFrequency = 0
    rankedFrequency = 100
    randomFrequency = 0
    abstainFrequency = 0
    
    // skill rule
    skillRuleName = skillLevel
    // possible values
    // fitFormula FIT_FORMULA_GAUSSIAN, fiftyPercentFitValueDifference = 40
    // OSDK_matchExact    = [0:1.0]
    // OSDK_matchAny      = [0:0.0]
    // OSDK_matchRelax    = [0:REM, 1:INF]
    // OSDK_skillWithin5  = [0:5]
    // OSDK_skillWithin10 = [0:10]
    // OSDK_skillWithin20 = [0:20]
    // OSDK_skillWithin30 = [0:30]
    // OSDK_skillWithin40 = [0:40]
    skillRuleFitThresholdName = OSDK_matchAny
    userSkillValueOverrride = true
    minimumSkill = 1
    maximumSkill = 99
    // Rete3.04, note: assuming skill within 100 for now, come back and check actual max range

    // dnf rule
    // the maximum acceptable DNF value
    maxDNFValue = 101

    // host balancing rule
    // comment out threshold name to disable rule
    // possible values
    // matchAny = [ 0:HOSTS_UNBALANCED ]
    hostBalancingFitThresholdName = matchAny
    
    // host viability rule
    // comment out threshold name to disable rule
    // possible values
    // OSDK_connAssured = [0:CONNECTION_ASSURED]
    // OSDK_connLikely = [0:CONNECTION_LIKELY]
    // OSDK_connUnlikely = [0:CONNECTION_UNLIKELY]
    hostViabilityFitThresholdName = OSDK_connUnlikely
    
    // expanded ping site rule
    // comment out range offset list name to disable rule
    // possible values
    // OSDK_matchExact    = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }]
    // OSDK_matchAny      = [{ t=0, offset=["INF"]}]
    // OSDK_matchRelax    = [{ t=0, offset=[100]}, { t=5, offset=[200]}]
    pingSiteRangeOffsetListName = OSDK_matchRelax
  
    // generic rule configs
    #include "../etc.ilt.sports/stress/integrated/otp-rules.cfg"

    // generic attribute configs
    #include "../etc.ilt.sports/stress/integrated/otp-attributes.cfg"


    //
    // Game Manager utility configuration
    //
    
    // percent chance of a settings update on the ame
    gmGameSettingsRandomUpdates = 0.1
    // percent chance of a external session status update on the game
    gmGameExternalStatusRandomUpdates = 0.05
    // Number of cycles a game should last
    gmGameLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#
    // Number of cycles a player should last
    gmGamePlayerLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#
    // Max number of players for a game (random number from min to this)
    gmGamePlayerSeed = 10
    // Minimum number of player in a game.
    gmGamePlayerLowerLimit = 6
    // Game Mode Attribute Name
    gmGameModeAttributeName = "OSDK_gameMode"
    
    // game groups configuration
    // chance a stress instance will be a gg leader
    ggLeaderFreq = 25
    // chance a stress instance will be a gg follower
    ggJoinerFreq = 75
    // Control the fraction of instances that create game groups for the test.  The remaining fraction execute the test action RPCs
    ggGamegroupsFreq = 0.00909
    ggCapacity = 4    
    // Control the how long the group remains alive - a scalar to delay (so time = grouptimescalar * delay) 
    ggLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#
    ggMemberLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#

    //
    // Game Reporting utility configuration
    //
    
    // the game types to use to send reports
    // NOTE: currently we only have a single H2H report creator registered for gameType0 with the CustomGameReporterFactory,
    // before adding more report types here you'll need to register more report creators/handlers
    onlineReportGameTypes = [ 
        { typeName = "gameType0",  weight = 100 }
    ]

    // NOTE: currently we only have a single Solo report creator registered for gameType7 with the CustomGameReporterFactory,
    // before adding more report types here you'll need to register more report creators/handlers
    offlineReportGameTypes = [ 
        { typeName = "gameType7", weight = 100 }
    ]

    grSubmitReports = true
    
    overrideUserGeoIpSampleDbFilename = "#GEOIP_SAMPLES_DB#"
}

