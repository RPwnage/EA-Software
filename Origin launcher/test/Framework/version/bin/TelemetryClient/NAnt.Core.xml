<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NAnt.Core</name>
    </assembly>
    <members>
        <member name="P:NAnt.Core.ArgumentElement.Value">
            <summary>Text value</summary>
        </member>
        <member name="P:NAnt.Core.ArgumentElement.File">
            <summary>File Path. Relative file path is combined with current project base path.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.BuildAttributeAttribute">
             <summary>Indicates that field should be treated as a XML attribute for the task.</summary>
             <example>
             Examples of how to specify task attributes
             <code>
             // task XmlType default is string
             [BuildAttribute("out", Required=true)]
             string _out = null; // assign default value here
            
             [BuildAttribute("optimize")]
             // during ExecuteTask you can safely use Convert.ToBoolean(_optimize)
             string _optimize = Boolean.FalseString;
            
             [BuildAttribute("warnlevel")]
             [Int32Validator(0,4)] // limit values to 0-4
             // during ExecuteTask you can safely use Convert.ToInt32(_optimize)
             string _warnlevel = "0";
            
             [FileSet("sources")]
             FileSet _sources = new FileSet();
             </code>
             NOTE: Attribute values must be of type of string if you want
             to be able to have macros.  The field stores the exact value during
             InitializeTask.  Just before ExecuteTask is called NAnt will expand
             all the macros with the current values.
             </example>
        </member>
        <member name="T:NAnt.Core.Attributes.BuildElementAttribute">
            <summary>Indicates that field should be treated as an XML element for the task.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.BuildElementAttribute.Required">
            <summary>
            An error will e thrown if element is not present.
            </summary>
        </member>
        <member name="P:NAnt.Core.Attributes.BuildElementAttribute.Initialize">
            <summary>
            Tasks which set the initialize to false are required to initialize the element themselves.
            </summary>
        </member>
        <member name="P:NAnt.Core.Attributes.BuildElementAttribute.Override">
            <summary>
            Elements with Override set to true are allowed to replace elements from base classes. No validation is done that the base has something to override however.
            </summary>
        </member>
        <member name="T:NAnt.Core.Attributes.ElementNameAttribute">
            <summary>Indicates that class should be treated as a NAnt element.</summary>
            <remarks>
            Attach this attribute to a subclass of Element to have NAnt be able
            to recognize it.  The name should be short but must not conflict
            with any other element already in use.
            </remarks>
        </member>
        <member name="P:NAnt.Core.Attributes.ElementNameAttribute.Name">
            <summary>The short name of the task that appears on the XML tags in build files.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.ElementNameAttribute.Mixed">
            <summary>Task XML node may contain combination of nested elements and plain text,
            rather than only nested elements.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.FunctionClassAttribute">
            <summary>
            Indicates that class contains functions.
            </summary>
        </member>
        <member name="T:NAnt.Core.Attributes.FunctionAttribute">
            <summary>
            Indicates that method should be treated as a function.
            </summary>
        </member>
        <member name="T:NAnt.Core.Attributes.Int32ValidatorAttribute">
            <summary>Indicates that field should be able to be converted into an Int32 within the given range.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.PropertyAttribute">
            <summary>Indicates that field should be treated as a XML file set for the task.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.StringValidatorAttribute">
            <summary>Validates a string.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.ArgumentSetAttribute">
            <summary>Indicates that field should be treated as an argument set for the task.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.TaskAttributeAttribute">
             <summary>Indicates that field should be treated as a XML attribute for the task.</summary>
             <example>
             Examples of how to specify task attributes
             <code>
             // task XmlType default is string
             [TaskAttribute("out", Required=true)]
             string _out = null; // assign default value here
            
             [TaskAttribute("optimize")]
             // during ExecuteTask you can safely use Convert.ToBoolean(_optimize)
             string _optimize = Boolean.FalseString;
            
             [TaskAttribute("warnlevel")]
             [Int32Validator(0,4)] // limit values to 0-4
             // during ExecuteTask you can safely use Convert.ToInt32(_optimize)
             string _warnlevel = "0";
            
             [FileSet("sources")]
             FileSet _sources = new FileSet();
             </code>
             NOTE: Attribute values must be of type of string if you want
             to be able to have macros.  The field stores the exact value during
             InitializeTask.  Just before ExecuteTask is called NAnt will expand
             all the macros with the current values.
             </example>
        </member>
        <member name="T:NAnt.Core.Attributes.FileSetAttribute">
            <summary>Indicates that field should be treated as a XML file set for the task.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.TaskNameAttribute">
            <summary>Indicates that class should be treated as a task.</summary>
            <remarks>
            Attach this attribute to a subclass of Task to have NAnt be able
            to recognize it.  The name should be short but must not conflict
            with any other task already in use.
            </remarks>
        </member>
        <member name="P:NAnt.Core.Attributes.TaskNameAttribute.Name">
            <summary>The short name of the task that appears on the XML tags in build files.</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.TaskNameAttribute.XmlSchema">
            <summary>This task XML node gets added to list of nestable elements. This bool property
            is equivalent to using XmlSchemaAttribute however using this bool is apparently faster
            than adding multiple attributes to a class</summary>
        </member>
        <member name="P:NAnt.Core.Attributes.TaskNameAttribute.Mixed">
            <summary>Task XML node may contain combination of nested elements and plain text,
            rather than only nested elements.</summary>
        </member>
        <member name="T:NAnt.Core.Attributes.OptionSetAttribute">
            <summary>Indicates that field should be treated as a XML option set for the task.</summary>
        </member>
        <member name="M:NAnt.Core.Attributes.ValidatorAttribute.Validate(System.Object@)">
            <summary>
            Validates the current object and updates it as necessary.
            </summary>
        </member>
        <member name="P:NAnt.Core.Attributes.XmlElementAttribute.Mixed">
            <summary>Task XML node may contain combination of nested elements and plain text,
            rather than only nested elements.</summary>
        </member>
        <member name="T:NAnt.Core.ConditionalElement">
            <summary>Models a Conditional NAnt XML element in the build file.</summary>
        </member>
        <member name="P:NAnt.Core.ConditionalElement.IfDefined">
            <summary>If true then the target will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.ConditionalElement.UnlessDefined">
            <summary>Opposite of if.  If false then the target will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="T:NAnt.Core.Element">
            <summary>Models a NAnt XML element in the build file.</summary>
            <remarks>
              <para>Automatically validates attributes in the element based on Attribute settings in the derived class.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Element.WarnOnMultiple">
            <summary>Whether to print a warning if the same element is initialized multiple times.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Location">
            <summary><see cref="P:NAnt.Core.Element.Location"/> in the build file where the element is defined.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Project">
            <summary>The <see cref="P:NAnt.Core.Element.Project"/> this element belongs to.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Parent">
            <summary>The Parent object. This will be your parent Task, Target, or Project depending on where the element is defined.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Properties">
            <summary>The properties local to this Element and the project.</summary>
        </member>
        <member name="P:NAnt.Core.Element.Log">
            <summary>The Log instance associated with the project.</summary>
        </member>
        <member name="M:NAnt.Core.Element.Initialize">
            <summary>Calls initialize on an elements store XmlNode value, used when creating a task programmatically</summary>
        </member>
        <member name="M:NAnt.Core.Element.Initialize(System.Xml.XmlNode)">
            <summary>Performs default initialization.</summary>
            <remarks>
              <para>Derived classes that wish to add custom initialization should override <see cref="M:NAnt.Core.Element.InitializeElement(System.Xml.XmlNode)"/>.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Element.InitializeBuildElement(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>Helper task for manual initialization of a build element.(nested into this element)</summary>
        </member>
        <member name="M:NAnt.Core.Element.WarnOnMultipleInitialization(System.Xml.XmlNode)">
            <summary>Prints a warning if the same element is initialized multiple times.</summary>
        </member>
        <member name="M:NAnt.Core.Element.InitializeElement(System.Xml.XmlNode)">
            <summary>Allows derived classes to provide extra initialization and validation not covered by the base class.</summary>
            <param name="elementNode">The XML node of the element to use for initialization.</param>
        </member>
        <member name="T:NAnt.Core.BuildException">
            <summary>
            Thrown whenever an error occurs during the build.
            </summary>
        </member>
        <member name="F:NAnt.Core.ContextCarryingException.CallstackImplicitNamespaces">
            List of Namespaces to be omitted from the callstack for the sake of simplicity.
        </member>
        <member name="M:NAnt.Core.ContextCarryingException.GetSimpleTypeName(System.Type,System.Collections.Generic.List{System.String})">
            <summary>
            Returns a simplified name for a type.
            </summary>
            <param name="type">The type.</param>
            <param name="implicitNamespaces">NAnt project.</param>
            <returns>The formatted type name.</returns>
        </member>
        <member name="T:NAnt.Core.BuildExceptionStackTraceSaver">
            <summary>
            Proxy exception used to preserve stack trace of original BuildException. This exception should be transparent in the output.
            </summary>
        </member>
        <member name="T:NAnt.Core.ExceptionStackTraceSaver">
            <summary>
            Proxy exception used to preserve stack trace of original Syatem.Exception. This exception should be transparent in the output.
            </summary>
        </member>
        <member name="T:NAnt.Core.ExpressionException">
            <summary>Thrown whenever an exception is invalid.</summary>
        </member>
        <member name="T:NAnt.Core.Expression">
            <summary>
            This class implements a string expression evaluator.
            </summary>
            <remarks><![CDATA[
            Definitions:
                boolean         ::  true false 
                binary_operator ::  (C operators for LESS LESS_EQUALS GREATER GREATER_EQUALS EQUALS NOT_EQUALS AND OR: stupid X_M_L)
                unary_operator  ::  !
                parentheses:    ::  ( )
                op_char         ::  binary_operator | unary_operator | parentheses
                string          ::  '[any chars]' | 
                                    "[any chars]" | 
                                    `[any chars]` |
                                    [any string of chars that doesn't include an op_char and 
                                    doesn't begin with with a boolean.]
                                    In addition, any of the quote delimited forms can include the quote delimiter
                                    if it is escaped by a backslash '\', (e.g. "this \" has a quote")
                expression      ::  boolean |
                                    string  |
                                    ( expression ) |
                                    unary_operator expression |
                                    expression binary_operator expression
            
            Operator precedence (highest to lowest, those on same lines are equal):
                ()
                NOT
                LESS LESS_EQUALS GREATER GREATER_EQUALS
                EQUALS NOT_EQUALS
                AND
                OR  
            NOTES:
                Strings are Case Sensitive.
                An empty expression or a null expression generates an exception.                    
            ]]>
            </remarks>
            <exception cref="T:NAnt.Core.ExpressionException">Thrown when an illegal expression is input.</exception>
        </member>
        <member name="M:NAnt.Core.Expression.Evaluate(System.String)">
            <summary>Takes in a string expression, parsers and evaluates it down to a single value returned as a bool.</summary>
            <param name="expression">Input expression to evaluate.</param>
            <returns>Boolean value of the expression.</returns>
        </member>
        <member name="P:NAnt.Core.Expression.Operator.Precedence">
            <summary>
            Precedence of the operator, with 0 being the highest.
            </summary>
        </member>
        <member name="M:NAnt.Core.Expression.Operator.RunOperation(System.Collections.Stack)">
            <summary>
            Runs the operation popping required operands from the stack and returning the result to it.
            </summary>
            <param name="stack">Given stack for operands and result.</param>
        </member>
        <member name="T:NAnt.Core.Expression.Lexer">
            <summary>
            Takes an input string expression and returns a queue of string tokens representing the expression.
            </summary>
        </member>
        <member name="M:NAnt.Core.Expression.Lexer.OffsetInfo">
            <summary>
            Outputs some offset info for the exceptions.
            </summary>
            <returns>
            Formatted string that is the expression followed by another line below it which points to 
            the offset with a '^' character.
            </returns>  
        </member>
        <member name="T:NAnt.Core.FileItem">
            <summary>
            A FileItem is a fileset item after its pattern has been expanded
            </summary>
        </member>
        <member name="P:NAnt.Core.FileItem.Index">
            <summary>Internal use only for storage!</summary>
        </member>
        <member name="T:NAnt.Core.FileItemList">
            <summary>
            An array list of file items
            </summary>
        </member>
        <member name="M:NAnt.Core.FileItemList.ToStringCollection">
            <summary>Converts this array of FileItems to a StringCollection of filenames.</summary>
            <remarks>Provided as a convenience for backwards compatibility and external libraries.</remarks>
        </member>
        <member name="T:NAnt.Core.FileSetItem">
            <summary>
            A FileSetItem is a fileset item before its pattern has been expanded
            </summary>
        </member>
        <member name="T:NAnt.Core.FileSetItemCollection">
            <summary>
            A collection of FileSetItems
            </summary>
        </member>
        <member name="T:NAnt.Core.FileSetItemCollection.FileItemContainer">
            <summary>
            A specialized container class for optimizing the storage of files.
            A hashtable of linked lists where the key is the base directory of the file.
            </summary>
        </member>
        <member name="M:NAnt.Core.FileSetItemCollection.GetMatchingItems(NAnt.Core.FileSetItemCollection,System.Boolean,System.Boolean)">
            <summary>Returns a collection of file items which match the set of patterns</summary>
        </member>
        <member name="M:NAnt.Core.FileSet.FindMoreRecentLastWriteTime(System.Collections.Specialized.StringCollection,System.DateTime)">
            <summary>Determines if a file has a more recent last write time than the given time.</summary>
            <param name="fileNames">A collection of filenames to check last write times against.</param>
            <param name="targetLastWriteTime">The datetime to compare against.</param>
            <returns>The name of the first file that has a last write time greater than <c>targetLastWriteTime</c>; otherwise null.</returns>
        </member>
        <member name="P:NAnt.Core.FileSet.DefaultExcludes">
            <summary>Indicates whether default excludes should be used or not.  Default "false".</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.BaseDirectory">
            <summary>The base of the directory of this file set.  Default is project base directory.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FailOnMissingFile">
            <summary>Indicates if a build error should be raised if an explicitly included file does not exist.  Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FromFileSetName">
            <summary>The name of a file set to include.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.Sort">
            <summary>Sort the fileset by filename. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.IncludesDefined">
            <summary>True if any includes were specified even if their conditional attributes did not evaluate to true.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileItems">
            <summary>Collection of file set items that match the file set.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.ExcludesDefined">
            <summary>True if any excludes were specified even if their conditional attributes did not evaluate to true.</summary>
        </member>
        <member name="M:NAnt.Core.FileSet.InitializeElement(System.Xml.XmlNode)">
            <summary>Optimization. Directly initialize</summary>
        </member>
        <member name="T:NAnt.Core.FileSet.FileSetElement">
            <summary>Base class for includes and excludes file set elements.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.Pattern">
            <summary>The filename or pattern used for file inclusion/exclusion. Default specifies no file.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.OptionSet">
            <summary>
            The name of an optionset to associate with this set of includes or excludes.
            </summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.FromFileSetName">
            <summary>
            The name of a fileset defined by the &lt;fileset&gt; task. This fileset will be used for file inclusion/exclusion. Default is empty.
            </summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.FromFile">
            <summary>The name of a file containing a newline delimited set of files/patterns to include/exclude..</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.AsIs">
            <summary>If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.Force">
            <summary>If true the file name will be added to the file set regardless if it is already included. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.FileSet.FileSetElement.BaseDirectory">
            <summary>The base of the directory of this include pattern. 
            Default is fileset base directory. When 'basedir' is specified here it will be propagated to fileitems.
            Use this attribute to set custom basedir value which is different from the FileSet basedir, 
            In addition to evaluating patterns, basedir is used to set Link elements and file folders in Visual Studio,
            compiler resources, in CopyTask, etc.
            </summary>
        </member>
        <member name="M:NAnt.Core.FileSet.FileSetElement.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly initialize</summary>
        </member>
        <member name="T:NAnt.Core.FileSet.GroupElement">
            <summary>Represents groups of files in a file set.</summary>
        </member>
        <member name="M:NAnt.Core.FileSet.GroupElement.OptimizedInitializeDefaultGroup(System.Xml.XmlNode)">
            <summary>Optimization for default group. Directly initialize</summary>
        </member>
        <member name="T:NAnt.Core.Functions.CharacterFunctions">
            <summary>
            Collection of character manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsDigit(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is a decimal digit.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is a decimal digit; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsDigit('5', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsNumber(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized 
            as a decimal digit or hexadecimal number.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is a decimal digit or hexadecimal number; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsNumber('9', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsWhiteSpace(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized 
            as white space.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is white space; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsWhiteSpace(' ', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsLetter(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether a character is categorized as an alphabetic letter.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is an alphabetic character; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsLetter('a', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsLetterOrDigit(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized as an 
            alphabetic character or a decimal digit.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is an alphabetic character or a decimal digit; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsLetterOrDigit('a', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharToLower(NAnt.Core.Project,System.Char)">
            <summary>
            Converts the value of a character to its lowercase equivalent.
            </summary>
            <param name="project" />
            <param name="c">The character.</param>
            <returns>The lowercase equivalent of c.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharToLower('A')} == a" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharToUpper(NAnt.Core.Project,System.Char)">
            <summary>
            Converts the value of a character to its uppercase equivalent.
            </summary>
            <param name="project" />
            <param name="c">The character.</param>
            <returns>The uppercase equivalent of c.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharToUpper('a')} == A" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsLower(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized as a lowercase letter.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is a lowercase letter; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsLower('a', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.CharacterFunctions.CharIsUpper(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Indicates whether the character at the specified position in a string is categorized as an uppercase letter.
            </summary>
            <param name="project" />
            <param name="s">The string.</param>
            <param name="index">The character position in s.</param>
            <returns>Returns true if the character at position index in s is an uppercase letter; otherwise, false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{CharIsUpper('A', '0')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.DateTimeFunctions">
            <summary>
            Collection of time and date manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeNow(NAnt.Core.Project)">
            <summary>
            Gets the date and time that is the current local date and time on this computer.  NOTE: The output format will depend on your current OS's locale setting!
            </summary>
            <param name="project" />
            <returns>The current local date and time on this computer.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{DateTimeNow()}" />
</project>

<!-- Your output on en-US locale will look something like: 
[echo] 1/29/2015 2:51:55 PM
-->

<!-- Your output on en-CA locale will look something like: 
[echo] 29/01/2015 2:51:55 PM
-->

<!-- Your output on en-GB locale will look something like: 
[echo] 29/01/2015 14:51:55
-->
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeUtcNow(NAnt.Core.Project)">
            <summary>
            Gets the date and time that is the current local date and time on this computer expressed as coordinated universal time (UTC).  NOTE: The output format will depend on your current OS's locale setting!
            </summary>
            <param name="project" />
            <returns>The current local date and time on this computer expressed as UTC.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{DateTimeUtcNow()}" />
</project>

<!-- Your output on en-US locale will look something like: 
[echo] 1/29/2015 10:51:55 PM
-->

<!-- Your output on en-CA locale will look something like: 
[echo] 29/01/2015 10:51:55 PM
-->

<!-- Your output on en-GB locale will look something like: 
[echo] 29/01/2015 22:51:55
-->
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeNowAsFiletime(NAnt.Core.Project)">
            <summary>
            Gets the date and time that is the current local date and time on this computer expressed as a file timestamp.  NOTE: The output format will depend on your current OS's locale setting!
            </summary>
            <param name="project" />
            <returns>The current local date and time on this computer expressed as UTC.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{DateTimeNowAsFiletime()}" />
</project>

<!-- Your output on en-US locale will look something like: 
[echo] 132344629031570819
-->
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeToday(NAnt.Core.Project)">
            <summary>
            Gets the current date.  NOTE: The output format will depend on your current OS's locale setting!
            </summary>
            <param name="project" />
            <returns>The current date and time with the time part set to 00:00:00.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{DateTimeToday()}" />
</project>

<!-- Your output on en-US locale will look something like: 
[echo] 1/29/2015 12:00:00 AM
-->

<!-- Your output on en-CA locale will look something like: 
[echo] 29/01/2015 12:00:00 AM
-->

<!-- Your output on en-GB locale will look something like: 
[echo] 29/01/2015 00:00:00
-->
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeDayOfWeek(NAnt.Core.Project)">
            <summary>
            Returns the current day of the week.  NOTE: This function always returns the name in English.
            </summary>
            <param name="project" />
            <returns>The current day of the week.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message='@{DateTimeDayOfWeek()}' />
</project>

<!-- Your output may look something like this 
[echo] Thursday
-->
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DateTimeFunctions.DateTimeCompare(NAnt.Core.Project,System.DateTime,System.DateTime)">
            <summary>
            Compares two datetime stamps.  NOTE: The input DateTime format is expected to match your OS's locale setting or in ISO 8601 format that DateTime.Parse can handle.
            </summary>
            <param name="project" />
            <param name="t1">The first datetime stamp.</param>
            <param name="t2">The second datetime stamp.</param>
            <returns>
            	Less than zero - t1 is less than t2.  &lt;br/&gt;
            	Zero - t1 equals t2. &lt;br/&gt;
            	Greater than zero - t1 is greater than t2. &lt;br/&gt;
            </returns>
            <example>
    <code>
        <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- Compare file time -->
    <echo file="testfile1.txt" message="test file 1"/>
    <property name='t1' value="@{FileGetLastWriteTime('testfile1.txt')}" />
    <echo message="LastWriteTime of testfile1.txt = ${t1}"/>
    <sleep milliseconds="1000"/>
    <echo file="testfile2.txt" message="test file 2"/>
    <property name='t2' value="@{FileGetLastWriteTime('testfile2.txt')}" />
    <echo message="LastWriteTime of testfile2.txt = ${t2}"/>
    <echo message="DateTimeCompare result = @{DateTimeCompare('${t1}', '${t2}')}"/>

    <!-- Example Output
          [echo] LastWriteTime of testfile1.txt = 1/29/2015 3:20:34 PM
          [sleep] Sleeping for 1000 milliseconds
          [echo] LastWriteTime of testfile2.txt = 1/29/2015 3:20:35 PM
          [echo] DateTimeCompare result = -1
    -->


    <!-- Hard coding input time in specific format -->
    <property name="t1De" value="29.01.2015 09:00:00"/>
    <echo message="t1De = ${t1De}"/>
    <!-- Need to convert that to local OS format first and save to property t1 -->
    <script language="C#" compile="true">
        <code>
            <![CDATA[
                public static void ScriptMain(Project project)
                {
                    string deDateTimeStr = project.Properties["t1De"];
                    DateTime localCultureDateTime = DateTime.Parse(deDateTimeStr, new System.Globalization.CultureInfo("de-DE", true));
                    project.Properties.Add("t1", localCultureDateTime.ToString() );
                }
            ] ]>
        </code>
    </script>
    <echo message="t1 = ${t1}"/>
    <property name="t2" value="@{DateTimeNow()}"/>
    <echo message="t2 = ${t2}"/>
    <echo message="DateTimeCompare result = @{DateTimeCompare('${t1}', '${t2}')}"/>

    <!-- Example Output
          [echo] t1De = 29.01.2015 09:00:00
          [echo] t1 = 1/29/2015 9:00:00 AM
          [echo] t2 = 1/29/2015 2:51:55 PM
          [echo] DateTimeCompare result = -1
    -->


    <!-- Making sure that your input format is universal (ie ISO 8601) -->
    <property name="t1" value="2015-01-29T15:00:00"/>
    <echo message="t1 = ${t1}"/>
    <property name="t2" value="@{DateTimeNow()}"/>
    <echo message="t2 = ${t2}"/>
    <echo message="DateTimeCompare result = @{DateTimeCompare('${t1}', '${t2}')}"/>

    <!-- Example Output
          [echo] t1 = 2015-01-29T15:00:00
          [echo] t2 = 1/29/2015 2:51:55 PM
          [echo] DateTimeCompare result = 1
    -->

</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.DirectoryFunctions">
            <summary>
            Collection of directory manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryExists(NAnt.Core.Project,System.String)">
            <summary>
            Determines whether the given path refers to an existing directory on disk.
            </summary>
            <param name="project" />
            <param name="path">The path to test.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <fail unless="@{DirectoryExists('foo')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryIsEmpty(NAnt.Core.Project,System.String)">
            <summary>
            Returns true if the specified directory does not contain any files or directories; otherwise false.
            </summary>
            <param name="project" />
            <param name="path">The path to the directory.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir='foo' />
    <fail unless="@{DirectoryIsEmpty('foo')}" 
          message='Directory should have been empty' />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetFileCount(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns the number of files in a specified directory which match the given search pattern.
            </summary>
            <param name="project" />
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <returns>Number of files in a specified directory that match the given search pattern.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <delete dir="foo" failonerror="false" />
    <mkdir dir="foo" />
    <touch file="foo/bar.txt" />
    
    <fail unless="@{DirectoryGetFileCount('foo', '*.txt')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetFiles(NAnt.Core.Project,System.String,System.String,System.Char)">
            <summary>
            Returns a delimited string of file names in the given directory.
            </summary>
            <param name="project" />
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <param name="delim">The delimiter to use.</param>
            <returns>Delimited string of file names.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <touch file="foo/bar.txt" />
    <touch file="foo/baz.txt" />
    
    <eval code="@{DirectoryGetFiles('foo', '*.*', '|')}" 
          property="files" 
          type="Function" />
    
    <foreach item="String" in="${files}" property="file" delim="|">
        <fail unless="@{FileExists('${file}')}" />
    </foreach>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetDirectories(NAnt.Core.Project,System.String,System.String,System.Char)">
            <summary>
            Returns a delimited string of subdirectory names in the given directory.
            </summary>
            <param name="project" />
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <param name="delim">The delimiter to use.</param>
            <returns>Delimited string of directory names.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <mkdir dir="foo/raz" />
    <mkdir dir="foo/bar" />
    
    <eval code="@{DirectoryGetDirectories('foo', '*', '|')}" 
          property="directories" 
          type="Function" />
    
    <foreach item="String" in="${directories}" property="directory" delim="|">
        <fail unless="@{DirectoryExists('${directory}')}" />
    </foreach>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoriesGetDirectoryListHelper(System.String,System.String)">
            <summary>
            Returns a collection of directory names from a preorder traversal of the directory tree
            <returns>ArrayList of directory names: provided directory and children.</returns>
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetDirectoriesRecursive(NAnt.Core.Project,System.String,System.String,System.Char)">
            <summary>
            Returns a delimited string of recursively searched directory names from (and including) the provided path
            </summary>
            
            <param name="project">The project being built</param>
            <param name="path">The path to the directory.</param>
            <param name="pattern">The search pattern to use.</param>
            <param name="delim">The delimiter to use.</param>
            <returns>Delimited string of directory names: provided directory and children.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <mkdir dir="foo/raz" />
    <mkdir dir="foo/bar" />
    <mkdir dir="foo/bar/1" />
    <mkdir dir="foo/bar/2" />
    <mkdir dir="foo/bar/3" />

    <eval code="@{DirectoryGetDirectoriesRecursive('foo', '*', '|')}" 
          property="directories" 
          type="Function" />
    
    <foreach item="String" in="${directories}" property="directory" delim="|">
        <fail unless="@{DirectoryExists('${directory}')}" />
    </foreach>
</project>
]]>
</code>
</example>        
            
            
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetLastAccessTime(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns last accessed time of specified directory as a string. The string is formated using pattern specified by user.
            </summary>
            <param name="project" />
            <param name="path">The path to the directory.</param>
            <param name="pattern">format pattern.</param>
            <returns>Formated last access time of a directory specified by user.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <echo message="@{DirectoryGetLastAccessTime('foo', 'dd MMM yyyy')}"/>
    <echo message="@{DirectoryGetLastAccessTime('foo', 'yyyyMMdd')}"/>
    <echo message="@{DirectoryGetLastAccessTime('foo', 'HHmm')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryGetLastWriteTime(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns last write time of specified directory as a string. The string is formated using pattern specified by user.
            </summary>
            <param name="project" />
            <param name="path">The path to the directory.</param>
            <param name="pattern">format pattern.</param>
            <returns>Formated last access time of a directory specified by user.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <echo message="@{DirectoryGetLastWriteTime('foo', 'dd MMM yyyy')}"/>
    <echo message="@{DirectoryGetLastWriteTime('foo', 'yyyyMMdd')}"/>
    <echo message="@{DirectoryGetLastWriteTime('foo', 'HHmm')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.DirectoryFunctions.DirectoryMove(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Moves the whole directory. When source and dest are on the same drive it just renames dir without copying files.
            </summary>
            <param name="project" />
            <param name="source">The path to the source directory.</param>
            <param name="dest">The path to destination directory.</param>
            <returns>Full path to the destination directory.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="foo" />
    <fail unless="@{DirectoryMove('foo', 'bar')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Functions.EnvironmentFunctions">
            <summary>
            Collection functions for inquiring about aspects of the environment, such as looking up environment variable values.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.EnvironmentFunctions.GetEnvironmentVariable(NAnt.Core.Project,System.String)">
            <summary>
            Returns the value of a specified Environment variable. Equivalent to using the property sys.env.(name of environment variable).
            </summary>
            <param name="project" />
            <param name="variableName">The name of the environment variable to return, environment variable names are case insensitive on windows platforms.</param>
            <returns>The value of the environment variable.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="Path: @{GetEnvironmentVariable('PATH')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Functions.FileFunctions">
            <summary>
            Collection of file manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileExists(NAnt.Core.Project,System.String)">
            <summary>
            Determines whether the specified file exists.
            </summary>
            <param name="project" />
            <param name="path">The file to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <fail unless="@{FileExists('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileCheckAttributes(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Check the FileAttributes of the file on the fully qualified path against a set of FileAttributes.
            </summary>
            <param name="project" />
            <param name="path">The path to the file.</param>
            <param name="attributes">The set of attributes to check. Delimited by a space.</param>
            <remarks>
            &lt;dl&gt;
            	&lt;dt&gt;List of available attributes.&lt;/dt&gt;
            	&lt;dl&gt;
            		&lt;li&gt; Archive &lt;/li&gt;
            		&lt;li&gt; Compressed &lt;/li&gt;
            		&lt;li&gt; Device &lt;/li&gt;
            		&lt;li&gt; Directory &lt;/li&gt;
            		&lt;li&gt; Encrypted &lt;/li&gt;
            		&lt;li&gt; Hidden &lt;/li&gt;
            		&lt;li&gt; Normal &lt;/li&gt;
            		&lt;li&gt; NotContentIndexed &lt;/li&gt;
            		&lt;li&gt; Offline &lt;/li&gt;
            		&lt;li&gt; ReadOnly &lt;/li&gt;
            		&lt;li&gt; ReparsePoint &lt;/li&gt;
            		&lt;li&gt; SparseFile &lt;/li&gt;
            		&lt;li&gt; System &lt;/li&gt;
            		&lt;li&gt; Temporary &lt;/li&gt;
            	&lt;/dl&gt;
            &lt;/dl&gt;
            </remarks>
            <returns>True if all specified attributes are set; otherwise false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <attrib file='foo.txt' archive='true' />
    <fail unless="@{FileCheckAttributes('foo.txt', 'Archive')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetAttributes(NAnt.Core.Project,System.String)">
            <summary>
            Gets the FileAttributes of the file on the fully qualified path.
            </summary>
            <param name="project" />
            <param name="path">The path to the file.</param>
            <remarks>
            &lt;dl&gt;
            	&lt;dt&gt;List of available attributes.&lt;/dt&gt;
            	&lt;dl&gt;
            		&lt;li&gt; Archive &lt;/li&gt;
            		&lt;li&gt; Compressed &lt;/li&gt;
            		&lt;li&gt; Device &lt;/li&gt;
            		&lt;li&gt; Directory &lt;/li&gt;
            		&lt;li&gt; Encrypted &lt;/li&gt;
            		&lt;li&gt; Hidden &lt;/li&gt;
            		&lt;li&gt; Normal &lt;/li&gt;
            		&lt;li&gt; NotContentIndexed &lt;/li&gt;
            		&lt;li&gt; Offline &lt;/li&gt;
            		&lt;li&gt; ReadOnly &lt;/li&gt;
            		&lt;li&gt; ReparsePoint &lt;/li&gt;
            		&lt;li&gt; SparseFile &lt;/li&gt;
            		&lt;li&gt; System &lt;/li&gt;
            		&lt;li&gt; Temporary &lt;/li&gt;
            	&lt;/dl&gt;
            &lt;/dl&gt;
            </remarks>
            <returns>A set of FileAttributes separated by a space.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <attrib file='foo.txt' archive='true' />
    <fail unless="@{FileGetAttributes('foo.txt')} == Archive" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetLastAccessTime(NAnt.Core.Project,System.String)">
            <summary>
            Gets the date time stamp the specified file or directory was last accessed.
            </summary>
            <param name="project" />
            <param name="path">The path to the file or directory.</param>
            <returns>The date and time that the specified file or directory was last accessed.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <echo message="@{FileGetLastAccessTime('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetLastWriteTime(NAnt.Core.Project,System.String)">
            <summary>
            Gets the date time stamp the specified file or directory was last written to.
            </summary>
            <param name="project" />
            <param name="path">The path to the file or directory.</param>
            <returns>The date and time that the specified file or directory was last written to.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <echo message="@{FileGetLastWriteTime('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetCreationTime(NAnt.Core.Project,System.String)">
            <summary>
            Gets the creation date time stamp of the specified file or directory.
            </summary>
            <param name="project" />
            <param name="path">The path to the file or directory.</param>
            <returns>The date and time that the specified file or directory was created.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <echo message="@{FileGetCreationTime('foo.txt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetVersion(NAnt.Core.Project,System.String)">
            <summary>
            Get the version number for the specified file.
            </summary>
            <param name="project" />
            <param name="path">The path to the specified file.</param>
            <returns>The version number for the specified file.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{FileGetVersion('${nant.location}\nant.exe')} == ${nant.version}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileFunctions.FileGetSize(NAnt.Core.Project,System.String)">
            <summary>
            Get the size of the specified file.
            </summary>
            <param name="project" />
            <param name="path">The path to the specified file.</param>
            <returns>Size of the specified file in bytes.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt" />
    <echo message="foo.txt is @{FileGetSize('foo.txt')} bytes"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.FileSetFunctions">
            <summary>
            Collection of file set manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetExists(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified fileset is defined.
            </summary>
            <param name="project" />
            <param name="filesetName">The fileset name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fileset name="f" />
    <fail unless="@{FileSetExists('f')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetCount(NAnt.Core.Project,System.String)">
            <summary>
            Gets the number of files contained in the FileSet.
            </summary>
            <param name="project" />
            <param name="fileSetName">The name of the FileSet.</param>
            <returns>Number of file in the fileset.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fileset name="f">
        <includes name="one.txt" asis="true" />
        <includes name="two.txt" asis="true" />
    </fileset>
    
    <fail unless="@{FileSetCount('f')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetGetItem(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Returns the specified filename at the zero-based index of the specified FileSet.
            </summary>
            <param name="project" />
            <param name="fileSetName">The name of the FileSet.</param>
            <param name="index">Zero-based index of the specified FileSet. Index must be non-negative and less than the size of the FileSet.</param>
            <returns>Filename at zero-based index of the FileSet. </returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fileset name="f">
        <includes name="one.txt" asis="true" />
        <includes name="two.txt" asis="true" />
    </fileset>
    
    <fail unless="'@{FileSetGetItem('f', '0')}' == 'one.txt'" />
    <fail unless="'@{FileSetGetItem('f', '1')}' == 'two.txt'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetToString(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Converts a FileSet to a string.
            </summary>
            <param name="project" />
            <param name="fileSetName">The name of the FileSet.</param>
            <param name="delimiter">The delimiter used to separate each file.</param>
            <returns>A string of delimited files.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fileset name="f">
        <includes name="one.txt" asis="true" />
        <includes name="two.txt" asis="true" />
    </fileset>
    
    <fail unless="'@{FileSetToString('f', ';')}' == 'one.txt;two.txt'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetUndefine(NAnt.Core.Project,System.String)">
            <summary>
            Undefine an existing fileset
            </summary>
            <param name="project" />
            <param name="filesetName">The fileset name to undefine.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fileset name="f" />
    <echo message="Fileset f exists: @{FileSetExists('f')}" />
    <echo message="Removing f: @{FileSetUndefine('f')}" />
    <fail message="f still exists" if="@{FileSetExists('f')} == True" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetGetBaseDir(NAnt.Core.Project,System.String)">
            <summary>
            Get the base directory of a fileset
            </summary>
            <param name="project" />
            <param name="fileSetName" />
            <returns>Path to the base directory</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fileset name="myfileset" basedir="${package.dir}/source" />
    <fail unless="@{FileSetGetBaseDir('myfileset')} eq '${package.dir}/source'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.FileSetFunctions.FileSetDefinitionToXmlString(NAnt.Core.Project,System.String)">
            <summary>
            Converts a FileSet to an XML string.
            </summary>
            <param name="project"></param>
            <param name="fileSetName">The name of the FileSet.</param>
            <returns>string containing XML describing the fileset.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.MathFunctions">
            <summary>
            Collection of NAnt Math routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathPI(NAnt.Core.Project)">
            <summary>
            The ratio of the circumference of a circle to its diameter.
            </summary>
            <param name="project" />
            <returns>PI</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathPI()} == 3.1415926535897931" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathE(NAnt.Core.Project)">
            <summary>
            The natural logarithmic base.
            </summary>
            <param name="project" />
            <returns>E</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathE()} == 2.7182818284590451" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathLT(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is less than second.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if less than, otherwise False</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathLT('1', '2')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathLTEQ(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is less than or equal to second.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if less than or equal, otherwise False</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathLTEQ('1', '2')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathGT(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is greater than second.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if greater than, otherwise False</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathGT('2', '1')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathGTEQ(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is greater than or equal to second.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if greater than or equal, otherwise False</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathGTEQ('2', '1')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathEQ(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Compare two numbers to determine if first number is equal to second.
            </summary>
            <param name="project"></param>
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>True if equal, otherwise False</returns>
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAdd(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Add two integer numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The sum of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathAdd('1', '1')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAddf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Add two floating-point numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The sum of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathAddf('1.2', '1.2')} == 2.4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSub(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Subtract two integer numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The difference of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathSub('4', '2')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSubf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Subtract two floating-point numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The difference of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathSubf('2.0', '1.0')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathMul(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Multiply two integer numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The product of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathMul('3', '3')} == 9" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathMulf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Multiply two floating-point numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The product of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathMulf('1.2', '2.0')} == 2.4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathMod(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Computes the modulo of two numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The modulo of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathMod('24', '18')} == 6" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathModf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Computes the modulo of two numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The modulo of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathModf('24.0', '18.0')} == 6" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathDiv(NAnt.Core.Project,System.Int32,System.Int32)">
            <summary>
            Divide two integer numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The division of two numbers.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathDiv('6', '3')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathDivf(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Divide two floating-point numbers.
            </summary>
            <param name="project" />
            <param name="a">The first number.</param>
            <param name="b">The second number.</param>
            <returns>The division of two numbers.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathDivf('3.0', '2.0')} == 1.5" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAbs(NAnt.Core.Project,System.Int32)">
            <summary>
            Calculates the absolute value of a specified number.
            </summary>
            <param name="project" />
            <param name="a">The number.</param>
            <returns>The absolute value of a specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathAbs('-1')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathAbsf(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the absolute value of a specified number.
            </summary>
            <param name="project" />
            <param name="a">The number.</param>
            <returns>The absolute value of a specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathAbsf('-1.2')} == 1.2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathCeiling(NAnt.Core.Project,System.Double)">
            <summary>
            Returns the smallest whole number greater than or equal to the specified number.
            </summary>
            <param name="project" />
            <param name="a">The number.</param>
            <returns>The smallest whole number greater than or equal to the specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathCeiling('1.2')} == 2" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathFloor(NAnt.Core.Project,System.Double)">
            <summary>
            Returns the largest whole number less than or equal to the specified number.
            </summary>
            <param name="project" />
            <param name="a">The number.</param>
            <returns>The largest whole number less than or equal to the specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathFloor('1.2')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathPow(NAnt.Core.Project,System.Double,System.Double)">
            <summary>
            Raise the specified number to the specified power.
            </summary>
            <param name="project" />
            <param name="x">The number.</param>
            <param name="y">The power.</param>
            <returns>The number x raised to the power y.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathPow('2.0', '2.0')} == 4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSqrt(NAnt.Core.Project,System.Double)">
            <summary>
            Computes the square root of a specified number.
            </summary>
            <param name="project" />
            <param name="a">The specified number.</param>
            <returns>The square root of a specified number.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{MathSqrt('25.0')} == 5" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathDegToRad(NAnt.Core.Project,System.Int32)">
            <summary>
            Converts an angle from degrees to radians.
            </summary>
            <param name="project" />
            <param name="a">The specified number of degrees.</param>
            <returns>The degree of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name='pi' value='@{MathPI()}' />
    <property name='rad' value='@{MathDivf("${pi}", "180")}' />
    <property name='deg' value='@{MathMulf("90", "${rad}")}' />
    
    <echo message="@{MathDegToRad('90')} == ${deg}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathSin(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the sine of the specified angle.
            </summary>
            <param name="project" />
            <param name="a">The specified angle in radians.</param>
            <returns>The sine of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="deg" value="@{MathDegToRad('90')}" />
    <fail unless="@{MathSin('${deg}')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathCos(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the cosine of the specified angle.
            </summary>
            <param name="project" />
            <param name="a">The specified angle in radians.</param>
            <returns>The cosine of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="deg" value="@{MathDegToRad('90')}" />
    <fail unless="@{MathCos('${deg}')} == 6.1230317691118863E-17" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathTan(NAnt.Core.Project,System.Double)">
            <summary>
            Calculates the tangent of the specified angle.
            </summary>
            <param name="project" />
            <param name="a">The specified angle in radians.</param>
            <returns>The tangent of a.</returns>
            <remarks>Full precision ensures that numbers converted to strings will 
            have the same value when they are converted back to numbers.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="deg" value="@{MathDegToRad('180')}" />
    <fail unless="@{MathTan('${deg}')} == -1.2246063538223773E-16" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.MathFunctions.MathChangePrecision(NAnt.Core.Project,System.Double,System.Int32)">
            <summary>
            Changes the precision of a specified floating-point number.
            </summary>
            <param name="project" />
            <param name="a">The specified floating-point number.</param>
            <param name="precision">The new precision.</param>
            <returns>The value of a using the specified precision.</returns>
            <remarks>By default NAnt math functions return doubles using full precision (17 bits). Typically only 
            15 bits are needed.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <eval code="@{MathSubf('2.2', '1.2')}" property='p' type='Function'/>
    <fail unless='${p} == 1.0000000000000002' />

    <eval code="@{MathChangePrecision('${p}', '15')}" property='p' type='Function'/>
    <fail unless='${p} == 1' />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.NAntFunctions">
            <summary>
            Collection of NAnt Project routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.NAntFunctions.NAntIsParallel(NAnt.Core.Project)">
            <summary>
            Tests whether Framework (NAnt) is running in parallel mode.
            </summary>
            <param name="project"></param>
            <returns>Returns true if Framework is in parallel mode (default).</returns>
            <remarks>Parallel mode can be switched off by NAnt command line parameter -noparallel.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.NAntFunctions.GetLogFilePaths(NAnt.Core.Project)">
            <summary>
            Gets log file name paths.
            </summary>
            <param name="project"></param>
            <returns>Returns new line separated list of log file names or an empty string when log is not redirected to a file</returns>
        </member>
        <member name="T:NAnt.Core.Functions.OptionSetFunctions">
            <summary>
            Option set manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetGetValue(NAnt.Core.Project,System.String,System.String)">
            <summary>Get the value of an option in a named optionset.</summary>
            <param name="project" />
            <param name="optionSetName">The name of the optionset to get from.</param>
            <param name="optionName">The name of the option to get.</param>
            <returns>The value of the option or an empty string if no option defined.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name='optset'>
        <option name='opt' value='1' />
    </optionset>
    
    <fail unless="@{OptionSetGetValue('optset', 'opt')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetExists(NAnt.Core.Project,System.String)">
            <summary>Check if the specified optionset is defined.</summary>
            <param name="project" />
            <param name="optionSetName">The name of the optionset.</param>
            <returns>True if the option set is defined, otherwise False.</returns>returns&gt;
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name='optset' />

    <fail unless="@{OptionSetExists('optset')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetOptionExists(NAnt.Core.Project,System.String,System.String)">
            <summary>Check if the specified option is defined within the specified optionset.</summary>
            <param name="project" />
            <param name="optionSetName">The name of the optionset.</param>
            <param name="optionName">The name of the option.</param>
            <returns>True if the option is defined, otherwise False.</returns>returns&gt;
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name='optset'>
        <option name='opt' value='1' />
    </optionset>
    
    <fail unless="@{OptionSetOptionExists('optset', 'opt')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetUndefine(NAnt.Core.Project,System.String)">
            <summary>
            Undefine the specified optionset.
            </summary>
            <param name="project" />
            <param name="optionSetName">The optionset name to undefine.</param>
            <returns>True if the optionset was undefined properly, otherwise False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name='optset' />
    <eval code="@{OptionSetUndefine('optset')}" type="Function" />
    <fail if="@{OptionSetExists('optset')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetOptionUndefine(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Undefine the specified optionset option.
            </summary>
            <param name="project" />
            <param name="optionSetName">The name of the optionset.</param>
            <param name="optionName">The name of the option to undefine.</param>
            <returns>True if the optionset option was undefined properly, otherwise False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name='optset'>
        <option name='opt' value='1' />
    </optionset>
    
    <eval code="@{OptionSetOptionUndefine('optset', 'opt')}" type="Function" />
    
    <fail if="@{OptionSetOptionExists('optset', 'opt')}"/>
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.OptionSetFunctions.OptionSetToString(NAnt.Core.Project,System.String)">
            <summary>
            Output option set to string
            </summary>
            <param name="project"></param>
            <param name="optionSetName">The optionset name.</param>
            <returns>string with optionset content.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.PackageFunctions">
            <summary>
            Collection of NAnt Project routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.PackageGetMasterversion(NAnt.Core.Project,System.String)">
            <summary>
            Returns package masterversion declared in masterconfig file. This function does not perform dependent task.
            </summary>
            <param name="project"></param>
            <param name="packageName"></param>
            <returns>masterversion string.</returns>
            <remarks>Throws error if package is not not declared in masterconfig file.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.PackageGetMasterDir(NAnt.Core.Project,System.String)">
            <summary>
            Returns package master release directory.
            </summary>
            <param name="project"></param>
            <param name="packageName"></param>
            <returns>package directory string.</returns>
            <remarks>Throws error if package is not not declared in masterconfig file or failed to install.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.PackageGetMasterDirOrEmpty(NAnt.Core.Project,System.String)">
            <summary>
            Returns package master release directory.
            </summary>
            <param name="project"></param>
            <param name="packageName"></param>
            <returns>package directory string.</returns>
            <remarks>returns empty string if package is not not declared in masterconfig file or is not installed.</remarks>
        </member>
        <member name="M:NAnt.Core.Functions.PackageFunctions.GetPackageRoot(NAnt.Core.Project,System.String)">
            <summary>
            </summary>
        </member>
        <member name="T:NAnt.Core.Functions.PathFunctions">
            <summary>
            Collection of path manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFullPath(NAnt.Core.Project,System.String)">
            <summary>
            Returns the complete path.
            </summary>
            <param name="project" />
            <param name="path">The relative path to convert.</param>
            <returns>Complete path with drive letter (if applicable).</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathGetFullPath('.')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFileSystemFileName(NAnt.Core.Project,System.String)">
            <summary>
            Return the true/real filename stored in the file system. If file doesn't exist, it will
            just return the path passed in.
            </summary>
            <param name="project" />
            <param name="path">full path or path that specify a file</param>
            <returns>if file exist, return the actual filename stored in the file system, else return the path passed in.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="FileName" value="@{PathGetTempPath()}Mixed Case.txt"/>
    <touch file="${FileName}"/>
    <property name="DOSPath" value="@{PathGetFileSystemFileName('@{PathGetTempPath()}MIXEDC~1.TXT')}"/>
    <fail 
        unless="'@{PathGetFileName(${DOSPath})}' == '@{PathGetFileName(${FileName})}'"
        message="'@{PathGetFileName(${DOSPath})}' does not match case of '@{PathGetFileName(${FileName})}'."
        />
    <delete file="${FileName}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToUnix(NAnt.Core.Project,System.String)">
            <summary>
            Returns the path with backward slashes '\' converted to forward slashes '/'.
            </summary>
            <param name="project" />
            <param name="path">The path string from which to convert.</param>
            <returns>Path with backward slashes converted to forward slashes.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathToUnix('c:\windows')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToCygwin(NAnt.Core.Project,System.String)">
            <summary>
            Returns the path with drive letter and semicolon are substituted to cygwin notation,
            backward slashes '\' converted to forward slashes '/'.
            </summary>
            <param name="project" />
            <param name="path">The path string from which to convert.</param>
            <returns>cygwin path.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathToUnix('c:\windows')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToWindows(NAnt.Core.Project,System.String)">
            <summary>
            Returns the string with forward slashes '/' converted to backward slashes '\'.
            </summary>
            <param name="project" />
            <param name="path">The path string from which to convert.</param>
            <returns>Path with forward slashes converted to backward slashes.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathToWindows('/usr/linux')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToNativeOS(NAnt.Core.Project,System.String)">
            <summary>
            Returns the string with the correct format for the current OS.
            </summary>
            <param name="project" />
            <param name="path">The path string from which to convert.</param>
            <returns>Path with correct format for the current OS.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathToUnix('c:\windows')}" />
</project>
]]>
</code>
</example>  
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathToWsl(NAnt.Core.Project,System.String)">
            <summary>
            Returns the windows path but formated for the windows subsystem for linux.
            Specifically drive letter, C:, is changed to /mnt/c, and slashes are reversed.
            </summary>
            <param name="project"></param>
            <param name="path">The path string from which to convert.</param>
            <returns>Path with correct format for WSL.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetDirectoryName(NAnt.Core.Project,System.String)">
            <summary>
            Returns the directory name for the specified path string.
            </summary>
            <param name="project" />
            <param name="path">The path of a file or directory.</param>
            <returns>Directory name of the specified path string.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathGetDirectoryName('packages\build')} == 'packages'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetRelativePath(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Relative path from the first given path to the second.
            </summary>
            <param name="project"></param>
            <param name="path">The path of a file or directory.</param>
            /// <param name="basepath">Base path used to compute relative path.</param>
            <returns>Relative path or full path when computing relative path is not possible.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFileName(NAnt.Core.Project,System.String)">
            <summary>
            Returns the file name and extension of the specified path string.
            </summary>
            <param name="project" />
            <param name="path">The path string from which to obtain the file name and extension.</param>
            <returns>File name and extension of the specified path string.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathGetFileName('packages\nant.exe')} == 'nant.exe'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetExtension(NAnt.Core.Project,System.String)">
            <summary>
            Returns the extension of the specified path string.
            </summary>
            <param name="project" />
            <param name="path">The path string from which to get the extension.</param>
            <returns>Extension of the specified path string.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathGetExtension('nant.exe')} == '.exe'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetFileNameWithoutExtension(NAnt.Core.Project,System.String)">
            <summary>
            Returns the file name of the specified path string without the extension.
            </summary>
            <param name="project" />
            <param name="path">The path of the file.</param>
            <returns>File name of the specified path string without the extension.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathGetFileNameWithoutExtension('nant.exe')} == 'nant'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathChangeExtension(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Changes the extension of the specified path.
            </summary>
            <param name="project" />
            <param name="path">The specified path.</param>
            <param name="extension">The new extension.</param>
            <returns>The specified path with a different extension.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathChangeExtension('nant.exe', 'cfg')} == 'nant.cfg'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathCombine(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Combine two specified paths.
            </summary>
            <param name="project" />
            <param name="path1">The first specified path.</param>
            <param name="path2">The second specified path.</param>
            <returns>A new path containing the combination of the two specified paths.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathCombine('packages', 'nant')} == 'packages\nant'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetPathRoot(NAnt.Core.Project,System.String)">
            <summary>
            Returns the root directory of the specified path.
            </summary>
            <param name="project" />
            <param name="path">The specified path.</param>
            <returns>The root directory of the specified path.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathGetPathRoot('d:\packages')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetTempFileName(NAnt.Core.Project)">
            <summary>
            Returns a unique temporary file name which is created as an empty file on disk.
            </summary>
            <param name="project" />
            <returns>The temporary file (full path) which has been created on disk at user's temporary folder.  Note that this function call will throw IOException if the temp file cannot be created!</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <trycatch>
        <try>
            <eval code="@{PathGetTempFileName()}" type="Function" property="temp-file"/>
        </try>
        <catch>
        </catch>
    </trycatch>
    <choose>
        <do if="@{FileExists(${temp-file})}">
            <echo message="${temp-file} is just created on disk." />
        </do>
        <do>
            <echo message="Unable to create ${temp-file} on disk."/>
        </do>
    </choose>
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetRandomFileName(NAnt.Core.Project)">
            <summary>
            Returns a cryptographically strong, random string that can be used as either a folder name or a file name.
            </summary>
            <param name="project" />
            <returns>A random string that can be used as either a folder name or a file name.  Unlike PathGetTempFileName(), this function will not create a file on disk.  This function is added in Framework 7.06.00.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathGetRandomFileName()}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathGetTempPath(NAnt.Core.Project)">
            <summary>
            Returns the path to the systems temp folder.
            </summary>
            <param name="project" />
            <returns>The path to the systems temp folder.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{PathGetTempPath()}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathHasExtension(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified path has a filename extension.
            </summary>
            <param name="project" />
            <param name="path">The specified path.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathHasExtension('nant.exe')}" />
    <fail if="@{PathHasExtension('nant')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.PathFunctions.PathIsPathRooted(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified path contains absolute or relative path information.
            </summary>
            <param name="project" />
            <param name="path">The specified path.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{PathIsPathRooted('d:\nant.exe')}" />
    <fail if="@{PathIsPathRooted('nant.exe')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Functions.PlatformFunctions">
            <summary>
            Collection of string manipulation routines. 
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformIsUnix(NAnt.Core.Project)">
            <summary>
            Returns 'true' if the current platform is Linux.
            </summary>
            <param name="project"></param>
            <returns>'true' if the current platform is Linux, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformIsWindows(NAnt.Core.Project)">
            <summary>
            Returns 'true' if the current platform is Windows.
            </summary>
            <param name="project"></param>
            <returns>'true' if the current platform is Windows, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformIsOSX(NAnt.Core.Project)">
            <summary>
            Returns 'true' if the current platform is OSX.
            </summary>
            <param name="project"></param>
            <returns>'true' if the current platform is OSX, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.PlatformPlatform(NAnt.Core.Project)">
            <summary>
            Returns the Operating System we are running on.
            </summary>
            <returns>name of the platform. Supported values are: Windows, Unix, OSX, Xbox, Unknown. </returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.IsMonoRuntime(NAnt.Core.Project)">
            <summary>
            Returns 'true' if running under mono.
            </summary>
            <param name="project"></param>
            <returns>'true' if running under mono, otherwise 'false'.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PlatformFunctions.RuntimeVersion(NAnt.Core.Project)">
            <summary>
            Returns current .NET runtime version.
            </summary>
            <param name="project"></param>
            <returns>Current .NET runtime version.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.ProjectFunctions">
            <summary>
            Collection of NAnt Project routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetLastError(NAnt.Core.Project)">
            <summary>
            Returns the previous build exception message.
            </summary>
            <param name="project" />
            <returns>The previous build exception message that was thrown.</returns>
            <remarks>If no error message exists an empty string is returned.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{ProjectGetLastError()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetLastInnerError(NAnt.Core.Project)">
            <summary>
            Returns the previous inner build exception message.
            </summary>
            <param name="project" />
            <returns>The previous inner build exception message that was thrown.</returns>
            <remarks>If no error message exists an empty string is returned.</remarks>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="@{ProjectGetLastInnerError()}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetName(NAnt.Core.Project)">
            <summary>
            Gets the name of the project.
            </summary>
            <param name="project" />
            <returns>The project name or empty string if none exists.</returns>
            <example>
<code>
<![CDATA[
<project name='test'>
    <fail unless="'@{ProjectGetName()}' == 'test'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.ProjectFunctions.ProjectGetDefaultTarget(NAnt.Core.Project)">
            <summary>
            Gets the name of the default target.
            </summary>
            <param name="project" />
            <returns>The name of the default target or empty string if none exists.</returns>
            <example>
<code>
<![CDATA[
<project default='build'>
    <target name='build'>
        <fail unless="'@{ProjectGetDefaultTarget()}' == 'build'" />
    </target>
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.Functions.PropertyFunctions">
            <summary>
            Collection of property manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyExists(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified property is defined.
            </summary>
            <param name="project" />
            <param name="propertyName">The property name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="p" value="1" />
    <fail unless="@{PropertyExists('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyTrue(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified property value is true. 
            If property does not exist, an Exception will be thrown.
            </summary>
            <param name="project" />
            <param name="propertyName">The property name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="p" value="true" />
    <fail unless="@{PropertyTrue('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyEqualsAny(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Check if the specified property value equals the argument
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to check.</param>
            <param name="comparands">A comma-seperated-list of string values to compare against. They are trimmed.</param>
            <returns>True or False.</returns>
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyExpand(NAnt.Core.Project,System.String)">
            <summary>
            Expand the specified property.
            </summary>
            <param name="project" />
            <param name="propertyName">The property name to expand.</param>
            <returns>The value of the specified property. If the property does not exits a BuildException is thrown.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="p" value="1" />
    <fail unless="@{PropertyExpand('p')} == 1" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.PropertyUndefine(NAnt.Core.Project,System.String)">
            <summary>
            Undefine the specified property.
            </summary>
            <param name="project" />
            <param name="propertyName">The property name to undefine.</param>
            <returns>True if the property was undefined properly, otherwise False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="p" value="1" />

    <eval code="@{PropertyUndefine('p')}" type='Function' />
    <fail if="@{PropertyExists('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.IsPropertyGlobal(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified property is defined as global property in masterconfig.
            </summary>
            <param name="project" />
            <param name="propertyName">The property name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="p" value="1" />
    <fail unless="@{IsPropertyGlobal('p')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.PropertyFunctions.GetPropertyOrDefault(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Returns property value or default value if property does not exist.
            </summary>
            <param name="project"></param>
            <param name="propertyName">The property name to check.</param>
            <param name="defaultVal">default value.</param>
            <returns>property value.</returns>
        </member>
        <member name="T:NAnt.Core.Functions.StringFunctions">
            <summary>
            Collection of string manipulation routines. 
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrLen(NAnt.Core.Project,System.String)">
            <summary>
            Gets the number of characters in a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to count.</param>
            <returns>The number of characters in the specified string.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrLen('nant.exe')} == 8" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrEndsWith(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Determines whether the end of a string matches a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to search.</param>
            <param name="strB">The string to match.</param>
            <returns>True if the specified string strA ends with the specified string strB.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrEndsWith('nant.exe', '.exe')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrStartsWith(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Determines whether the start of a string matches a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to search.</param>
            <param name="strB">The string to match.</param>
            <returns>True if the specified string, strA, starts with the specified string, strB.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrStartsWith('nant.exe', 'nant')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrCompare(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified strings.
            </summary>
            <param name="project" />
            <param name="strA">The first String.</param>
            <param name="strB">The second String.</param>
            <returns>
            	Less than zero - strA is less than strB. &lt;br/&gt;
            	Zero - strA is equal to strB. &lt;br/&gt;
            	Greater than zero - strA is greater than strB. &lt;br/&gt;
            </returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrCompare('nant', 'nant')} == 0" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrCompareVersions(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified version strings.  Version strings should be numbers 
            separated by any non digit separator. Separators are used in comparison as well.
            Dot separator will take a precedence over dash separator. 
            Numbers are always considered newer than letters, version strings that are starting with "dev" or "work" are considered a special case, dev and work takes precedence over numbers
            
            For example, versions will be sorted this way in descending order:
            test-09
            test-8-1
            test-8.1-alpha
            test-8.1
            test-8       
            Work and dev will be newer than numeric versions, but only if package name is not included:
            dev
            1.01.00
            This function assumes that separators used in both version strings are the same.
            
            </summary>
            <param name="project" />
            <param name="strA">The first version String.</param>
            <param name="strB">The second version String.</param>
            <returns>
            	Less than zero - strA is less than strB. &lt;br/&gt;
            	Zero - strA is equal to strB. &lt;br/&gt;
            	Greater than zero - strA is greater than strB. &lt;br/&gt;
                Comparison algorithm takes into account version formatting, rather than doing simple lexicographical comparison.
            </returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrCompareVersions('1.00.00', '1.00.00')} == 0" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrVersionLess(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified version strings in the same way as StrCompareVersions.
            However returns a boolean value of true if strA is less than strB.
            </summary>
            <param name="project" />
            <param name="strA">The first version String.</param>
            <param name="strB">The second version String.</param>
            <returns>true if strA is less than strB, false otherwise</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrVersionLess('1.05.00', '1.10.00')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrVersionLessOrEqual(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified version strings in the same way as StrCompareVersions.
            However returns a boolean value of true if strA is less than or equal to strB.
            </summary>
            <param name="project" />
            <param name="strA">The first version String.</param>
            <param name="strB">The second version String.</param>
            <returns>true if strA is less than or equal to strB, false otherwise</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrVersionLessOrEqual('1.05.00', '1.10.00')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrVersionGreater(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified version strings in the same way as StrCompareVersions.
            However returns a boolean value of true if strA is greater than strB.
            </summary>
            <param name="project" />
            <param name="strA">The first version String.</param>
            <param name="strB">The second version String.</param>
            <returns>true if strA is greater than strB, false otherwise</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrVersionGreater('1.10.00', '1.05.00')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrVersionGreaterOrEqual(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Compares two specified version strings in the same way as StrCompareVersions.
            However returns a boolean value of true if strA is greater than or equal to strB.
            </summary>
            <param name="project" />
            <param name="strA">The first version String.</param>
            <param name="strB">The second version String.</param>
            <returns>true if strA is greater than or equal to strB, false otherwise</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrVersionGreaterOrEqual('1.10.00', '1.05.00')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrLastIndexOf(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Reports the index position of the last occurrence of a string within a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to search.</param>
            <param name="strB">The string to seek.</param>
            <returns>The last index position of string strB in string strA if found; otherwise -1 if not found.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrLastIndexOf('nant.exe.config', '.')} == 8" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrIndexOf(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Reports the index of the first occurrence of a string in a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to search.</param>
            <param name="strB">The string to seek.</param>
            <returns>The index position of string strB in string strA if found; otherwise -1 if not found.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrIndexOf('nant.exe', '.')} == 4" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrContains(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Reports if the first string contains the second string.
            </summary>
            <param name="project" />
            <param name="strA">The string to search.</param>
            <param name="strB">The string to seek.</param>
            <returns>true if strB is found in  string strA; otherwise false if not found.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrContains('nant.exe', 'nant')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrRemove(NAnt.Core.Project,System.String,System.Int32,System.Int32)">
            <summary>
            Deletes a specified number of characters from the specified string beginning at a specified position.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <param name="startIndex">The position in the string to begin deleting characters.</param>
            <param name="count">The number of characters to delete.</param>
            <returns>A string having count characters removed from strA starting at startIndex.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrRemove('nant.exe', '4', '1')}' == 'nantexe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrReplace(NAnt.Core.Project,System.String,System.String,System.String)">
            <summary>
            Replaces all occurrences of a string in a string, with another string.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <param name="oldValue">The string to be replaced.</param>
            <param name="newValue">The string to replace all occurrences of oldValue.</param>
            <returns>A string having every occurrence of oldValue in strA replaced with newValue.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrReplace('nant.exe', '.exe', '.config')}' == 'nant.config'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrInsert(NAnt.Core.Project,System.String,System.Int32,System.String)">
            <summary>
            Inserts a string at a specified index position in a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to insert into.</param>
            <param name="startIndex">The index position of the insertion.</param>
            <param name="value">The string to insert.</param>
            <returns>A string equivalent to strA but with value inserted at position startIndex.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrInsert('.exe', '0', 'nant')}' == 'nant.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrSubstring(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Retrieves a substring from a string. The substring starts at a specified character position.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <param name="startIndex">The starting character position of a substring in this instance.</param>
            <returns>A substring of strA starting at startIndex.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrSubstring('nant.exe', '4')}' == '.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrSubstring(NAnt.Core.Project,System.String,System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from a string.
            The substring starts at a specified character position and has a specified length.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <param name="startIndex">The index of the start of the substring.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>A substring of strA starting at startIndex and with a specified length.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrSubstring('nant.exe', '0', '4')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrConcat(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Concatenates two strings.
            </summary>
            <param name="project" />
            <param name="strA">The first string.</param>
            <param name="strB">The second string.</param>
            <returns>The concatenation of strA and strB.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrConcat('nant', '.exe')}' == 'nant.exe'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrPadLeft(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Right-aligns the characters a string, padding with spaces on the left for a total length.
            </summary>
            <param name="project" />
            <param name="strA">The string to pad.</param>
            <param name="totalWidth">
            The number of characters in the resulting string, equal to the number of original characters plus 
            any additional padding characters.
            </param>
            <returns>
            A string that is equivalent to strA, but right-aligned and padded on the left with as many 
            spaces as needed to create a length of totalWidth. 
            If totalWidth is less than the length of strA, a string that is identical to strA is returned.
            </returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrPadLeft('nant', '8')}' == '    nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrPadRight(NAnt.Core.Project,System.String,System.Int32)">
            <summary>
            Left-aligns the characters in a string, padding with spaces on the left for a total length.
            </summary>
            <param name="project" />
            <param name="strA">The string to pad.</param>
            <param name="totalWidth">
            The number of characters in the resulting string, equal to the number of original characters plus 
            any additional padding characters.
            </param>
            <returns>
            A string that is equivalent to strA, but left-aligned and padded on the right with as many 
            spaces as needed to create a length of totalWidth. 
            If totalWidth is less than the length of strA, a string that is identical to strA is returned.
            </returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrPadRight('nant', '8')}' == 'nant    '" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrTrim(NAnt.Core.Project,System.String)">
            <summary>
            Removes all occurrences of white space characters from the beginning and end of a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to trim.</param>
            <returns>A string equivalent to strA after white space characters are removed.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrTrim('  nant  ')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrTrimWhiteSpace(NAnt.Core.Project,System.String)">
            <summary>
            Removes all occurrences of white space characters (including tabs and new lines)from the beginning and end of a string.
            </summary>
            <param name="project" />
            <param name="strA">The string to trim.</param>
            <returns>A string equivalent to strA after white space characters are removed.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrTrim('  nant  ')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrToUpper(NAnt.Core.Project,System.String)">
            <summary>
            Returns a copy of the given string in uppercase.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <returns>A string in uppercase.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrToUpper('nant')}' == 'NANT'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrToLower(NAnt.Core.Project,System.String)">
            <summary>
            Returns a copy of the given string in lowercase.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <returns>A string in lowercase.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrToLower('NANT')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrPascalCase(NAnt.Core.Project,System.String)">
            <summary>
            Takes a space separated list of words and joins them with only the first letter of each capitalized
            </summary>
            <param name="project" />
            <param name="strA">A space separate list of words</param>
            <returns>A one word string composed of all of the input words joined and with only the starting letter of each capitalized</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrPascalCase('hello world')} eq 'HelloWorld'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrEcho(NAnt.Core.Project,System.String)">
            <summary>
            Echo a string.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <returns>The string.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrEcho('nant')}' == 'nant'" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrIsEmpty(NAnt.Core.Project,System.String)">
            <summary>
            Returns true if the specified string is the Empty string.
            </summary>
            <param name="project" />
            <param name="strA">The string.</param>
            <returns>True of False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{StrIsEmpty('')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.StrSelectIf(NAnt.Core.Project,System.String,System.String,System.String)">
            <summary>
            Returns "strTrue" or "strFalse" depending on value of conditional
            </summary>
            <param name="project" />
            <param name="strCondition">The string to determine whether True or False.</param>
            <param name="strTrue">String to return when conditional evaluates to True</param>
            <param name="strFalse">String to return when conditional evaluates to False</param>
            <returns>Either strTrue or strFalse</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="'@{StrSelectIf('True', 'IsTrue', 'IsFalse')}' == 'IsTrue'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.DistinctItems(NAnt.Core.Project,System.String)">
            <summary>
            Eliminates duplicates from the list of space separated items.
            </summary>
            <param name="project" />
            <param name="str">The string to process.</param>
            <returns>A Space separated String containing distinct items.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{DistinctItems('a b f c d d e f g')} eq 'a b f c d e g'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Core.Functions.StringFunctions.DistinctItemsCustomSeparator(NAnt.Core.Project,System.String,System.String)">
            <summary>
            Eliminates duplicates from the list of items.
            </summary>
            <param name="project" />
            <param name="str">The string to process.</param>
            <param name="sep">A custom separator string</param>
            <returns>String containing distinct items.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <fail unless="@{DistinctItemsCustomSeparator('a b f c d d e f g', '|')} eq 'a|b|f|c|d|e|g'" />
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Functions.TargetFunctions">
            <summary>
            Collection of target manipulation routines.
            </summary>
        </member>
        <member name="M:NAnt.Core.Functions.TargetFunctions.TargetExists(NAnt.Core.Project,System.String)">
            <summary>
            Check if the specified target exists.
            </summary>
            <param name="project" />
            <param name="targetName">The target name to check.</param>
            <returns>True or False.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name='build' />
    <fail unless="@{TargetExists('build')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="T:NAnt.Core.FunctionClassBase">
            <summary>
            Classes which define static methods to be used as NAnt function must derive from this class.
            </summary>
            <remarks>
            To declare a method as available to be called from within NAnt you must declare a method in a class where: 
            
            	- the class derives the NAnt.FunctionClassBase abstract class
            	- the class defines a NAnt.Attributes.FunctionClassAttribute attribute
            	- the method defines a NAnt.Attributes.FunctionAttribute attribute
            	- the method is static
            	- the method returns a string
            	- the first parameter of the method is of type NAnt.Project
            	- the remaining parameters are capable of being converted from a string to their assigned type
            	
            Function names need not be unique. However, functions are distinguished by name and number of parameters.
            So you may not have two functions with the same name and same number of parameters. Regardless of the types.
            </remarks>
            <example>
            [FunctionClass()]
            public class NantFunctionClass
            {
            	[Function()]
            	public static string Echo(Project project, string s)
            	{
            		return s;
            	}
            	
            	[Function()]
            	public static string Add(Project project, int a, int b)
            	{
            		int sum = a + b;
            		return sum.ToString();
            	}
            }
            </example>
        </member>
        <member name="T:NAnt.Core.Location">
            <summary>
            Stores the file name, line number and column number to record a position in a text file.
            </summary>
        </member>
        <member name="M:NAnt.Core.Location.GetLocationFromNode(System.Xml.XmlNode)">
            
             <summary>Location factory that return meaningful location from custom nodes that
             support position information.
             </summary>
            
        </member>
        <member name="M:NAnt.Core.Location.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Creates a location consisting of a file name, line number and column number.</summary>
            <remarks>fileName can be a local URI resource, e.g., file:///C:/WINDOWS/setuplog.txt</remarks>
        </member>
        <member name="M:NAnt.Core.Location.#ctor(System.String)">
            <summary>Creates a location consisting of a file name.</summary>
            <remarks>fileName can be a local URI resource, e.g., file:///C:/WINDOWS/setuplog.txt</remarks>
        </member>
        <member name="M:NAnt.Core.Location.#ctor">
            <summary>Creates an "unknown" location.</summary>
        </member>
        <member name="M:NAnt.Core.Location.ToString">
             <summary>
             Returns the file name, line number and a trailing space. An error
             message can be appended easily. For unknown locations, returns
             an empty string.
            </summary>
        </member>
        <member name="T:NAnt.Core.ObjectDictionary">
            <summary>
            Provides a dictionary of named option sets.  This is used by NAnt and the
            <see cref="T:NAnt.Core.Tasks.OptionSetTask"/> to create named option sets.
            </summary>
        </member>
        <member name="T:NAnt.Core.OptionSetDictionary">
            <summary>
            Provides a dictionary of named option sets.  This is used by NAnt and the
            <see cref="T:NAnt.Core.Tasks.OptionSetTask"/> to create named option sets.
            </summary>
        </member>
        <member name="T:NAnt.Core.OptionDictionary">
            <summary>
            Provides a dictionary of options.  An <see cref="T:NAnt.Core.OptionSet"/> contains
            a dictionary of named string options.
            </summary>
        </member>
        <member name="T:NAnt.Core.OptionSet">
            <summary>Manages a set of options as a name/value collection.</summary>
        </member>
        <member name="P:NAnt.Core.OptionSet.Options">
            <summary>The dictionary used to map option names to option values.</summary>
        </member>
        <member name="P:NAnt.Core.OptionSet.FromOptionSetName">
            <summary>The name of an option set to include.</summary>
        </member>
        <member name="M:NAnt.Core.OptionSet.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly initialize</summary>
        </member>
        <member name="M:NAnt.Core.OptionSet.InitializeElement(System.Xml.XmlNode)">
            <summary>Add all the child option elements.</summary>
            <param name="elementNode">XML node to initialize from.</param>
        </member>
        <member name="P:NAnt.Core.OptionSet.Option._name">
            <summary>The name of the option.</summary>
        </member>
        <member name="P:NAnt.Core.OptionSet.Option._val">
            <summary>The value of the option. Value can be set as option element text. 
            To get current value use ${option.value} expression.
            </summary>
        </member>
        <member name="T:NAnt.Core.PackageCore.IPackageServerV2">
            <summary>
            Version 2 of the IPackageServer interface. Can be used to connect with package server V2 API.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServerV2.Init(NAnt.Core.Project,System.Boolean,System.String)">
            <summary>
            Initializes the connection with the package server.
            </summary>
            <param name="project">The project</param>
            <param name="usev2">Whether or not to use the V2 API</param>
            <param name="token">The auth token when using V2 API, otherwise may be empty</param>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.Init(NAnt.Core.Project)">
            <summary>
            Initializes the connection with the package server.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.TryGetPackageReleases(System.String,System.Collections.Generic.IList{NAnt.Core.PackageCore.MasterConfig.IPackage}@)">
            <summary>
            Returns a list of all of the release of a package found on the package server.
            This is used when the version request is not found but other versions are available, in order to provide a helpful message.
            </summary>
            <param name="name">The name of the package</param>
            <param name="releases">A list of all of the releases of the package found on the package server</param>
            <returns></returns>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.Install(NAnt.Core.PackageCore.MasterConfig.IPackage,System.String)">
            <summary>
            Installs required package from a Package Server or throws an exception.
            </summary>
            <param name="packageSpec">Name of the package to install.</param>>
            <param name="rootDirectory">Local directory to install the release into.</param>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.Update(NAnt.Core.PackageCore.Release,System.Uri,System.String)">
            <summary>
            For protocol package servers only, updates release to version specified by protocol uri if required.
            </summary>
            <param name="release">The release to update.</param>
            <param name="ondemandUri">Uri to update package from.</param>
            <param name="rootDirectory">This directory is default install root. Package server can use this to temporarily relocation the package during the update.</param>
        </member>
        <member name="M:NAnt.Core.PackageCore.IPackageServer.IsPackageServerRelease(NAnt.Core.PackageCore.Release,System.String)">
            <summary>
            For protocol package servers only, returns true if passed in release is controlled by this package server.
            </summary>
            <param name="release">Release to check</param>
            <param name="rootDirectory"></param>
        </member>
        <member name="P:NAnt.Core.PackageCore.ReleaseBase.Name">
            <remarks/>
        </member>
        <member name="P:NAnt.Core.PackageCore.ReleaseBase.PackageId">
            <remarks/>
        </member>
        <member name="M:NAnt.Core.PackageCore.MasterConfig.GetOnDemandRoot(NAnt.Core.Project)">
            <summary>Returns the resolved ondemand root. Checks for the environment variable, evaluates conditions on the masterconfig elements and expands properties.</summary>
            <param name="project">If provided, nant properties in the root will be expanded.</param>
        </member>
        <member name="M:NAnt.Core.PackageCore.MasterConfig.GetDevelopmentRoot(NAnt.Core.Project)">
            <summary>Returns the resolved development root. Checks for the environment variable, evaluates conditions on the masterconfig elements and expands properties.</summary>
            <param name="project">If provided, nant properties in the root will be expanded.</param>
        </member>
        <member name="M:NAnt.Core.PackageCore.MasterConfig.GetLocalOnDemandRoot(NAnt.Core.Project)">
            <summary>Returns the resolved local ondemand root. Evaluates conditions on the masterconfig elements and expands properties.
            This property does not have an environment variable because it should be different for each build environment.</summary>
            <param name="project">If provided, nant properties in the root will be expanded.</param>
        </member>
        <member name="M:NAnt.Core.PackageCore.MasterConfig.ResolveRoot(System.String,System.Collections.Generic.List{NAnt.Core.PackageCore.MasterConfig.SpecialRootInfo},NAnt.Core.Project,System.String)">
            <summary>Resolves special roots, such as the development and ondemand roots, returning the value of the environment variable if set 
            or the appropriate root in the masterconfig after evaluating conditions.</summary>
            <param name="rootDescription">The name of the root, used for printing helpful log messages</param>
            <param name="rootInfoList">The list of roots in the masterconfig file</param>
            <param name="project">When provided, nant properties in the root will be expanded</param>
            <param name="environmentVariableOverride">The name of the environment variable that can be used to override the masterconfig file roots</param>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.EvaluateGroupTypes">
            <summary>whether to evaluate grouptype exceptions</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.EvaluateMasterVersions">
            <summary>whether to evaluate exceptions and replace the default with the evaluated version</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.HideFragments">
            <summary>skips writing the fragments block</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.ResolveGlobalProperties">
            <summary>whether to evaluate global property conditions</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.ResolveRoots">
            <summary>resolves the normal and special roots by evaluating properties and converting to absolute paths</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.ShowFragmentSources">
            <summary>whether to show which fragment a particular part of the masterconfig file is coming from</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.MasterConfigWriter.RemoveMetaPackages">
            <summary>An option to remove any metapackage attributes from packages</summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.MasterConfigWriter.WriteGlobalDefine(System.Linq.IGrouping{System.String,NAnt.Core.PackageCore.MasterConfig.GlobalDefine})">
            <summary>Writes a single global define</summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.PackageMap.OnDemand">
            <summary>
            Should we download missing packages from the package server on demand?
            This functionality make it harder than necessary to have a complete
            archive in source control, due to silent downloads of packages which
            haven't been checked into source control, so is turned off by default.
            </summary>
        </member>
        <member name="P:NAnt.Core.PackageCore.PackageMap.TopLevelRelease">
            <summary>
            If set to true, then package map apis will always use the the 
            version and location of the given top level release rather than 
            information from the masterconfig for that package.
            </summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.AutomaticPackageVersions">
            <summary>Mechanism for specifying versions automatically if we can determine package version to use without a masterconfig version.</summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.m_packageReleaseCache">
            <summary>
            Every time we attempt to locate an installed package or install a package we query this cache. For each IPackage (with custom compare rules) it will return
            a cache object that will either contain 1) a found installed release or a release that was installed by last call or 2) an exception (with dispatch info)
            that was thrown last time a package was searched / installed. The exception can be valid for remote search (on package server) or just for local searching
            so TryGetCachedResult ReleaseCacheResult to validate the right exception is being thrown. This dictionary is concurrent just so multiple entries can be updated
            parallel - we never expect to have two threads update the same entry simultaneously.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.GetFrameworkRelease">
            <summary>
            Returns the Framework package release we are currently running or throws exeception. Should only be called
            from code paths that are limited to running inside Framework.
            </summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.PackageMap.GetMasterOrAutoPackage(NAnt.Core.Project,System.String,System.String,System.String)">
            <summary>
            get master package of the given package, if none it set
            then set an automatic version to use for this package
            optionally takes the name of the package that is providing
            this version in which case we will inherit group/attributes
            </summary>
        </member>
        <member name="F:NAnt.Core.PackageCore.PackageMap.CompatibilityConditions">
            <summary>Returns a collection of releases.</summary>
        </member>
        <member name="M:NAnt.Core.PackageCore.Release.Utility.ObliterateDirectory(System.String)">
            <summary>Remove all files and directories in the given path regardless of readonly attributes.</summary>
            <param name="path">The path </param>
        </member>
        <member name="T:NAnt.Core.PackageCore.Compatibility">
            <summary>
            Class to store package compatibility.
            </summary>
            <remarks>
             <para>One declares package compatibility in the Manifest.xml file of a package. An example may look like:
              &lt;compatibility package="eacore"&gt;
              &lt;api-supported&gt;
              1.00.00
              1.00.01
              &lt;/api-supported&gt;
              &lt;binary-compatible&gt;
              1.00.01
              &lt;/binary-compatible&gt;
              &lt;dependent package="EABase"&gt;
              &lt;compatible&gt;
              2.0.4
              2.0.5
              &lt;/compatible&gt;
              &lt;incompatible version="2.0.3" message="Known bug in blah blah blah" /&gt;
              &lt;/dependent&gt;
              &lt;/compatibility&gt;
             </para>
            </remarks>
        </member>
        <member name="T:NAnt.Core.PackageCore.Compatibility.Incompatible">
            <summary>
            Class to store &lt;incompatible&gt;
            </summary>
        </member>
        <member name="T:NAnt.Core.PackageCore.Compatibility.Dependent">
            <summary>
            Class to store &lt;depenent&gt;
            </summary>
        </member>
        <member name="M:NAnt.Core.ParallelTaskContainer.ExecuteChildTasks">
            <summary>
            Creates and Executes the embedded (child XML nodes) elements.
            </summary>
            <remarks> Skips any element defined by the host task that has an BuildElementAttribute (included filesets and special XML) defined.</remarks>
        </member>
        <member name="M:NAnt.Core.Project.Execute(System.String,System.Boolean,System.Boolean)">
            <summary>Executes a specific target, and only that target.</summary>
            <param name="targetName">target name to execute.</param>
            <param name="force"></param>
            <param name="failIfTargetDoesNotExist">Fail build if target does not exist</param>
            <remarks>
              <para>Only the target is executed. No global tasks are executed.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Project.ExpandProperties(System.String)">
            <summary>
            Expands a string from known properties
            </summary>
            <param name="input">The string with replacement tokens</param>
            <returns>The expanded and replaced string</returns>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.Undefine(System.String)">
            <summary>Removes a property if it exists, returns a boolean to indicate if the property was found</summary>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.EvaluateParameter(NAnt.Core.PropertyKey,System.Collections.Generic.Stack{System.String})">
            <summary>
            Property evaluator callback without deprecated functions.
            </summary>
            <param name="key">The name of the property to evaluate.</param>
            <param name="evaluationStack">Evaluation stack for deferred expansions to prevent recursive self expansion.</param>
            <returns>The parameters evaluated value.</returns>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.EvaluateFunction(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Function evaluator callback for running functions.
            </summary>
        </member>
        <member name="M:NAnt.Core.PropertyDictionary.ExpandProperties(System.String)">
            <summary>Expands a string with macros.</summary>
            <param name="expression">The string with macros to expand.</param>
            <returns>The string with all macros expanded.</returns>
        </member>
        <member name="T:NAnt.Core.PropertyElement">
            <summary>A property element is used by tasks that want to have the user enter a string 
            but not as an attribute.  Useful if the string is going to hold multiple lines.</summary>
        </member>
        <member name="T:NAnt.Core.XmlPropertyElement">
            <summary>A property element is used by tasks that want to have the user enter a string 
            but not as an attribute.  Useful if the string is going to hold multiple lines.
            Can also contain build script tasks.</summary>
        </member>
        <member name="M:NAnt.Core.Reflection.FunctionFactory.Run(System.String,System.Collections.Generic.List{System.String},NAnt.Core.Project)">
            <summary>
            Run a function given the NAnt function name. 
            This corresponds to the name defined in the FunctionAttribute by the static method.
            </summary>
        </member>
        <member name="M:NAnt.Core.Reflection.FunctionFactory.AddFunctions(System.Reflection.Assembly,System.Boolean,System.Boolean,System.String)">
            <summary>Scans the given assembly for any classes derived from Function.</summary>
            <param name="assembly">The Assembly containing the new functions to be loaded.</param>
            <param name="overrideExistingFunc"></param>
            <param name="failOnError"></param>
            <param name="assemblyName"></param>
            <returns>The count of tasks found in the assembly.</returns>
        </member>
        <member name="M:NAnt.Core.Reflection.TaskFactory.CreateTask(System.Xml.XmlNode,NAnt.Core.Project)">
            <summary> Creates a new Task instance for the given XML and project.</summary>
            <param name="taskNode">The XML to initialize the task with.</param>
            <param name="project">The Project that the Task belongs to.</param>
            <returns>The Task instance.</returns>
        </member>
        <member name="M:NAnt.Core.Reflection.TaskFactory.CreateTask(System.String,NAnt.Core.Project)">
            <summary> Creates a new Task instance for the given task name and project.</summary>
            <param name="taskName">The task name to initialize the task with.</param>
            <param name="project">The Project that the Task belongs to.</param>
            <returns>The Task instance, or null if not found.</returns>
        </member>
        <member name="M:NAnt.Core.StringExtensions.ValueAt(System.String,System.Int32)">
            Helper function for StrCompareVersions. Returns character value at position pos, 
            or '\0' if index is outside the string
            <param name="str"> string</param>
            <param name="pos">position in the string</param>        
        </member>
        <member name="M:NAnt.Core.StringParser.ExpandString(System.String,NAnt.Core.StringParser.PropertyEvaluator,NAnt.Core.StringParser.FunctionEvaluator,NAnt.Core.StringParser.FindClosePropertyMatches)">
            <summary>
            Expands properties and functions within a string.
            </summary>
            <remarks>
              <para>Can handle nested expressions like ${${a}}.</para>
              <para>Cannot use '${' in expressions without invoking expansion.</para>
            </remarks>
            <param name="expression">The string to expand.</param>
            <param name="evaluateProperty">The delegate function to call when a property needs evaluating.</param>
            <param name="evaluateFunction">The delegate function to call when a function needs evaluating.</param>
            <param name="findClosePropertyMatches">The delegate function to call when a property fails to evaluate and close matches need to be gound for error message</param>
        </member>
        <member name="M:NAnt.Core.StringParser.ParseProperty(System.String,System.Int32@,NAnt.Core.StringParser.PropertyEvaluator,NAnt.Core.StringParser.FunctionEvaluator,NAnt.Core.StringParser.FindClosePropertyMatches,System.Collections.Generic.Stack{System.String}@)">
            <summary>
            Returns the expansion of a property within a string.
            </summary>
            <remarks>
              <para>Can handle nested expressions like ${${a}}.</para>
              <para>Cannot use '${' in expressions without invoking expansion.</para>
            </remarks>
            <param name="expression">The expression to expand.</param>
            <param name="offset">The offset in the expression of the property to expand.</param>
            <param name="evaluateProperty">The delegate function to call when a property needs evaluating.</param>
            <param name="evaluateFunction">The delegate function to call when a function needs evaluating.</param>
            <param name="findClosePropertyMatches">The delegate function to call when a property fails to evaluate and close matches need to be gound for error message</param>
            <param name="evaluationStack">A stack of properties that have already been attempt to be resolved in recursive calls (for dealing with deferred properties).</param>
        </member>
        <member name="M:NAnt.Core.StringParser.ParseFunction(System.String,System.Int32@,NAnt.Core.StringParser.PropertyEvaluator,NAnt.Core.StringParser.FunctionEvaluator,NAnt.Core.StringParser.FindClosePropertyMatches,System.Collections.Generic.Stack{System.String}@)">
            <summary>
            Returns the expansion of a function within a string.
            </summary>
            <param name="expression">The expression to expand.</param>
            <param name="offset">The offset in the expression of the property to expand.</param>
            <param name="evaluateProperty">The delegate function to call when a property needs evaluating.</param>
            <param name="evaluateFunction">The delegate function to call when a function needs evaluating.</param>
            <param name="findClosePropertyMatches">The delegate function to call when a property fails to evaluate and close matches need to be gound for error message</param>
            <param name="evaluationStack">A stack of properties that have already been attempt to be resolved in recursive calls (for dealing with deferred properties).</param>
        </member>
        <member name="T:NAnt.Core.Structured.ConditionalPropertyElement">
            <summary></summary>
        </member>
        <member name="P:NAnt.Core.Structured.ConditionalPropertyElement.IfDefined">
            <summary>If true then the task will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Structured.ConditionalPropertyElement.UnlessDefined">
            <summary>Opposite of if.  If false then the task will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Structured.ConditionalPropertyElement.AttrValue">
            <summary>Argument. Default is null.</summary>
        </member>
        <member name="P:NAnt.Core.Structured.ConditionalPropertyElement.Append">
            <summary>Append new data to the current value. The current value may come from partial modules. Default: 'true'.</summary>
        </member>
        <member name="T:NAnt.Core.Structured.ConditionElement">
            <summary></summary>
        </member>
        <member name="P:NAnt.Core.Structured.ConditionElement.IfDefined">
            <summary>If true then the task will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Structured.ConditionElement.UnlessDefined">
            <summary>Opposite of if.  If false then the task will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="M:NAnt.Core.Target.#ctor(NAnt.Core.Target)">
            <summary>Copy constructor.</summary>
            <param name="t">The target to copy values from.</param>
        </member>
        <member name="P:NAnt.Core.Target.Name">
            <summary>The name of the target.</summary>
            <remarks>
              <para>Hides Element.Name to have <c>Target</c> return the name of target, not the name of XML element - which would always be <c>target</c>.</para>
              <para>Note: Properties are not allowed in the name.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Target.IfDefined">
            <summary>If true then the target will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Target.UnlessDefined">
            <summary>Opposite of if.  If false then the target will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Target.Description">
            <summary>The Target description.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Style">
            <summary>Framework 2 packages only: Style can be 'use', 'build', or 'clean'.  Default value is either 'use' or inherited from parent target. See <see cref="!:AutoBuildClean"/> for details.</summary>
        </member>
        <member name="P:NAnt.Core.Target.DependencyList">
            <summary>A space separated list of target names that this target depends on.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Hidden">
            <summary>Prevents the target from being listed in the project help. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Target.Override">
            <summary>Override target with the same name if it already exists.</summary>
        </member>
        <member name="P:NAnt.Core.Target.AllowOverride">
            <summary>Override target with the same name if it already exists.</summary>
        </member>
        <member name="P:NAnt.Core.Target.BaseTarget">
            <summary> Overridden base target </summary>
        </member>
        <member name="P:NAnt.Core.Target.BaseDirectory">
            <summary>The base directory to use when executing tasks in this target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.HasExecuted">
            <summary>Indicates if the target has been executed.</summary>
            <remarks>
              <para>Targets that have been executed will not execute a second time.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Target.Dependencies">
            <summary>A collection of target names that must be executed before this target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.TargetNode">
            <summary>The XML used to initialize this Target.</summary>
        </member>
        <member name="P:NAnt.Core.Target.LogPrefix">
            <summary>The prefix used when sending messages to the log.</summary>
        </member>
        <member name="M:NAnt.Core.Target.Execute(NAnt.Core.Project)">
            <summary>Executes dependent targets first, then the target.</summary>
        </member>
        <member name="M:NAnt.Core.Target.System#ICloneable#Clone">
            <summary>
            Creates a deep copy by calling Copy().
            </summary>
            <returns></returns>
        </member>
        <member name="M:NAnt.Core.Target.Copy">
            <summary>
            Creates a new (deep) copy.
            </summary>
            <returns>A copy with the _hasExecuted set to false. This allows the new Target to be Executed.</returns>
        </member>
        <member name="P:NAnt.Core.Task.FailOnError">
            <summary>Determines if task failure stops the build, or is just reported. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Task.Verbose">
            <summary>Task reports detailed build log messages.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Task.IfDefined">
            <summary>If true then the task will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Task.UnlessDefined">
            <summary>Opposite of if.  If false then the task will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Task.TaskSuccess">
            <summary>Returns true if the task succeeded.</summary>
        </member>
        <member name="P:NAnt.Core.Task.LogPrefix">
            <summary>The prefix used when sending messages to the log.</summary>
        </member>
        <member name="M:NAnt.Core.Task.Execute">
            <summary>Executes the task unless it is skipped.</summary>
        </member>
        <member name="M:NAnt.Core.Task.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes the task and checks for correctness.</summary>
        </member>
        <member name="M:NAnt.Core.Task.ExecuteTask">
            <summary>Executes the task.</summary>
        </member>
        <member name="M:NAnt.Core.TaskContainer.ExecuteChildTasks">
            <summary>
            Creates and Executes the embedded (child XML nodes) elements.
            </summary>
            <remarks> Skips any element defined by the host task that has an BuildElementAttribute (included filesets and special XML) defined.</remarks>
        </member>
        <member name="T:NAnt.Core.Tasks.AsyncStart">
            <summary>Starts asynchronous execution of nested block.
            <para>
              <b>NOTE.</b> Make sure there are no race conditions, properties with same names, etc each group.
            </para>
            <para>
              <b>NOTE.</b> local properties are local to the thread. Normal NAnt properties are shared between threads.
            </para>
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AsyncStart.Key">
            <summary>Unique key string. When using global context make sure that key string does 
            not collide with keys that may be defined in other packages. 
            Using "package.[package name]." prefix is a good way to ensure unique values.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AsyncWait.Key">
            <summary>Unique key string. When using global context make sure that key string does 
            not collide with keys that may be defined in other packages. 
            Using "package.[package name]." prefix is a good way to ensure unique values.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.AttribTask">
            <summary>Changes the file attributes of a file or set of files.</summary>
            <remarks>
              <para>The <c>attrib</c> task does not conserve prior file attributes.  Any specified file 
              attributes are set; all other attributes are switched off.</para>
            </remarks>
            <example>
<para>Set the <c>ReadOnly</c> attribute to true for the specified file.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt"/>
    <attrib file="foo.txt" readonly="true"/>
    <fail 
        message="'foo.txt' not set to readonly."
        unless="@{FileCheckAttributes('foo.txt', 'ReadOnly')}"
        />
</project>
]]>
</code>
</example>
            <example>
<para>Clean any flags on the specified file.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt"/>

    <!-- first let's add some attributes -->
    <attrib file="foo.txt" readonly="true" hidden="true"/>

    <!-- now let's clear them -->
    <attrib file="foo.txt" normal="true"/>
    <fail 
        message="'foo.txt' not set to readonly."
        if="@{FileCheckAttributes('foo.txt', 'ReadOnly Hidden')}"
        />
</project>
]]>
</code>
</example>
            <example>
<para>Set the normal file attributes to all executable files in the current 
directory and sub-directories.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <attrib normal="true">
        <fileset>
            <includes name="**/*.exe"/>
            <includes name="**/*.dll"/>
        </fileset>
    </attrib>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.FileName">
            <summary>The name of the file which will have its attributes set.  This is provided as an alternate to using the task's fileset.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.AttribFileSet">
            <summary>All the files in this fileset will have their file attributes set.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.ArchiveAttrib">
            <summary>Set the archive attribute.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.HiddenAttrib">
            <summary>Set the hidden attribute.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.NormalAttrib">
            <summary>Set the normal file attributes.  This attribute is valid only if used alone.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.ReadOnlyAttrib">
            <summary>Set the read only attribute.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.AttribTask.SystemAttrib">
            <summary>Set the system attribute.  Default is "false".</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.CallBaseTask">
            <summary>
            Calls a NAnt target.
            </summary>
            <example>
<para>Call the target "build".</para>
<code>
<![CDATA[
<project default="run">
	<target name="MyTarget" allowoverride="true">
		<echo message="Hello from base target"/>
	</target>

	<target name="MyTarget" override="true">
		<call-base />
	</target>
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.CallTask">
            <summary>
            Calls a NAnt target.
            </summary>
            <example>
<para>Call the target "build".</para>
<code>
<![CDATA[
<project default="run">
	<target name="build">
		<echo message="Hello, Build!"/>
	</target>

	<target name="run">
		<call target="build"/>
	</target>
</project>
]]>
</code>
</example>
            <example>
<para>This shows how a project could 'compile' a debug and release build using a common compile target.</para>
<code>
<![CDATA[
<project default="build">
    <target name="compile">
      <echo message="compiling with debug = ${debug}"/>
    </target>

    <target name="build">
        <property name="debug" value="false"/>
        <call target="compile"/>
        <property name="debug" value="true"/>
        <call target="compile" force="true"/> <!-- notice the force attribute -->
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CallTask.TargetName">
            <summary>NAnt target to call.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CallTask.ForceExecute">
            <summary>Force an Execute even if the target 
            has already been executed.  Forced execution occurs on a copy of the unique
            target, since the original can only be executed once.
            Default value is true.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.CancelBuildTargetsExecutionTask">
            <summary>Stops execution of next top level target (when targets are chained</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ChooseTask">
            <summary>
            The <c>choose</c> task is used in conjunction with the <c>do</c> task to express multiple conditional 
            statements.
            </summary>
            <remarks>
              <para>
              The code of the first, and only the first, <c>do</c> task whose expression evaluates to true is executed.
              </para>
            </remarks>
            <example>
<para>If / Else conditional.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name='a' value='true' />

    <choose>
        <do if='${a}'>
            <echo message='a is true' />
        </do>
        <do>
            <echo message='a is false' />
        </do>
    </choose>    
</project>
]]>
</code>
</example>
            <example>
<para>If / ElseIf / Else conditional.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name='a' value='false' />
    <property name='b' value='true' />

    <choose>
        <do if='${a}'>
            <echo message='a is true' />
        </do>
        <do if='${b}'>
            <echo message='a is false and b is true' />
        </do>
        <do>
            <echo message='a is false and b is false' />
        </do>
    </choose>    
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.CollectBuildStats">
            <summary>Collects statistics for a group of tasks wrapped by this element</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CollectBuildStats.Label">
            <summary>Unique label name for this set of build stats.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.PrintBuildStats">
            <summary>Prints colected build statistics</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PrintBuildStats.BuildPackages">
            <summary>Package list that was in this build.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PrintBuildStats.BuildVersion">
            <summary>A version string for this build.
            </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.PrintBuildStats.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes the task.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.CopyTask">
            <summary>Copies a file or file set to a new location.</summary>
            <remarks>
              <para>
              By default, files are copied if the source file is newer than the destination file, or if the 
              destination file does not exist. However, you can explicitly overwrite (newer) files with the 
              <c>overwrite</c> attribute set to true.</para>
              <para>
              A file set, defining groups of files using patterns, can be copied if 
              the <c>todir</c> attribute is set.  All the files matched by the file set will be 
              copied to that directory, preserving their associated directory structure.
              Beware that <c>copy</c> handles only a single fileset, but note that
              a fileset may include another fileset.
              </para>
              <para>Any directories are created as needed by the <c>copy</c> task.</para>
              <para>There is another task available that is similar to the copy task, the &lt;synctargetdir&gt; task.
              The difference is that it tries to ensure two directories are in sync by only copying 
              files with changes and deleting files that are no longer existent in the source fileset.
              </para>
            </remarks>
            <example>
<para>Copy a single file.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo file="source.txt">A temp file.</echo>
    <copy file="source.txt" tofile="destination.txt"/>
    <fail message="File did not copy." unless="@{FileExists('destination.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Copy a set of files to a new directory.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- create some test files -->
    <touch file="a.txt"/>
    <touch file="b.txt"/>
    <touch file="c.txt"/>
    
    <!-- copy the files to new directory (directory will get created) -->
    <copy todir="sub">
        <fileset>
            <includes name="*.txt"/> 
        </fileset>
    </copy>

    <!-- make sure the files got copied -->    
    <fail unless="@{FileExists('sub/a.txt')}"/>
    <fail unless="@{FileExists('sub/b.txt')}"/>
    <fail unless="@{FileExists('sub/c.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Copy a set of files in a different basedirectory to a new directory.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- create some test files -->
    <mkdir dir="source/foo"/>
    <mkdir dir="source/bar"/>
    <touch file="source/foo/a.txt"/>
    <touch file="source/bar/b.txt"/>
    <fail message="Source file not in expected location" unless="@{FileExists('source/foo/a.txt')}"/>
    
    <!-- copy the files to new directory (directory will get created) -->
    <copy todir="sub">
        <fileset basedir="source">
            <includes name="**/*.txt"/> 
        </fileset>
    </copy>

    <!-- make sure the files got copied -->    
    <fail message="Destination file not in expected location" unless="@{FileExists('sub/foo/a.txt')}"/>
    <fail message="Destination file not in expected location" unless="@{FileExists('sub/bar/b.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Test to show how specifying duplicate source files doesn't cause problems.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo file="source.txt">A temp file.</echo>
    <copy todir="out">
        <fileset>
            <includes name="Source.txt"/>
            <includes name="Source.txt"/>
            <includes name="*/**.txt"/>
        </fileset>
    </copy>
    <fail message="File did not copy." unless="@{FileExists('out/source.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Example of &lt;copy&gt; task with flatten set to true.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="srcDir" value="${nant.location}\..\config"/>
    <echo message="Copying NAnt's config folder to temp"/>
    <mkdir dir="temp"/>
    <copy todir="temp" flatten="true">
        <fileset basedir="${srcDir}">
            <includes name="**/*.*"/>
        </fileset>
    </copy>
    <echo>Folder temp has @{DirectoryGetFileCount('temp', '*.*')} files</echo>
    <echo>Deleting temp</echo>
    <delete dir="temp" failonerror="false"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.SourceFile">
            <summary>The file to transfer in a single file transfer operation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.ToFile">
            <summary>The file to transfer to in a single file transfer operation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.ToDirectory">
            <summary>The directory to transfer to, when transferring a file set.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.Overwrite">
            <summary>Overwrite existing files even if the destination files are newer. Defaults is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.Clobber">
            <summary>Allow hidden and read-only files to be overwritten if appropriate (i.e. if source is newer or overwrite is set to true). Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.MaintainAttributes">
            <summary>Maintain file attributes of overwritten files. By default and if destination file does not exist file attributes are carried over from source file. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.Flatten">
            <summary>Flatten directory structure when transferring a file set. All files are placed in the <i>todir</i>, without duplicating the directory structure.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.RetryCount">
            <summary>Number of times to retry the copy operation if copy fails.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.RetryDelay">
            <summary>Length of time in milliseconds between retry attempts.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.HardLink">
            <summary>Tries to create a hard link to the source file rather than copying the entire contents of the file.
            If unable to create a hard link it simply copies the file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.SymLink">
            <summary>Tries to create a hard link to the source file rather than copying the entire contents of the file.
            If unable to create a hard link it simply copies the file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CopyTask.CopyFileSet">
            <summary>The (single) file set to be copied.  
            Note the todir attribute must be set, and that a fileset 
            may include another fileset.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.CopyTask.DoFileOperations">
            <summary>
            Actually does the file (and possibly empty directory)
            transfers.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.Echo">
            <summary>Write to the log file. Default is false</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.DumpProperties">
            <summary>Dump properties. Default - true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.DumpFilesets">
            <summary>Dump fileset names. Default - true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.DumpOptionsets">
            <summary>Dump optionset names</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.ExpandAll">
            <summary>Include content of filesets and optionsets. Default is false</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.ToFile">
            <summary>Dump optionset names</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CoreDumpTask.Format">
            <summary>format: text, xml. Default - text</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.RunTask">
            <summary>
            Executes a task created by &lt;createtask&gt;. 
            </summary>
            <remarks>
            <para>Use &lt;createtask&gt; to create a new 'task' that is made of NAnt 
            script.  Then use the &lt;task&gt; task to call that task with the required parameters.</para>
            
            <para>Each parameter may be either an attribute (eg. Message in example below) or a nested text element
            (eg. DefList in example below) that allows multiple lines of text.  Multiple lines may be needed for certain task elements like
            &lt;includedirs&gt;, &lt;usingdirs&gt;, and &lt;defines&gt; in &lt;cc&gt;.	</para>
            
            <para>If &lt;createtask&gt; was not used to create a task with that name and there is a regular C# task with the same name it will execute that.
            This mechanism can be used to override a default task with custom behavior or convert a xml task to a C# task without breaking users build scripts.</para>
            </remarks>
            <example>
<para>Test to show how to use &lt;createtask&gt; and &lt;task&gt;.</para>
<code>
<![CDATA[
<!-- testtask.build -->
<project xmlns="schemas/ea/framework3.xsd">
	<property name="propdefs">
	DEFINE1
	DEFINE2
	</property>
	
    <createtask name="TestTask">
        <parameters>
            <option name="Message" value="Required"/>
            <option name="DefList" value="Required"/>
        </parameters>
        <code>
            <echo message="${TestTask.Message}"/>
		    <dependent name="VisualStudio"/>
			<cc >
				<defines>
				TEST_DEF
				${TestTask.DefList}
				</defines>
				<sources>
					<includes name="test.cpp"/>
				</sources>
			</cc>
        </code>
    </createtask>

    <foreach item="OptionSet" in="Task.TestTask.Parameters" property="parameter">
        <echo message="${parameter.name} = ${parameter.value}"/>
    </foreach>

    <echo message="${Task.TestTask.Code}"/>

    <task name="TestTask" Message="@{DateTimeToday()}">
		<DefList>
		TEST_DEFINITION
		TEST_DEFINE
		${propdefs}
		</DefList>
	</task>
   
</project>
]]>
</code>

<code file="Manifest.xml">
<![CDATA[
<!-- manifest.xml -->
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>

<code file="masterconfig.xml">
<![CDATA[
<!-- masterconfig.xml -->
<project xmlns="schemas/ea/framework3.xsd">
	<masterversions>
		<package name="VisualStudio" version="7.1.1-5"/>
		<package name="Framework" version="dev"/>
	</masterversions>
	<config package="Framework" default="win-release"/>
</project>
]]>
</code>

<code file="test.cpp">
<![CDATA[
//test.cpp
#ifndef TEST_DEFINE
#error TEST_DEFINE not defined
#endif
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.RunTask.TaskName">
            <summary>The name of the task being declared.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RunTask.ParameterValues">
            <summary>
            The parameters to be passed to &lt;createtask&gt;
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.CreateTaskTask">
            <summary>Create a task that is made of NAnt script and can be used by &lt;task&gt;.
            </summary>
            <remarks>
            
            <para>Use the &lt;createtask&gt; to create a new 'task' that is made of NAnt 
            script.  Then use the &lt;task&gt; task to call that task with the required parameters.</para>
            
            <para>The following unique properties will be created, for use by &lt;task&gt;:</para>
            <list type="bullet">
            <item><b>Task.{name}</b></item>
            <item><b>Task.{name}.Code</b></item>
            </list>
            The following named optionset will be created, for use by &lt;task&gt;:
            <list type="bullet">
            <item><b>Task.{name}.Parameters</b></item>
            </list>
            </remarks>
            <example>
                <code>
            &lt;createtask name="BasicTask"&gt;
               &lt;parameters&gt;
                   &lt;option name="DummyParam" value="Required"/&gt;
                   &lt;option name="Indentation"/&gt;
               &lt;/parameters&gt;
               &lt;code&gt;
                   &lt;echo message="${BasicTask.Indentation}Start BasicTask."/&gt;
                   &lt;echo message="${BasicTask.Indentation}    DummyParam value = ${BasicTask.DummyParam}"/&gt;
                   &lt;echo message="${BasicTask.Indentation}Finished BasicTask."/&gt;
               &lt;/code&gt;
            &lt;/createtask&gt;
                </code>
            </example>
            <example>
<para>Test to show how to use &lt;createtask&gt; and &lt;task&gt;.</para>
<code>
<![CDATA[
<!-- testtask.build -->
<project xmlns="schemas/ea/framework3.xsd">
	<property name="propdefs">
	DEFINE1
	DEFINE2
	</property>
	
    <createtask name="TestTask">
        <parameters>
            <option name="Message" value="Required"/>
            <option name="DefList" value="Required"/>
        </parameters>
        <code>
            <echo message="${TestTask.Message}"/>
		    <dependent name="VisualStudio"/>
			<cc >
				<defines>
				TEST_DEF
				${TestTask.DefList}
				</defines>
				<sources>
					<includes name="test.cpp"/>
				</sources>
			</cc>
        </code>
    </createtask>

    <foreach item="OptionSet" in="Task.TestTask.Parameters" property="parameter">
        <echo message="${parameter.name} = ${parameter.value}"/>
    </foreach>

    <echo message="${Task.TestTask.Code}"/>

    <task name="TestTask" Message="@{DateTimeToday()}">
		<DefList>
		TEST_DEFINITION
		TEST_DEFINE
		${propdefs}
		</DefList>
	</task>
   
</project>
]]>
</code>

<code file="Manifest.xml">
<![CDATA[
<!-- manifest.xml -->
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>

<code file="masterconfig.xml">
<![CDATA[
<!-- masterconfig.xml -->
<project xmlns="schemas/ea/framework3.xsd">
	<masterversions>
		<package name="VisualStudio" version="7.1.1-5"/>
		<package name="Framework" version="dev"/>
	</masterversions>
	<config package="Framework" default="win-release"/>
</project>
]]>
</code>

<code file="test.cpp">
<![CDATA[
//test.cpp
#ifndef TEST_DEFINE
#error TEST_DEFINE not defined
#endif
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.TaskName">
            <summary>The name of the task being declared.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.Overload">
            <summary>Overload existing definition.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.Parameters">
            <summary>The set of task parameters.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.CreateTaskTask.Code">
            <summary>
            The NAnt script this task is made out from
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DebugBreakTask">
            <summary>
            Triggers a debug break so that you can stop execution at a sepecific point in a build script and inspect the state in the debugger.
            </summary>
            <remarks>
              <para>
              Useful when trying to debug a build script in order to stop execution a specific point to inspect the state of framework properties.
              For more information about debugging framework see the "Debugging Framework" guide in the User Guides section of the Framework documentation.
              </para>
            </remarks>
        </member>
        <member name="T:NAnt.Core.Tasks.DeleteTask">
            <summary>Deletes a file, file set or directory.</summary>
            <remarks>
              <para>Deletes either a single file, all files in a specified directory and its sub-directories, or a set of files specified by one or more file sets.</para>
              <note>If the file attribute is set then the file set contents will be ignored.  To delete the files in the file set, omit the file attribute in the delete element.</note>
              <note>All items specified including read-only files and directories are 
              deleted.  If an item cannot be deleted because of some other reason 
              the task will fail if "failonmissing" is true.</note>
            </remarks>
            <example>
<para>Delete a single file.  If the file does not exist the task does nothing.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt"/>
    <delete file="foo.txt"/>
    <fail if="@{FileExists('foo.txt')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Delete a directory and the contents within.  If the directory does not 
exist the task will fail.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="c:\bar69"/>
    <touch file="c:\bar69\one.txt"/>
    <touch file="c:\bar69\two.txt"/>
    <delete dir="c:\bar69" failonmissing="true"/>
    <fail if="@{DirectoryExists('c:\bar69')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Delete a set of files.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="apple.txt"/>
    <touch file="banana.txt"/>
    <touch file="carot.bin"/>
    <delete>
        <fileset>
            <includes name="*.txt"/>
        </fileset>
    </delete>
    <fail if="@{FileExists('apple.txt')}"/>
    <fail unless="@{FileExists('carot.bin')}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.FileName">
            <summary>The file to delete. Applies only to the single file delete operation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.DirectoryName">
            <summary>The directory to delete.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.FailOnMissing">
            <summary>If true the task will fail if a file or directory specified is not present.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.Quiet">
            <summary>If true then be quiet - don't report on the deletes. Default is false</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeleteTask.DeleteFileSet">
            <summary>All the files in the file set will be deleted.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DependsTask">
            <summary>Performs a generic dependency check.</summary>
            <remarks>
            <para>When properly used, this task sets the specified property to true if any file in the <c>inputs</c> is newer than any
            file in the <c>outputs</c> fileset.</para>
            <para>
            Proper usage requires that at least one file needs to be present in the inputs fileset, as well as the outputs fileset.  
            </para>
            <para>
            If either fileset is empty, the property will be set to true.
            Note that a fileset can be empty if it includes a nonexistent file(name) "asis" 
            (by setting the attribute asis="true").
            Since the asis attribute is false by default, it's impossible to create
            a fileset that includes a nonexistent file without overriding asis.
            </para>
            <para>
            Additionally, if any file included in the outputs fileset does not exist, the 
            property will be set to true.</para>
            </remarks>
            <example>
<para>Shows how to setup basic dependency checking for any task.  
Notice the use of the <see cref="T:NAnt.Core.Tasks.TouchTask" /> to create a persistent file.  
This is useful if you are doing recursive builds.  
Remember to create the -start file at the start of your build using 
another <see cref="T:NAnt.Core.Tasks.TouchTask" /> instance.  
Note that if the depends task was not used, the core-build target would keep 
getting called because of the recursive nature of the build.</para>
<code file="fruit.build">
<![CDATA[
<project default="build">
    <touch file="start"/>

    <target name="build" depends="apple banana">
        <fail unless="@{FileExists('apple')}"/>
        <fail unless="@{FileExists('banana')}"/>
    </target>

    <target name="apple">
        <nant buildfile="core.xml" target="apple-build"/>
    </target>

    <target name="banana">
        <nant buildfile="core.xml" target="banana-build"/>
    </target>
</project>
]]>
</code>
<para>Where <c>core.xml</c> contains:</para>
<code file="core.xml">
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="core">
        <depends property="needs-building">
            <inputs>
                <includes name="start"/>
            </inputs>
            <outputs>
                <includes name="core-built"/>
            </outputs>
        </depends>
        <nant 
            if="${needs-building}" 
            buildfile="core.xml" target="core-build"
            />
        <touch file="core-built"/>
    </target>

    <target name="apple-build" depends="core">
        <echo message="Building apple"/>
        <touch file="apple"/>
    </target>

    <target name="banana-build" depends="core">
        <echo message="Building banana"/>
        <touch file="banana"/>
    </target>

    <target name="core-build">
        <echo message="Building core"/>
        <touch file="core"/>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.DependsTask.PropertyName">
            <summary>The property name to set to hold the result of the dependency check.  The value in 
            this property after the task has run successfully will be either <c>true</c> or 
            <c>false</c>.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DependsTask.Inputs">
            <summary>Set of input files to check against.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DependsTask.Outputs">
            <summary>Set of output files to check against.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.DependsTask.TaskNeedsRunning">
            <summary>Determine if the task needs to run.</summary>
            <returns><c>true</c> if we should run the program (dependents missing or not up to date), otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NAnt.Core.Tasks.DeprecateTask">
            <summary>Display a deprecation message in the current build.</summary>
            <remarks>
              <para>Displays a deprecation message and location in the build file then continues with the build.</para>
            </remarks>
            <example>
<para>Displays a deprecation message and location in the build file then continues with the build.</para>
<code file="simple.build">
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <deprecate message="This is an example deprecate task usage."/>
</project>
]]></code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.DeprecateTask.Message">
            <summary>The deprecation message to display.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DeprecateTask.Group">
            <summary>
            Categorizes the deprecation for the framework build messaging system. 
            Allows users to disable all deprecations in a category.
            (Designed to be used only by internal Framework packages for now)
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DoOnce">
            <summary>Container task. Executes nested elements once for a given unique key and a context.</summary>
            <remarks>
            do.once task is thread safe.
            This task acts within single NAnt process. It can not cross NAnt process boundary.
            </remarks>
            <example>
             <para>
             In the following example an expensive code generation step is preformed which the build script writer only wants to happen once.
             </para>
             <code><![CDATA[
             <do.once key="package.TestPackage.generate-code" context="global">
               <do if="${config-system}==pc"/>
                 <Generate-PC-Code/>
               </do>
             </do.once>
             ]]></code>
            </example>
        </member>
        <member name="P:NAnt.Core.Tasks.DoOnce.Key">
            <summary>Unique key string. When using global context make sure that key string does 
            not collide with keys that may be defined in other packages. 
            Using "package.[package name]." prefix is a good way to ensure unique values.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DoOnce.Context">
            <summary>
            Context for the key. Context can be either <b>global</b> or <b>project</b>. Default value is <b>global</b>.
            <list type="bullet">
            <item><b>global</b> context means that for each unique key task is executed once in NAnt process.</item>
            <item><b>project</b> context means that for each unique key task is executed once for each package.</item>
            </list>
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.DoOnce.IsBlocking">
            <summary>
            Defines behavior when several instances of do.once task with the same key are invoked simultaneously.
            <list type="bullet">
            <item><b>blocking=false</b> (default) - One instance will execute nested elements, other instances will return immediately without waiting.</item>
            <item><b>blocking=true</b> - One instance will execute nested elements, other instances will wait for the first instance to complete and
            then return without executing nested elements.</item>
            </list>
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.DoTask">
            <summary>Allows wrapping of a group of tasks to be executed based on a conditional.</summary>
            <remarks>
            <para>Use the do task in conjunction with the if and unless attributes to execute a series
            of tasks based on the condition.</para>
            <para>Another use for the task is when you want to execute a task only if a property is
            defined.  Normally NAnt will try to expand the property at the same time performing
            the if/unless condition check.</para>
            </remarks>
            <example>
<para>Simple example of wrapping a series of tasks with a single condition.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <do if="true">
        <echo message="Hello, World!"/>
        <echo message="Goodbye, Cruel World!"/>
    </do>
</project>
]]>
</code>
</example>
            <example>
<para>Shows how to execute a task that takes a property but only if that property is defined.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="foo" value="bar"/>
    <do if="@{PropertyExists('foo')}">
        <echo message="${foo}"/>
    </do>
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.EchoTask">
            <summary>Writes a message to the build log.</summary>
            <remarks>
              <para>A copy of the message will be sent to every defined
            build log and logger on the system.  Property references in the message will be expanded.</para>
            </remarks>
            <example>
<para>Writes message to build log.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo message="Hello, World!"/>
</project>
]]>
</code>
</example>
            <example>
<para>Writes message with expanded macro to build log using the implicit text element.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo>Base build directory = ${nant.project.basedir}</echo>
</project>
]]>
</code>
</example>
            <example>
<para>Writes messages to a named file, instead of the build log.</para>
<para>Remember that the <c>append</c> attribute defaults to <i>false</i>, 
so by default echoing a message to a file will create a new instance of 
that file, destroying any previously existing version.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
	<echo message="Everyone Talks About Whether Nobody Does Anything" file="irony.out" />
	<echo message="On a clear disk, you can seek forever." file="irony.out" append="true" />
</project>
]]>
</code>
<para>After this build file executes, the file <c>irony.out</c> will
contain </para>
<![CDATA[
Everyone Talks About Whether Nobody Does Anything
On a clear disk, you can seek forever.
]]>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.Message">
            <summary>The message to display.  For longer messages use the inner text element of the task.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.FileName">
            <summary>The name of the file to write the message to.  If empty write message to log.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.Append">
            <summary>Indicates if message should be appended to file.  Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EchoTask.LogLevel">
            <summary>The log level that the message should be printed at. (ie. quiet, minimal, normal, detailed, diagnostic) default is normal.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.EchoTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes the task.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.EvalTask">
            <summary>Evaluate a block of code.</summary>
            <remarks>
            The eval task will evaluate a specified block of code and optionally store the result in a property. If 
            no property name is specified the result ignored. This task is useful for running functions which do not 
            require output.
            </remarks>
            <example>
<para>Evaluate a Function.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name='p' />
    <eval code="@{PropertyUndefine('p')}" type="Function" />
</project>
]]>
</code>
</example>
            <example>
<para>Evaluate a Property and place the result in a property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name='a' value='Hello' />
    <property name='b' value='World' />
    
    <eval property='x' code="${a}, ${b}" type="Property" />
    <echo message='${x}' />
</project>
]]>
</code>
</example>
            <example>
<para>Evaluate an Expression and place the result in a property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <eval property='x' code="1 == 0" type="Expression" />
    <echo message='${x}' />
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.EvalTask.Code">
            <summary>The code to evaluate.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EvalTask.Type">
            <summary>The type of code to evaluate. Valid values are <c>Property</c>, <c>Function</c> and <c>Expression</c>.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.EvalTask.PropertyName">
            <summary>The name of the property to place the result into. If none is specified result is ignored.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ExecTask">
             <summary>Executes a system command.</summary>
             <remarks>
             <para>Any options in the <c>env</c> option set get added as environment variables when
             the program is run.</para>
            
             <para>You can use <![CDATA[<arg value="switch"/> or <arg file="filename.txt"/>]]> to
             specify command line options in a more manageable way. The values in these elements get
             appended to whatever value is in the commandline attribute if that attribute exists.
             File values specified using the <c>file</c> attribute get expanded to their full paths.</para>
            
             <para>The <c>inputs</c> and <c>outputs</c> file sets allow you to perform dependency checking.
             The <c>program</c> will only get executed if one of the inputs is newer than all of the
             outputs.</para>
             
             <para>After each <see cref="T:NAnt.Core.Tasks.ExecTask" /> task is completed the read-only property <c>${exec.exitcode}</c> 
             is set to the value that the process specified when it terminated. The default value is -1 and 
             is specified when the process fails to return a valid value.</para>
            
             <para>Note: By default errors will not be generated if files are missing from the output file
             set.  Normally filesets will throw a build exception if a specifically named file does not
             exist.  This behaviour is controlled by the <c>failonmissing</c> file set attribute, which
             defaults to <c>true</c>.  If set to <c>false</c>, no build exception will be thrown when a
             specifically named file is not found.</para>
            
             <para>Note: Dependency checking requires at least one file in the <c>inputs</c> fileset and one
             file in the <c>outputs</c> fileset.  If either of these filesets is empty, no dependency
             checking will be performed.</para>
             </remarks>
             <example>
<para>Run nant and display its help.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <exec program="nant" commandline="-help"/>
</project>
]]>
</code>
</example>
             <example>
<para>Use of the <c>arg</c> element and environment variables in the <c>env</c> option set.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <exec program="cmd.exe">
        <args>
            <arg value="/c echo"/>
            <arg value="Hello, %MyName%!"/>
        </args>
        <env>
            <option name="MyName" value="Paul"/>
            <option name="PATH" value="${sys.env.PATH};c:\phoenix;"/>
        </env>
    </exec>
</project>
]]>
</code>
</example>
             <example>
<para>This is an example of using the <c>inputs</c> and <c>outputs</c> file sets to perform
dependency checking.  The program will be executed if the files in the inputs are newer
than the files in the outputs.  This example also shows how to redirect standard output to a file.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="in.0.txt"/>
    <touch file="in.1.txt"/>
    <exec program='cmd.exe' output="out.txt">
        <args>
            <arg value='/c echo ${exec.inputs.0} ${exec.inputs.1}'/>
        </args>
        <inputs failonmissing='false'>
            <includes name='in.*.txt'/>
        </inputs>
        <outputs>
            <includes name='out.txt' asis='true'/>
        </outputs>
    </exec>
    <fail message="out.txt file was not created" unless="@{FileExists('out.txt')}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Program">
            <summary>The program to execute. Specify the fully qualified name unless the program is in the path.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Message">
            <summary>The message to display to the log.  If present then no other output will be displayed unless there is an error or the verbose attribute is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Arguments">
            <summary>The command line arguments for the program.  Consider using <c>arg</c> elements (see task description) for improved readability.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.ResponseFile">
            <summary>Use the contents of this file as input to the program.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.CommandLineTemplate">
            <summary>The template used to form the command line. Default is '%commandline% %responsefile%'.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Output">
            <summary>The file to which the standard output will be redirected. By default, the standard output is redirected to the console.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Append">
            <summary>true if the output file is to be appended to. Default = "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Stdout">
            <summary>Write to standard output. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.RedirectOut">
            <summary>Set true to redirect stdout and stderr. When set to false, this will disable options such as stdout, outputfile etc.  Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.RedirectIn">
            <summary>Set true to redirect stdin. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.CreateInWindow">
            <summary>Set true to create process in a new window.. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Silent">
            <summary>If true standard output from the external program (as well as the execution command line) will not be written to log. Does not affect standard error. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.SilentError">
            <summary>If true standard error from the external program (as well as the execution command line) will not be written to log. Does not affect standard output. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.WorkingDirectory">
            <summary>The directory in which the command will be executed. The workingdir will be evaluated relative to the build file's directory.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.ClearEnv">
            <summary>Set true to clear all environmental variable before executing, environmental variable specified in env OptionSet will still be added as environmental variable.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.EnvironmentVariables">
            <summary>The set of environment variables for when the program runs.
            Benefit of setting variables, like "Path", here is that it will be
            local to this program execution (i.e. global path is unaffected).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.TimeOut">
            <summary>Stop the build if the command does not finish within the specified time.  Specified in milliseconds.  Default is no time out.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Inputs">
            <summary>Program inputs.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.Outputs">
            <summary>Program outputs.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExecTask.ArgSet">
            <summary>A set of command line arguments.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExecTask.TaskNeedsRunning">
            <summary>Determine if the task needs to run.</summary>
            <returns><c>true</c> if we should run the program (dependents missing or not up to date), otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NAnt.Core.Tasks.ExternalProgramBase">
            <summary>Provides the abstract base class for tasks that execute external applications.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.ProgramFileName">
            <summary>Gets the application to start.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.ProgramArguments">
            <summary>Gets the command line arguments for the application.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.OutputFile">
            <summary>The file to which the standard output will be redirected.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.OutputAppend">
            <summary>True if the output file is to be appended to.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.Stdout">
            <summary>Write to standard output. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.RedirectOut">
            <summary>Redirect standard output. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.RedirectIn">
            <summary>Redirect standard input. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.CreateInWindow">
            <summary>Whether to create process in its own window. Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.Quiet">
            <summary>If true standard output from the external program will not be written to log.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.QuietError">
            <summary>If true standard error from the external program will not be written to log.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.ExitCode">
            <summary>Returns the exit code of the process once it has run. Default is -1.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.BaseDirectory">
            <summary>Gets the working directory for the application.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.TimeOut">
            <summary>The maximum amount of time the application is allowed to execute, expressed in milliseconds.  Defaults to no time-out.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ExternalProgramBase.Args">
            <summary>Get the command line arguments for the application.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.GetCommandLine">
            <summary>Get the command line arguments, separated by spaces.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.PrepareProcess(System.Diagnostics.Process@)">
            <summary>
            Sets the StartInfo Options and returns a new Process that can be run.
            </summary>
            <returns>new Process with information about programs to run, etc.</returns>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.LogStdOut(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stdout</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.ExternalProgramBase.LogStdErr(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stderr</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FailTask">
            <summary>Exit the current build.</summary>
            <remarks>
              <para>Exits the current build optionally printing additional information.</para>
            </remarks>
            <example>
<para>Will exit the current build displaying a message if the property
<c>should-fail</c> is set to true.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="should-fail" value="false"/>
    <fail if="${should-fail}" message="Because 'should-fail' was true."/>

    <trycatch>
      <try>
       <fail unless="@{FileExists(${filename})}" type="FileNotFoundException" message="File ${filename} was not found."/>
       <!-- do something with the file in ${filename}-->
      </try>
      <catch exception="FileNotFoundException">
        <echo message="File ${filename} could not be properly treated because it was not found"/>
      </catch>
    </trycatch>    
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.FailTask.Type">
            <summary>Type of the exception thrown, for use with the &lt;trycatch&gt; task.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FailTask.Message">
            <summary>A message giving further information on why the build exited.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FileSetTask">
            <summary>
            Filesets are groups of files defined by a set of patterns.
            </summary>
            <remarks>
  <para>
    Filesets are groups of files defined by a set of patterns.
    Filesets can be specified in 2 ways:  named and unnamed.
  </para>
  <para>
    Named filesets are created by the <c>&lt;fileset&gt;</c> task, and so are defined
    at the project level.  They are a mechanism allowing multiple tasks to reference and modify the same group of files.
    This is conceptually the same as the creation of project level properties by the <c>&lt;property&gt;</c> task.
  </para>

  <para>
  An unnamed fileset, also known as a fileset "element", may exist for certain tasks
  other than the <c>&lt;fileset&gt;</c> task
  (e.g. "inputs" is a fileset element in the exec task).
  But an unnamed fileset is accessible only to the task that owns it.  It can't
  be accessed by an arbitrary task; a named fileset is needed for that.
  </para>

  <para>Filesets are rooted at a base directory; by default, this is the directory containing the NAnt build file. Pattern matching may be used to exclude or include specific contents and children of this directory; by default, everything but CVS-specific directories and files are included in the fileset.</para>

  <para>
  Attributes/parameters differ between named (task) and unnamed (element) filesets.
  </para>
  <para>
  <b>Speed tip:</b>
  <br />
  Avoiding directory wildcards (\** or \*\) in filesets will speed up
  NAnt.  This would entail explicit, known folder names in the fileset though.
  Also more script is needed since directory wildcards aren't used.
  </para>
  <h3>Table showing which attributes/parameters are supported</h3>
  <code>
    <![CDATA[
Attribute          FileSet Task (named)            FileSet Element (unnamed)
----------------------------------------------------------------------------
name                     Yes                             No
append                   Yes                             No
failonerror              Yes                             No
verbose                  Yes                             No
if                       Yes                             No
unless                   Yes                             No
              
defaultexcludes          No                              Yes
failonmissing            No                              Yes
              
basedir                  Yes                             Yes
fromfileset              Yes                             Yes
sort                     Yes                             Yes

]]>
  </code>

  <h3>Syntax for named filesets</h3>
  <code>
    <![CDATA[
<fileset
  name=""
  append=""
  basedir="" 
  fromfileset="" 
  sort="" 
  if=""
  unless=""
  failonerror=""
  verbose=""
  > 
</fileset>
]]>
  </code>

  <h3>Parameters for named filesets</h3>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>

    <item>
      <term>name</term>
      <term>Name of the fileset</term>
      <term>Yes</term>
    </item>
    <item>
      <term>append</term>
      <term>If append is true, the patterns specified by this task are added to the patterns contained in the named file set.  If append is false, the named file set contains the patterns specified by this task. Default is "false".
      </term>
      <term>No</term>
    </item>
    <item>
      <term>basedir</term>
      <term>The base of the directory tree defining the fileset.  Default is the directory containing the build file.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>Name of a fileset to include.</term>
      <term>No</term>
    </item>
    <item>
      <term>sort</term>
      <term>Indicates if the fileset contents should be sorted by file name or left in the order specified.  Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>if</term>
      <term>Execute only if condition is true.</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Execute only if condition is false.</term>
      <term>No</term>
    </item>
    <item>
      <term>failonerror</term>
      <term>Determines if task failure stops the build, or is just reported. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>verbose</term>
      <term>Task reports detailed build log messages.  Default is "false".</term>
      <term>No</term>
    </item>

  </list>


  <h3>Syntax for unnamed fileset element:  exec task example</h3>
  <code>
    <![CDATA[
<exec program="cmd.exe"

  <!-- inputs is a fileset element of exec task -->
  <inputs
    basedir="" 
    fromfileset="" 
    sort="" 
    defaultexcludes=""
    failonmissing=""
    > 
  /input>
</exec>
]]>
  </code>

  <h3>Parameters for unnamed fileset element</h3>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>

    <item>
      <term>basedir</term>
      <term>The base of the directory tree defining the fileset.  Default is the directory containing the build file.</term>
      <term>No</term>
    </item>
    <item>
      <term>defaultexcludes</term>
      <term>
        <para>If "false", default excludes are not used otherwise default excludes are used.  Default is "true"</para>
        <para>
          The following patterns are excluded from filesets by default:
          <list type="bullet">
            <item>**/CVS/*</item>
            <item>**/.cvsignore</item>
            <item>**/*~</item>
            <item>**/#*#</item>
            <item>**/.#*</item>
            <item>**/%*%</item>
            <item>**/SCCS</item>
            <item>**/SCCS/**</item>
            <item>**/vssver.scc</item>
          </list>
        </para>
      </term>
      <term>No</term>
    </item>
    <item>
      <term>failonmissing</term>
      <term>Indicates if a build error should be raised if an explictly included file does not exist.  Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>Name of a fileset to include.</term>
      <term>No</term>
    </item>
    <item>
      <term>sort</term>
      <term>Indicates if the fileset contents should be sorted by file name or left in the order specified.  Default is "false".</term>
      <term>No</term>
    </item>

  </list>

  <h3>Nested Elements for both named and unnamed filesets</h3>

  <h4>&lt;group&gt;</h4>
  <para>Groups help you organize related files into groups that can be conditionally included or excluded using if/unless attributes.  Note that groups can be nested.  See below for an example.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>if</term>
      <term>If true then the task will be executed; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the task will be executed; otherwise skipped.  Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>asis</term>
      <term>If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>force</term>
      <term>If true the file name will be added to the fileset regardless if it is already included. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>optionset</term>
      <term>The name of an optionset to associate with this group of files.</term>
      <term>No</term>
    </item>
  </list>

  <h4>&lt;includes&gt;</h4>
  <para>Defines a file pattern to be included in the fileset.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>name</term>
      <term>The filename or pattern used for file inclusion.  Default specifies no file.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>
        The name of a fileset defined by the <c>&lt;fileset&gt;</c> task.  This fileset will be used for file inclusion.  Default is empty.
      </term>
      <term>No</term>
    </item>
    <item>
      <term>optionset</term>
      <term>The name of an optionset to associate with this set of includes.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfile</term>
      <term>The name of a file containing a newline delimited set of files/patterns to include.</term>
      <term>No</term>
    </item>
    <item>
      <term>asis</term>
      <term>If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>force</term>
      <term>If true a the file name will be added to the fileset regardless if it is already included. Default is "false".</term>
      <term>No</term>
    </item>
    <item>
      <term>if</term>
      <term>If true then the task will be executed; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the task will be executed; otherwise skipped. Default is "false".</term>
      <term>No</term>
    </item>
  </list>

  <h4>&lt;excludes&gt;</h4>
  <para>Defines a file pattern of files to be excluded from the fileset.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>name</term>
      <term>The patterns used for file exclusion.  Default specifies no file.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfileset</term>
      <term>The name of a fileset defined by the &lt;fileset&gt; task.  This fileset will be used for file exclusion.  Default is empty.</term>
      <term>No</term>
    </item>
    <item>
      <term>optionset</term>
      <term>The name of an optionset to associate with this set of excludes.</term>
      <term>No</term>
    </item>
    <item>
      <term>fromfile</term>
      <term>The name of a file containing a newline delimited set of files/patterns to exclude.</term>
      <term>No</term>
    </item>
    <item>
      <term>if</term>
      <term>If true then the task will be executed; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the task will be executed; otherwise skipped. Default is "false".</term>
      <term>No</term>
    </item>
  </list>

  <para type="point">
    <b>Note:</b> Multiple <c>includes</c> and <c>excludes</c>
    elements can be used to specify the fileset.
    The fileset will be constructed by including all the <c>includes</c> elements,
    then excluding all the <c>excludes</c> elements without considering statement order.
  </para>

  <para type="point">
    <b>Note:</b> Preceding and trailing spaces will be trimmed off from the name attribute of
    &lt;fileset&gt;.
  </para>


  <h3>Examples: named filesets</h3>
  <para>
    <b>Specifying a fileset with all the files in the base directory.</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="*.*"/> 
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset using an absolute path:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="/packages/ToUpper/2.0.0/lib/ToUpper.lib" asis='true' /> 
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset using multiple patterns:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="*.c"/> 
    <includes name="*.cpp"/> 
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset with all the files in the current folder except one:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <includes name="*.*"/> 
    <excludes name="error.log"/>
</fileset>
]]>
  </code>

  <para>
    <b>Specifying a fileset with groups:</b>
  </para>
  <code>
    <![CDATA[
<fileset>
    <group if="${platform} == win">
        <includes name="*.*"/>
    </group>
    <excludes name="error.log"/>
</fileset>
]]>
  </code>
  <para>
    <b>
      Specifying a named fileset named <i>sourcedirs</i>:
    </b>
  </para>
  <code>
    <![CDATA[
<fileset name="sourcedirs">
    <group if="${platform} == pc-vc7">
        <includes name="sources/pc-vc7/**"/>
    </group>
    <excludes name="*~"/>
    <excludes name="*.bak"/>
</fileset>
]]>
  </code>


  <para>
    <b>Specifying a fileset from a file:</b>
  </para>
  <code>
    <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
  <fileset name='test'>
    <includes fromfile='files.txt' />
  </fileset>

  <fail unless='@{FileSetCount("test")} == 2' 
    message='FileSet fromfile attribute failed.' />
</project>
]]>
  </code>
  <h6>files.txt for the above example:</h6>
  <code>
    <![CDATA[
01.cpp
02.cpp
]]>
  </code>


  <para>
    <b>Creates a named fileset which can be referenced by other tasks.</b>
  </para>
  <code>
    <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- first create some files to include in the fileset -->
    <echo file="foo.txt">foo file</echo>
    <echo file="bar.txt">bar file</echo>
    <echo file="hack.txt">hack file</echo>

    <!-- now create the fileset to include the just created files -->
    <fileset name="sources">
        <includes name="*.txt"/>
        <excludes name="hack.txt"/>
    </fileset>
</project>
]]>
  </code>


  <para>
    <b>Creates a named fileset using named groups to help organize the files a conditionally include groups of files.</b>
  </para>
  <code>
    <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- first create some files to include in the fileset -->
    <echo file="good.txt">A temp file</echo>
    <echo file="fast.txt">A temp file</echo>
    <echo file="hack.txt">A temp file</echo>
    
    <property name="platform" value="win"/>
    <property name="debug" value="true"/>

    <!-- now create the fileset to include the just created files -->
    <fileset name="sources">
        <!-- include these files in the 'debug' config. -->
        <group if="${platform} == win">
            <includes name="fast.txt"/>
            <!-- groups can be nested inside of each other -->
            <group if="${debug}">
                <includes name="hack.txt"/>
            </group>
        </group>
        <includes name="good.txt"/>
    </fileset>
    <fail message="fileset 'sources' should have had 3 files but instead had @{FileSetCount('sources')}." unless="@{FileSetCount('sources')} == 3"/>
</project>
]]>
  </code>

  <h2>Fileset Patterns</h2>
  <para>The patterns used for file inclusion and exclusion look like the patterns used in DOS and UNIX:</para>

  <para>
    <c>*</c> matches zero or more characters, <c>?</c> matches one character.
  </para>

  <para>
    <c>*.cs</c> matches <c>.cs</c>, <c>x.cs</c> and <c>FooBar.cs</c>, but not <c>FooBar.xml</c> (does not end with <c>.cs</c>).
  </para>

  <para>
    <c>?.cs</c>  matches <c>x.cs</c>, <c>A.cs</c>, but not <c>.cs</c> or <c>xyz.cs</c> (neither have one character before <c>.cs</c>).
  </para>

  <para>
    Combinations of <c>*</c>'s and <c>?</c>'s are allowed.
  </para>

  <para>
    Matching is done per-directory. This means that the first directory in the pattern is matched against the first directory in the path. Then the second directory in the pattern is matched against the second directory in the path, and so on. For example, when we have the pattern <c>/?abc/*/*.cs</c> and the path <c>/xabc/foobar/test.cs</c>, the first <c>?abc</c> is matched with <c>xabc</c>, then <c>*</c> is matched with <c>foobar</c>, and finally <c>*.cs</c> is matched with <c>test.cs</c>. They all match, so the path matches the pattern.
  </para>

  <para>
    To make things a bit more flexible, we add one extra feature, which makes it possible to match multiple directory levels. This can be used to match a complete directory tree, or a file anywhere in the directory tree. To do this, ** must be used as the name of a directory. When <c>**</c> is used as the name of a directory in the pattern, it matches zero or more directories.
  </para>

  <h3>Examples</h3>

  <list type="table">
    <listheader>
      <term>Pattern</term>
      <description>Match</description>
    </listheader>
    <item>
      <term>/test/**</term>
      <description>
        <para>
          Matches all files/directories under <c>/test/</c>, such as <c>/test/x.cs</c>, or <c>/test/foo/bar/xyz.html</c>, but not <c>/xyz.xml</c>.
        </para>
      </description>
    </item>
    <item>
      <term>/test/</term>
      <description>
        <para>
          Just like <c>test/**</c>.  Matches all files/directories under <c>/test/</c>, such as <c>/test/x.cs</c>, or <c>/test/foo/bar/xyz.html</c>, but not <c>/xyz.xml</c>.
        </para>
      </description>
    </item>
    <item>
      <term>**/CVS/*</term>
      <description>
        <para>Matches all files in CVS directories that can be located anywhere in the directory tree.  Matches:</para>
        <list type="bullet">
          <item>
            <c>CVS/Repository</c>
          </item>
          <item>
            <c>org/apache/CVS/Entries</c>
          </item>
          <item>
            <c>org/apache/jakarta/tools/ant/CVS/Entries</c>
          </item>
        </list>
        <para>But not:</para>
        <list type="bullet">
          <item>
            <c>org/apache/CVS/foo/bar/Entries</c>
          </item>
        </list>
        <para>
          because <c>foo/bar/</c> part does not match.
        </para>
      </description>
    </item>
    <item>
      <term>org/apache/jakarta/**</term>
      <description>
        <para>
          Matches all files in the <c>org/apache/jakarta</c> directory tree.  Matches:
        </para>
        <list type="bullet">
          <item>
            <c>org/apache/jakarta/tools/ant/docs/index.html</c>
          </item>
          <item>
            <c>org/apache/jakarta/test.xml</c>
          </item>
        </list>
        <para>But not:</para>
        <list type="bullet">
          <item>
            <c>org/apache/xyz.java</c>
          </item>
        </list>
        <para>
          because the <c>jakarta/</c> part is missing.
        </para>
      </description>
    </item>
    <item>
      <term>org/apache/**/CVS/*</term>
      <description>
        <para>Matches all files in CVS directories that are located anywhere in the directory tree under org/apache.  Matches:</para>
        <list type="bullet">
          <item>
            <c>org/apache/CVS/Entries</c>
          </item>
          <item>
            <c>org/apache/jakarta/tools/ant/CVS/Entries</c>
          </item>
        </list>
        <para>But not:</para>
        <list type="bullet">
          <item>
            <c>org/apache/CVS/foo/bar/Entries</c>
          </item>
        </list>
        <para>
          <c>foo/bar/</c> part does not match.
        </para>
      </description>
    </item>
    <item>
      <term>**/test/**</term>
      <description>
        <para>
          Matches all files that have a <c>test</c> element in their path, including <c>test</c> as a filename.
        </para>
      </description>
    </item>
  </list>
</remarks>
            
            <example>
<para>Creates a named fileset which can be referenced by other tasks.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- first create some files to include in the file set -->
    <echo file="foo.txt">foo file</echo>
    <echo file="bar.txt">bar file</echo>
    <echo file="hack.txt">hack file</echo>

    <!-- now create the file set to include the just created files -->
    <fileset name="sources">
        <includes name="*.txt"/>
        <excludes name="hack.txt"/>
    </fileset>
</project>
]]>
</code>
</example>
            <example>
<para>Creates a named fileset using named groups to help organize the files a conditionally include groups of files.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- first create some files to include in the file set -->
    <echo file="good.txt">A temp file</echo>
    <echo file="fast.txt">A temp file</echo>
    <echo file="hack.txt">A temp file</echo>
    
    <property name="platform" value="win"/>
    <property name="debug" value="true"/>

    <!-- now create the file set to include the just created files -->
    <fileset name="sources">
        <!-- include these files in the 'debug' config. -->
        <group if="${platform} == win">
            <includes name="fast.txt"/>
            <!-- groups can be nested inside of each other -->
            <group if="${debug}">
                <includes name="hack.txt"/>
            </group>
        </group>
        <includes name="good.txt"/>
    </fileset>
    <fail message="File set 'sources' should have had 3 files but instead had @{FileSetCount('sources')}." unless="@{FileSetCount('sources')} == 3"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.FileSetName">
            <summary>Name for fileset. Preceding and trailing spaces will be trimmed off.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.Append">
            <summary>If append is true, the patterns specified by
            this task are added to the patterns contained in the
            named file set.  If append is false, the named file set contains
            the patterns specified by this task.
            Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.BaseDirectory">
            <summary>The base directory of the file set.  Default is the directory where the
            build file is located.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.FromFileSetName">
            <summary>The name of a file set to include.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.Sort">
            <summary>Sort the file set by filename. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.FailOnMissing">
            <summary>Indicates if a build error should be raised if an explicitly included file does not exist.  Default is true.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyAsis">
            <summary>
            If true then the file name will be added to the fileset without pattern matching or checking if the file exists. Default is "false".
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyOptionset">
            <summary>
            The name of an optionset to associate with this set of excludes.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyForce">
            <summary>
            If true a the file name will be added to the fileset regardless if it is already included. Default is "false".
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyDepends">
            <summary>
            <b>Invalid element in Framework</b>. Added to prevent existing scripts failing.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FileSetTask.DummyDefaultexcludes">
            <summary>
            If "false", default excludes are not used otherwise default excludes are used. Default is "true"
            <list type="bullet">
               <item>**/CVS/*</item>
               <item>**/.cvsignore</item>
               <item>**/*~</item>
               <item>**/#*#</item>
               <item>**/.#*</item>
               <item>**/%*%</item>
               <item>**/SCCS</item>
               <item>**/SCCS/**</item>
               <item>**/vssver.scc</item>
            </list>
            </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.FileSetTask.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly initialize</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ForEachTask">
            <summary>Iterates over a set of items.</summary>
            <remarks>
              <para>Can iterate over files in directory, lines in a file, etc.</para>
              <para>
              The <c>property</c> value is set for each item in turn as the <c>foreach</c> task 
              iterates over the given set of items. Any previously existing value in <c>property</c> 
              is stored before the block of tasks specified in the <c>foreach</c> task are invoked, 
              and restored when the block of tasks completes. 
              </para>
              <para>This storage ensures that the <c>property</c> will have the same value it had 
              before the <c>foreach</c> task was invoked once the <c>foreach</c> task completes.
              </para>
              <para>
              Valid foreach items are "File", "Folder", "Directory", "String", "Line", "FileSet",
              and "OptionSet".
              </para>
              <para>
              File - return each file name in an iterated directory<br />
              Folder - return each folder in an iterated directory<br />
              Directory - return each directory in an iterated directory<br />
              String - return each splitted string from a long string with user specified delimiter in delim.<br />
              Line - return each line in a text file.<br />
              FileSet - return each file name in a FileSet.<br />
              OptionSet - return each option in an OptionSet.<br />
              </para>
              <para>
              NOTE: When iterating over strings and lines extra leading and trailing whitespace
              characters will be trimmed and blank lines will be ignored.
              </para>
              <para>
              NOTE: When iterating over option sets the property name specified is used for a
              property prefix to the actual option name and values.  The name of option is available
              in the <c>&lt;property&gt;.name</c> property, the value in the <c>&lt;property&gt;.value</c>
              property.
              </para>
              <para>
              NOTE: When iterating over FileSet the BaseDirectory associated with the FileItem (see 'fileset' <c>&lt;include&gt;.name</c> help) is available
              in the <c>&lt;property&gt;.basedir</c> property.
              property.
              </para>
            </remarks>
            <example>
  <para>Loops over the files in C:\</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="File" in="c:\" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loop over all *.txt files in C:\</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="File" in="c:\*.txt" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Iterates over the directories in the current directory.</para>
  <code>
<![CDATA[
<project default="doloop">
    <target name="doloop">
        <foreach item="Directory" in="." property="path">
            <echo message="path='${path}' name='@{PathGetFileName('${path}')}"/>
        </foreach>
    </target>    
</project>
]]>
  </code>
</example>
            <example>
  <para>Iterate over all pc-* directories in the current directory.</para>
  <code>
<![CDATA[
<project default="doloop">
    <target name="doloop">
        <foreach item="Directory" in="pc-*" property="path">
            <echo message="${path}"/>
        </foreach>
    </target>    
</project>
]]>
  </code>
</example>
            <example>
  <para>Loops over a list</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="String" in="1 2 3" delim=" " property="count">
                <echo message="${count}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loops over a fileset</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <fileset name="myfileset">
            <includes name="*" />
        </fileset>
        <target name="doloop">
            <foreach item="FileSet" in="myfileset" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>    
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loops over an optionset</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <optionset name="SharedLibrary">
            <option name="cc.options" value="-c -nologo"/>
            <option name="cc.program=" value="cl.exe"/>
        </optionset>
        <target name="doloop">
            <foreach item="OptionSet" in="SharedLibrary" property="option">
                <echo message="${option.name} = ${option.value}"/>
            </foreach>
        </target>    
    </project>
    ]]>
  </code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Property">
            <summary>The property name that holds the current iterated item value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.ItemType">
            <summary>
            The type of iteration that should be done. Valid values are: 
            File, Directory, String, Line, FileSet, and OptionSet.
            When choosing the Line option, you specify a file and the task
            iterates over all the lines in the text file.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Source">
            <summary>
            The source of the iteration.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Delimiter">
            <summary>
            The delimiter string array. Default is whitespace.  
            Multiple characters are allowed.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ForEachTask.Local">
            <summary>
            Indicates if the property that holds the iterated value is going to be defined in a local context and thus, it will be restricted to a local scope . 
            Default is false.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FuncDefTask">
            <summary>Loads functions from a specified assembly.</summary>
            <remarks>
            <para>
            NAnt can only use .NET assemblies; other types of files which
            end in .dll won't work.
            </para>
            </remarks>
            <example>
<para>Include the functions in an assembly.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="init">
        <funcdef assembly="MyCustomFunctions.dll"/>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.FuncDefTask.AssemblyFileName">
            <summary>File name of the assembly containing the NAnt functions.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.FuncDefTask.Override">
            <summary>
            Override function(s) with the same name.
            Default is false. When override is 'false' &lt;funcdef&gt; will fail on duplicate function names.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.GetTask">
            <summary>Get a particular file from a URI source.</summary>
            <remarks>
              <para>Options include verbose reporting, timestamp based fetches and controlling actions on failures.</para>
              <para>Currently, only HTTP and UNC (Windows shared directory names of the form <c>//&lt;server&gt;/&lt;directory&gt;</c>) protocols are supported. FTP support may be added when more pluggable protocols are added to the System.Net assembly.</para>
              <para>The <c>useTimeStamp</c> option enables you to control downloads so that the remote file is only fetched if newer than the local copy. If there is no local copy, the download always takes place. When a file is downloaded, the timestamp of the downloaded file is set to the remote timestamp.</para>
              <note>This timestamp facility only works on downloads using the HTTP protocol.</note>
            </remarks>
            <example>
<para>Gets the index page of the NAnt home page, and stores it in the file help/index.html.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="fetch" description="Downloads the NAnt home page">
        <get src="http://nant.sourceforge.org/" dest="index.html"/>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.Source">
            <summary>The URL from which to retrieve a file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.Destination">
            <summary>The file where to store the retrieved file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.Proxy">
            <summary>If inside a firewall, proxy server/port information
            Format: {proxy server name}:{port number}
            Example: proxy.mycompany.com:8080 </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.ignoreErrors">
            <summary>Log errors but don't treat as fatal. ("true"/"false"). Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.useTimeStamp">
            <summary>Conditionally download a file based on the timestamp of the local copy. HTTP only. ("true"/"false"). Default is "false".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.GetTask.FileSet">
            <summary>FileSets are used to select files to get.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.GetTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">XML node used to define this task instance.</param>
        </member>
        <member name="M:NAnt.Core.Tasks.GetTask.ExecuteTask">
            <summary>This is where the work is done </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.GetTask.TouchFile(System.String,System.DateTime)">
            <summary>Set the timestamp of a named file to a specified time.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.IncludeTask">
            <summary>Include an build file.</summary>
            <remarks>
              <para>This task is used to break your build file into smaller chunks.  
              You can load a partial build file and have it included into the main 
              build file.</para>
              <note>Any global (project level) tasks in the included build file are 
              executed when this task is executed.  Tasks in target elements of the 
              included build file are only executed if that target is executed.</note>
              <note>The project element attributes in an included build
              file are ignored.</note>
              <note>If this task is used within a target, the include included file
              should not have any targets (or include files with targets).  Doing so 
              would compromise NAnt's knowledge of available targets.</note>
            </remarks>
            <example>
<para>Include the build script in the <c>other.xml</c> file.</para>
<code file="Default.build">
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <include file="Component.xml"/>
    <fail message="Included script didn't execute" unless="@{FileExists('out.txt')}"/>
</project>
]]>
</code>
<para>Where <c>Component.xml</c> contains:</para>
<code file="Component.xml">
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo file="out.txt" message="The component build file."/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.IncludeTask.FileName">
            <summary>Build file to include.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.IncludeTask.IgnoreMissing">
            <summary>Ignore if file does not exist</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.InternalQuickDependency">
            <summary>
            This is a simpler version of the dependent task that simply loads a packages initialize.xml and sets up package properties.
            This can be used to quickly load things like sdk packages without all of the overhead of ciruclar dependency checking.
            It is currently only intended for internal use in cases where we are certain that the extra features are not needed.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.InternalQuickDependency.PackageName">
            <summary>The name of the package to depend on.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.InternalQuickDependency.InitializeScript">
            <summary>If false the execution of the Initialize.xml script will be suppressed. Default is true.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.MailTask">
            <summary>A task to send email.</summary>
            <remarks>
            Text and text files to include in the message body may be specified as well as binary attachments.
            </remarks>
            <example>
<para>Sends an email from nant@sourceforge.net to three recipients with a subject about the 
attachments.  The body of the message will be the combined contents of body1.txt through 
body4.txt.  The body1.txt through body3.txt files will also be included as attachments.  
The message will be sent using the smtpserver.anywhere.com SMTP server.</para>
<code><![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="sendmail" description="Send email">
        <mail 
            from="nant@sourceforge.net" 
            tolist="recipient1@sourceforge.net" 
            cclist="recipient2@sourceforge.net" 
            bcclist="recipient3@sourceforge.net" 
            subject="Msg 7: With attachments" 
            files="body1.txt,body2.txt;body3.txt,body4.txt" 
            attachments="body1.txt,body2.txt;,body3.txt" 
            mailhost="smtpserver.anywhere.com"
        />
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.From">
            <summary>Email address of sender </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.ToList">
            <summary>Comma- or semicolon-separated list of recipient email addresses</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.CcList">
            <summary>Comma- or semicolon-separated list of CC: recipient email addresses </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.BccList">
            <summary> Comma- or semicolon-separated list of BCC: recipient email addresses</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Mailhost">
            <summary>Host name of mail server. Defaults to "localhost"</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Message">
            <summary>Text to send in body of email message. At least one of the fields 'files' or 'message' must be provided.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Subject">
            <summary>Text to send in subject line of email message.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Format">
            <summary>Format of the message body. Valid values are "Html" or "Text".  Defaults to "Text".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Files">
            <summary>Name(s) of text files to send as part of body of the email message. 
            Multiple file names are comma- or semicolon-separated. At least one of the fields 'files' or 'message' must be provided.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Attachments">
            <summary>Name(s) of files to send as attachments to email message.
            Multiple file names are comma- or semicolon-separated.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.MailTask.Async">
            <summary>Sends the message asynchronously rather than waiting for the task to send the message before proceeding</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.MailTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">XML node used to define this task instance.</param>
        </member>
        <member name="M:NAnt.Core.Tasks.MailTask.ExecuteTask">
            <summary>
            This is where the work is done
            </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.MailTask.ReadFile(System.String)">
            <summary>
            Reads a text file and returns the contents
            in a string
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="T:NAnt.Core.Tasks.MkDirTask">
            <summary>Creates a directory path.</summary>
            <remarks>
            <para>
            A directory specified with an absolute pathname will be
            created, and any parent directories in the directory path which
            do not already exist will also be created.
            </para> <para>
            A directory specified with a relative pathname will be created 
            relative to the
            location of the build file.  Any directories in the relative
            directory path which do not already exist will be created.
            </para>
            </remarks>
            <example>
<para>Create the directory "build".</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="build"/>
    <fail unless="@{DirectoryExists('build')}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Create the directory tree "one/two/three".</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <mkdir dir="one/two/three"/>
    <fail unless="@{DirectoryExists('one/two/three')}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.MkDirTask.Dir">
            <summary>The directory to create.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.MoveTask">
            <summary>Moves a file or file set to a new location.</summary>
            <remarks>
              <para>Files are only moved if the source file is newer than the destination file, or if the destination file does not exist.  This applies to files matched by a file set as well as files specified individually.</para>
              <note>You can explicitly overwrite files with the overwrite attribute.</note>
              <para>File sets are used to select groups of files to move. To use a file set, the todir attribute must be set.</para>
            </remarks>
            <example>
<para>Move a single file.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo file="myfile.txt" message="A file to move."/>
    <move file="myfile.txt" tofile="mytarget.txt"/>
</project>
]]>
</code>
</example>
            <example>
  <para>Move a set of files.</para>
  <code>
  <![CDATA[
  <project default="MoveFiles">
     <target name="MoveFiles">
        <mkdir dir="C:\test"/>
        <move todir="C:\test">
            <fileset basedir=".">
                <includes name="*.txt"/>
            </fileset>
        </move>
     </target>
  </project>
  ]]>
  </code>
</example>
        </member>
        <member name="M:NAnt.Core.Tasks.MoveTask.DoFileOperations">
            <summary>
            Actually does the file (and possibly empty directory) moves.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.NamedLock">
            <summary>Allows wrapping of a group of tasks to be executed in a mutually exclusive way based on 'name' attribute.</summary>
            <remarks>
                <para>This task acts as a named mutex for a group of nested tasks.</para>
                <para>Make sure that name name value does not collide with namedlock names that can be defined in other packages.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.NamedLock.LockName">
            <summary>Unique name for the lock. All &lt;namedlock&gt; sections with same name are mutually exclusive
            Make sure that key string does not collide with names of &lt;namedlock&gt; that may be defined in other packages. 
            Using "package.[package name]." prefix is a good way to ensure unique values.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.NAntTask">
            <summary>Runs NAnt on a supplied build file.</summary>
            <remarks>
                <para>This task can be used to build subprojects which have their own full build files.  See the
                <see cref="T:NAnt.Core.Tasks.DependsTask"/> for a good example on how to build sub projects only once per build.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.OutProperty.OutPropertyName">
            <summary>Property name in which to store property from child invocation.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.OutProperty.ChildPropertyName">
            <summary>Name of property in child invocation to store in out-property-name.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.BuildFileName">
            <summary>The name of the *.build file to use.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.BuildPackage">
            <summary>The name of the package from which to use .build file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.DefaultTarget">
            <summary>The target to execute.  To specify more than one target separate targets with a space.  Targets are executed in order if possible.  Default to use target specified in the project's default attribute.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.OptionSetName">
            <summary>The name of an optionset containing a set of properties to be passed into the supplied build file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.IndentLevel">
            <summary>The log IndentLevel. Default is the current log IndentLevel + 1.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.GlobalPropertiesAction">
            <summary>
            Defines how global properties are set up in the dependent project. 
            Valid values are <b>propagate</b> and <b>initialize</b>. Default is 'propagate'.
            </summary>
            <remarks>
            <para>
            'propagate' means standard global properties propagation.
            </para>
            <para>
            when value is 'initialize' global properties in dependent project are set using values from masterconfig and NAnt command line
            the same way they are set at the start of NAnt process. Usual used in combination with 'start-new-build'
            </para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.NAntTask.StartNewBuild">
            <summary>
            Start new build graph in the dependent project. Default is 'false'
            </summary>
            <remarks>
            Normally dependent project is added to the current build graph. Setting 'start-new-build' 
            to true will create new build graph in dependent project. This is useful when NAnt task is used to invoke separate independent build.
            </remarks>
        </member>
        <member name="T:NAnt.Core.Tasks.OptionSetTask">
            <summary>Optionset is a dictionary containing [name, value] pairs called options.</summary>
            <remarks>
  <para>
    An optionset denotes a group of options or properties.
    Optionsets can be specified in 2 ways:  named and unnamed.
  </para>
  <para>
    A named optionset is created by the <c>&lt;optionset&gt;</c> task, and so are defined
    at the project level.  They are a mechanism allowing multiple tasks to reference and modify the same group of options.
    This is conceptually the same as the creation of project level properties by the <c>&lt;property&gt;</c> task.
  </para>
  <para>
    An unnamed optionset, also known as an optionset "element", may exist for certain tasks
    other than the <c>&lt;optionset&gt;</c> task
    (e.g. "env" is an optionset element in the exec task).
    But an unnamed optionset is accessible only to the task that owns it.  It can't
    be accessed by an arbitrary task; a named optionset is needed for that.
  </para>
  <para>
    Attributes/parameters differ between named (task) and unnamed (element) optionsets.
  </para>
  <h3>Table showing which attributes/parameters are supported</h3>
  <code>
    <![CDATA[
Attribute   optionset Task (named)	optionset Element (unnamed)
----------------------------------------------------------------------------
name            Yes                       No
append          Yes                       No
failonerror     Yes                       No
verbose         Yes                       No
if              Yes                       No
unless          Yes                       No
                                           
fromoptionset   Yes                       Yes

]]>
  </code>

  <h3>Syntax for named optionsets</h3>
  <code>
    <![CDATA[
<optionset
  name=""
  append=""
  fromoptionset="" 
  if=""
  unless=""
  failonerror=""
  verbose=""
  > 
</optionset>
]]>
  </code>

  <h3>Parameters for named optionsets</h3>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>name</term>
      <term>The name of the option set.</term>
      <term>Yes</term>
    </item>
    <item>
      <term>append</term>
      <term>If append is true, the options specified by this option set task are added to the options contained in the named option set.  Options that already exist are replaced. If append is false, the named option set contains the options  specified by this option set task.  Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>fromoptionset</term>
      <term>The name of an optionset to include.</term>
      <term>No</term>
    </item>
    <item>
      <term>if</term>
      <term>Execute only if condition is true.</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Execute only if condition is false.</term>
      <term>No</term>
    </item>
    <item>
      <term>failonerror</term>
      <term>Determines if task failure stops the build, or is just reported. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>verbose</term>
      <term>Task reports detailed build log messages.  Default is "false".</term>
      <term>No</term>
    </item>
  </list>


  <h3>Syntax for unnamed optionset element:  exec task example</h3>
  <code>
    <![CDATA[
<exec program="cmd.exe"

  <!-- env is an optionset element of exec task -->
  <env
    fromoptionset="" 
    > 
  /env>
</exec>
]]>
  </code>

  <h3>Parameters for unnamed optionset element</h3>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>fromoptionset</term>
      <term>The name of an existing optionset to initialize from.  Default is null.</term>
      <term>No</term>
    </item>
  </list>

  <h3>Nested elements for both named and unnamed optionsets:</h3>

  <h4>&lt;option&gt;</h4>
  <para>Specifies an option in the optionset.</para>
  <list type="table">
    <listheader>
      <term>Attribute</term>
      <term>Description</term>
      <term>Must Provide</term>
    </listheader>
    <item>
      <term>if</term>
      <term>If true then the option will be added; otherwise skipped. Default is "true".</term>
      <term>No</term>
    </item>
    <item>
      <term>unless</term>
      <term>Opposite of if. If false then the option will be added; otherwise skipped.  Default is "false".</term>
      <term>No</term>
    </item>

    <item>
      <term>name</term>
      <term>The name of the option.</term>
      <term>Yes</term>
    </item>
    <item>
      <term>value</term>
      <term>
        The value of the option.  You can specify the current option value using the special <c>${option.value}</c> property.  If the option has not been defined this property will expand to an empty string.
      </term>
      <term>Yes</term>
    </item>
  </list>

  <h3>Examples of named optionsets:</h3>
  <para>Specify an optionset with 2 options.</para>
  <code>
    <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name="DefaultSettings">
        <option name="foo" value="bar"/>
        <option name="nant" value="rules"/>
    </optionset>
</project>
]]>
  </code>
  <para>Specifies an optionset based on an exsting optionset and then changes the value of the second option.  Also shows how to get the value from an optionset using a function.</para>
  <code>
    <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name="DefaultSettings">
        <option name="foo" value="bar"/>
        <option name="nant" value="rules"/>
    </optionset>
    <optionset name="Settings" fromoptionset="DefaultSettings">
        <option name="nant" value="${option.value} the world"/>
    </optionset>
    <echo message="nant @{OptionSetGetValue('Settings', 'nant')}"/>
</project>
]]>
  </code>
  <code>
    <![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name="settings">
        <option name="clean" value="exclude" />
    </optionset>

    <optionset name="defaults">
        <option name="build" value="include" />
        <option name="buildall" value="include" />
        <option name="clean" value="include" />
    </optionset>

    <echo message="settings (before):" />
    <foreach item="OptionSet" in="settings" property="option">
        <echo message="'${option.name} = '${option.value}'" />
    </foreach>
    <echo message="" />

    <!-- <optionset> used ${option.value} internally, which conflicts with the option property in <foreach> -->
    <foreach item="OptionSet" in="defaults" property="option">
        <do unless="@{OptionSetOptionExists('settings', '${option.name}')}">
            <echo message="   appending: '${option.name} = '${option.value}'" />
            <optionset name="settings" append="true">
                <option name="${option.name}" value="${option.value}" />
            </optionset>
        </do>
    </foreach>
    <echo message="" />

    <echo message="settings (after):" />
    <foreach item="OptionSet" in="settings" property="option">
        <echo message="'${option.name} = '${option.value}'" />
    </foreach>
</project>
]]>
  </code>
</remarks>
            <example>
<para>Creates a named option set which can be used by other tasks.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <optionset name="SharedLibrary">
        <option name="cc.options" value="-c -nologo"/>
        <option name="cc.program=" value="cl.exe"/>
    </optionset>
    <foreach item="OptionSet" in="SharedLibrary" property="option">
        <echo message="${option.name} = ${option.value}"/>
    </foreach>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.OptionSetTask.OptionSetName">
            <summary>The name of the option set.</summary>        
        </member>
        <member name="P:NAnt.Core.Tasks.OptionSetTask.Append">
            <summary>If append is true, the options specified by
            this option set task are added to the options contained in the
            named option set.  Options that already exist are replaced.
            If append is false, the named option set contains the options 
            specified by this option set task.
            Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.OptionSetTask.FromOptionSetName">
            <summary>The name of a file set to include.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.OptionSetTask.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly initialize</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ParallelDoTask">
            <summary>Executes nested tasks in parallel. Only immediate nested tasks are executed in parallel.
            <para>
              <b>NOTE.</b> Make sure there are no race conditions, properties with same names, etc each group.
            </para>
            <para>
              <b>NOTE.</b> local properties are local to each thread. Normal NAnt properties are shared between threads.
            </para>
            </summary>
            <example>
<para>Load Nant scripts in parallel.</para>
  <code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
  <parallel.do>
    <include file="file1.xml" />
    <include file="file2.xml" />
  </parallel.do>
</project>
]]>
</code>
</example>
            <example>
  <para>Executes three groups of tasks in parallel.</para>
  <code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
  <parallel.do>
     <do>
         <echo>Started test1.exe</echo>
         <exec program="test1.exe"/>
         <echo>Finished test1.exe</echo>
     </do>
     <do>
         <echo>Started test2.exe</echo>
         <exec program="test2.exe"/>
         <echo>Finished test2.exe</echo>
     </do>
     <do>
         <echo>Started test3.exe</echo>
         <exec program="test3.exe"/>
         <echo>Finished test32.exe</echo>
     </do>
  </parallel.do>
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.ParallelForEachTask">
            <summary>Iterates over a set of items in parallel. Similar to &lt;foreach&gt; task.</summary>
            
            <remarks>
              <para>Can iterate over files in directory, lines in a file, etc.</para>
              <para>
              The <c>property</c> value is set for each item in turn as the <c>foreach</c> task 
              iterates over the given set of items. Any previously existing value in <c>property</c> 
              is stored before the block of tasks specified in the <c>foreach</c> task are invoked, 
              and restored when the block of tasks completes. 
              </para>
              <para>This storage ensures that the <c>property</c> will have the same value it had 
              before the <c>foreach</c> task was invoked once the <c>foreach</c> task completes.
              </para>
              <para>
              Valid foreach items are "File", "Folder", "Directory", "String", "Line", "FileSet",
              and "OptionSet".
              </para>
              <para>
              File - return each file name in an iterated directory<br />
              Folder - return each folder in an iterated directory<br />
              Directory - return each directory in an iterated directory<br />
              String - return each splitted string from a long string with user specified delimiter in delim.<br />
              Line - return each line in a text file.<br />
              FileSet - return each file name in a FileSet.<br />
              OptionSet - return each option in an OptionSet.<br />
              </para>
              <para>
              NOTE: When iterating over strings and lines extra leading and trailing whitespace
              characters will be trimmed and blank lines will be ignored.
              </para>
              <para>
              NOTE: When iterating over option sets the property name specified is used for a
              property prefix to the actual option name and values.  The name of option is available
              in the <c>&lt;property&gt;.name</c> property, the value in the <c>&lt;property&gt;.value</c>
              property.
              </para>
            </remarks>
            <example>
  <para>Loops over the files in C:\</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="File" in="c:\" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loop over all *.txt files in C:\</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="File" in="c:\*.txt" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Iterates over the directories in the current directory.</para>
  <code>
<![CDATA[
<project default="doloop">
    <target name="doloop">
        <foreach item="Directory" in="." property="path">
            <echo message="path='${path}' name='@{PathGetFileName('${path}')}"/>
        </foreach>
    </target>    
</project>
]]>
  </code>
</example>
            <example>
  <para>Iterate over all pc-* directories in the current directory.</para>
  <code>
<![CDATA[
<project default="doloop">
    <target name="doloop">
        <foreach item="Directory" in="pc-*" property="path">
            <echo message="${path}"/>
        </foreach>
    </target>    
</project>
]]>
  </code>
</example>
            <example>
  <para>Loops over a list</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <target name="doloop">
            <foreach item="String" in="1 2 3" delim=" " property="count">
                <echo message="${count}"/>
            </foreach>
        </target>
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loops over a fileset</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <fileset name="myfileset">
            <includes name="*" />
        </fileset>
        <target name="doloop">
            <foreach item="FileSet" in="myfileset" property="filename">
                <echo message="${filename}"/>
            </foreach>
        </target>    
    </project>
    ]]>
  </code>
</example>
            <example>
  <para>Loops over an optionset</para>
  <code>
    <![CDATA[
    <project default="doloop">
        <optionset name="SharedLibrary">
            <option name="cc.options" value="-c -nologo"/>
            <option name="cc.program=" value="cl.exe"/>
        </optionset>
        <target name="doloop">
            <foreach item="OptionSet" in="SharedLibrary" property="option">
                <echo message="${option.name} = ${option.value}"/>
            </foreach>
        </target>    
    </project>
    ]]>
  </code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.Property">
            <summary>The property name that holds the current iterated item value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.ItemType">
            <summary>
            The type of iteration that should be done. Valid values are: 
            File, Directory, String, Line, FileSet, and OptionSet.
            When choosing the Line option, you specify a file and the task
            iterates over all the lines in the text file.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.Source">
            <summary>
            The source of the iteration.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ParallelForEachTask.Delimiter">
            <summary>
            The delimiter string array. Default is whitespace.  
            Multiple characters are allowed.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.PropertyTask">
            <summary>Sets a property in the current project.</summary>
            <remarks>
              <para>NAnt uses a number of predefined properties that start with nant.* or [taskname].*.  In general you should place properties into a namespace such as global.* or ProjectName.*.</para>
              <para>If the property name is invalid a build error will occur.</para>
              <para>The following regular expression is used to test for valid properties: <c>^([\w-\.]+)$</c>.  In English this means only A-Z, a-z, 0-9, '_', '-', and '.' characters are allowed.  The leading character should be a letter for readability.</para>
              <para>The task declares the <c>${property.value}</c> property within the task itself.  The <c>${property.value}</c> property is equal to the previous value of the property if already defined, otherwise it is equal to an empty string.  By using the <c>${property.value}</c> property, user can easily insert/append to an existing property.</para>
              <para><b>NOTE:</b> If you are using this property task inside a &lt;parallel.do&gt; task or &lt;parallel.foreach&gt; task, please be aware that this property task is not thread safe.  So if you are using this task inside either of the parallel blocks, you will need to make sure that they have unique names inside each block to avoid conflict.</para>
            </remarks>
            <example>
<para>Define a <c>debug</c> property with the value <c>true</c> and use the 
user-defined <c>debug</c> property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="debug" value="true"/>
    <property name="trace" value="${debug}"/>
    <fail unless="${trace} == ${debug}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Define a <c>copyright</c> property using a nested property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="copyright">Copyright (C) 2003 Gerry Shaw</property>
    <fail if="@{StrIndexOf('${copyright}', '2003')} == -1"/>
</project>
]]>
</code>
</example>
            <example>
<para>Shows how to use the <c>${property.value}</c> to append to a property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="test">bar;${property.value}</property>
    <property name="test" value="foo;${property.value}"/>
    <fail unless="${test} == foo;bar;"/>
</project>
]]>
</code>
</example>
            <example>
<para>Shows how to use the <c>fromfile</c> attribute to read from a file into a property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <echo file="test.txt">Hello World!</echo>
    <property name="test" fromfile="test.txt" />
    <fail unless="'${test}' == 'Hello World!'"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.PropertyName">
            <summary>The name of the property to set.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.Value">
            <summary>The value of the property. If not specified, the default will be no value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.FileName">
            <summary>The path to a file from which content is read into the property value.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.ReadOnly">
            <summary>Indicates if the property should be read-only.  Read only properties can never be changed.  Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.Deferred">
            <summary>Indicates if the property's value will expand encapsulated properties' value at definition time or at use time. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.PropertyTask.Local">
            <summary>Indicates if the property is going to be defined in a local context and thus, it will be restricted to a local scope. Default is false.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.PropertyTask.Initialize(System.Xml.XmlNode)">
            <summary>Optimization. Directly initialize</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.PropertyTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">XML node used to define this task instance.</param>
        </member>
        <member name="T:NAnt.Core.Tasks.RecordTask">
            <summary>A task that records the build's output to a property or file.</summary>
            <remarks>
            This task allows you to record the build's output, or parts of it to 
            a named property or file.
            </remarks>
            <example>
<para>Simple example recording build log to a named property.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <record property="log">
        <echo message="This gets saved in the log property"/>
    </record>
    <fail 
        unless="@{StrIndexOf('${log}', 'This gets saved in the log property')} != 0" 
        message="Log wasn't saved: ${log}"/>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.RecordTask.PropertyName">
            <summary>Name of the property to record output.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RecordTask.Silent">
            <summary>If set to true, no other output except of property is produced. Console or other logs are suppressed</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RecordTask.FileName">
            <summary>The name of a file to write the output to</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.RegexMatchTask">
            <summary>A task that execute the RegularExpression's Match function.
            <para>
              <b>NOTE</b> This task is new in Framework version 3.28.00.  So if you use this task in your build script, 
              you need to make sure that your project don't need to be build by older version of Framework.
            </para>
            </summary>
            <remarks>
            This task executes the System.Text.RegularExpressions.Regex.Match .Net function for 
            the given input and pattern.  The match result will be sent to the properties provided.
            The first property provided will always store the match result.  If a match is not
            found, the properties provided will be set to empty string.
            </remarks>
            <example>
<para>Simple example using RegExMatch task.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="TestString">
        Ubuntu clang version 3.4-1ubuntu3 (tags/RELEASE_34/final) (based on LLVM 3.4)
        Target: x86_64-pc-linux-gnu
        Thread model: posix
    </property>

    <RegexMatch 
        Input="${TestString}" 
        Pattern="clang version (\d)\.(\d)" 
        Properties="ClangVersionString;ClangMajorVer;ClangMinorVer"
    />

    <fail 
        unless="'${ClangVersionString}' == 'clang version 3.4'" 
        message="Unexpected ClangVersionString result."
    />

    <fail 
        unless="'${ClangMajorVer}' == '3'" 
        message="Unexpected ClangMajorVer result."
    />

    <fail 
        unless="'${ClangMinorVer}' == '4'" 
        message="Unexpected ClangMinorVer result."
    />

    <RegexMatch 
        Input="${TestString}" 
        Pattern="Expecting no match (\d)\.(\d)\.(\d)" 
        Properties="MatchResult"
    />

    <fail 
        unless="@{StrIsEmpty('${MatchResult}')}" 
        message="Expecting empty string MatchResult for no match."
    />

</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.RegexMatchTask.Input">
            <summary>The input string.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RegexMatchTask.Pattern">
            <summary>The search pattern.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RegexMatchTask.OutProperties">
            <summary>The output property names (separated by semi-colon ';') to store the match output.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.RegistrySetValueTask">
            <summary>Add or update a value in an existing registry key.</summary>
            <remarks>
              <para>This task will add or update a value in an existing registry key.
              A build exception will be thrown if the key does not exist or the process
              does not have sufficient privileges to modify the registry.  Use this
              task with caution as changing registry values can wreak havoc on your
              system.
              </para>
              </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.RegistrySetValueTask.Hive">
            <summary>The top-level node in the windows registry. Possible values are: LocalMachine, Users, CurrentUser, and ClassesRoot.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RegistrySetValueTask.Key">
            <summary>Key in which the value is to be updated.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RegistrySetValueTask.ValueName">
            <summary>Name of the value to add or change.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.RegistrySetValueTask.Value">
            <summary>New value of the entry.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.ScriptTask">
             <summary>Executes the code contained within the task.</summary>
             <remarks>
            
             <para>The <c>script</c> element must contain a single <c>code</c> element, which in turn
             contains the script code.</para>
             <para>A static entry point named <c>ScriptMain</c> is required. It must have a single
             Nant.Core.Project parameter.</para>
            
             <para>The following namespaces are loaded by default:</para>
             <list type="bullet">
                 <item>System</item>
                 <item>System.Collections</item>
                 <item>System.Collections.Specialized</item>
                 <item>System.IO</item>
                 <item>System.Text</item>
                 <item>System.Text.RegularExpressions</item>
                 <item>NAnt.Core</item>
             </list>
             The <b>&lt;imports&gt;</b> element can be used to import more namespaces; see example below.
             You may need to add <c>&lt;references&gt;</c> to load assemblies containing those namespaces.
             </remarks>
             <example>
<para>Run a C# script that sets a nant property that can be used by the rest of the build. Show examples of using 
the mainclass attribute and import sub-element.</para>
<code>
&lt;project&gt;
    &lt;script mainclass="Scriptlet"&gt;
        &lt;code&gt;&lt;![CDATA[
            // If you specify the class name using the mainclass attribute, you can 
            // use it like a normal class, with data members, constructors, and so on.
            Project _project;
			
            public Scriptlet(Project project)
            {
                _project = project;
            }
			
            void Run()
            {
                _project.Properties.Add("foo", "bar");
                // Example of using System.Data.DataTable
                DataTable dt = new DataTable("Table1");
                Log("dt.TableName=" + dt.TableName);
                // Since &lt;, '&amp;', and '&gt;' are reserved characters in XML, 
                // it'll be an error to use them without the containing CDATA element.
                if (1 &lt; 2 &amp;&amp; 1 &gt; 0)
                   Log("1 &lt; 2 &amp;&amp; 1 &gt; 0");
            }
			
            void Log(string msg)
            {
                NAnt.Core.Logging.Log.WriteLine(msg);
            }
            
            public static void ScriptMain(Project project) {
                Scriptlet script = new Scriptlet(project);
                script.Run();
            }
        ]]&gt;&lt;/code&gt;
        &lt;references basedir="C:\WINDOWS\Microsoft.NET\Framework\v1.1.4322"&gt;
            &lt;!-- extra assemblies to use --&gt;
            &lt;includes name="System.Data.dll"/&gt;
        &lt;/references&gt;
        &lt;imports&gt;
            &lt;!-- Extra namespaces to use --&gt;
            &lt;import name="System.Data"/&gt;
        &lt;/imports&gt;
    &lt;/script&gt;
    &lt;fail message="Property foo not set correctly." unless="${foo} == bar"/&gt; 
&lt;/project&gt;
</code>
</example>
             <example>
<para>Shows how to manipulate properties inside a script.</para>
<code>
&lt;project&gt;
    &lt;!-- script that adds a property (normally use the &lt;property/&gt; task)  --&gt;
    &lt;script&gt;
        &lt;code&gt;&lt;![CDATA[
            public static void ScriptMain(Project project) {
                project.Properties["filename"] = "test.txt";
            }
        ]]&gt;&lt;/code&gt;
    &lt;/script&gt;

    &lt;!-- use the property added in the script inside some tasks --&gt;
    &lt;echo message="creating ${filename}"/&gt;
    &lt;touch file="${filename}"/&gt;

    &lt;!-- script that gets a property value to do something with it --&gt;
    &lt;script&gt;
        &lt;code&gt;&lt;![CDATA[
            public static void ScriptMain(Project project) {
                string fileName = project.GetFullPath(project.GetPropertyValue("filename"));
                if (!File.Exists(fileName)) {
                    string msg = String.Format("File '{0}' should exist.", fileName);
                    throw new BuildException(msg);
                }
                File.Delete(fileName);
            }
        ]]&gt;&lt;/code&gt;
    &lt;/script&gt;
&lt;/project&gt;
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Language">
            <summary>The language of the script block (C# or VB).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.References">
            <summary>Required assembly references to link with.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Code">
            <summary>The script to execute. It's required that the script be put in a CDATA element. This is
            because the potential use of XML reserved characters in the script. See example below.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.DummyImports">
            <summary>Namespaces to import.</summary>
            <remarks>
            Should contain elements:
             &lt;import name="namespace name"/&gt;
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.MainClass">
            <summary>The name of the main class containing the static <c>ScriptMain</c> entry point.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.ScriptTask.Compile">
            <summary>The flag of compiling code into a saved assembly or not. The default value is false. Given the file
            containing the &lt;script&gt; is named package.build, the assembly will be named package.build.dll</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.SleepTask">
            <summary>
            A task for sleeping a specified period of time, useful when a build or deployment process
            requires an interval between tasks. If none of the time attributes are specified then the task sleeps for 0 milliseconds.
            </summary>
            <example>
<para>Sleep 123 milliseconds.</para>
<code>
<![CDATA[
<project default="SleepForAWhile">
    <target name="SleepForAWhile">
        <sleep milliseconds="123" />
    </target>
</project>
]]>
</code>
</example>
            <example>
<para>Sleep 1 hour, 2 minutes, 3 seconds and 4 milliseconds.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="SleepForAWhile">
        <sleep hours="1" minutes="2" seconds="3" milliseconds="4" />
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Hours">
            <summary>Hours to add to the sleep time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Minutes">
            <summary>Minutes to add to the sleep time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Seconds">
            <summary>Seconds to add to the sleep time.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SleepTask.Milliseconds">
            <summary>Milliseconds to add to the sleep time.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.SleepTask.GetSleepTime">
            <summary>Return time to sleep.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.SleepTask.DoSleep(System.Int32)">
            <summary>Sleep the specified number of milliseconds.</summary>
            <param name="millis">Milliseconds to sleep.</param>
        </member>
        <member name="M:NAnt.Core.Tasks.SleepTask.InitializeTask(System.Xml.XmlNode)">
            <summary>
             Verify parameters.
            </summary>
            <param name="taskNode"> taskNode used to define this task instance </param>
        </member>
        <member name="T:NAnt.Core.Tasks.StartTask">
            <summary>Launches an application or document.</summary>
            <remarks>
              The main purpose of this class is to open documents, web pages and launch GUI apps.  
              If you want to capture the output of a program use the <see cref="T:NAnt.Core.Tasks.ExecTask"/>.
            </remarks>
            <example>
            <para>Open a document:</para>
            <code>
            <![CDATA[
            <project>
                <start filename='file.txt' />
            </project>
            ]]>
            </code> 
            </example>
            <example>
            <para>Open a web page:</para>
            <code>
            <![CDATA[
            <project>
                <start filename='iexplore.exe'>
                    <args>
                        <arg value='www' />
                    </args>
                </start>
            </project>
            ]]>
            </code> 
            </example>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.FileName">
            <summary>The program or document to run.  Can be a program, document or URL.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.WorkingDirectory">
            <summary>The working directory to start the program from.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.Kill">
            <summary>If true the process will be killed right after being started.  Used by automated tests.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.ArgSet">
            <summary>The set of command line arguments.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.ClearEnv">
            <summary>Set true to clear all environmental variable before executing, environmental variable specified in env OptionSet will still be added as environmental variable.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.EnvironmentVariables">
            <summary>The set of environment variables for when the program runs.
            Benefit of setting variables, like "Path", here is that it will be
            local to this program execution (i.e. global path is unaffected).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StartTask.UseShell">
            <summary>Start process in a separate shell. Default is true. 
            NOTE. When useshell is set to true environment variables are not passed to the new process.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.StyleTask">
            <summary>
            Process a document with XSLT.
            This is useful for building views of XML based documentation, or in generating code.
            </summary>
            <example>
<para>Create a report in HTML.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="DoXslt">
        <style style="mytest.xsl" in="data.xml"/>	
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.BaseDir">
            <summary>Where to find the source XML file, default is the project's basedir.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.DestDir">
            <summary>Directory in which to store the results. The default is the current directory.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.Extension">
            <summary>Desired file extension to be used for the targets. The default is "html".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.StyleSheet">
            <summary>Name of the stylesheet to use - given either relative to the project's basedir or as an absolute path.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.SrcFile">
            <summary>Specifies a single XML document to be styled. Should be used with the <c>out</c> attribute.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.StyleTask.OutputFile">
            <summary>Specifies the output name for the styled result from the in attribute. The default is the name specified by the in attribute but with an .html extension.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.StyleTask.InitializeTask(System.Xml.XmlNode)">
            <param name="taskNode"> taskNode used to define this task instance </param>
        </member>
        <member name="T:NAnt.Core.Tasks.SyncTargetDirTask">
            <summary>Synchronizes target directory file set(s) to a target dir and removes files from the target dir that aren't present in the file set(s).</summary>
            <remarks>
              <para>
              By default, files are copied if the source file is newer than the destination file, or if the 
              destination file does not exist. However, you can explicitly overwrite (newer) files with the 
              <c>overwrite</c> attribute set to true.</para>
              <para>
              A file set(s), defining groups of files using patterns, is copied.
              All the files matched by the file set will be 
              copied to that directory, preserving their associated directory structure.
              </para>
              <para>Any directories are created as needed by the <c>synctargetdir</c> task.</para>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.ToDirectory">
            <summary>The directory to transfer to, when transferring a file set.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.Overwrite">
            <summary>Overwrite existing files even if the destination files are newer. Defaults is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.Clobber">
            <summary>Allow hidden and read-only files to be overwritten if appropriate (i.e. if source is newer or overwrite is set to true). Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.MaintainAttributes">
            <summary>Maintain file attributes of overwritten files. By default and if destination file does not exist file attributes are carried over from source file. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.Flatten">
            <summary>Flatten directory structure when transferring a file set. All files are placed in the <i>todir</i>, without duplicating the directory structure.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.RetryCount">
            <summary>Number of times to retry the copy operation if copy fails.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.RetryDelay">
            <summary>Length of time in milliseconds between retry attempts.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.HardLink">
            <summary>Tries to create a hard link to the source file rather than copying the entire contents of the file.
            If unable to create a hard link it simply copies the file.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.DeleteEmptyDirs">
            <summary>Delete empty folders under the target directory. Default:true</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.Quiet">
            <summary>Do not print any info. Default:false</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.CopyFilesOnly">
            <summary>Just copy the files only but do not do directory/fileset synchronization. Default:false</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.CopyFileSet">
            <summary>The (single) file set to be copied.  
            Note the todir attribute must be set, and that a fileset 
            may include another fileset.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.FilesetNames">
            <summary>Names of the filesets to synchronize</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.SyncTargetDirTask.ExcludeFileSet">
            <summary>Files to exclude from synchronization. Files in this fileset will 
            not be deleted even if these files aren't present in the input files to copy.
            Note: 'excludefiles' fileset does not affect copy phase.
            </summary>
        </member>
        <member name="M:NAnt.Core.Tasks.SyncTargetDirTask.CopyFiles">
            <summary>
            Actually does the file (and possibly empty directory)
            transfers.
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.SysInfoTask">
            <summary>(Deprecated) Set properties with system information.</summary>
            <remarks>
              <para>This task is Deprecated and no longer preforms any function. All of the properties that were setup by this task are now setup automatically for each project.</para>
              <para>Sets a number of properties with information about the system environment.  The intent of this task is for nightly build logs to have a record of the system information that the build was performed on.</para>
              <list type="table">
                <listheader><term>Property</term>      <description>Value</description></listheader>
                <item><term>sys.clr.version</term>     <description>Common Language Runtime version number.</description></item>
                <item><term>sys.env.*</term>           <description>Environment variables, stored both in upper case or their original case.(e.g., sys.env.Path or sys.env.PATH).</description></item>
                <item><term>sys.os.folder.system</term><description>The System directory.</description></item>
                <item><term>sys.os.folder.temp</term>  <description>The temporary directory.</description></item>
                <item><term>sys.os.platform</term>     <description>Operating system platform ID.</description></item>
                <item><term>sys.os.version</term>      <description>Operating system version.</description></item>
                <item><term>sys.os</term>              <description>Operating system version string.</description></item>
              </list>
            </remarks>
            <example>
<para>Register the properties with the default property prefix.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <sysinfo/>
    <echo message="Your operating system is: ${sys.os}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Register the properties without a prefix.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <sysinfo prefix=""/>
    <echo message="Your operating system is: ${os}"/>
</project>
]]>
</code>
</example>
            <example>
<para>Register properties and display the values set.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <sysinfo verbose="true"/>
</project>
]]>
</code>
</example>
            <example>
<para>Register properties and display the values set.</para>
<code>
<![CDATA[
<project default="build">
	<target name="build">
		<echo message="sys.env.windir == ${sys.env.windir}"/>
	</target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.SysInfoTask.Prefix">
            <summary>The string to prefix the property names with.  Default is "sys."</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TargetTask">
            <summary>
            Create a dynamic target. 
            </summary>
            <remarks>
            <para>With Framework 1.x, you can declare &lt;target&gt; within a &lt;project&gt;, but not within any
            task. Moreover, the target name can't be variable. But with TargetTask, you can declare a target with variable
            name, or within any task that supports probing. You declare a dynamic target, and call it using &lt;call&gt;.
            </para>
            </remarks>
            <example>
<para>Test to show how to use &lt;target&gt; task.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name="prop" value="val"/>
    <do if="@{PropertyExists('prop')}">
        <!-- 
        Target conditional depends on defition of prop
        If you run command: nant conditional, you'll see conditional executed after some targets.
        Reasons:
        1. When the build runs, do is executed, hence is conditional
        2. When conditional runs, it adds a target named conditional to the target list
        3. Then the build runs the foreach, hence executing its targets
        4. And finally, the build runs conditional as the given target.
        -->
        <target name="conditional">
            <echo message="In target ${target.name}"/>
        </target>
    </do>

    <optionset name="myOptSet">
        <option name="option1" value="1"/>
        <option name="option2" value="2"/>
    </optionset>
    
    <foreach item="OptionSet" in="myOptSet" property="option" verbose="true">
        <target name="looped" hidden="true">
            <echo message="In target ${target.name}: ${option.name}=${option.value}"/>
        </target>
        <!-- Without call, looped won't be executed in the loop -->
        <call target="looped"/>
        
        <property name="targetName" value="var${option.value}"/>
        <!-- Define a target with variable name -->
        <target name="${targetName}">
            <echo message="In target ${target.name}"/>
        </target>
        <call target="${targetName}"/>
    </foreach>
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.TargetName">
            <summary>The name of the target.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.DependencyList">
            <summary>A space separated list of target names that this target depends on.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Description">
            <summary>The Target description.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.IfDefined">
            <summary>If true then the target will be executed; otherwise skipped. Default is "true".</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Hidden">
            <summary>Prevents the target from being listed in the project help. Default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Override">
            <summary>
            Override target with the same name if it already exists. Default is 'false'. 
            Depends on the 'allowoverride' setting in target it tries to override.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.AllowOverride">
            <summary>Defines whether target can be overridden by other target with same name. Default is 'false'</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.Style">
            <summary>Style can be 'use', 'build', or 'clean'.   See <see cref="!:AutoBuildClean"/> 
            page for details.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TargetTask.UnlessDefined">
            <summary>Opposite of if.  If false then the target will be executed; otherwise skipped. Default is "false".</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TaskDefTask">
            <summary>Loads tasks from a specified assembly. When source files are provided as input assembly is built first.</summary>
            <remarks>
            <para>All assemblies already loaded in the NAnt Application Domain are automatically added as references when assembly is built from sources.</para>
            <para>
            Task definitions are propagated to dependent packages like global properties.
            </para>
            <para>
            NAnt by default will scan any assemblies ending in *Task.dll in the 
            same directory as NAnt.  You can use this task to include assemblies 
            in different locations or which use a different file
            convention.  (Some .NET assemblies end will end in .net
            instead of .dll)
            </para>
            <para>
            NAnt can only use .NET assemblies; other types of files which
            end in .dll won't work.
            </para>
            </remarks>
            <example>
<para>Include the tasks in an assembly.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="init">
        <taskdef assembly="MyCustomTasks.dll"/>
    </target>
</project>
]]>
</code>
</example>
            <example>
<para>Include the tasks in an assembly.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <target name="init">
        <taskdef assembly="MyCustomTasks.dll">
          <sources>
              <includes name="src/*.cs"/>
          </sources>
          <references>
            <includes name="System.Drawing.dll" asis="true"/>
          </references>          
        </taskdef>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.AssemblyFileName">
            <summary>File name of the assembly containing the NAnt task.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.Override">
            <summary>
            Override task with the same name if it already loaded into the Project. Default is "false"
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.Sources">
            <summary>If defined, Tasks DLL will be built using these source files.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.References">
            <summary>Reference assembles. The following assemblies are automatically referenced: System, System.Core System.Runtime, System.Xml, NAnt.Core, NAnt.Tasks and EA.Tasks.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.NugetReferences">
            <summary>Nuget package references. Nuget packages will be automatically downloaded and containted assemblies added as references.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.DebugBuild">
            <summary>Setting this to false will generate optimized code. Defaults to true to aid debugging because &lt;taskdef&gt; code is rarely performance critical.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TaskDefTask.Compiler">
            <summary>
            Version of .Net compiler to use when building tasks. Format is: 'v3.5', or 'v4.0', or 'v4.5', ... . Default is "v4.0"
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.TouchTask">
            <summary>
            Touch a file and/or fileset(s); corresponds to the Unix
            <i>touch</i> command.
            </summary>
            <remarks>If the file exists, <c>touch</c> changes the <i>last access</i> and <i>last write</i> timestamps to the current time.  If no file of that name exists, <c>touch</c> will create an empty file with that name, and set the <i>create</i>, <i>last access</i> and <i>last write</i> timestamps to the current time.
            </remarks>
            <example>
<para>Touch a file using the current time.  If the file does not exist it will be created..</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch file="foo.txt"/>
</project>
]]>
</code>
</example>
            <example>
<para>Touch all executable files in the current directory and its subdirectories.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <touch>
        <fileset>
            <includes name="**/*.exe"/>
            <includes name="**/*.dll"/>
        </fileset>
    </touch>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.FileName">
            <summary>Assembly Filename (required unless a fileset is specified).</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.Millis">
            <summary>
            Specifies the new modification time of the file in milliseconds since midnight Jan 1 1970.
            The FAT32 file system has limitations on the date value it can hold. The smallest is 
            <code>"12/30/1979 11:59:59 PM"</code>, and largest is <code>"12/30/2107, 11:59:58 PM"</code>.
            </summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.Datetime">
            <summary>Specifies the new modification time of the file in the format MM/DD/YYYY HH:MM AM_or_PM.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TouchTask.TouchFileSet">
            <summary>Fileset to use instead of single file.</summary>
        </member>
        <member name="M:NAnt.Core.Tasks.TouchTask.InitializeTask(System.Xml.XmlNode)">
            <summary>Initializes task and ensures the supplied attributes are valid.</summary>
            <param name="taskNode">XML node used to define this task instance.</param>
        </member>
        <member name="T:NAnt.Core.Tasks.TryCatchTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in try/catch/finally clauses. <b>This task is a Framework 2 
            feature.</b>
            </summary>
            <remarks>
            It uses format similar to Ant's: <a href="http://ant-contrib.sourceforge.net/tasks/trycatch.html">http://ant-contrib.sourceforge.net/tasks/trycatch.html</a>. It's a simple implementation of try/catch/finally/throw
            common in languages like C++ and C#.
            <para>
            A build exception will be thrown if:
            <list type="number">
            <item>&lt;trycatch&gt; doesn't have one &lt;try&gt;</item>
            <item>&lt;trycatch&gt; has more than one &lt;finally&gt;</item>
            <item>&lt;trycatch&gt; has tags other than &lt;try&gt;, &lt;catch&gt;, and &lt;finally&gt;</item>
            <item>&lt;catch&gt; and &lt;finally&gt; are both missing</item>
            <item>&lt;catch&gt; is ahead of &lt;try&gt;</item>
            <item>&lt;finally&gt; is ahead of &lt;try&gt; or &lt;catch&gt;</item>
            <item>&lt;throw&gt; appears in &lt;try&gt; or &lt;finally&gt;</item>
            </list>
            </para>
            <para>trycatch won't handle the above exception. Instead, it'll rethrow it, halting the build process,
            and allow you to correct the error. But for other exceptions, it'll catch them if it has a &lt;catch&gt;.
            </para>
            <para>
            When an exception is caught, &lt;trycatch&gt; will store the exception message in property 
            <i>trycatch.error</i> of the project, and remove the message when it goes out of the scope. It'll 
            rethrow the exception at the end of execution if &lt;catch&gt; has &lt;throw&gt;. As usual, tasks
            remained in &lt;catch&gt; will be ignored.
            </para>
            <para>
            &lt;trycatch&gt; can be nested within &lt;try&gt;, &lt;catch&gt;, and &lt;finally&gt;.
            </para>
            </remarks>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.TryTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in a try clause. <b>This task can appear only inside trycatch task.</b>
            </summary>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.CatchTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in a catch clause. <b>This task can appear only inside trycatch task.</b>
            </summary>
            <remarks>Also allows rethrowing a caught exception.</remarks>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.CatchTask.Exception">
            <summary>The type of the exception to be caught.</summary>
        </member>
        <member name="T:NAnt.Core.Tasks.FinallyTask">
            <summary>
            Allows wrapping of a group of tasks to be executed in a finally clause. <b>This task can appear only inside trycatch task.</b>
            </summary>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.ThrowTask">
            <summary>
            Rethrows a caught exception. <b>This task can appear only inside catch task.</b>
            </summary>
            <example>
<para>Examples of using try, catch, and finally.</para>
<code>
<![CDATA[
<project default="simple">
    <echo message="ver=${package.frameworkversion}"/>
    <target name="simple">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
        <!-- And this won't echo since trycatch.error is removed when trycatch goes out of scope -->
        <do if="@{PropertyExists('trycatch.error')}">
            <echo message="Caugth: ${trycatch.error}"/>
        </do>
    </target>
    
    <target name="throw">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message='In try.'/>
                <fail message='Tada!'/>
            </try>
            <catch>
                <echo message='In catch.'/>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch will rethrow the exception at the end of execution -->
                <throw/>
                <!-- and ignore remaining tasks -->
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
            <finally>
                <echo message='In finally.'/>
            </finally>
        </trycatch>
    </target>
    
    <target name="throwFalse">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <fail message="fail for throwFalse"/>
            </try>
            <catch>
                <echo message="Caught: ${trycatch.error}"/>
                <!-- trycatch won't rethrow the exception since throw's if attribute is false -->
                <throw if="false"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="nested">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <fail message="Inner fail"/>
                    </try>
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="moreThanOnes">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
            <try/>
            <catch/>
            <catch/>
            <finally/>
            <finally/>
            <echo message="Should not be here"/>
        </trycatch>
    </target>
    
    <target name="missing">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try/>
        </trycatch>
    </target>
    
    <target name="aheads">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <finally/>
            <catch/>
            <try/>
        </trycatch>
    </target>
    
    <target name="throwInWrongPlaces">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <throw/>
            </try>
            <catch/>
            <finally>
                <throw/>
            </finally>
        </trycatch>
    </target>
    
    <target name="bubbleUp">
        <echo message="In target ${target.name}"/>
        <trycatch>
            <try>
                <echo message="In target ${target.name}"/>
                <trycatch>
                    <try>
                        <!-- This is a syntax error, bubbled up to the top for your correction -->
                        <throw/>
                    </try>
                    <!-- This won't catch the bubbled exception -->
                    <catch>
                        <echo message="Caugth: ${trycatch.error}"/>
                    </catch>
                </trycatch>
                <fail message="Outer fail"/>
            </try>
            <!-- Neither will this -->
            <catch>
                <echo message="Caugth: ${trycatch.error}"/>
            </catch>
        </trycatch>
    </target>
    
    <target name="catchingExceptionTypes">
        <echo message="In target ${target.name}"/>
        <trycatch>
          <try>
            <fail type="Type1.Subtype1" message="Type1.Subtype1 exception thrown!"/>
          </try>
          <catch exception="Type1.*">
            <echo message="Type1 or one of its subtypes exception catched"/>
          </catch>
        </trycatch>
        <trycatch>
          <try>
            <fail type="UnknownTypeException" message="UnknownTypeException thrown!"/>
          </try>
          <catch exception="Type2">
            <echo message="This won't catch the UnknownTypeException exception"/>
          </catch>
          <catch>
            <echo message="But this will"/>
            <echo message="Exception with message ${trycatch.error} caught."/>
            <echo message="Exception of type ${trycatch.exceptiontype} caught."/>
          </catch>
        </trycatch>
    </target>    
</project>
]]>
</code>
<code file="Manifest.xml">
<![CDATA[
<package>
    <frameworkVersion>2</frameworkVersion>
    <buildable>false</buildable>
</package>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.Core.Tasks.TStampTask">
            <summary>Sets properties with the current date and time.</summary>
            <remarks>
              <para>By default <c>tstamp</c> displays the current date and time and sets the following properties:</para>
              <list type="bullet">
                <item><description><c>tstamp.date</c> to yyyyMMdd</description></item>
                <item><description><c>tstamp.time</c> to HHmm</description></item>
                <item><description><c>tstamp.now</c> using the default DateTime.ToString() method</description></item>
              </list>
              <para>To set an additional property with a custom date/time use the property and pattern attributes.  To set a number of additional properties all with the exact same date and time use the formatter nested element (see example).</para>
              <para>The date and time string displayed by the tstamp task uses the computer's default long date and time string format.  You might consider setting these to the <a href="http://www.cl.cam.ac.uk/~mgk25/iso-time.html">ISO 8601 standard for date and time notation</a>.</para>
            </remarks>
            <example>
<para>Set the build.date property.</para>
<code>
<![CDATA[
<project default="DoStamp">
    <target name="DoStamp">
        <tstamp property="build.date" pattern="yyyyMMdd" verbose="true"/>
    </target>
</project>
]]>
</code>
</example>
            <example>
<para>Set a number of properties for Ant like compatibility.</para>
<code>
<![CDATA[
<project default="DoStamp">
    <target name="DoStamp">
        <tstamp verbose="true">
            <formatter property="TODAY" pattern="dd MMM yyyy"/>
            <formatter property="DSTAMP" pattern="yyyyMMdd"/>
            <formatter property="TSTAMP" pattern="HHmm"/>
        </tstamp>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.Property">
            <summary>The property to receive the date/time string in the given pattern.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.Pattern">
            <summary>The date/time pattern to be used.</summary>
            <remarks>
              <para>The following table lists the standard format characters for each standard pattern. The format characters are case-sensitive; for example, 'g' and 'G' represent slightly different patterns.</para>
              <list type="table">
                <listheader>
                  <description>Format Character</description>
                  <description>Description Example Format Pattern (en-US)</description>
                </listheader>
                <item><description>d</description><description>MM/dd/yyyy</description></item>
                <item><description>D</description><description>dddd, dd MMMM yyyy</description></item>
                <item><description>f</description><description>dddd, dd MMMM yyyy HH:mm</description></item>
                <item><description>F</description><description>dddd, dd MMMM yyyy HH:mm:ss</description></item>
                <item><description>g</description><description>MM/dd/yyyy HH:mm</description></item>
                <item><description>G</description><description>MM/dd/yyyy HH:mm:ss</description></item>
                <item><description>m, M</description><description>MMMM dd</description></item>
                <item><description>r, R</description><description>ddd, dd MMM yyyy HH':'mm':'ss 'GMT'</description></item>
                <item><description>s</description><description>yyyy'-'MM'-'dd'T'HH':'mm':'ss</description></item>
                <item><description>t</description><description>HH:mm</description></item>
                <item><description>T</description><description>HH:mm:ss</description></item>
                <item><description>u</description><description>yyyy'-'MM'-'dd HH':'mm':'ss'Z'</description></item>
                <item><description>U</description><description>dddd, dd MMMM yyyy HH:mm:ss</description></item>
                <item><description>y, Y</description><description>yyyy MMMM</description></item>
              </list>
              <para>The following table lists the patterns that can be combined to construct custom patterns. The patterns are case-sensitive; for example, "MM" is recognized, but "mm" is not. If the custom pattern contains white-space characters or characters enclosed in single quotation marks, the output string will also contain those characters. Characters not defined as part of a format pattern or as format characters are reproduced literally.</para>
              <list type="table">
                <listheader>
                  <description>Format</description>
                  <description>Pattern Description</description>
                </listheader>
                <item><description>d</description><description>The day of the month. Single-digit days will not have a leading zero.</description></item>
                <item><description>dd</description><description>The day of the month. Single-digit days will have a leading zero.</description></item>
                <item><description>ddd</description><description>The abbreviated name of the day of the week.</description></item>
                <item><description>dddd</description><description>The full name of the day of the week.</description></item>
                <item><description>M</description><description>The numeric month. Single-digit months will not have a leading zero.</description></item>
                <item><description>MM</description><description>The numeric month. Single-digit months will have a leading zero.</description></item>
                <item><description>MMM</description><description>The abbreviated name of the month.</description></item>
                <item><description>MMMM</description><description>The full name of the month.</description></item>
                <item><description>y</description><description>The year without the century. If the year without the century is less than 10, the year is displayed with no leading zero.</description></item>
                <item><description>yy</description><description>The year without the century. If the year without the century is less than 10, the year is displayed with a leading zero.</description></item>
                <item><description>yyyy</description><description>The year in four digits, including the century.</description></item>
                <item><description>gg</description><description>The period or era. This pattern is ignored if the date to be formatted does not have an associated period or era string.</description></item>
                <item><description>h</description><description>The hour in a 12-hour clock. Single-digit hours will not have a leading zero.</description></item>
                <item><description>hh</description><description>The hour in a 12-hour clock. Single-digit hours will have a leading zero.</description></item>
                <item><description>H</description><description>The hour in a 24-hour clock. Single-digit hours will not have a leading zero.</description></item>
                <item><description>HH</description><description>The hour in a 24-hour clock. Single-digit hours will have a leading zero.</description></item>
                <item><description>m</description><description>The minute. Single-digit minutes will not have a leading zero.</description></item>
                <item><description>mm</description><description>The minute. Single-digit minutes will have a leading zero.</description></item>
                <item><description>s</description><description>The second. Single-digit seconds will not have a leading zero.</description></item>
                <item><description>ss</description><description>The second. Single-digit seconds will have a leading zero.</description></item>
                <item><description>f</description><description>The fraction of a second in single-digit precision. The remaining digits are truncated.</description></item>
                <item><description>ff</description><description>The fraction of a second in double-digit precision. The remaining digits are truncated.</description></item>
                <item><description>fff</description><description>The fraction of a second in three-digit precision. The remaining digits are truncated.</description></item>
                <item><description>ffff</description><description>The fraction of a second in four-digit precision. The remaining digits are truncated.</description></item>
                <item><description>fffff</description><description>The fraction of a second in five-digit precision. The remaining digits are truncated. </description></item>
                <item><description>ffffff</description><description>The fraction of a second in six-digit precision. The remaining digits are truncated. </description></item>
                <item><description>fffffff</description><description>The fraction of a second in seven-digit precision. The remaining digits are truncated. </description></item>
                <item><description>t</description><description>The first character in the AM/PM designator.</description></item>
                <item><description>tt</description><description>The AM/PM designator. </description></item>
                <item><description>z</description><description>The time zone offset ("+" or "-" followed by the hour only). Single-digit hours will not have a leading zero. For example, Pacific Standard Time is "-8".</description></item>
                <item><description>zz</description><description>The time zone offset ("+" or "-" followed by the hour only). Single-digit hours will have a leading zero. For example, Pacific Standard Time is "-08".</description></item>
                <item><description>zzz</description><description>The full time zone offset ("+" or "-" followed by the hour and minutes). Single-digit hours and minutes will have leading zeros. For example, Pacific Standard Time is "-08:00".</description></item>
                <item><description>:</description><description>The default time separator.</description></item>
                <item><description>/</description><description>The default date separator.</description></item>
                <item><description>\ c</description><description>Pattern Where c is any character. Displays the character literally. To display the backslash character, use "\\". </description></item>
              </list>
            </remarks>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.PrintTime">
            <summary>Print time stamp into the output, default is false.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.FormatterElement.Property">
            <summary>The property to set.</summary>       
        </member>
        <member name="P:NAnt.Core.Tasks.TStampTask.FormatterElement.Pattern">
            <summary>The string pattern to use to format the property.</summary>       
        </member>
        <member name="T:NAnt.Core.Tasks.WarnTask">
            <summary>Display a warning message in the current build.</summary>
            <remarks>
              <para>Displays a warning message and location in the build file then continues with the build.</para>
            </remarks>
            <example>
<para>Display a message to a log with the current position in the build</para>
<code file="simple.build">
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <warn message="This warning is on line four."/>
</project>
]]></code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.WarnTask.Message">
            <summary>The warning message to display.</summary>
        </member>
        <member name="P:NAnt.Core.Tasks.WarnTask.Group">
            <summary>
            Categorizes the warning for the framework build messaging system. 
            Allows users to disable all warnings in a category.
            (Designed to be used only by internal Framework packages for now)
            </summary>
        </member>
        <member name="T:NAnt.Core.Tasks.WhileTask">
            <summary>Allows wrapping of a group of tasks to be repeatedly executed based on a conditional.</summary>
            <example>
<para>Uses a while statement to loop over a series of numbers.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <property name='x' value='0' />
    <while condition='${x} lte 1'>
        <eval type='Function' code="@{MathAdd('${x}', '1')}" property='x' />
    </while>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.Core.Tasks.WhileTask.Condition">
            <summary>The expression used to test for termination criteria.</summary>
        </member>
        <member name="M:NAnt.Core.Util.CheckDependency.ReadDependencyFile">
            <summary>Reads list of files from dependency file</summary>
            <returns>A sorted List containing all files listed in the dependency file</returns>
        </member>
        <member name="M:NAnt.Core.Util.CheckDependency.WriteDependencyFile(System.IO.TextWriter,System.Collections.Generic.List{NAnt.Core.Util.PathString})">
            <summary>Writes list of files to a dependency file</summary>
        </member>
        <member name="M:NAnt.Core.Util.CheckDependency.InputDependencyListChanged(System.Collections.Generic.List{NAnt.Core.Util.PathString},System.Collections.Generic.List{NAnt.Core.Util.PathString})">
            <summary>Determine if the current and previous list of input files differ</summary>
            <returns><c>true</c> if the lists are not identical</returns>
        </member>
        <member name="M:NAnt.Core.Util.FileSetExtensions.AppendWithBaseDir(NAnt.Core.FileSet,NAnt.Core.FileSet,System.String,System.Boolean)">
            <summary>
            Appends a fileset and overwrites the base directory of the original fileset. 
            The base directory of the fromfileset will be used unless an explicit basedir is provided.
            If you want to preserve the basedirectory from the original fileset you should probably just use append.
            </summary>
            <param name="fileSet">The original fileset that will be modified by this function</param>
            <param name="fromfileSet">The fileset to append, this filesets base directory will overwrite the one from the original fileset</param>
            <param name="baseDir">The base directory to use instead of the base directory of the fromfileset</param>
            <param name="copyNoFailOnMissing">Wheather to copy the value of failonmissing from the fromfileset</param>
            <returns>The integer 1 for success and 0 for failure</returns>
        </member>
        <member name="M:NAnt.Core.Util.FileSetExtensions.IncludeWithBaseDir(NAnt.Core.FileSet,NAnt.Core.FileSet,System.String,System.Nullable{System.Boolean})">
            <summary>
            Appends only Includes from a fileset and overwrites the base directory of the original fileset. 
            Includes from the original fileset are given the base directory of the original if it was set.
            </summary>
            <param name="fileSet">The original fileset that will be modified by this function</param>
            <param name="fromfileSet">The fileset to append, this fileset's base directory will overwrite the one from the original fileset</param>
            <param name="optionSetName">A custom optionset to attach to each of the file items from the fromfileset, will replace any optionset they original had</param>
            <param name="force">Overrides the force status of the fileitems appended from the fromfileset</param>
            <returns>true if the function succeeded to append files, false if one of the filesets was null or if no files were appended</returns>
        </member>
        <member name="M:NAnt.Core.Util.Hash.MakeGUIDfromString(System.String)">
            <summary>
            Calculate a hash for the argument and return it as a 16 byte GUID-format string
            </summary>
        </member>
        <member name="M:NAnt.Core.Util.Hash.BytesToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the bytes in a buffer to a hex representation
            </summary>
        </member>
        <member name="T:NAnt.Core.Util.DirectorySeparatorOptions">
            <summary>
            An enum indicating whether to preserve the directory separator or change to match the current system
            </summary>
        </member>
        <member name="F:NAnt.Core.Util.DirectorySeparatorOptions.CurrentSystem">
            <summary>Change directory separators to match what is used by the current system.</summary>
        </member>
        <member name="F:NAnt.Core.Util.DirectorySeparatorOptions.Preserve">
            <summary>Preserve the directory separators, keep them as they are in the original path.</summary>
        </member>
        <member name="T:NAnt.Core.Util.PathNormalizer">
            <summary>Helper class for normalizing paths so they can be compared.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathNormalizer.Normalize(System.String,System.Boolean,System.Boolean,NAnt.Core.Util.DirectorySeparatorOptions)">
            <summary>Converts a path so that it can be compared against another path.</summary>
            <remarks>
              <para>For some unknown reason using the DirectoryInfo and FileInfo classes to get the full name
              of a file or directory does not return a full path that can be always be compared.  Often the
              drive letter or directory separators are wrong.  If you want to determine if a path starts
              with another path first normalize the paths with this method and then use the 
              "String.StartsWith" method.
            </para>
            </remarks>
            <example>
            string path1 = PathNormalizer.Normalize(path1);
            string path2 = PathNormalizer.Normalize(path2);
            if (path1.StartsWith(path2) {
                string dir = path1.Substring(path2.Length);
            }
            </example>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.RelativePath(NAnt.Core.Util.PathString,NAnt.Core.Util.PathString,System.Boolean,System.Boolean,NAnt.Core.Util.DirectorySeparatorOptions)">
            <summary>Takes two paths and returns a relative path from the source path to the destination path.</summary>
            <param name="srcPath">The source path.</param>
            <param name="dstPath">The destination path.</param>
            <param name="failOnError">Whether this function should throw an exception if an error occurs.</param>
            <param name="addDot">Whether to add a dot, representing the current directory, to the beginning of the relative path.</param>
            <param name="separatorOptions">Indicates whether to preserve the separator or change it to match the current system.</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.SafeRelativePath_OrFullPath(NAnt.Core.Util.PathString,NAnt.Core.Util.PathString,System.Boolean,System.Boolean,NAnt.Core.Logging.Log)">
            <summary>Takes two paths and computes relative path and returns it if (dstPath + relativePath) is less than 260. Otherwise returns full path.</summary>
            <param name="srcPath">The source path.</param>
            <param name="dstPath">The destination path.</param>
            <param name="failOnError">Whether this function should throw an exception if an error occurs.</param>
            <param name="addDot">Whether to add a dot, representing the current directory, to the beginning of the relative path.</param>
            <param name="log">If log is not null - prints warning message when full path is returned.</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.RelativePath(System.String,System.String,System.Boolean,System.Boolean,NAnt.Core.Util.DirectorySeparatorOptions)">
            <summary>Takes two paths and returns a relative path from the source path to the destination path.</summary>
            <param name="srcPath">The source path.</param>
            <param name="dstPath">The destination path.</param>
            <param name="failOnError">Whether this function should throw an exception if an error occurs.</param>
            <param name="addDot">Whether to add a dot, representing the current directory, to the beginning of the relative path.</param>
            <param name="separatorOptions">Indicates whether to preserve the directory separators or change to match current system.</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.GetDriveLetter(System.String)">
            <summary>Return the drive letter as string</summary>
            <param name="path">The path whose drive letter we are interested in.</param>
            <returns>The drive letter as a string, or null if no drive letter can be determined.</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.GetAssemblyRootDir(System.String)">
            <summary>Returns the path to the drive letter directory on windows (or /mnt/[drive] under Windows Subsystem for Linux) and to the home directory on Unix host.  Mainly used to setup 'nant.drive' system property.</summary>
            <param name="assemblyLocation">The path to the assembly whose root directory the function should return, if null it will get the location of the executing assembly</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsPathInBuildRoot(NAnt.Core.Project,System.String)">
            <summary>Checks whether a path is a subdirectory of a projects build root directory.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsPathInPackageRoots(System.String)">
            <summary>
            Test the input path is in the package roots that is listed in your masterconfig.
            Note that if PackageMap is not initialized (for tools like eapm that doesn't
            load build file and masterconfig), this function will always return false.
            </summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.TestAllowCopyWithHardlinkUsage(NAnt.Core.Project,System.String,System.String)">
            <summary>
             Test that the given source to destination copy allow copy with hard link usage. We currently
             disallow hard link usage if source file is in source tree. File attributes are part of the file
             not the link so changing one link modifies them all. Files inside the source tree have file
             attributes that are usually tied to source control (such as Perforce) so we don't want to modify
             them if we can avoid it.
            </summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsPathInDirectory(System.String,System.String)">
            <summary>Checks whether the given path is equal to or a sub directory of the given directory.</summary>
            <param name="path">The path that is tested to see if it is within the directory.</param>
            <param name="dir">The directory that is tested to see if it contains the path.</param>
            <returns>Return true if the path is within the directory and false otherwise.</returns>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsValidPathString(System.String)">
            <summary>Checks if a string is a valid path string, ie. contains no invalid symbols.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.DeleteDirectory(System.String,System.Boolean,System.Boolean)">
            <summary>
            Deletes a directory with all content. File attributes are reset to normal before delete.
            </summary>
            <param name="path">The path to the directory</param>
            <param name="verify">Verify that directory does not exist after delete and throw exception otherwise.</param>
            <param name="failOnError">Fail in the case of error if true, otherwise ignore errors</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.MoveDirectory(System.String,System.String,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Move a directory from one destination to another. Note that operation will fail if you're moving one directory to a different volume or
            if source and destination is the same. If the operation fails it will retry several times and throw an exception if the retries fail.
            </summary>
            <param name="sourceDir">The source directory to move to</param>
            <param name="destDir">Verify that directory does not exist after delete and throw exception otherwise.</param>
            <param name="failOnError">Fail in the case of error if true, otherwise ignore errors</param>
            <param name="iterations"></param>
            <param name="waitMs"></param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.SetAllFileAttributesToNormal(System.String)">
            <summary>For each file and directory in the given path set the file attributes to Normal. Will NOT enter symlinked directories</summary>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.IsFileNotAccessible(System.String)">
            <summary>
            Check if a file is inaccessible by doing a simple file open test.  If it failed, it can be either
            user has no access permission to the file or the file has exclusive lock by another process.
            NOTE:  This function is really only useful on PC.  On OSX and Unix, we can't detect a lock by
            doing a simple file open.
            </summary>
            <param name="filepath">The path to the file</param>
        </member>
        <member name="M:NAnt.Core.Util.PathUtil.FindFirstNotAccessibleFileInDirectory(System.String,System.String@)">
            <summary>
            Find the first file that cannot be accessed from the given directory.  This function will search through all subdirectories as well.
            </summary>
            <param name="path">The path to the file</param>
            <param name="firstNotAccessibleFile">This parameter returns the first file being found that has access issue (or null if nothing is found)</param>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.IsExplicitPattern(System.String)">
            <summary>Check if the specified pattern does not contain any wild cards.</summary>
            <returns>True if the pattern does not contain any wild cards, otherwise false.</returns>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.IsImplicitPattern(System.String)">
            <summary>Check if the specified pattern contains any wild cards.</summary>
            <returns>True if the pattern contains any wild cards, otherwise false.</returns>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.ConvertPattern(System.String,System.String@)">
            <summary>Adds regular expressions for any non-explicit (ie, uses wild cards) NAnt patterns.</summary>
            <param name="nantPattern">The NAnt pattern to convert.  Absolute or relative paths.</param>
            <param name="absoluteFileName">Absolute pattern will return file name here.</param>
            <returns>The resulting regular expression. Absolute canonical path.</returns>
            <remarks>
            	<para>Only NAnt patterns that contain a wild card character as converted to regular expressions.
            	Explicit patterns are expected to be handled using absoluteFileName.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.IsPathInPatternSet(System.String,NAnt.Core.Util.Pattern.RegexPattern,System.Boolean,System.Collections.Generic.List{NAnt.Core.Util.Pattern.RegexPattern},System.Collections.Specialized.StringCollection)">
            <summary>Verifies that a path matches the regex pattern.
            More efficient implementation, to be used when caller knows
            if the volume is case sensitive.</summary>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.ToRegex(System.String,System.Boolean)">
            <summary>Converts NAnt search pattern to a regular expression. Use cached version or compile and cache</summary>
            <param name="pattern">input pattern string</param>
            <param name="caseSensitive">Is volume case sensitive</param>
            <returns>Compiler Regular expression</returns>
        </member>
        <member name="M:NAnt.Core.Util.Pattern.ToRegexPatternOpt(System.String)">
            <summary>Converts NAnt search pattern to a regular expression pattern</summary>
            <param name="nantPattern">Search pattern relative to the search directory</param>
            <returns>Regular expression (absolute path) for searching matching file/directory names</returns>
        </member>
        <member name="M:NAnt.Core.Util.ExplictPattern.ConvertPattern(System.String,System.String@)">
            <summary>Adds regular expressions for any non-explicit (ie, uses wild cards) NAnt patterns.</summary>
            <param name="nantPattern">The NAnt pattern to convert.  Absolute or relative paths.</param>
            <param name="absoluteFileName">Absolute pattern will return file name here.</param>
            <returns>The resulting regular expression. Absolute canonical path.</returns>
            <remarks>
            	<para>Only NAnt patterns that contain a wild card character as converted to regular expressions.
            	Explicit patterns are expected to be handled using absoluteFileName.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Util.ImplicitPattern.ScanDirectoryOpt(System.String,NAnt.Core.Util.Pattern.RegexPattern,System.Collections.Generic.List{NAnt.Core.Util.Pattern.RegexPattern},System.Collections.Specialized.StringCollection,System.Collections.Generic.List{System.String},System.Int32,System.Int32)">
            <summary>Searches a directory recursively for files and directories matching the search criteria</summary>
            <param name="directoryPath">Directory in which to search (absolute canonical path)</param>
            <param name="regexPattern">Regular expression to match</param>
            <param name="excludePatterns">List of regular expression patterns to exclude</param>
            <param name="excludeFileNames">List of explicit file names to exclude</param>
            <param name="matchingFiles"></param>
            <param name="recursion_level"></param>
            <param name="MaxRecursionLevel"></param>
        </member>
        <member name="M:NAnt.Core.Util.ImplicitPattern.ConvertPattern(System.String,System.String@)">
            <summary>Adds regular expressions for any non-explicit (ie, uses wild cards) NAnt patterns.</summary>
            <param name="nantPattern">The NAnt pattern to convert.  Absolute or relative paths.</param>
            <param name="absoluteFileName">Absolute pattern will return file name here.</param>
            <returns>The resulting regular expression. Absolute canonical path.</returns>
            <remarks>
            	<para>Only NAnt patterns that contain a wild card character as converted to regular expressions.
            	Explicit patterns are expected to be handled using absoluteFileName.</para>
            </remarks>
        </member>
        <member name="M:NAnt.Core.Util.ImplicitPattern.ParseSearchDirectoryAndPatternOpt(System.String)">
            <summary>Given a NAnt search pattern returns a search directory and an regex search pattern.</summary>
            <param name="originalNAntPattern">NAnt search pattern (relative to the base directory OR absolute, relative paths referring to parent directories ( ../ ) also supported)</param>   
        </member>
        <member name="T:NAnt.Core.Util.PatternFactory">
            <summary>singleton class for creating patterns</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String)">
            <summary>Creates a pattern with asis bit set to true and default basedir.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String,System.Boolean)">
            <summary>Creates a pattern with default basedir.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String,System.String)">
            <summary>Creates a pattern with asis bit set to false.</summary>
        </member>
        <member name="M:NAnt.Core.Util.PatternFactory.CreatePattern(System.String,System.String,System.Boolean)">
            <summary>Creates a pattern.</summary>
        </member>
        <member name="T:NAnt.Core.Util.ProcessRunner">
             <remarks>
             Launches a process and maintains two threads for reading from the processes stdout and stderr.
             Uses the process watcher instance to maintain a list of process ids. Useful for cleaning up processes
             when terminating.
             When an instance of a process runner goes out of scope the process will be automatically destroyed along
             with any child processes it launched.
             </remarks>
             <example>
            		Process p = new Process;  // prepare a process
            		ProcessRunner run = new ProcessRunner(p); // attach process to process runner
            
            		run.ProcessEvent += new EventHandler; // handle process events
            		run.StdOutputEvent += new EventHandler; // handle output events
            
            		try
            		{
            			timeout = run.Start()
            
            			if ( timeout )
            				// report any errors
            		}
            		catch( e )
            			// report any errors
            
            		// when process runner leaves scope process and child processes will be destroyed
             </example>
        </member>
        <member name="M:NAnt.Core.Util.Program.LogStdOut(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stdout</summary>
        </member>
        <member name="M:NAnt.Core.Util.Program.LogStdErr(NAnt.Core.Util.OutputEventArgs)">
            <summary>Callback for procrunner stderr</summary>
        </member>
        <member name="M:NAnt.Core.Util.StringUtil.MinimumEditDistance(System.String,System.String,System.Int32)">
            <summary>
            Calculates the Minimum Edit Distance between two strings in order to quantify the similarity of two strings.
            Minimum Edit Distance is the number of insertions, deletions and substitutions required to convert one string into another.
            Levenshtein Distance is Minimum Edit Distance when the substitution cost is set to 2.
            </summary>
            <param name="source">The source string</param>
            <param name="target">The target string</param>
            <param name="substitutionCost">
            The cost applied when a character is substituted.
            When the substitution cost is set to 2 it is called Levenshtein Distance.
            </param>
        </member>
        <member name="T:NAnt.Core.Util.ThreadRunner">
            <summary>
            </summary>
        </member>
        <member name="T:NAnt.Core.Util.UriFactory">
            <summary>Helper class for creating valid URIs.</summary>
        </member>
        <member name="M:NAnt.Core.Util.UriFactory.CreateUri(System.Uri)">
            <remarks>
            The basic idea of this method is to remove the scheme from the file name before
            passing it to the Uri constructor. Thus, the constructor will treat the constructor
            as a file and not a URI, given us the result we desire.
            
            The build file needs to contain a '#' in the filename for the test below. 
            I cant add this test to perforce because it wont accept filenames with '#'.
            </remarks>
            <example>
            <project>
            <fail 
                message='Uri class returned invalid result for buildfile path.'
                if='@{StrIndexOf("${nant.project.buildfile}", "Bug.#653.build")} == -1' />
            </project>
            </example>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetChildElementsByName(System.Xml.XmlNode,System.String)">
            <summary>Loops through immediate child elements and returns all children that matches the given name</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetChildElementByName(System.Xml.XmlNode,System.String)">
            <summary>Loops through immediate child elements and returns the first that matches the given name</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetChildElementByNameAndAttribute(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>Loops through immediate child elements and returns the first that match the given name 
            and has the given attribute</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetOrAddElement(System.Xml.XmlDocument,System.String,System.String)">
            <summary>Gets a child element or adds it if missing. If no namespace is provided it will
            only search immediate child nodes.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetOrAddElement(System.Xml.XmlNode,System.String,System.String)">
            <summary>Searches immediate child elements for one with the given name and adds it if not found.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetOrAddElementWithAttributes(System.Xml.XmlNode,System.String,System.String,System.String)">
            <summary>Searches immediate child elements for one with the given name and attribute and adds it if not found</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.SetAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>Sets an attribute value of a node, or adds a new attribute if an attribute
            by the given name does not exist.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.SetAttributeIfMissing(System.Xml.XmlNode,System.String,System.String)">
            <summary>Sets the value of a node's attribute only if the attribute's value
            is equal to null.</summary>
        </member>
        <member name="M:NAnt.Core.Util.XmlExtensions.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>Returns the value of an attribute, or a provided default value if either the
            node or attribute are null.</summary>
        </member>
        <member name="M:NAnt.Core.Writers.CachedWriter.Flush">
            <summary>
            Write memory content to the file. If file exist and content did not change leave file intact.
            </summary>
        </member>
        <member name="T:NAnt.Win32Tasks.Functions.RegistryFunctions">
            <summary>Collection of windows registry manipulation routines.</summary>
        </member>
        <member name="M:NAnt.Win32Tasks.Functions.RegistryFunctions.RegistryGetValue(NAnt.Core.Project,Microsoft.Win32.RegistryHive,System.String,System.String)">
            <summary>
            Get the specified value of the specified key in the windows registry.
            </summary>
            <param name="project" />
            <param name="hive">
            The top-level node in the windows registry. Possible values are: LocalMachine, Users, 
            CurrentUser, and ClassesRoot.
            </param>
            <param name="key">The name of the windows registry key.</param>
            <param name="value">The name of the windows registry key value.</param>
            <returns>The specified value of the specified key in the windows registry.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- HKEY_LOCAL_MACHINE\SOFTWARE\Electronic Arts\Framework -->
    <echo message="@{RegistryGetValue('LocalMachine', 'SOFTWARE\Electronic Arts\Framework', 'Path')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Win32Tasks.Functions.RegistryFunctions.RegistryGetValue(NAnt.Core.Project,Microsoft.Win32.RegistryHive,System.String)">
            <summary>
            Get the default value of the specified key in the windows registry.
            </summary>
            <param name="project" />
            <param name="hive">
            The top-level node in the windows registry. Possible values are: LocalMachine, Users, 
            CurrentUser, and ClassesRoot.
            </param>
            <param name="key">The name of the windows registry key.</param>
            <returns>The default value of the specified key in the windows registry.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- HKEY_LOCAL_MACHINE\SOFTWARE\Electronic Arts\Framework -->
    <echo message="@{RegistryGetValue('LocalMachine', 'SOFTWARE\Electronic Arts\Framework')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="M:NAnt.Win32Tasks.Functions.RegistryFunctions.RegistryKeyExists(NAnt.Core.Project,Microsoft.Win32.RegistryHive,System.String)">
            <summary>
            Checks that the specified key exists in the windows registry.
            </summary>
            <param name="project" />
            <param name="hive">
            The top-level node in the windows registry. Possible values are: LocalMachine, Users, 
            CurrentUser, and ClassesRoot.
            </param>
            <param name="key">The name of the windows registry key.</param>
            <returns>True if the specified registry key exists, otherwise false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- HKEY_LOCAL_MACHINE\SOFTWARE\Electronic Arts\Framework -->
    <echo message="@{RegistryKeyExists('LocalMachine', 'SOFTWARE\Electronic Arts\Framework')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Win32Tasks.Functions.RegistryFunctions.RegistryValueExists(NAnt.Core.Project,Microsoft.Win32.RegistryHive,System.String,System.String)">
            <summary>
            Checks that the specified value of the specified key exists in the windows registry.
            </summary>
            <param name="project" />
            <param name="hive">
            The top-level node in the windows registry. Possible values are: LocalMachine, Users, 
            CurrentUser, and ClassesRoot.
            </param>
            <param name="key">The name of the windows registry key.</param>
            <param name="value">The name of the windows registry key value.</param>
            <returns>True if the value exists, otherwise false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- HKEY_LOCAL_MACHINE\SOFTWARE\Electronic Arts\Framework -->
    <echo message="@{RegistryValueExists('LocalMachine', 'SOFTWARE\Electronic Arts\Framework', 'Path')}" />
</project>
]]>
</code>
</example>        
        </member>
        <member name="M:NAnt.Win32Tasks.Functions.RegistryFunctions.RegistryValueExists(NAnt.Core.Project,Microsoft.Win32.RegistryHive,System.String)">
            <summary>
            Checks that the default value of the specified key exists in the windows registry.
            </summary>
            <param name="project" />
            <param name="hive">
            The top-level node in the windows registry. Possible values are: LocalMachine, Users, 
            CurrentUser, and ClassesRoot.
            </param>
            <param name="key">The name of the windows registry key.</param>
            <returns>True if the default value exists, otherwise false.</returns>
            <example>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <!-- HKEY_LOCAL_MACHINE\SOFTWARE\Electronic Arts\Framework -->
    <echo message="@{RegistryValueExists('LocalMachine', 'SOFTWARE\Electronic Arts\Framework')}" />
</project>
]]>
</code>
</example>
        </member>
        <member name="T:NAnt.ZipTasks.UnZipTask">
            <summary>
            Unzip the contents of a zip file to a specified directory.
            </summary>
            <example>
<para>Zip and UnZip files to a directory.</para>
<code>
<![CDATA[
<project xmlns="schemas/ea/framework3.xsd">
    <zip zipfile="backup.zip">
        <fileset basedir=".">
            <includes name="*.*"/>
            <excludes name="backup.zip"/>
        </fileset>
    </zip>
    
    <unzip zipfile="backup.zip" outdir="backup" />
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.ZipTasks.UnZipTask.ZipFileName">
            <summary>The full path to the zip file.</summary>
        </member>
        <member name="P:NAnt.ZipTasks.UnZipTask.OutDir">
            <summary>The full path to the destination folder.</summary>
        </member>
        <member name="P:NAnt.ZipTasks.UnZipTask.PreserveSymlink">
            <summary>
            If zip file contains entry with symlink, preserve the symlink if possible (default true).
            </summary>
        </member>
        <member name="T:NAnt.ZipTasks.ZipTask">
            <summary>
            Creates a zip file from a specified fileset.
            </summary>
            <remarks>
              <para>Uses <a href="http://www.icsharpcode.net/OpenSource/NZipLib/">NZipLib</a>, an open source Zip/GZip library written entirely in C#.</para>
            <para>Full zip functionality is not available; all you can do
            is to create a zip file from a fileset.</para>
            </remarks>
            <example>
<para>Zip all files in the subdirectory <c>build</c> to <c>backup.zip</c>.</para>
<code>
<![CDATA[
<project default="DoZip">
    <target name="DoZip">
        <zip zipfile="backup.zip">
            <fileset basedir=".">
                <includes name="*.*"/>
                <excludes name="backup.zip"/>
            </fileset>
        </zip>
    </target>
</project>
]]>
</code>
</example>
        </member>
        <member name="P:NAnt.ZipTasks.ZipTask.ZipFileName">
            <summary>The zip file to create. Use a qualified name to create the zip file in a 
            location which is different than the current working directory.</summary>
        </member>
        <member name="P:NAnt.ZipTasks.ZipTask.ZipLevel">
            <summary>Desired level of compression Default is 6.</summary>
            <value>0 - 9 (0 - STORE only, 1-9 DEFLATE (1-lowest, 9-highest))</value>
        </member>
        <member name="P:NAnt.ZipTasks.ZipTask.ZipEntryDir">
            <summary>Prepends directory to each zip file entry.</summary>
        </member>
        <member name="P:NAnt.ZipTasks.ZipTask.ZipFileSet">
            <summary>The set of files to be included in the archive.</summary>
        </member>
        <member name="P:NAnt.ZipTasks.ZipTask.UseModTime">
            <summary>Preserve last modified timestamp of each file.</summary>
        </member>
        <member name="T:NAnt.Shared.Properties.PackageProperties">
            <summary>
            PackageTask properties.
            </summary>
        </member>
        <member name="M:EA.SharpZipLib.ZipLib.UnzipSpecificFile(System.String,System.String,System.String)">
            <summary>
            Unzips a specific file from a zip file to the output target dir
            </summary>
            <param name="pathToZip">The full path to the zip file.</param>
            <param name="targetDir">The full path to the destination folder.</param>
            <param name="fileName">If file to unzip.</param>
        </member>
        <member name="M:EA.SharpZipLib.ZipLib.UnzipFile(System.String,System.String,System.Boolean)">
            <summary>
            Unzip a file.
            </summary>
            <param name="zipFileName">The full path to the zip file.</param>
            <param name="targetDir">The full path to the destination folder.</param>
            <param name="preserveSymlink">If zip entry contain symlink, preserve that symlink if possible.</param>
        </member>
        <member name="M:EA.SharpZipLib.ZipLib.UnzipStream(System.IO.Stream,System.String)">
            <summary>
            Unzip an input stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="targetDir">The full path to the destination folder.</param>
        </member>
        <member name="M:EA.SharpZipLib.ZipLib.UnzipStream(System.IO.Stream,System.String,System.Int32,System.Boolean)">
            <summary>
            Unzip an input stream.
            </summary>
            <param name="stream">The stream.</param>
            <param name="targetDir">The full path to the destination folder.</param>
            <param name="entryCount">The total number of entries.</param>
            <param name="preserveSymlink">If zip entry contains symlink, preserve that symlink if possible.</param>
        </member>
        <member name="M:EA.SharpZipLib.ZipLib.ZipFile(System.Collections.Specialized.StringCollection,System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Create a zip file.
            </summary>
            <param name="fileNames">The collection of files to add to the zip file.</param>
            <param name="baseDirectory">The full path to the basedirectory from which each zipentry will be made relative to.</param>
            <param name="zipFileName">The full path to the zip file.</param>
            <param name="zipEntryDir">The base path to prepend to each zip entry, should be relative. May be null for none.</param>
            <param name="zipLevel">Compression level. May be 0 for default compression.</param>
            <param name="useModTime">Preserve last modified timestamp of each file.</param>
        </member>
    </members>
</doc>
