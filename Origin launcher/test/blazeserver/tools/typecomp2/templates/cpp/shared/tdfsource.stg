group tdfsource : servercommon;

typedef() ::= ""
includeFile(node) ::= ""
bitfieldBoolMember() ::= ""
bitfield() ::= ""

file(fileNode) ::= <<
<includeFiles()>

//These allocation defines are different on the client and the server
#if defined(BLAZE_CLIENT_SDK)
#define BLAZE_DELETE_MGID(_mg, _ptr) BLAZE_DELETE(_mg, _ptr)
#define BLAZE_FREE_MGID(_mg, _ptr) BLAZE_FREE(_mg, _ptr)
#else
#define BLAZE_DELETE_MGID(_mg, _ptr) delete _ptr
#define BLAZE_FREE_MGID(_mg, _ptr) BLAZE_FREE(_ptr)
#endif

<fileNode.Defs:{<defineHelper(node=it)>};  separator="\n\n">

#undef BLAZE_DELETE_MGID
#undef BLAZE_FREE_MGID


>>

includeFiles() ::= <<
#include "framework/blaze.h"
#include "<fileNode.InputFile;format="baseFile">.h"
#include "framework/util/shared/blazestring.h"
#include "framework/util/shared/util.h"
#include "framework/tdf/tdf.h"
>>

namespace(node) ::= <<
namespace <node.Name>
{
<node.Defs:{<defineHelper(node=it)>};  separator="\n\n">

<if(node.ExplicitRegistrationRequired)>
void <fileNode.InputFile;format="baseFile">RegisterTdfs()
{
    <node.Defs:{<tdfRegistrationHelper(node=it)>}>
}

void <fileNode.InputFile;format="baseFile">DeregisterTdfs()
{
    <node.Defs:{<tdfDeregistrationHelper(node=it)>}>
}
<\n>
<endif>
} //<node.Name>
>>

defineHelper(node) ::= "<if(node.Category)><({define<node.Category>})()><elseif(node.Filename)><includeFile(node=node)><else><namespace(node=node)><endif>"
defineENUM() ::= "<enum(...)>"
defineBITFIELD() ::= "<bitfield(...)>"
defineCLASS() ::= "<if(!node.IsFwdDecl)><class(...)><endif>"
defineUNION() ::= "<union(...)>"
defineCONST() ::= "<if(node.IsString)><stringConst(...)><else><const(...)><endif>"
defineTYPEDEF() ::= "<typedef(...)>"
defineNAMESPACE() ::="<namespace(...)>"
defineCUSTOM_ATTRIBUTE() ::=  "<custom_attribute(...)>"


custom_attribute(node) ::= <<

#ifdef BLAZE_ENABLE_CUSTOM_TDF_ATTRIBUTES
void <node.Name>Attribute::addAttributeToMap(uint32_t tdfId, uint32_t tag, <node.Name>Attribute &attr)
{
    getMap()[(uint64_t)tdfId \<\< 32 | tag] = &attr;
};

<node.Name>Attribute::<node.Name>AttributeMap& <node.Name>Attribute::getMap()
{
    static <node.Name>AttributeMap sMap;
    return sMap;
};

const <node.Name>Attribute* <node.Name>Attribute::get<node.Name>Attribute(const Tdf& tdf, uint32_t tagId)
{
    <node.Name>AttributeMap::const_iterator attributeIt= getMap().find((uint64_t)tdf.getTdfId() \<\< 32 | tagId);
    if (attributeIt!=getMap().end())
    {
        return attributeIt->second;
    }
    return NULL;
};
#endif //BLAZE_ENABLE_CUSTOM_TDF_ATTRIBUTES

>>

///////////////////////////////////
// class Templates
//////////////////////////////////

defaultMemGroup() ::= "DEFAULT_BLAZE_MEMGROUP"

class(node) ::= <<
const Blaze::MemoryGroupId <printTypeRef(node)>::MEM_GROUP = (<defaultMemGroup()>);
<node.Defs:{<defineHelper(node=it)>};  separator="\n\n">
<if(node.Members)><classTagInfo()>
<node.Members:customAttributeInstanceMapInitHelper(member=it);separator="\n">
<endif><\n><\n>
<if(node.tdfid)>
<if(!node.ExplicitRegistration)>Blaze::TdfRegistration <printTypeRef(node)>::mTdfRegistration("<printTypeRefFullScope(node)>", Blaze::TdfCreator(&<printTypeRef(node)>::create), (Blaze::TdfId)<node.tdfid>);<\n>
<endif><endif>
<classConstructor()><\n>
<classTdfMemberInfo()><\n>

>>

customAttributeInstanceMapInitHelper(member) ::= <<
<if(member.CustomAttributeList)>
#ifdef BLAZE_ENABLE_CUSTOM_TDF_ATTRIBUTES
<member.CustomAttributeList:customAttributeInstanceAttribInit(attrib=it);separator="\n">
#endif //BLAZE_ENABLE_CUSTOM_TDF_ATTRIBUTES
<endif>
>>

customAttributeInstanceAttribInit(attrib) ::= <<
static <attrib.AttributeName>Attribute s<node.Name><member.Name>Attribute(<node.Name>::TDF_ID, <memberTagHex()> /*tagid*/, <attrib.AttributeMembers:{<it>};separator=", ">);
>>

//generates the tag info for the class
classTagInfo() ::= <<
#if BLAZE_TDF_TAG_INFO_CHECK(<if(node.reflect)>1<else>0<endif>)
const Blaze::TdfTagInfo <printTypeRef(node)>::mTagInfo[<length(node.SortedMembers)>] = {
<node.SortedMembers:{member|
    Blaze::TdfTagInfo(<memberTagHex()>, "<member.ParseName>", <member.SortedMemberNumber>
#ifdef BLAZE_ENABLE_RECONFIGURE_TAG_INFO
        , <memberReconfigurable()>
#endif
#ifdef BLAZE_ENABLE_EXTENDED_TDF_TAG_INFO
        , "<if(member.description)><member.description><else>Field needs a description.<endif>", "<memberDefault()>", <member.PrintFormat>
#endif
        )}; separator=",\n">
};

const Blaze::TdfTagInfoMap <printTypeRef(node)>::mTagInfoMap(<printTypeRef(node)>::mTagInfo, <length(node.SortedMembers)>);
#endif // BLAZE_TDF_TAG_INFO_CHECK
>>

memberDefault() ::= "<if(member.default)><member.default><else><({memberDefault<member.TypeRef.Symbol.ActualCategory>})()><endif>"
memberReconfigurable() ::= "<if(member.reconfigurable)><member.reconfigValue><else>Blaze::TdfTagInfo::RECONFIGURE_DEFAULT<endif>"

memberDefaultLIST() ::= <<
<if(member.TypeRef.ActualSymbol.ValueType.ActualCategoryString)>
<!<elseif(member.TypeRef.ActualSymbol.ValueType.ActualCategoryEnum)><member.TypeRef.ActualSymbol.ValueType.Symbol.Scope.ScopeName>::<first(member.TypeRef.Actual.ValueType.Members).Name> !>
<else>0
<endif>
<! <({memberDefault<member.TypeRef.ActualSymbol.ValueType.ActualCategory>})()> !>
>>
memberDefaultMAP() ::= "0"
memberDefaultSTRING() ::= ""
memberDefaultENUM() ::= "<printTypeList(member.TypeRef.ActualSymbolScopeName)><if(member.TypeRef.ActualSymbolScopeName)>::<endif><first(member.TypeRef.ActualSymbol.Members).ActualSymbol.Name>"
memberDefaultINT_PRIMITIVE() ::= "0"
memberDefaultFLOAT_PRIMITIVE() ::= "0.0f"
memberDefaultCLASS() ::= "0"
memberDefaultVARIABLE() ::= "NULL"
memberDefaultBLOB() ::= "0"
memberDefaultBITFIELD() ::= "0"
memberDefaultUNION() ::= "0"
memberDefaultBLAZE_OBJECT_TYPE() ::= ""
memberDefaultBLAZE_OBJECT_ID() ::= ""
memberDefaultTIMEVALUE() ::= ""

classConstructor() ::= <<
<printTypeRef(node)>::<node.Name>(Blaze::MemoryGroupId memGroupId) :
<if(node.trackChanges)>
#ifdef BLAZE_ENABLE_TDF_CHANGE_TRACKING
    Blaze::TdfWithChangeTracking\<<length(node.Members)>\>(memGroupId)<node.Members:classMemberInitHelper(member=it)>
#else
    Blaze::Tdf(memGroupId)<node.Members:classMemberInitHelper(member=it)>
#endif //BLAZE_ENABLE_TDF_CHANGE_TRACKING
<else>
    Blaze::Tdf(memGroupId)<node.Members:classMemberInitHelper(member=it)>
<endif>

{
    <node.Members:classMemberConstructHelper(member=it)>
}
>>

classMemberInitHelper(member) ::= "<({classMemberInit<member.TypeRef.Symbol.ActualCategory>})()><classMemberRefInit()>"

classMemberRefInit() ::= "<if(member.allowref)>,<\n>    m<member.Name>Ptr(&m<member.Name>)<endif>"

//indirect templates for the class initializer
classMemberInit() ::= ""
classMemberInitMAP() ::= ",<\n>    m<member.Name>(memGroupId, MEM_NAME(memGroupId, \"<node.Name>::m<member.Name>\")<if(member.TypeRef.ActualSymbol.ValueType.ActualCategoryStruct)>,<if(member.ownsmem)>true<else>false<endif><endif>)"
classMemberInitLIST() ::= "<classMemberInitMAP()>"
classMemberInitINT_PRIMITIVE() ::= ",<\n>    m<member.Name>(<if(member.default)><member.default><else>0<endif>)"
classMemberInitFLOAT_PRIMITIVE() ::= ",<\n>    m<member.Name>(<if(member.default)><member.default><else>0.0f<endif>)"
classMemberInitVARIABLE() ::= ",<\n> m<member.Name>(memGroupId, <if(member.isOwned)><member.isOwned><else>true<endif>)"
classMemberInitSTRING() ::= ",<\n>    m<member.Name>(<if(member.default)>\"<member.default>\", <endif>memGroupId)"
classMemberInitENUM() ::= ",<\n>    m<member.Name>(<memberDefault()>)"
classMemberInitCLASS() ::= "<if(!member.TypeRef.ActualSymbol.IsFwdDecl)>,<\n>    m<member.Name>(memGroupId)<endif>"
classMemberInitUNION() ::= "<classMemberInitCLASS()>"
classMemberInitBITFIELD() ::= ""
classMemberInitBLOB() ::= "<classMemberInitCLASS()>"
classMemberInitTYPEDEF() ::= ""
classMemberInitBLAZE_OBJECT_TYPE() ::= ",<\n>    m<member.Name>(<if(member.default)>BlazeObjectType::parseString(\"<member.default>\")<endif>)"
classMemberInitBLAZE_OBJECT_ID() ::= ",<\n>    m<member.Name>(<if(member.default)>BlazeObjectId::parseString(\"<member.default>\")<endif>)"
classMemberInitTIMEVALUE() ::= ",<\n>    m<member.Name>(<if(member.default)>\"<member.default>\", TimeValue::TIME_FORMAT_INTERVAL<else>0<endif>)"



//indirect templates for the class constructor
classMemberConstructHelper(member) ::= "<({classMemberConstruct<member.TypeRef.Symbol.ActualCategory>})()>"
classMemberConstruct() ::= ""

classMemberConstructLIST() ::= <<
<if(member.TypeRef.ActualSymbol.ReserveSize)>
<if(member.TypeRef.ActualSymbol.FillList)>
m<member.Name>.initVector(<printTypeList(member.TypeRef.ActualScopedAttributes.ReserveSizeConst)><member.TypeRef.ActualSymbol.ReserveSizeValue>);<\n>
<else>
m<member.Name>.reserve(<printTypeList(member.TypeRef.ActualScopedAttributes.ReserveSizeConst)><member.TypeRef.ActualSymbol.ReserveSizeValue>);<\n>
<endif>
<endif>

>>

classMemberConstructMAP() ::= ""
classMemberConstructINT_PRIMITIVE() ::= ""
classMemberConstructFLOAT_PRIMITIVE() ::= ""
classMemberConstructVARIABLE() ::= ""
classMemberConstructSTRING() ::= ""
classMemberConstructENUM() ::= ""
classMemberConstructCLASS() ::= ""
classMemberConstructUNION() ::= ""
classMemberConstructBITFIELD() ::= ""
classMemberConstructBLOB() ::= ""
classMemberConstructTYPEDEF() ::= ""
classMemberConstructBLAZE_OBJECT_TYPE() ::= ""
classMemberConstructBLAZE_OBJECT_ID() ::= ""
classMemberConstructTIMEVALUE() ::= ""

classTdfMemberInfo() ::= <<
<if(node.SortedMembers)>
const <printTypeRef(node)>::TdfMemberInfoDefinition <printTypeRef(node)>::<node.Name;format="toUpper">_TDF_MEMBER_INFO = {
    <node.SortedMembers:classMemberTdfVHelper(member=it);separator=",\n">
};

const Blaze::TdfMemberInfo *<printTypeRef(node)>::getTdfMemberInfo() const
{
    return (const Blaze::TdfMemberInfo*)(const char8_t*)&<node.Name;format="toUpper">_TDF_MEMBER_INFO; // cast to (const char8_t*) solely to avoid strict-aliasing warning on some compilers (SN in particular)
}
<endif>
>>

///////////////////////////////////
// Union Templates
//////////////////////////////////

union(node) ::= <<
const Blaze::MemoryGroupId <printTypeRef(node)>::MEM_GROUP = (<defaultMemGroup()>);
<unionTagInfo()><\n>
<unionConstructor()><\n>
<unionDestructor()><\n>
<unionVisit()><\n>
<unionIsSet()>



<unionDelete()><\n>
<if(node.Members)>
<unionReflection()><\n>
<endif>
<node.Defs:{<defineHelper(node=it)>};  separator="\n\n">
>>

//generates the tag info for the class
unionTagInfo() ::= <<
const Blaze::TdfTagInfo <printTypeRef(node)>::mTagInfo[<length(node.Members)>] = {
<node.Members:unionMemberTagInfo(); separator=",\n">
};
const Blaze::TdfTagInfoMap <printTypeRef(node)>::mTagInfoMap(<printTypeRef(node)>::mTagInfo, <length(node.Members)>);
>>

unionMemberTagInfo(member) ::= <<
    Blaze::TdfTagInfo(<memberTagHex()>, "m<member.Name>", MEMBER_<member.Name;format="toUpper">
#ifdef BLAZE_ENABLE_RECONFIGURE_TAG_INFO
        , <memberReconfigurable()>
#endif
#ifdef BLAZE_ENABLE_EXTENDED_TDF_TAG_INFO
        , "", "<memberDefault()>", <member.PrintFormat>
#endif
)
>>


unionConstructor() ::= <<
<printTypeRef(node)>::<node.Name>(Blaze::MemoryGroupId memGroupId)
    : Blaze::TdfUnion(memGroupId), mActiveMember(MEMBER_UNSET)
{
    <if(node.tdfid)>assert(!"Registration of UNION types is not supported");<endif>
}
>>


unionDestructor() ::= <<
<printTypeRef(node)>::~<node.Name>()
{
    switchActiveMember(MEMBER_UNSET);
}
>>

unionVisit() ::= <<
void <printTypeRef(node)>::visit(Blaze::TdfVisitor &visitor, Blaze::Tdf& rootTdf, const Tdf &referenceTdfUncasted)
{
    const <node.Name> &referenceTdf = (const <node.Name> &) referenceTdfUncasted;
    switch (mActiveMember)
    {
        <node.Members:unionVisitSwitchCase(member=it);separator="\n">
        default:
        {
            mActiveMember = MEMBER_UNSET;
            break;
        }
    }
}
<if(node.trackChanges)>
#ifdef BLAZE_ENABLE_TDF_CHANGE_TRACKING
void <printTypeRef(node)>::visitIfSet(Blaze::TdfVisitor &visitor, Blaze::Tdf& rootTdf, const Tdf &referenceTdfUncasted)
{
    if (isSet())
    {
        visit(visitor, rootTdf, referenceTdfUncasted);
    }
}
#endif //BLAZE_ENABLE_TDF_CHANGE_TRACKING
<endif>
>>

unionVisitSwitchCase(member) ::= <<
<if(!member.IsVariable)>
case MEMBER_<member.Name;format="toUpper">:
{
    <! invoke the appropriate template for the type  !>
    <unionMemberVisitHelper()>
    break;
}
<endif>
>>

unionGetSizeStringHelperString() ::= <<
case MEMBER_<member.Name;format="toUpper">
return strlen(get<member.Name>()) + 1;
>>

unionGetSizeStringHelperClass() ::= <<
case MEMBER_<member.Name;format="toUpper">
return strlen(get<member.Name>()) + 1;
>>

//Print out the membername of a union - so union member "foo" is "mFoo"
unionMemberDefName() ::= <<
m<member.Name; format="pascal">
>>


unionReflection() ::= <<
bool <printTypeRef(node)>::getValueByTag(uint32_t tag, Blaze::TdfBaseTypeValue& value, const Blaze::TdfMemberInfo** memberInfo, bool* memberSet) const
{
	if (memberInfo != NULL)
		*memberInfo = NULL;
    if (memberSet != NULL)
        *memberSet = false;

    if (((uint32_t) mActiveMember) != tag)
        return false;

    switch(tag)
    {
        <node.Members:unionReflectionHelper(member=it);separator="\n">

        default:
            return false;
    }
}
>>

unionReflectionHelper(member) ::= <<
case MEMBER_<member.Name;format="toUpper">:
    <({unionReflection<member.TypeRef.Symbol.ActualCategory>})()>
    return true;
>>
unionReflectionINT_PRIMITIVE() ::= "<unionReflectionPRIMITIVE()>"
unionReflectionFLOAT_PRIMITIVE() ::= "<unionReflectionPRIMITIVE()>"
unionReflectionPRIMITIVE() ::= "value.set(u.<unionMemberDefName()>);"
unionReflectionLIST() ::= "<unionReflectionSTRUCT()>"
unionReflectionMAP() ::= "<unionReflectionSTRUCT()>"
unionReflectionCLASS() ::= "<unionReflectionSTRUCT()>"
unionReflectionSTRING() ::= "<unionReflectionSTRUCT()>"
unionReflectionBLOB() ::= "<unionReflectionSTRUCT()>"
unionReflectionSTRUCT() ::= "value.set(*u.<unionMemberDefName()>);"



unionDelete() ::= <<
void <printTypeRef(node)>::switchActiveMember(uint32_t newActiveMember)
{
    switch(mActiveMember)
    {
        <node.Members:unionDeleteHelper(member=it);separator="\n">
        default:
        {
            break;
        }
    }

    switch(newActiveMember)
    {
        case MEMBER_UNSET:
        {
            mActiveMember = (Member) newActiveMember;
            break;
        }
        <node.Members:unionAllocHelper(member=it);separator="\n">
        default:
        {
            mActiveMember = MEMBER_UNSET;
            break;
        }
    }
}
>>

unionDeleteMember() ::= <<
<if(node.allocInPlace)>u.<unionMemberDefName()>->~<printTypeRef(member)>()<else>BLAZE_DELETE_MGID(mMemGroup, u.<unionMemberDefName()>)<endif>
>>
unionAllocMember() ::= <<
<if(node.allocInPlace)>new (mBuffer)<else> BLAZE_NEW_MGID(mMemGroup, "<node.Name>_UNIONALLOC_m<member.Name>")<endif> <printTypeRef(member)>(<if(member.TypeRef.ActualSymbol.CategoryString)>NULL, <endif>mMemGroup)
>>

unionDeleteHelper(member) ::= <<
case MEMBER_<member.Name;format="toUpper">:
{
    <({unionDelete<member.TypeRef.Symbol.ActualCategory>})()>
}
>>
unionDeleteINT_PRIMITIVE() ::= "break;"
unionDeleteFLOAT_PRIMITIVE() ::= "break;"
unionDeleteLIST() ::= <<
for(<printTypeRef(node.Name)>::iterator i = u.<unionMemberDefName()>->begin(), e = u.<unionMemberDefName()>->end(); i != e; i++)
{
    delete *i;
}
<unionDeleteMember()>;
u.<unionMemberDefName()> = NULL;
break;
>>

unionDeleteMAP() ::= <<
for(<printTypeRef(node.Name)>::iterator i = u.<unionMemberDefName()>->begin(), e = u.<unionMemberDefName()>->end(); i != e; i++)
{
    delete i->second;
}
<unionDeleteMember()>;
u.<unionMemberDefName()> = NULL;
break;
>>

unionDeleteSTRUCT() ::= <<
<unionDeleteMember()>;
u.<unionMemberDefName()> = NULL;
break;
>>
unionDeleteCLASS() ::= "<unionDeleteSTRUCT()>"
unionDeleteSTRING() ::= "<unionDeleteSTRUCT()>"
unionDeleteBLOB() ::= "<unionDeleteSTRUCT()>"

unionAllocHelper(member) ::= "<({unionAlloc<member.TypeRef.Symbol.ActualCategory>})()>"

unionAllocINT_PRIMITIVE() ::= "<unionAllocPRIMITIVE()>"
unionAllocFLOAT_PRIMITIVE() ::= "<unionAllocPRIMITIVE()>"
unionAllocPRIMITIVE() ::= <<
case MEMBER_<member.Name;format="toUpper">:
{
    mActiveMember = (Member) newActiveMember;
    break;
}
>>

unionAllocLIST() ::= "<unionAllocSTRUCT()>"
unionAllocMAP() ::= "<unionAllocSTRUCT()>"
unionAllocCLASS() ::= "<unionAllocSTRUCT()>"
unionAllocSTRING() ::= "<unionAllocSTRUCT()>"
unionAllocBLOB() ::= "<unionAllocSTRUCT()>"
unionAllocSTRUCT() ::= <<
case MEMBER_<member.Name;format="toUpper">:
{
    u.<unionMemberDefName()> = <unionAllocMember()>;
    mActiveMember = (Member) newActiveMember;
    break;
}
>>

unionIsSet() ::= <<
<if(node.trackChanges)>
#ifdef BLAZE_ENABLE_TDF_CHANGE_TRACKING
bool <printTypeRef(node)>::isSet() const
{
    if (TdfChangeTracker::isSet())
        return true;

    switch (mActiveMember)
    {
        <node.Members:unionIsSetSwitchCase(member=it);separator="\n">
        default:
        {
            return false;
            break;
        }
    }
    return false;
}

void <printTypeRef(node)>::clearIsSet()
{
    TdfChangeTracker::clearIsSet();
    switch (mActiveMember)
    {
        <node.Members:unionClearIsSetSwitchCase(member=it);separator="\n">
        default:
        {
            mActiveMember = MEMBER_UNSET;
            break;
        }
    }
}

void <printTypeRef(node)>::markSet()
{
    TdfChangeTracker::markSet();
    switch (mActiveMember)
    {
        <node.Members:unionMarkSetSwitchCase(member=it);separator="\n">
        default:
        {
            mActiveMember = MEMBER_UNSET;
            break;
        }
    }
}
#endif //BLAZE_ENABLE_TDF_CHANGE_TRACKING
<endif>
>>

unionIsSetSwitchCase(member) ::= <<
case MEMBER_<member.Name;format="toUpper">:
{
    <({unionMemberIsSet<member.TypeRef.Symbol.ActualCategory>})()>
    break;
}
>>

unionMemberIsSet() ::= ""
unionMemberIsSetSTRING() ::= ""
unionMemberIsSetENUM() ::= ""
unionMemberIsSetINT_PRIMITIVE() ::= ""
unionMemberIsSetFLOAT_PRIMITIVE() ::= ""
unionMemberIsSetUNION() ::= "if (u.m<member.Name>->isSet()) return true;"
unionMemberIsSetBITFIELD() ::= ""
unionMemberIsSetCLASS() ::= "if (u.m<member.Name>->isSet()) return true;"
unionMemberIsSetVARIABLE() ::= "if (u.m<member.Name>->isSet()) return true;"
unionMemberIsSetTYPEDEF() ::= ""
unionMemberIsSetBLOB() ::= "if (u.m<member.Name>->isSet()) return true; "
unionMemberIsSetCONST() ::= ""
unionMemberIsSetBLAZE_OBJECT_TYPE() ::= ""
unionMemberIsSetBLAZE_OBJECT_ID() ::= ""
unionMemberIsSetTIMEVALUE() ::= ""
unionMemberIsSetMAP() ::= "if (!u.m<member.Name>->isSet()) return true;"
unionMemberIsSetLIST() ::= "if (!u.m<member.Name>->isSet()) return true;"

unionClearIsSetSwitchCase(member) ::= <<
<if(!member.IsVariable)>
case MEMBER_<member.Name;format="toUpper">:
{
    <({unionMemberClearIsSet<member.TypeRef.Symbol.ActualCategory>})()>
    break;
}
<endif>
>>

unionMemberClearIsSet() ::= ""
unionMemberClearIsSetSTRING() ::= ""
unionMemberClearIsSetENUM() ::= ""
unionMemberClearIsSetINT_PRIMITIVE() ::= ""
unionMemberClearIsSetFLOAT_PRIMITIVE() ::= ""
unionMemberClearIsSetUNION() ::= "u.m<member.Name>->clearIsSet();"
unionMemberClearIsSetBITFIELD() ::= ""
unionMemberClearIsSetCLASS() ::= "u.m<member.Name>->clearIsSet();"
unionMemberClearIsSetVARIABLE() ::= "u.m<member.Name>->clearIsSet();"
unionMemberClearIsSetTYPEDEF() ::= ""
unionMemberClearIsSetBLOB() ::= "u.m<member.Name>->clearIsSet();"
unionMemberClearIsSetCONST() ::= ""
unionMemberClearIsSetBLAZE_OBJECT_TYPE() ::= ""
unionMemberClearIsSetBLAZE_OBJECT_ID() ::= ""
unionMemberClearIsSetTIMEVALUE() ::= ""
unionMemberClearIsSetMAP() ::= "u.m<member.Name>->clearIsSet();"
unionMemberClearIsSetLIST() ::= "u.m<member.Name>->clearIsSet();"


unionMarkSetSwitchCase(member) ::= <<
<if(!member.IsVariable)>
case MEMBER_<member.Name;format="toUpper">:
{
    <({unionMemberMarkSet<member.TypeRef.Symbol.ActualCategory>})()>
    break;
}
<endif>
>>

unionMemberMarkSet() ::= ""
unionMemberMarkSetSTRING() ::= ""
unionMemberMarkSetENUM() ::= ""
unionMemberMarkSetINT_PRIMITIVE() ::= ""
unionMemberMarkSetFLOAT_PRIMITIVE() ::= ""
unionMemberMarkSetUNION() ::= "u.m<member.Name>->markSet();"
unionMemberMarkSetBITFIELD() ::= ""
unionMemberMarkSetCLASS() ::= "u.m<member.Name>->markSet();"
unionMemberMarkSetVARIABLE() ::= "u.m<member.Name>->markSet();"
unionMemberMarkSetTYPEDEF() ::= ""
unionMemberMarkSetBLOB() ::= "u.m<member.Name>->markSet();"
unionMemberMarkSetCONST() ::= ""
unionMemberMarkSetBLAZE_OBJECT_TYPE() ::= ""
unionMemberMarkSetBLAZE_OBJECT_ID() ::= ""
unionMemberMarkSetTIMEVALUE() ::= ""
unionMemberMarkSetMAP() ::= "u.m<member.Name>->markSet();"
unionMemberMarkSetLIST() ::= "u.m<member.Name>->markSet();"

///////////////////////////////////
// Enum Templates
//////////////////////////////////

enum(node) ::= <<
<enumTable()>

<enumToString()>

<enumParse()>

<enumGetMap()>
>>

enumTable() ::= <<
static const Blaze::TdfEnumInfo <enumTableNameHelper(suffix="EnumInfo")>[<length(node.Members)>] = {
    <node.Members:{\{ "<it.Name>", (int32_t)<printTypeRef(it)> \}}; separator=",\n">
};
const Blaze::TdfEnumMap <enumTableNameHelper(suffix="EnumMap")>(<enumTableNameHelper(suffix="EnumInfo")>, <length(node.Members)>);
>>

enumToString() ::= <<
const char8_t *<printTypeRef(node)>ToString(<node.Name> value)
{
    const char8_t* name = NULL;
    <enumTableNameHelper(suffix="EnumMap")>.findByValue((int32_t)value, &name);
    return name;
}
>>

enumParse() ::= <<
bool8_t <if(node.TypeRef.SymbolScopeName)><printTypeList(node.TypeRef.SymbolScopeName)>::<endif>Parse<node.Name>(const char8_t* name, <node.Name> &result)
{
    <if(node.Members)>    return <enumTableNameHelper(suffix="EnumMap")>.findByName(name, (int32_t&) result);
    <else>    return false;
    <endif>
}
>>

enumGetMap() ::= <<
const Blaze::TdfEnumMap& <if(node.TypeRef.SymbolScopeName)><printTypeList(node.TypeRef.SymbolScopeName)>::<endif>Get<node.Name>EnumMap()
{
     return <enumTableNameHelper(suffix="EnumMap")>;
}

const Blaze::TdfEnumMap <if(node.TypeRef.SymbolScopeName)><printTypeList(node.TypeRef.SymbolScopeName)>::<endif><enumTableNameHelper(suffix="EnumMapRef")> = <enumTableNameHelper(suffix="EnumMap")>;
>>

enumTableNameHelper(suffix) ::= "s<node.TypeRef.ScopedSymbolName:{<it>};separator=\"_\">_<suffix>"
enumGetMapNameForTypeHelper(parentTypeRef, typeref) ::= "<if(typeref.ActualSymbolScopeName)><printTypeList(typeref.ActualSymbolScopeName)>::<elseif(parentTypeRef.ActualSymbolScopeName)><printTypeList(parentTypeRef.ActualSymbolScopeName)>::<endif>Get<typeref.ActualSymbol.Name>EnumMap()"
enumGetMapNameForMemberHelper() ::= "<enumGetMapNameForTypeHelper(typeref=member.TypeRef)>"

///////////////////////////////////
// Const Templates
//////////////////////////////////
stringConst(node) ::= "const char8_t *<printTypeRef(node)> = \"<node.Value>\";"

const(node) ::= ""


///////////////////////////////////
// Visit Helpers
//////////////////////////////////
classMemberVisitIfSetHelper(member) ::= "if (referenceTdf.is<member.Name>Set()) { <({classMemberVisit<member.TypeRef.Symbol.ActualCategory>})()> }"
classMemberVisit() ::= ""
classMemberVisitMAP() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()>);"
classMemberVisitLIST() ::= "<classMemberVisitMAP()>"
classMemberVisitINT_PRIMITIVE() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()>, <memberDefault()>);"
classMemberVisitFLOAT_PRIMITIVE() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()>, <memberDefault()>);"
classMemberVisitENUM() ::= <<
// temporary value used to avoid casting an enum to (int32_t&)
// which would break compiler strict aliasing rules (GOSOPS-18815)
int32_t <visitMemberNameHelper()>TempVal = (int32_t) <visitMemberNameHelper()>;
const int32_t <visitMemberNameHelper()>RefVal = (const int32_t) <referenceMemberName()>;
visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>TempVal, <visitMemberNameHelper()>RefVal, &<enumGetMapNameForMemberHelper()>, <memberDefault()>);
<visitMemberNameHelper()> = (<printTypeRef(member)>) <visitMemberNameHelper()>TempVal;
>>
classMemberVisitSTRING() ::= <<visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()>, "<member.default>", <printTypeList(member.TypeRef.ActualScopedAttributes.SizeConstant)><if(!member.TypeRef.ActualScopedAttributes.GenConstant)> + 1<endif>);>>
classMemberVisitSTRUCT() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()>);"
classMemberVisitVARIABLE() ::= "<classMemberVisitSTRUCT()>"
classMemberVisitBITFIELD() ::= "<classMemberVisitSTRUCT()>"
classMemberVisitBLOB() ::= "<classMemberVisitSTRUCT()>"
classMemberVisitUNION() ::= "<classMemberVisitSTRUCT(...)>"
classMemberVisitCLASS() ::= "<classMemberVisitSTRUCT(...)>"
classMemberVisitBLAZE_OBJECT_TYPE() ::= <<visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()><if(member.default)>, Blaze::BlazeObjectType::parseString("<member.default>")<endif>);>>
classMemberVisitBLAZE_OBJECT_ID() ::= <<visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()><if(member.default)>, Blaze::BlazeObjectId::parseString("<member.default>")<endif>);>>
classMemberVisitTIMEVALUE() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, <visitMemberNameHelper()>, <referenceMemberName()>, Blaze::TimeValue(<if(member.default)>\"<member.default>\", Blaze::TimeValue::TIME_FORMAT_INTERVAL<else>0<endif>));"
classMemberVisitTYPEDEF() ::= ""
visitMemberNameHelper() ::= "<if(member.allowref)>*<endif>m<member.Name><if(member.allowref)>Ptr<endif>"
referenceMemberName() ::= "<if(member.allowref)>*<endif>referenceTdf.m<member.Name><if(member.allowref)>Ptr<endif>"

classMemberTdfVHelper(member) ::= "<({memberTdfVType<member.TypeRef.Symbol.ActualCategory>})()>"
memberTdfVType() ::= ""
memberTdfVTypeMAP() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_MAP, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, <isAllowRef_GetOffsetToRefMap()> }"
memberTdfVTypeLIST() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_LIST, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, <isAllowRef_GetOffsetToRefList()> }"
memberTdfVTypeINT_PRIMITIVE() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_<({memberTdfVTypeINT_PRIMITIVE_<member.TypeRef.ActualSymbol.Name>})()>, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, <memberDefault()> }"
memberTdfVTypeFLOAT_PRIMITIVE() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_FLOAT, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, <memberDefault()> }"
memberTdfVTypeENUM() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_ENUM, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, (int32_t)<memberDefault()>, &<enumGetMapNameForMemberHelper()> }"
memberTdfVTypeSTRING() ::= <<{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_STRING, <nextMemberOffset()>, <isAllowRef_GetOffset()>, "<member.ParseName>" }, "<memberDefault()>", <printTypeList(member.TypeRef.ActualScopedAttributes.SizeConstant)><if(!member.TypeRef.ActualScopedAttributes.GenConstant)> + 1<endif> }>>
memberTdfVTypeSTRUCT() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_STRUCT, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeVARIABLE() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_VARIABLE, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeBITFIELD() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_BITFIELD, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeBLOB() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_BLOB, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeUNION() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_UNION, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeCLASS() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_CLASS, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, <isAllowRef_GetOffsetToRefTdf()> }"
memberTdfVTypeBLAZE_OBJECT_TYPE() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_BLAZE_OBJECT_TYPE, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeBLAZE_OBJECT_ID() ::= "{ <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_BLAZE_OBJECT_ID, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }"
memberTdfVTypeTIMEVALUE() ::= "{ { <memberTagHex()> | <isAllowRef_GetFlag()>, Blaze::TDF_MEMBER_TIMEVALUE, <nextMemberOffset()>, <isAllowRef_GetOffset()>, \"<member.ParseName>\" }, Blaze::TimeValue(<if(member.default)>\"<member.default>\", Blaze::TimeValue::TIME_FORMAT_INTERVAL<else>0<endif>).getMicroSeconds() }"
memberTdfVTypeTYPEDEF() ::= ""
isAllowRef_GetFlag() ::= "<if(member.allowref)>TDF_MEMBER_INFO_FLAG_IS_POINTER<else>0<endif>"
isAllowRef_GetOffset() ::= "OFFSETOF_MEMBER(<printTypeRef(node)>, m<member.Name><if(member.allowref)>Ptr<endif>)"
isAllowRef_GetOffsetToRefMap() ::= "OFFSETOF_MAP(<member.Name>_TYPE)"
isAllowRef_GetOffsetToRefList() ::= "OFFSETOF_LIST(<member.Name>_TYPE)"
isAllowRef_GetOffsetToRefTdf() ::= "OFFSETOF_TDF(<printTypeRef(member)>)"
nextMemberOffset() ::= "<if(member.NextMemberByTag)>static_cast\<uint8_t\>(OFFSETOF_MEMBER(<printTypeRef(node)>::TdfMemberInfoDefinition, m<member.NextMemberByTag.Name>Def) - OFFSETOF_MEMBER(<printTypeRef(node)>::TdfMemberInfoDefinition, m<member.Name>Def))<else>0<endif>"

memberTdfVTypeINT_PRIMITIVE_bool() ::= "BOOL"
memberTdfVTypeINT_PRIMITIVE_bool8_t() ::= "BOOL8"
memberTdfVTypeINT_PRIMITIVE_char8_t() ::= "INT8"
memberTdfVTypeINT_PRIMITIVE_int8_t() ::= "INT8"
memberTdfVTypeINT_PRIMITIVE_uint8_t() ::= "UINT8"
memberTdfVTypeINT_PRIMITIVE_int16_t() ::= "INT16"
memberTdfVTypeINT_PRIMITIVE_uint16_t() ::= "UINT16"
memberTdfVTypeINT_PRIMITIVE_int32_t() ::= "INT32"
memberTdfVTypeINT_PRIMITIVE_uint32_t() ::= "UINT32"
memberTdfVTypeINT_PRIMITIVE_int64_t() ::= "INT64"
memberTdfVTypeINT_PRIMITIVE_uint64_t() ::= "UINT64"
memberTdfVTypeINT_PRIMITIVE_BlazeId() ::= "BLAZEID"
memberTdfVTypeINT_PRIMITIVE_ComponentId() ::= "COMPONENTID"
memberTdfVTypeINT_PRIMITIVE_EntityType() ::= "ENTITYTYPE"
memberTdfVTypeINT_PRIMITIVE_EntityId() ::= "ENTITYID"

unionMemberVisitHelper() ::= "<({unionMemberVisit<member.TypeRef.Symbol.ActualCategory>})()>"
unionMemberVisit() ::= ""
unionMemberVisitMAP() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, u.m<member.Name>, <referenceMemberName()>);"
unionMemberVisitLIST() ::= "<unionMemberVisitMAP()>"
unionMemberVisitINT_PRIMITIVE() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, u.m<member.Name>, referenceTdf.u.m<member.Name>, <memberDefault()>);"
unionMemberVisitFLOAT_PRIMITIVE() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, u.m<member.Name>, referenceTdf.u.m<member.Name>, <memberDefault()>);"
unionMemberVisitENUM() ::= <<
// temporary value used to avoid casting an enum to (int32_t&)
// which would break compiler strict aliasing rules (GOSOPS-18815)
int32_t <member.Name>TempVal = (int32_t) m<member.Name>;
const int32_t <member.Name>RefVal = (const int32_t) referenceTdf.u.m<member.Name>;
visitor.visit(rootTdf, *this, <memberTagHex()>, <member.Name>TempVal, <member.Name>RefVal, &<enumGetMapNameForMemberHelper()>, <memberDefault()>);
m<member.Name> = (<printTypeRef(member)>) <member.Name>TempVal;
>>
unionMemberVisitSTRING() ::= <<visitor.visit(rootTdf, *this, <memberTagHex()>, *u.m<member.Name>, *referenceTdf.u.m<member.Name>, "<member.default>");>>
unionMemberVisitSTRUCT() ::= "visitor.visit(rootTdf, *this, <memberTagHex()>, *u.m<member.Name>, *referenceTdf.u.m<member.Name>);"
unionMemberVisitVARIABLE() ::= "<unionMemberVisitSTRUCT()>"
unionMemberVisitBITFIELD() ::= "<unionMemberVisitSTRUCT()>"
unionMemberVisitBLOB() ::= "<unionMemberVisitSTRUCT()>"
unionMemberVisitUNION() ::= "<unionMemberVisitSTRUCT(...)>"
unionMemberVisitCLASS() ::= "<unionMemberVisitSTRUCT(...)>"
unionMemberVisitTYPEDEF() ::= ""

memberTagHex() ::= "<member.TagValue;format=\"hex\">"

tdfRegistrationHelper(node) ::= <<
<if(node.ExplicitRegistration)>TdfFactory::get().registerTdf("<printTypeRefFullScope(node)>", Blaze::TdfCreator(&<printTypeRef(node)>::create), (Blaze::TdfId)<node.tdfid>);<\n><endif>
>>

tdfDeregistrationHelper(node) ::= <<
<if(node.ExplicitRegistration)>TdfFactory::get().deregisterTdf((Blaze::TdfId)<node.tdfid>);<\n><endif>
>>
