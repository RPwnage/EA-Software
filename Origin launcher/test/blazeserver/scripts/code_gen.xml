<project xmlns="schemas/ea/framework3.xsd">
  <dependent name="protobuf"/>
  <dependent name="EATDF"/>

  <property name="proto.gen.dir" value="${package.builddir}/gen/protos" />
  <!-- comma separated path names (avoid delim in space in case directory name has a space) -->
  <property name="blazeserver.protoinbound.additional_paths" >
    .
    ${package.protobuf.dir}/src
    ${package.blazeserver_grpc_tools.dir}/protos
    ${blazeserver.protoinbound.additional_paths.custom??}
  </property>

  <property name="blazeserver.protooutbound.additional_paths">
    .
    ${package.protobuf.dir}/src
    ${package.blazeserver_grpc_tools.dir}/protos
    ${blazeserver.protooutbound.additional_paths.custom??}
  </property>

  <!-- An integrator does not need to drop any new files here so no custom settings. These are core helpers needed for blazeserver framework.-->
  <property name="blazeserver.protohelpers.additional_paths">
    .
    ${package.protobuf.dir}/src
  </property>
  
  <!-- Use blazeserver.generate_protos on blaze server to enable protobuf related code generation. A property is needed because there are pieces of shared tool files in EATDF that are used to 
    generate code for blaze server, blaze sdk and eatdf test. Those shared pieces should only generate the protobuf related code when building blaze server. -->
  <!-- Setting proto.generate to 'false' will still generate proto files and *.cc files on blazeserver albeit effectively empty. So although not recommended, one can use it for faster build times. -->
  <property name="proto.generate" value="${blazeserver.generate_protos??true}"/>
  
  <!-- Set blazeserver.generate_custom_protos property to true during build if you'd like to add Protobuf/Grpc support for customcode/customcomponents.
    However, we explicitly disallow /arson related custom stuff below as that thing has some really odd EATDF usages that'd otherwise need to be reworked. -->
  <property name="proto.generate_custom" value="${blazeserver.generate_custom_protos??false}"/>
  
  <!-- When generating proto files for custom components/code after enabling the generation via blazeserver.generate_custom_protos=true, you can blacklist certain custom 
  components/custom code (for whatever variety of reason you need it). 
  
  Note that if any usage of a message/class in a disabled component is leaked somewhere else (so you have a component A including some proto message from a disabled component B), you'd 
  need to use generateProto=false attribute in your component A in these specific use cases. This is expected to be an edge case. 

  Usage:
  1. To blacklist custom component 'foo', use <property name="proto.generate_custom_comp_blacklist.foo" value="true"/>. Add more of such statement as necessary.  
  2. To blacklist custom code 'gamereporting', use <property name="proto.generate_custom_code_blacklist.gamereporting" value="true"/>. Add more of such statement as necessary.  
  -->
  
  <!-- Disable arson custom component ourselves. -->
  <property name="proto.generate_custom_comp_blacklist.arson" value="true"/>
 
  <!-- A concatenated string to pass to TdfComp. -->
  <property name="proto.generate_custom_comp_blacklist.all" value="" />
  <property name="proto.generate_custom_code_blacklist.all" value="" />

  <!-- If you run into an error while generating code from proto files (protoc-blaze.exe or protoc.exe failed), set blazeserver.log_protos to true in order to get debug logs.
  In addition, also add -noparallel switch to your nant command line. -->
  <property name="proto.log" value="${blazeserver.log_protos??false}"/>

  <include file="${package.blazeserver_grpc_tools.dir}/scripts/cpp_code_gen.xml"/>
  
  
  <target name="typecomp" >
    <echo message="generatecode: typecomp"/>
    <dependent name="EATDF"/>

    <fileset name="package.blazeserver.component.tdfs"/>

    <foreach item="String" in="${components}" delim=" " property="component">
      <fileset name="package.blazeserver.component.tdfs" append="true">
        <includes name="${package.dir}/component/${component}/**.tdf"/>
        <includes name="${package.dir}/customcomponent/${component}/**.tdf"/>
        <includes name="${package.dir}/proxycomponent/${component}/**.tdf"/>
      </fileset>
    </foreach>

    <fileset name="package.blazeserver.framework.tdfs">
      <includes name="${package.dir}/framework/**.tdf"/>
    </fileset>

    <fileset name="package.blazeserver.customcode.tdfs">
      <includes name="${package.dir}/customcode/**.tdf"/>
    </fileset>

    <!-- ALL TDFS -->
    <fileset name="package.blazeserver.all.tdfs" append="true" fromfileset="package.blazeserver.component.tdfs"/>
    <fileset name="package.blazeserver.all.tdfs" append="true" fromfileset="package.blazeserver.framework.tdfs"/>
    <fileset name="package.blazeserver.all.tdfs" append="true" fromfileset="package.blazeserver.customcode.tdfs"/>

    <property name="package.blazeserver.tdfincludedirs" local="true">
      ${package.blazeserver.dir}/component
      ${package.blazeserver.dir}/customcomponent
      ${package.blazeserver.dir}/proxycomponent
      ${blazeserver.custom.tdfincludedirs??}
    </property>

    <property name="package.blazeserver.codegen.templatedirs" local="true">
      ${package.EATDF.dir}/tool/templates/cpp
      ${package.EATDF.dir}/tool/templates/protobuf
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp/shared
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp/server
    </property>

    <property name="package.blazeserver.codegen.templates" local="true">
      tdfheaderfile={RelativeDirNoGen}/tdf/{FileBase}.h
      tdfsource={RelativeDirNoGen}/tdf/{FileBase}.cpp
    </property>


    <foreach item="String" in="${components}" delim=" " property="component">
      <property name="customcomp.blacklisted" value="${proto.generate_custom_comp_blacklist.${component}??false} and @{DirectoryExists('${package.dir}/customcomponent/${component}')}" />
      <property name="proto.generate_custom_comp_blacklist.all" value="${property.value} ${component}" if="${customcomp.blacklisted}"/>
      
      <property name="customcode.blacklisted" value="${proto.generate_custom_code_blacklist.${component}??false} and @{DirectoryExists('${package.dir}/customcode/component/${component}')}" />
      <property name="proto.generate_custom_code_blacklist.all" value="${property.value} ${component}" if="${customcode.blacklisted}"/>
      
      <fileset name="package.blazeserver.proto.tdfs" append="true">
        <includes name="${package.dir}/component/${component}/**.tdf"/>
        <includes name="${package.dir}/proxycomponent/${component}/**.tdf"/>

        <includes name="${package.dir}/customcomponent/${component}/**.tdf" if="${proto.generate_custom} and !${customcomp.blacklisted}"/>
        <includes name="${package.dir}/customcode/component/${component}/**.tdf" if="${proto.generate_custom} and !${customcode.blacklisted}" />
      </fileset>
    </foreach>

    <fileset name="package.blazeserver.proto.tdfs" append="true">
      <includes name="${package.dir}/framework/**.tdf"/>
    </fileset>


    <property name="package.blazeserver.proto.templatedirs" local="true">
      ${package.EATDF.dir}/tool/templates/protobuf
    </property>

    <property name="package.blazeserver.proto.templates" local="true">
      protobuf=protos/${blazeserver.proto_rootdir??}/{RelativeDirNoGen}/{FileBase}.proto
    </property>

    <!-- This property is used in both tdfcomp and rpccomp targets but created here. The values come from the processing above in this task. -->
    <property name="proto.tdfcomp.commandargs" value="-D:generateProtos=${proto.generate} -D:generateCustomProtos=${proto.generate_custom} -D:protoRootDir=${blazeserver.proto_rootdir??} -D:customCompBlacklistProtos=&quot;${proto.generate_custom_comp_blacklist.all}&quot; -D:customCodeBlacklistProtos=&quot;${proto.generate_custom_code_blacklist.all}&quot;"/>

    <!-- Generate C++ code out of tdf. -->
    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen"
        templates="${package.blazeserver.codegen.templates}"
        templatedirs="${package.blazeserver.codegen.templatedirs}"
        inputs="package.blazeserver.all.tdfs"
        extraArgs="${proto.tdfcomp.commandargs}"
        includedirs="${package.blazeserver.tdfincludedirs}"
        dep="${package.builddir}/gen/alltdfs.d"
        />

    <!-- Generate proto files from the tdf files. -->
    <!-- ${package.blazeserver.tdfincludedirs} usage below is intentional -->
    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen"
        templates="${package.blazeserver.proto.templates}"
        templatedirs="${package.blazeserver.proto.templatedirs}"
        inputs="package.blazeserver.proto.tdfs"
        extraArgs="${proto.tdfcomp.commandargs}"
        includedirs="${package.blazeserver.tdfincludedirs}"
        dep="${package.builddir}/gen/protofromtdf.d"
        />
  </target>

  <target name="rpccomp">
    <echo message="generatecode: rpccomp"/>
    <fileset name="package.blazeserver.rpcs">
      <includes name="${package.dir}/blazerpccomponent.rpc"/>
      <includes name="${package.dir}/framework/**.rpc"/>
    </fileset>

    <foreach item="String" in="${components}" delim=" " property="component">
      <fileset name="package.blazeserver.rpcs" append="true">
        <includes name="${package.dir}/component/${component}/**.rpc"/>
        <includes name="${package.dir}/customcomponent/${component}/**.rpc"/>
      </fileset>
    </foreach>

    <!-- package.blazeserver.dir is for the protobuf generated root component -->
    <property name="package.blazeserver.rpcincludedirs" local="true">
      ${package.blazeserver.dir}
      ${package.blazeserver.dir}/component
      ${package.blazeserver.dir}/customcomponent
      ${package.blazeserver.dir}/proxycomponent
      ${blazeserver.custom.rpcincludedirs??}
    </property>

    <property name="package.blazeserver.codegen.templatedirs" local="true">
      ${package.EATDF.dir}/tool/templates/cpp
      ${package.EATDF.dir}/tool/templates/protobuf
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp/shared
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp/server
      ${package.blazeserver.dir}/tools/typecomp2/templates/protobuf
    </property>
    
    <property name="package.blazeserver.rpc.templates.cpp" local="true">
      componentinterfaceheader={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}.h
      componentinterfacesource={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}.cpp
      stuberrorheader={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}_errorstub.h
      stuberrorsource={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}_errorstub.cpp
      stubheaderslave={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}_stub.h
      stubheadermaster={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}_stub.h
      stubsourcemaster={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}_stub.cpp
      stubsourceslave={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}_stub.cpp
      componentdefinitionheader={RelativeDirNoGen}/rpc/{ComponentName}_defines.h
      componentdefinitionsource={RelativeDirNoGen}/rpc/{ComponentName}_defines.cpp
      commandheader={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}/{CommandName}_stub.h
    </property>

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen"
        templates="${package.blazeserver.rpc.templates.cpp}"
        templatedirs="${package.blazeserver.codegen.templatedirs}"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        extraArgs="${proto.tdfcomp.commandargs}"
        dep="${package.builddir}/gen/blazerpc.d"
        />

    <property name="package.blazeserver.rpc.templates.cpp.errorheader" local="true">
      errorheader=blazerpcerrors.h
    </property>

    <property name="package.blazeserver.rpc.templates.cpp.errorsource" local="true">
      errorsource=blazerpcerrors.cpp
    </property>

    <!-- blazecomponentdb.cpp is separated from blazerpcerrors.cpp because 
      1) It does not belong there in terms of functionality.
      2) DepChecker needs to avoid linking against it.
    -->
    <property name="package.blazeserver.rpc.templates.cpp.componentdbsource" local="true">
      componentdbsource=blazecomponentdb.cpp
    </property>

    <fileset name="package.blazeserver.rpcroot">
      <includes name="${package.dir}/blazerpccomponent.rpc"/>
    </fileset>

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen"
        templates="${package.blazeserver.rpc.templates.cpp.errorheader}"
        templatedirs="${package.blazeserver.codegen.templatedirs}"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcroot"
        dep="${package.builddir}/gen/blazerpc_errorheader.d"/>

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen"
        templates="${package.blazeserver.rpc.templates.cpp.errorsource}"
        templatedirs="${package.blazeserver.codegen.templatedirs}"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        combine="true"
        dep="${package.builddir}/gen/blazerpc_errorsource.d"
        />

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen"
        templates="${package.blazeserver.rpc.templates.cpp.componentdbsource}"
        templatedirs="${package.blazeserver.codegen.templatedirs}"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        combine="true"
        dep="${package.builddir}/gen/blazerpc_componentdbsource.d"
        />

    <!-- generate gRPC service proto files for the .rpc files, for rootcomponent -->
    <property name="package.blazeserver.rpcroot.templates.proto" local="true">
      rootgrpcservice=protos/${blazeserver.proto_rootdir??}/{RelativeDirNoGen}/{FileBase}_grpcservice.proto
    </property>
    <task name="package.EATDF.typecomp.task"
      basedir="${package.dir}"
      outdir="${package.builddir}/gen"
      templates="${package.blazeserver.rpcroot.templates.proto}"
      templatedirs="${package.blazeserver.codegen.templatedirs}"
      includedirs="${package.blazeserver.rpcincludedirs}"
      inputs="package.blazeserver.rpcroot"
      dep="${package.builddir}/gen/protofromrpcroot.d"
    />

    <!-- generate gRPC service proto files for the .rpc files, for components -->
    <foreach item="String" in="${components}" delim=" " property="component">
      <fileset name="package.blazeserver.proto.rpcs" append="true">
        <includes name="${package.dir}/component/${component}/**.rpc"/>
        <includes name="${package.dir}/customcomponent/${component}/**.rpc" if="${proto.generate_custom}" unless="${proto.generate_custom_comp_blacklist.${component}??false}"/>
      </fileset>
    </foreach>

    <fileset name="package.blazeserver.proto.rpcs" append="true">
      <includes name="${package.dir}/framework/**.rpc"/>
    </fileset>

    <property name="package.blazeserver.rpc.templates.proto" local="true">
      grpcservice=protos/${blazeserver.proto_rootdir??}/{RelativeDirNoGen}/{ComponentName}{ComponentType}_grpcservice.proto
    </property>

    <task name="package.EATDF.typecomp.task"
      basedir="${package.dir}"
      outdir="${package.builddir}/gen"
      templates="${package.blazeserver.rpc.templates.proto}"
      templatedirs="${package.blazeserver.codegen.templatedirs}"
      includedirs="${package.blazeserver.rpcincludedirs}"
      inputs="package.blazeserver.proto.rpcs"
      extraArgs="${proto.tdfcomp.commandargs}"
      dep="${package.builddir}/gen/protofromrpc.d"
        />
  </target>

  <target name="proxyrpccomp">
    <echo message="generatecode: proxyrpccomp"/>
    <foreach item="String" in="${components}" delim=" " property="component">
      <fileset name="package.blazeserver.proxyrpcs" append="true">
        <includes name="${package.dir}/proxycomponent/${component}/**.rpc"/>
      </fileset>
    </foreach>

    <property name="package.blazeserver.codegen.templatedirs" local="true">
      ${package.EATDF.dir}/tool/templates/cpp
      ${package.EATDF.dir}/tool/templates/protobuf
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp/shared
      ${package.blazeserver.dir}/tools/typecomp2/templates/cpp/server
    </property>

    <property name="package.blazeserver.rpc.templates.cpp" local="true">
      componentinterfaceheader={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}.h
      componentinterfacesource={RelativeDirNoGen}/rpc/{ComponentName}{ComponentType}.cpp
      componentdefinitionheader={RelativeDirNoGen}/rpc/{ComponentName}_defines.h
      componentdefinitionsource={RelativeDirNoGen}/rpc/{ComponentName}_defines.cpp
    </property>

    <property name="package.blazeserver.rpcincludedirs" local="true">
      ${package.blazeserver.dir}/component
      ${package.blazeserver.dir}/customcomponent
      ${package.blazeserver.dir}/proxycomponent
    </property>

    <task name="package.EATDF.typecomp.task"
      basedir="${package.dir}"
      outdir="${package.builddir}/gen"
      templates="${package.blazeserver.rpc.templates.cpp}"
      templatedirs="${package.blazeserver.codegen.templatedirs}"
      includedirs="${package.blazeserver.rpcincludedirs}"
      inputs="package.blazeserver.proxyrpcs"
      dep="${package.builddir}/gen/rpcproxy.d"
      />

    <task name="package.EATDF.typecomp.task"
      basedir="${package.dir}"
      outdir="${package.builddir}/gen"
      templates="proxysource=blazerpcproxy.cpp"
      templatedirs="${package.blazeserver.codegen.templatedirs}"
      includedirs="${package.blazeserver.rpcincludedirs}"
      inputs="package.blazeserver.proxyrpcs"
      combine="true"
      dep="${package.builddir}/gen/rpcproxy_central.d"
      />
  </target>

  <target name="copytoetc">
    <property name="package.blazeserver.codegen.rpc.languages" local="true">
      html
      cpp
    </property>

    <foreach item="String" in="${package.blazeserver.codegen.rpc.languages}" local="true" property="package.blazeserver.codegen.language" delim=" ">
      <property name="package.blazeserver.codegen.outdir" local="true" value="${package.builddir}/gen_${package.blazeserver.codegen.language}"/>

      <!-- Special case for cpp so as not to disrupt the rest of the standard blaze build scripts -->
      <property name="package.blazeserver.codegen.outdir" local="true" value="${package.builddir}/gen" if="${package.blazeserver.codegen.language} == cpp"/>

      <!-- Copy any etc files generated -->
      <copy todir="${package.dir}/" flatten="false" clobber="false" overwrite="true">
        <fileset basedir="${package.blazeserver.codegen.outdir}/">
          <includes name="./etc/**"/>
        </fileset>
      </copy>
    </foreach>

    <!-- Copy any etc files generated -->
    <copy todir="${package.dir}/" flatten="false" clobber="false" overwrite="true">
      <fileset basedir="${package.builddir}/gen/">
        <includes name="./etc/**"/>
      </fileset>
    </copy>

    <copy todir="${package.dir}/" flatten="false" clobber="false" overwrite="true">
      <fileset basedir="${package.builddir}/gen_html/">
        <includes name="./etc/**"/>
      </fileset>
    </copy>
  </target>

  <!-- Bundle together all inbound protos (blaze protos and protos from the supporting packages). This is useful for tools like grpc_cli that need 1 unique root where all proto
  files need to exist and also for easy copy operations for some tools/integrators. -->
  <target name="bundleallinboundprotos">
    <echo message="generatecode: bundleallinboundprotos"/>

    <property name="proto.allinboundprotos.dir" value="${package.builddir}/allinboundprotos"/>
    <mkdir dir="${proto.allinboundprotos.dir}"/>
    
    <!-- Blaze protos -->
    <copy todir="${proto.allinboundprotos.dir}" flatten="false" clobber="false" overwrite="true">
      <fileset basedir="${package.builddir}/gen/protos">
        <includes name="./**/*.proto"/>
      </fileset>
    </copy>
    
    <!-- blazeserver_grpc_tools protos-->
    <copy todir="${proto.allinboundprotos.dir}" flatten="false" clobber="false" overwrite="true">
      <fileset basedir="${package.blazeserver_grpc_tools.dir}/protos">
        <includes name="./**/*.proto"/>
      </fileset>
    </copy>

    <!-- protobuf protos-->
    <copy todir="${proto.allinboundprotos.dir}" flatten="false" clobber="false" overwrite="true">
      <fileset basedir="${package.protobuf.dir}/src">
        <includes name="./**/*.proto"/>
      </fileset>
    </copy>
  </target>

  <!-- Generate the C++ code for proto files used to help blaze framework. Currently, these are just proto files contained in blazeserver_grpc_tools package. This is executed via the blaze build system
  as we intend to remove the blazeserver_grpc_tools package some day and absorb it's functionality in the grpc and blazeserver package itself. -->
  <target name="protogengrpc_helpers">
    <echo message="generatecode: protogengrpc_helpers"/>
    
    <property name="proto.cplusplus.helpersdir" value="${package.builddir}/gen/protogen/helpers"/>
    <mkdir dir="${proto.cplusplus.helpersdir}"/>

    <property name="proto.dependencies.helpersdir" value="${package.builddir}/gen/protodependencies/helpersdir" />
    <mkdir dir="${proto.dependencies.helpersdir}"/>

    <eval code="@{DirectoryGetDirectoriesRecursive('${package.blazeserver_grpc_tools.dir}/protos', '*', ' ')}" property="proto.helpers.directories" type="Function" />
    <property name="proto.helpers.directories" value="${package.blazeserver_grpc_tools.dir}/protos ${proto.helpers.directories}"/>

    <foreach item="String" in="${proto.helpers.directories}" property="proto.helpers.directory" delim=" ">
      <eval code="@{DirectoryGetFiles('${proto.helpers.directory}', '*.proto', ' ')}" property="proto.helpers.files" type="Function" />

      <parallel.foreach item="String" in="${proto.helpers.files}" property="proto.helpers.file" delim=" ">
        <property name="proto.helpers.file" value="@{PathGetRelativePath(${proto.helpers.file}, '${package.blazeserver_grpc_tools.dir}/protos')}"/>

        <property name="message.dep.file" local="true" value="${proto.dependencies.helpersdir}/messages/@{StrReplace('@{StrReplace('@{StrReplace('${proto.helpers.file}', '.proto', '.d')}', '\\', '_')}', '/', '_')}"/>
        <task name="message.gen.cpp" compiler="${protoc.exe}" workingdir="${package.blazeserver_grpc_tools.dir}/protos" protofile="${proto.helpers.file}" outputdir="${proto.cplusplus.helpersdir}" depfile="${message.dep.file}" protopaths="${blazeserver.protohelpers.additional_paths}" verbose="${proto.log}"/>

        <property name="service.dep.file" local="true" value="${proto.dependencies.helpersdir}/services/@{StrReplace('@{StrReplace('@{StrReplace('${proto.helpers.file}', '.proto', '.d')}', '\\', '_')}', '/', '_')}"/>
        <task name="service.gen.cpp" workingdir="${package.blazeserver_grpc_tools.dir}/protos" protofile="${proto.helpers.file}" outputdir="${proto.cplusplus.helpersdir}" depfile="${service.dep.file}" protopaths="${blazeserver.protohelpers.additional_paths}" verbose="${proto.log}"/>
      </parallel.foreach>
    </foreach>
  </target>

  <!-- Generate C++ code from the inbound proto files-->
  <target name="protogeninbound">
    <echo message="generatecode: protogeninbound"/>

    <property name="proto.cplusplus.inbounddir" value="${package.builddir}/gen/protogen/inbound"/>
    <mkdir dir="${proto.cplusplus.inbounddir}"/>

    <property name="proto.dependencies.inbounddir" value="${package.builddir}/gen/protodependencies/inbound" />
    <mkdir dir="${proto.dependencies.inbounddir}"/>

    <!--
      ProtoC does not accept wild cards for processing the .proto files so we need to generate the names of proto files out of our directory structure manually. 
        We do that below. 
        
        We want to 
        1. Process /blaze and /google directories in the protos using protoc while we want to process rest using protoc-blaze
        2. Create a message file set and a service file set (service files are identified by those ending in
        *grpcservice.proto
        
        Surprisingly, the step 1 can not be expressed with Framework File/Directory utility functions so we roll
        out a small script of our own.
        -->

    <property name="proto.files.relative.message" value="" />
    <property name="proto.files.relative.service" value="" />

    <script>
      <code>
        <![CDATA[
            private static bool IsServiceProto(string filename)
            {
                if (filename.EndsWith("grpcservice.proto"))
                {
                    return true;
                }
                return false;
            }
            
            private static bool IsMessageProto(string filename)
            {
                return !IsServiceProto(filename);
            }
            
            private static string GetRelativePath(string file, string folder)
            {
                Uri pathUri = new Uri(file);
                // Folders must end in a slash
                if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
                {
                    folder += Path.DirectorySeparatorChar;
                }
                Uri folderUri = new Uri(folder);
                return Uri.UnescapeDataString(folderUri.MakeRelativeUri(pathUri).ToString().Replace('/', Path.DirectorySeparatorChar));
            }
            
            private static void AddProtosToSet(Project project, string protoDir)
            {
                {
                    string[] messageProtoFiles = Array.FindAll(System.IO.Directory.GetFiles(protoDir, "*.proto"), IsMessageProto);
                    foreach (string file in messageProtoFiles)
                    {
                        project.Properties["proto.files.relative.message"] += GetRelativePath(file, project.GetPropertyValue("proto.gen.dir")) + ' ';
                    }
                }
                {
                    string[] serviceProtoFiles = Array.FindAll(System.IO.Directory.GetFiles(protoDir, "*.proto"), IsServiceProto);
                    foreach (string file in serviceProtoFiles)
                    {
                        project.Properties["proto.files.relative.service"] += GetRelativePath(file, project.GetPropertyValue("proto.gen.dir")) + ' ';
                    }
                }
            }
            
            public static void ScriptMain(Project project) 
            {
                // The root dir includes the blaze rootcomponent blazerpccomponent.rpc
                string rootDir = project.GetPropertyValue("proto.gen.dir") + "/" + project.GetPropertyValue("blazeserver.proto_rootdir");
                AddProtosToSet(project, rootDir);

                var topDirs = Directory.GetDirectories(rootDir);                
                foreach (string topDir in topDirs)
                {
                    if (!topDir.EndsWith("protobuf")) 
                    {
                        AddProtosToSet(project, topDir); // Looks like Array.add /concat method don't work in Framework so we do it this way instead of adding topDir to the array of strings below
                        
                        var protoDirs = Directory.GetDirectories(topDir, "*", SearchOption.AllDirectories);
                        foreach (string protoDir in protoDirs)
                        {
                            AddProtosToSet(project, protoDir);
                        }
                    }
                }
            }
        ]]>
      </code>
    </script>
    
    <!--
      ProtoC often gets confused in weird fashion with the file names depending on the directory strucutre. See https://stackoverflow.com/questions/18735609/the-path-in-protobuf. 
        Here, we do away with the include directories altogether and instead choose to work with a root level directory that has 
        all the protos that we need. 
        
        We also generate message with a separate invocation of protoc per proto file. This helps us being able to set the build dependency per proto file. If we process all the proto 
        files in a single invocation, we'd end up rebuilding all the generated C++ code for proto files even if just 1 of them changed.
        
        ProtoC has a dependency_out option but found few problems with it. 
          1. It did not work (the dependency file was generated but it did not "affect" the next iteration). Did not spend too much time investigating why it is broken because of other problems noted below.
          2. The output of the dependency was more Make like which took into account the dependent protos as well but that should not be needed for proto to cc code generation. The only time cc code generation
             needs to change is when the proto file changes. 
          3. It would not take into account any changes to the compiler itself. 
    -->
    
    <!-- Dependency files replace the directory separators with "_" and .proto with .d. -->

    <!-- Generate inbound messages code using protoc-blaze-->
    <parallel.foreach item="String" in="${proto.files.relative.message} ${proto.files.relative.service}" property="proto.file" delim=" ">
      <property name="dep.file" local="true" value="${proto.dependencies.inbounddir}/messages/@{StrReplace('@{StrReplace('@{StrReplace('${proto.file}', '.proto', '.d')}', '\\', '_')}', '/', '_')}"/>
      <task name="message.gen.cpp" compiler="${protoc-blaze.exe}" workingdir="${proto.gen.dir}" protofile="${proto.file}" outputdir="${proto.cplusplus.inbounddir}" depfile="${dep.file}" protopaths="${blazeserver.protoinbound.additional_paths}" verbose="${proto.log}"/>
    </parallel.foreach>

    <!-- Generate service code-->
    <parallel.foreach item="String" in="${proto.files.relative.service}" property="proto.file" delim=" ">
      <property name="dep.file" local="true" value="${proto.dependencies.inbounddir}/services/@{StrReplace('@{StrReplace('@{StrReplace('${proto.file}', '.proto', '.d')}', '\\', '_')}', '/', '_')}"/>
      <task name="service.gen.cpp" workingdir="${proto.gen.dir}" protofile="${proto.file}" outputdir="${proto.cplusplus.inbounddir}" depfile="${dep.file}" protopaths="${blazeserver.protoinbound.additional_paths}" verbose="${proto.log}"/>
    </parallel.foreach>
  </target>

  <target name="protogenoutbound">
    <echo message="generatecode: protogenoutbound"/>

    <!-- An early version of our script copied google's status.proto to following location which was a bad idea (adding a file to your source tree in a directory which is not the build directory). 
    We now delete this behind user's back otherwise they'll run into linking issues due to new improvements. This change is safe because we won't have google/rpc/status.proto added to the location below intentionally, ever. 
    -->
    <delete file="${package.blazeserver.dir}/outboundprotos/google/rpc/status.proto"/>

    <property name="proto.cplusplus.outbounddir" value="${package.builddir}/gen/protogen/outbound"/>
    <mkdir dir="${proto.cplusplus.outbounddir}"/>

    <property name="proto.dependencies.outbounddir" value="${package.builddir}/gen/protodependencies/outbound" />
    <mkdir dir="${proto.dependencies.outbounddir}"/>

    <eval code="@{DirectoryGetDirectoriesRecursive('${package.blazeserver.dir}/outboundprotos', '*', ' ')}" property="proto.outbound.directories" type="Function" />
    <property name="proto.outbound.directories" value="${package.blazeserver.dir}/outboundprotos ${proto.outbound.directories}"/> <!-- Add the top level directory as it is not included in above call. -->

    <foreach item="String" in="${proto.outbound.directories}" property="proto.outbound.directory" delim=" ">
      <eval code="@{DirectoryGetFiles('${proto.outbound.directory}', '*.proto', ' ')}" property="proto.outbound.files" type="Function" />

      <parallel.foreach item="String" in="${proto.outbound.files}" property="proto.outbound.file" delim=" ">
        <property name="proto.outbound.file" value="@{PathGetRelativePath(${proto.outbound.file}, '${package.blazeserver.dir}/outboundprotos')}"/>

        <property name="message.dep.file" local="true" value="${proto.dependencies.outbounddir}/messages/@{StrReplace('@{StrReplace('@{StrReplace('${proto.outbound.file}', '.proto', '.d')}', '\\', '_')}', '/', '_')}"/>
        <task name="message.gen.cpp" compiler="${protoc.exe}" workingdir="${package.blazeserver.dir}/outboundprotos" protofile="${proto.outbound.file}" outputdir="${proto.cplusplus.outbounddir}" depfile="${message.dep.file}" protopaths="${blazeserver.protooutbound.additional_paths}" verbose="${proto.log}"/>

        <property name="service.dep.file" local="true" value="${proto.dependencies.outbounddir}/services/@{StrReplace('@{StrReplace('@{StrReplace('${proto.outbound.file}', '.proto', '.d')}', '\\', '_')}', '/', '_')}"/>
        <task name="service.gen.cpp" workingdir="${package.blazeserver.dir}/outboundprotos" protofile="${proto.outbound.file}" outputdir="${proto.cplusplus.outbounddir}" depfile="${service.dep.file}" protopaths="${blazeserver.protooutbound.additional_paths}" verbose="${proto.log}"/>
      </parallel.foreach>
    </foreach>
  </target>

  <target name="wadl">
    <dependent name="EATDF"/>

    <fileset name="package.blazeserver.rpcs">
      <includes name="${package.dir}/framework/**.rpc"/>
    </fileset>

    <foreach item="String" in="${components}" delim=" " property="component">
      <fileset name="package.blazeserver.rpcs" append="true">
        <includes name="${package.dir}/component/${component}/**.rpc"/>
        <includes name="${package.dir}/customcomponent/${component}/**.rpc"/>
      </fileset>
    </foreach>

    <property name="package.blazeserver.rpcincludedirs" local="true">
      ${package.blazeserver.dir}/component
      ${package.blazeserver.dir}/customcomponent
      ${package.blazeserver.dir}/proxycomponent
    </property>

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen_html"
        templates="waldoc=wadl/{ComponentName}.html"
        templatedirs="tools/typecomp2/templates/html"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        dep="${package.builddir}/gen_html/wadl_d/wadl.d"
        useAltStringTemplateLexer="true"
        />

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen_html"
        templates="walindex=wadl/index.html"
        templatedirs="tools/typecomp2/templates/html"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        combine="true"
        dep="${package.builddir}/gen_html/wadl_d/wadl_central.d"
        useAltStringTemplateLexer="true"
        />

    <!-- copy the style sheets -->
    <copy todir="${package.builddir}/gen_html/wadl" flatten="true" clobber="true" overwrite="true">
      <fileset>
        <includes name="${package.dir}/tools/xslt/*"/>
      </fileset>
    </copy>
  </target>

  <target name="typecomp_framework_configdocs">
    <fileset name="package.blazeserver.framework.tdfs">
      <!-- This tdf file contains config tdf of framework, logging and boot. -->
      <includes name="${package.dir}/framework/gen/frameworkconfigtypes_server.tdf"/>
    </fileset>

    <property name="package.blazeserver.codegen.outdir" local="true" value="${package.builddir}/gen_html"/>
    <property name="package.blazeserver.codegen.templatedirs" local="true" value="tools/typecomp2/templates/html"/>

    <task name="package.EATDF.typecomp.task"
      basedir="${package.dir}"
      outdir="${package.blazeserver.codegen.outdir}"
      templates="configtdfdocclass=tdf/framework/{TdfDefinitionName}.html"
      templatedirs="${package.blazeserver.codegen.templatedirs}"
      inputs="package.blazeserver.framework.tdfs"
      dep="${package.blazeserver.codegen.outdir}/tdf_d/configdoctdf.d"
      includedirs=""
      useAltStringTemplateLexer="true"
      />
  </target>

  <target name="cfgdoc">
    <dependent name="EATDF"/>

    <fileset name="package.blazeserver.rpcs">
      <includes name="${package.dir}/framework/**.rpc"/>
    </fileset>

    <foreach item="String" in="${components}" delim=" " property="component">
      <fileset name="package.blazeserver.rpcs" append="true">
        <includes name="${package.dir}/component/${component}/**.rpc"/>
        <includes name="${package.dir}/customcomponent/${component}/**.rpc"/>
      </fileset>
    </foreach>

    <property name="package.blazeserver.rpcincludedirs" local="true">
      ${package.blazeserver.dir}/component
      ${package.blazeserver.dir}/customcomponent
      ${package.blazeserver.dir}/proxycomponent
    </property>

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen_html"
        templates="configtdfdoc=tdf/component/{ComponentName}.html"
        templatedirs="tools/typecomp2/templates/html"
        basetemplatedir="tools/typecomp2/templates/html"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        dep="${package.builddir}/gen_html/tdf_d/cfgdoc.d"
        useAltStringTemplateLexer="true"
        />

    <task name="package.EATDF.typecomp.task"
        basedir="${package.dir}"
        outdir="${package.builddir}/gen_html"
        templates="configtdfdocindex=tdf/index_component.html configtdfdocmasterindex=tdf/index.html"
        templatedirs="tools/typecomp2/templates/html"
        includedirs="${package.blazeserver.rpcincludedirs}"
        inputs="package.blazeserver.rpcs"
        combine="true"
        dep="${package.builddir}/gen_html/tdf_d/cfgdoc_central.d"
        useAltStringTemplateLexer="true"
        />

    <call target="typecomp_framework_configdocs"/>

    <!-- copy the style sheets -->
    <copy todir="${package.builddir}/gen_html/tdf" flatten="true" clobber="true" overwrite="true">
      <fileset>
        <includes name="${package.dir}/tools/xslt/*"/>
      </fileset>
    </copy>
  </target>

  <target name="bison">
    <echo message="generatecode: bison"/>
    <dependent name="bison"/>

    <fileset name="yacc.files" basedir="${package.dir}">
      <includes name="*component/**/*parser.y"/>
      <includes name="framework/**/*parser.y"/>
      <includes name="tools/**/*parser.y"/>
    </fileset>

    <foreach item="FileSet" in="yacc.files" local="true" property="yacc.input">
      <property name="yacc.prefix" local="true" value="@{StrReplace('@{PathGetFileName('${yacc.input}')}','parser.y','')}"/>
      <property name="yacc.output" local="true" value="${package.builddir}/gen@{StrRemove('@{PathGetDirectoryName('${yacc.input}')}','0','@{StrLen('${package.dir}')}')}/${yacc.prefix}parser.tab.cpp"/>

      <property name="yacc.output.dir" local="true" value="@{PathGetDirectoryName('${yacc.output}')}"/>
      <mkdir dir="${yacc.output.dir}" unless="@{DirectoryExists('${yacc.output.dir}')}"/>

      <exec program="${package.bison.exe}" workingdir="${package.bison.dir}/bin" silent="!${nant.verbose??false}">
        <args>
          <arg value="-dt"/>
          <arg value="-p ${yacc.prefix}" unless="@{StrIsEmpty('${yacc.prefix}')}"/>
          <arg value="--output-file=${yacc.output}"/>
          <arg value="${yacc.input}"/>
        </args>
        <inputs>
          <includes name="${yacc.input}"/>
        </inputs>
        <outputs>
          <includes name="${yacc.output}"/>
        </outputs>
      </exec>
    </foreach>
  </target>

  <target name="flex">
    <echo message="generatecode: flex"/>
    <dependent name="flex"/>

    <fileset name="flex.files" basedir="${package.dir}">
      <includes name="*component/**/*lexer.l"/>
      <includes name="framework/**/*lexer.l"/>
      <includes name="tools/**/*lexer.l"/>
    </fileset>

    <foreach item="FileSet" in="flex.files" local="true" property="flex.input">
      <property name="flex.prefix" local="true" value="@{StrReplace('@{PathGetFileName('${flex.input}')}','lexer.l','')}"/>
      <property name="flex.staging" local="true" value="${flex.input}"/>
      <property name="flex.output" local="true" value="${package.builddir}/gen@{StrRemove('@{PathGetDirectoryName('${flex.input}')}','0','@{StrLen('${package.dir}')}')}/${flex.prefix}lexer.cpp"/>

      <property name="flex.output.dir" local="true" value="@{PathGetDirectoryName('${flex.output}')}"/>
      <mkdir dir="${flex.output.dir}" unless="@{DirectoryExists('${flex.output.dir}')}"/>

      <exec program="${package.flex.exe}" workingdir="${package.flex.dir}/bin" silent="!${nant.verbose??false}">
        <args>
          <arg value="-P${flex.prefix}" unless="@{StrIsEmpty('${flex.prefix}')}"/>
          <arg value="-o${flex.output}"/>
          <arg value="${flex.staging}"/>
        </args>
        <inputs>
          <includes name="${flex.staging}"/>
        </inputs>
        <outputs>
          <includes name="${flex.output}"/>
        </outputs>
      </exec>
    </foreach>
  </target>

  <target name="generatecode">
    <!-- call a custom codegen target if blazeserver.custom.codegen is set to true-->
    <call target="blazeserver.custom.codegen.target" if="${blazeserver.custom.codegen??false}"/>

      <call target="typecomp"/>
      <call target="rpccomp"/>
    
    <parallel.do>
      <call target="protogeninbound" />
      <call target="protogenoutbound" />
      <call target="protogengrpc_helpers"/>
      <call target="proxyrpccomp"/>
      <call target="copytoetc"/>
      <call target="bison"/>
      <call target="flex"/>
    </parallel.do>
    <call target="bundleallinboundprotos"/>
  </target>

  <target name="cleangeneratedcode">
    <echo message="Cleaning generated code..."/>
    <delete dir="${package.builddir}/gen" failonmissing="false"/>
    <delete dir="${package.builddir}/gen_html" failonmissing="false"/>
    <delete dir="${package.builddir}/gen_java" failonmissing="false"/>
  </target>

  <target name="prepforcontainer">
    <property name="cfg" value="${cfg??${config}}"/>
    <property name="staging" value="${staging??false}"/>
    <echo message="prepforcontainer: cfg: ${cfg}, staging: ${staging}"/>

    <do if="${staging} == false">
      <dependent name="mariadb"/>
      <dependent name="google_perftools" if="${google-tcmalloc} or ${google-profile}"/>
      <dependent name="blaze_base" initialize="false"/>

      <delete dir="${package.builddir}/${cfg}/container_lib" if="@{DirectoryExists('${package.builddir}/${cfg}/container_lib')}"/>
      <copy todir="${package.builddir}/${cfg}/container_lib" flatten="true">
        <fileset>
          <includes name="${package.UnixClang.bindir}/../lib/libc++abi.*"/>
          <includes name="${package.UnixClang.bindir}/../lib/libc++.*"/>
          <includes name="${package.UnixClang.bindir}/../lib/clang/${clang_version}/lib/linux/*.so*" if="${blazeserver.sanitizer_enabled??false}"/>
          <includes name="${package.mariadb.libsdir}/libmariadb.so"/>
          <includes name="${package.google_perftools.libsdir}/libtcmalloc.so" if="${google-tcmalloc} == true"/>
          <includes name="${package.google_perftools.libsdir}/libprofiler.so" if="${google-profile} == true"/>
          <!-- include any custom shared libraries used by the game team (if needed) -->
          <includes fromfileset="blazeserver.customlibs" if="@{FileSetExists('blazeserver.customlibs')}"/>
        </fileset>
      </copy>
      <exec program="ln" workingdir="${package.builddir}/${cfg}/container_lib" commandline="-s -f libmariadb.so libmariadb.so.3" silent="!${nant.verbose??false}"/>
      <exec program="ln" workingdir="${package.builddir}/${cfg}/container_lib" commandline="-s -f libtcmalloc.so libtcmalloc.so.4" silent="!${nant.verbose??false}" if="${google-tcmalloc} == true"/>
      <exec program="ln" workingdir="${package.builddir}/${cfg}/container_lib" commandline="-s -f libprofiler.so libprofiler.so.0" silent="!${nant.verbose??false}" if="${google-profile} == true"/>
      <property name="image_name" fromfile="${package.blaze_base.dir}/TAG" unless="@{PropertyExists('image_name')}"/>
      <echo message="${image_name}" file="${package.builddir}/${cfg}/deployimage"/>

      <copy todir="${package.builddir}/${cfg}/bin" flatten="true">
        <fileset>
          <includes name="${package.UnixClang.bindir}/llvm-symbolizer" if="${blazeserver.sanitizer_enabled??false}"/>
        </fileset>
      </copy>
    </do>

    <do if="@{PropertyExists('target-dir')}">
      <delete dir="${target-dir}" if="@{DirectoryExists('${target-dir}')}"/>
      <copy todir="${target-dir}/bin" flatten="true">
        <fileset>
          <includes name="${package.builddir}/${cfg}/bin/*"/>
          <includes name="${package.builddir}/${cfg}/deployimage"/>
          <excludes name="${package.builddir}/${cfg}/bin/*.exe"/>
          <excludes name="${package.builddir}/${cfg}/bin/*.dll"/>
          <excludes name="${package.builddir}/${cfg}/bin/*.d"/>
          <excludes name="${package.builddir}/${cfg}/bin/*.obj"/>
          <excludes name="${package.builddir}/${cfg}/bin/*.dep"/>
        </fileset>
      </copy>
      <copy todir="${target-dir}/lib" flatten="true">
        <fileset>
          <includes name="${package.builddir}/${cfg}/container_lib/*"/>
        </fileset>
      </copy>
      <copy todir="${target-dir}" flatten="true">
        <fileset>
          <includes name="${package.builddir}/${cfg}/blazeversion.cfg"/>
        </fileset>
      </copy>
    </do>
  </target>

  <target name="getpackageinfo">
    <echo message="${package.builddir}" file="${package.dir}/docker/builddir.txt"/>
    <echo message="${nant.project.packageroots}" file="${package.dir}/docker/packageroots.txt"/>
    <echo message="${package.UnixClang.bindir}/../lib/clang/${clang_version}/lib/linux/libclang_rt.asan-x86_64.so" file="${package.dir}/docker/asan_so.txt"/>
    <echo message="${package.UnixClang.bindir}/llvm-symbolizer" file="${package.dir}/docker/llvm-symbolizer.txt"/>
  </target>

  <target name="vssetstartupprojects">
    <!-- Set startup projects for the VS solution.
         Note that VS saves startup project settings in the binary.suo file, and not in the human-readable .sln.
         To work around this, we call an external program which autogenerates an otherwise-blank .suo file
         with the desired startup project settings (if a .suo file does not already exist). -->
    <exec verbose="true" program="${package.dir}/scripts/VSSetStartupProjects/prebuilt/VSSetStartupProjects.exe">
      <args>
        <arg value="${package.builddir}/blazeserver.sln"/>
        <arg value="${vsversion}"/>
        <arg value="blazeredis"/>
        <arg value="blazeserver"/>
      </args>
    </exec>
  </target>
</project>
