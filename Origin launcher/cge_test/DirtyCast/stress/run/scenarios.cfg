
scenariosConfig = {

    // Misc. Global attributes that GOSCC needs: (Not tied to Rules, applied at end)
    globalAttributes = { 
        "StartMatchmakingRequest.sessionData.pseudoRequest" = { attrName = "PSEUDO_REQUEST", default = false, debugOnly = true }
        "StartMatchmakingRequest.sessionData.matchSelf" = { attrName = "ALLOW_SELF_MATCH", default = false, debugOnly = true }
        "StartMatchmakingRequest.criteriaData.preferredGamesRuleCriteria.preferredList" = { attrName = "EVALUATED_GAMES_LIST", default = [], debugOnly = true }
        "StartMatchmakingRequest.criteriaData.preferredGamesRuleCriteria.requirePreferredGame" = { 
                                                                                attrName = "ONLY_EVALUATE_GAMES_LIST", default = false, debugOnly = true }
        "StartMatchmakingRequest.sessionData.externalMmSessionTemplateName" = { attrName = "XONE_MM_SESSION_TEMPLATE", default = "" }
    }

    // Global Rules (Used by all sessions)
    globalRules = {
        "myRankedGameRule" = {               // Global rule names are arbitrary. Displayed via GOSCC.          
            "Predefined_RankedGameRule" = {  // <--- RankedGameRule name comes from list provided by RuleDescriptions. Same as in ruleSalience list. 
                "desiredValue"           = { attrName = "RANKED_CHOICE", default = "UNRANKED" }
                "minFitThreshold"        = { default = "requireExactMatch" }
            }
        }
        "expandedPingSiteRule" = { 
            "Predefined_ExpandedPingSiteRule" = {
                "rangeOffsetList"        = { default = "decay" }
                "latencyCalcMethod"      = { attrName = "LATENCY_CALC_METHOD", default = "BEST_LATENCY" }
                "sessionMatchCalcMethod" = { attrName = "SESSSION_MATCH_CALC_METHOD", default = "MY_BEST" }
                "pingSiteSelectionMethod" = { attrName = "PING_SITE_SELECTION_METHOD", default = "STD_DEV" }
            }
        }
    }

    // Non-Global Named Scenario Rules: 
    scenarioRuleMap = {
        "normalHostViability" = { 
            "Predefined_HostViabilityRule" = {
                "minFitThreshold"      = { default = "hostViability" }
            }
        }
        "normalPlayerCountRule" = { 
            "Predefined_PlayerCountRule" = {        // This rule checks the game's current player count                 
                "rangeOffsetList"     = { default = "testDecay" }      // By default, this expands to +/- 2 from desired value.  May need an update depending on your game's size.
                "desiredPlayerCount"  = { attrName = "DESIRED_PLAYER_COUNT", default = 2 }              // Attempt to find games with at least 2 players (including self)
                "maxPlayerCount"      = { attrName = "PLAYER_CAPACITY",      default = 8 }              // (These totals must include the joining player count)
                "minPlayerCount"      = { attrName = "MIN_PLAYER_COUNT",     default = 2 }              // (These totals must include the joining player count)
            }
        }

        "createGameTotalPlayerSlotsRule" = { 
            "Predefined_TotalPlayerSlotsRule" = {        // This rule is *required* when running createGame matchmaking (or the TeamCompositionRule)                
                "rangeOffsetList"           = { default = "testDecay" }
                "desiredTotalPlayerSlots"   = { attrName = "PLAYER_CAPACITY",     default = 8 }
                "minTotalPlayerSlots"       = { attrName = "PLAYER_CAPACITY",     default = 8 }
                "maxTotalPlayerSlots"       = { attrName = "PLAYER_CAPACITY",     default = 8 }
            }
        }


        "findGameModeRule" = { 
            "gameAttributeRules.gameModeMatchRule" = {
                "desiredValues"        = { attrName = "GAME_MODE_DESIRE", default = ["1"] }    // These are just strings that happen to be numbers, not ints. 
                "minFitThreshold"      = { default = "quickMatch" }
            } 
        }
        "findGameMapRule" = { 
            "gameAttributeRules.gameMapMatchRule" = {
                "desiredValues"        = { attrName = "GAME_MAP_DESIRE", default = ["1"] }
                "minFitThreshold"      = { default = "quickMatch" }
            }
        }

        "avoidPlayersRuleByBlazeId" = { 
            "Predefined_AvoidPlayersRule" = {
                "avoidList"         = { attrName = "AVOID_IDS", default = [] }
            }
        }

        // An alternative to the ping site rule:
        "normalGeoLocationRule" = { 
            "geoLocationRule" = {
                "minFitThreshold"   = { default = "quickMatch" }
            }
        }

        // Quickmatch Fill Lobby Example Rules:
        // Example rule that assumes GAME_MODE=0 is a 'lobby' value, which would be set to non-0 when the game is being played.
        "findGameLobby" = { 
            "gameAttributeRules.gameModeMatchRule" = {
                "desiredValues"        = { default = ["0"] }    
                "minFitThreshold"      = { default = "requireExactMatch" }
            } 
        }
        "findGameNotLobby" = { 
            "gameAttributeRules.gameModeMatchRule" = {
                "desiredValues"        = { default = ["1"] }    
                "minFitThreshold"      = { default = "quickMatch" }
            } 
        }
        "findAnyPlayerCountRule" = { 
            "Predefined_PlayerCountRule" = {        // This rule checks the game's current player count                 
                "rangeOffsetList"     = { default = "matchAny" }      // Match any will match any game, but prefers games closer to the desired value:
                "desiredPlayerCount"  = { attrName = "PLAYER_CAPACITY",      default = 8 }              // Prefer full games
                "maxPlayerCount"      = { attrName = "PLAYER_CAPACITY",      default = 8 }
                "minPlayerCount"      = { default = 1 }              
            }
        }

        // Selective rule examples:  Here we have 2 versions of the gameModeMatchRule, one for 'Big' mode, and one for 'Small' modes.
        // The selectiveSubsessions scenario will only enable the subsession for a given size, if the corresponding *_GAME_MODE_DESIRE value is sent up.
        "findBigGameModeRule" = { 
            "gameAttributeRules.gameModeMatchRule" = {
                "desiredValues"        = { attrName = "BIG_GAME_MODE_DESIRE" }
                "minFitThreshold"      = { default = "quickMatch" }
            } 
        }
        "findSmallGameModeRule" = { 
            "gameAttributeRules.gameModeMatchRule" = {
                "desiredValues"        = { attrName = "SMALL_GAME_MODE_DESIRE" }
                "minFitThreshold"      = { default = "quickMatch" }
            } 
        }
        "createBigGameTotalPlayerSlotsRule" = { 
            "Predefined_TotalPlayerSlotsRule" = {
                "rangeOffsetList"           = { default = "testDecay" }
                "desiredTotalPlayerSlots"   = { default = 40 }
                "minTotalPlayerSlots"       = { default = 40 }
                "maxTotalPlayerSlots"       = { default = 40 }
            }
        }
        "createSmallGameTotalPlayerSlotsRule" = { 
            "Predefined_TotalPlayerSlotsRule" = {
                "rangeOffsetList"           = { default = "testDecay" }
                "desiredTotalPlayerSlots"   = { default = 20 }
                "minTotalPlayerSlots"       = { default = 20 }
                "maxTotalPlayerSlots"       = { default = 20 }
            }
        }

        "dirtyCastTotalPlayerSlotsRule" = {
            "Predefined_TotalPlayerSlotsRule" = {        // This rule is *required* when running createGame matchmaking (or the TeamCompositionRule)                
                "rangeOffsetList"           = { default = "requireExactMatch" }
                "desiredTotalPlayerSlots"   = { attrName = "PLAYER_CAPACITY",     default = 8 }
                "minTotalPlayerSlots"       = { attrName = "PLAYER_CAPACITY",     default = 8 }
                "maxTotalPlayerSlots"       = { attrName = "PLAYER_CAPACITY",     default = 8 }
            }
        }
        "dirtyCastHostViability" = { 
            "Predefined_HostViabilityRule" = {
                "minFitThreshold"      = { default = "matchAny" }
            }
        }
        "dirtyCastHostBalancing" = {
            "Predefined_TeamBalanceRule" = {
                "rangeOffsetList" = { default = "testDecay" }
            }
        }
        "dirtyCastPlayerSlotUtilization" = {
            "Predefined_PlayerSlotUtilizationRule" = {
                "rangeOffsetList" = { default = "desiredOrMore"  }
                "desiredPercentFull" = { default = 80 }
                "maxPercentFull" = { default = 100 }
                "minPercentFull" = { default = 0 }
            }
        }
    }

    // Named Scenarios
    scenarios = {

        // Examples:
        // simpleQuickMatch just tries to find or create a game with a given number of players, and a given size.
        //   It includes the standard rules for finding good hosts, preferring nearby games, and making a game.
        //   It does only includes the required game mode attribute, and does not specify scenario attributes for topologies (using the defaults).
        //
        //   The scenario is split into two subsessions, with the create game subsession starting after 7s, when the find game subsession has fully decayed.
        //   NOTE: Subsessions start decayed, so in this example the quickMatchSessionCG will start with its rule thresholds at time 7s.

        "simpleQuickMatch" = {
            totalDuration = "15s"

            Variants = {
                "A" = { subSession = ["quickMatchSessionFG", "quickMatchSessionCG"] }
                "CG_only" = { subSession = ["quickMatchSessionCG"] }
                // Criteria can be used to choose between variants based on various census/request data.  See the Blaze Developer docs for more details!
                // "LongTimeToMatch" = { subSession = ["quickMatchSessionFG"], criteria = "ttm > '15s'" }
            }

            defaultVariant = "A"                         // default variant to use. Use "A" if not specified.
            // recoServerLookup = true                   // If set, scenario matchmaking will request variants from reco server. Default is false.
            // recommendationType = "matchmaking_test"   // The name of the A/B testing set up in EADP EM server
            // userVariants = { "nexus004" = "A",   "nexus006" = "CG_only" }   // Users map to particular variant. Debugging purpose.
            
            subsessions = {
                
                "quickMatchSessionFG" = {                         // Sub session names are arbitrary. Displayed via GOSCC.
                    
                    rulesList = [ "normalHostViability",    // Prefer hosts with open NAT 
                                  "normalPlayerCountRule"   // Find a game with the desired number of players (~4)
                                ]
         
                    matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                        sessionMode = "FindGame"
                    }
                },

                "quickMatchSessionCG" = {                        
                    
                    sessionStartTime = "7s"         // We delay by 7s, so that the FG subsession will have time to fully decay its rules (which decay in 5s).
                    // sessionEndTime = "10s"       // If we do not set an early end time, the subsession will run until the end of the scenario's totalDuration. 

                    rulesList = [ "normalHostViability",    // Prefer hosts with open NAT 
                                  "normalPlayerCountRule",   // Find a game with the desired number of players (~4)
                                  "createGameTotalPlayerSlotsRule" 
                                ]
         
                    matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                        sessionMode = "CreateGame"
                    }

                    // The CreateGameTemplate will be used as the basis for the create game request:
                    createGameTemplate = "basicGame"

                    // Scenarios can still set attributes to override what is in the createGameTemplate
                    createGameAttributes = {
                        // In the template, the mode is fixed, but we can override it with an attribute in the Scenario:
                        "GameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }
                    }
                }
            }
        }

        "expandedPingSite" = {
            totalDuration = "20s"
            subsessions = {

                "expandedPingSiteFG" = {
                
                    rulesList = [ "createGameTotalPlayerSlotsRule",
                                  "normalPlayerCountRule"   // Find a game with the desired number of players (~4)
                                ]
                    matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                        sessionMode = "FindGame"
                    }
                },
                
                "expandedPingSiteCG" = {
                    
                    sessionStartTime = "4s"         // We delay by 7s, so that the FG subsession will have time to fully decay its rules (which decay in 5s).
                    // sessionEndTime = "10s"       // If we do not set an early end time, the subsession will run until the end of the scenario's totalDuration. 

                    rulesList = [ "createGameTotalPlayerSlotsRule",
                                  "normalPlayerCountRule"   // Find a game with the desired number of players (~4)
                                ]
         
                    matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                        sessionMode = "CreateGame"
                    }

                    createGameAttributes = {
                        "GameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 8 }       // Max Capacity the game can be set to.
                        "GameCreationData.networkTopology"        = { default = "CLIENT_SERVER_PEER_HOSTED" }
                        "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                        "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                                "openToMatchmaking", 
                                                                                "openToInvites", 
                                                                                "openToJoinByPlayer",
                                                                                "joinInProgressSupported",
                                                                                "hostMigratable",     
                                                                                "allowAnyReputation"] }
                        "GameCreationData.externalSessionTemplateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }

                        // All games are required to specify a 'mode' (See gameModeAttributeName in gamesession.cfg)
                        "GameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }   // Required
                        "GameCreationData.gameAttribs[ISmap]"  = { attrName = "GAME_MAP",  default = "1" }   // Optional Example - Additional game attributes
                    }
                }
            }
        }

        // findGameByMapAndMode just tries to find a game with a given number of players, and a given map and mode.
        //   Unlike the single-string game attributes, the Rules' desired map and mode settings are lists, allowing you to specify multiple acceptable settings.

        "findGameByMapAndMode" = {
            totalDuration = "30s"
            subsessions = {
                "findGameSession" = {                       

                    rulesList = [ "normalHostViability",     // Prefer hosts with open NAT 
                                  "normalPlayerCountRule",   // Find a game with the desired number of players (~4)
                                  
                                  "findGameModeRule",        // Find via game mode: 
                                  "findGameMapRule"         // Find via game map: 
                                ]
         
                    matchmakingSettings = {                         
                        sessionMode = "FindGame"           // Just finding the game
                    }
                }
            }
        }

        "dirtyCastStress" = {
            totalDuration = "60s"
            subsessions = {

                "findGame" = {
                    rulesList = [
                        "dirtyCastTotalPlayerSlotsRule",
                        "normalPlayerCountRule",  // Find a game with the desired number of players (~4)
                        "dirtyCastHostViability",
                        "dirtyCastHostBalancing",
                        "dirtyCastPlayerSlotUtilization"
                    ]
                    matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                        sessionMode = "FindGame"
                    }
                },
                
                "createGame" = {
                    rulesList = [
                        "dirtyCastTotalPlayerSlotsRule",
                        "normalPlayerCountRule",  // Find a game with the desired number of players (~4)
                        "dirtyCastHostViability",
                        "dirtyCastHostBalancing",
                        "dirtyCastPlayerSlotUtilization"
                    ]
                    matchmakingSettings = {                         // These are values that would be in MatchmakingSessionData
                        sessionMode = "CreateGame"
                    }
                    createGameAttributes = {
                        "GameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 8 }       // Max Capacity the game can be set to.
                        "GameCreationData.networkTopology"        = { attrName = "NETWORK_TOPOLOGY", default = "CLIENT_SERVER_DEDICATED" }
                        "GameCreationData.voipNetwork"            = { attrName = "VOIP_NETWORK", default = "VOIP_DISABLED" }
                        "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                                "openToMatchmaking", 
                                                                                "openToInvites", 
                                                                                "openToJoinByPlayer",
                                                                                "joinInProgressSupported",
                                                                                "hostMigratable",     
                                                                                "allowAnyReputation"] }
                        "GameCreationData.gameName"               = { attrName = "GAME_NAME" }

                        // All games are required to specify a 'mode' (See gameModeAttributeName in gamesession.cfg)
                        "GameCreationData.gameAttribs[mode]"   = { default = "2" }   // Required
                        "GameCreationData.gameAttribs[OSDK_gameMode]" = { default = "2" }
                    }
                }
            }
        }


        // fullCreateGame tries to create a game with a given number of players, and a given size.
        //   It includes more settings for allowing Topology and the GameSettings to be changed. 

        "fullCreateGame" = {
            totalDuration = "15s"
            subsessions = {
                
                "quickMatchSession" = {                         // Sub session names are arbitrary. Displayed via GOSCC.

                    rulesList = [ "normalHostViability",        // Prefer hosts with open NAT 
                                  "normalPlayerCountRule",      // Find a game with the desired number of players (~4)
                                  "createGameTotalPlayerSlotsRule",
                                  
                                  "avoidPlayersRuleByBlazeId" 
                                ]
         
                    matchmakingSettings = {
                        sessionMode = "CreateGame"
                    }

                    createGameAttributes = {
                        "GameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 8 }       // Max Capacity the game can be set to.
                        "GameCreationData.networkTopology"        = { attrName = "NET_TOPOLOGY",    default = "PEER_TO_PEER_PARTIAL_MESH" }
                        "GameCreationData.voipNetwork"            = { attrName = "VOIP_TOPOLOGY",   default = "VOIP_DISABLED" }
                        "GameCreationData.gameSettings"           = { attrName = "GAME_SETTINGS",   default =   ["openToBrowsing",
                                                                                                                "openToMatchmaking", 
                                                                                                                "openToInvites", 
                                                                                                                "openToJoinByPlayer",
                                                                                                                "hostMigratable",
                                                                                                                "joinInProgressSupported",     
                                                                                                                "allowAnyReputation"] }
                        "GameCreationData.externalSessionTemplateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }

                        // All games are required to specify a 'mode' (See gameModeAttributeName in gamesession.cfg)
                        "GameCreationData.gameAttribs[mode]"   = { attrName = "GAME_MODE", default = "1" }   // Required
                        "GameCreationData.gameAttribs[ISmap]"  = { attrName = "GAME_MAP",  default = "1" }   // Optional Example - Additional game attributes
                    }
                }
            }
        }


        // quickMatchFillLobby - This is an example of how to use multiple subsessions to effiecently fill up game lobbies. (ex. Battlefront)
        //
        //   It performs 3 stages: 
        //   * First it joins any available game lobbies (perferring fuller lobbies)
        //   * Then (if no lobbies exist) it joins any available games (perferring fuller games)
        //   * Finally, if no lobbies exist, and no non-full games exist, then it creates a new lobby.
        //   (With this sequence, we ensure that lobbies are only created when all games are full, and the lobbies are filled as quickly as possible.)
        // 
        //   This scenario assumes that the GAME_MODE value ('mode') is set to 0 when the game is in a lobby state, and changes to 1 or higher when the game is being played.

        "quickMatchFillLobby" = {
            totalDuration = "15s"
            subsessions = {
                
                // First, fill up any lobbies that exist:
                "fillLobbySubsession" = {                     
                    
                    // sessionEndTime = "30s"  // We don't set an end time for this rule, because we want it to last the full session duration.

                    rulesList = [ "findAnyPlayerCountRule", // Accept any size lobby, preferring full ones
                                  "findGameLobby"           // Only accept lobbies
                                ]
         
                    matchmakingSettings = {
                        sessionMode = "FindGame"
                    }
                },

                // Second, fill up any games that exist:
                "fillNonEmptyGamesSubsession" = {                     

                    // We only need to delay by a short amount of time because the check for lobbies should be very fast                   
                    sessionStartTime = "1s"

                    rulesList = [ "normalHostViability",    // Prefer hosts with open NAT 
                                  "findAnyPlayerCountRule", // Accept any size game, preferring full ones
                                  "findGameNotLobby"        // Only accept lobbies
                                ]
         
                    matchmakingSettings = {
                        sessionMode = "FindGame"
                    }
                },

                // Finally, create a new game lobby, if no non-full games exist:
                "createNewLobby" = {                        
                    
                    // Delay until right before the end of the scenario:
                    sessionStartTime = "14s"

                    // Since we're creating an empty game lobby at this point, we don't need any rules except the total player slots rule:
                    rulesList = [ "createGameTotalPlayerSlotsRule" ]
         
                    matchmakingSettings = { 
                        sessionMode = "CreateGame"
                    }

                    createGameAttributes = {
                        "GameCreationData.maxPlayerCapacity"      = { attrName = "PLAYER_CAPACITY", default = 8 }       // Max Capacity the game can be set to.
                        "GameCreationData.networkTopology"        = { default = "PEER_TO_PEER_PARTIAL_MESH" }
                        "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                        "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                                "openToMatchmaking", 
                                                                                "openToInvites", 
                                                                                "openToJoinByPlayer",
                                                                                "joinInProgressSupported",
                                                                                "hostMigratable",     
                                                                                "allowAnyReputation"] }
                        "GameCreationData.externalSessionTemplateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }

                        "GameCreationData.gameAttribs[mode]"   = { default = "0" }   // Set the mode to 0 to indicate a lobby
                        "GameCreationData.gameAttribs[ISmap]"  = { default = "1" }   // Optional Example - Additional game attributes
                    }
                }
            }
        }


        // When running multiple subsessions, sometimes you may want to enable or disable the subsessions depending
        // In this example, we first attempt to find games with the desired mode (GAME_MODE_DESIRE), then if no games exist we attempt to create a game.
        // The Client is expected to split the (GAME_MODE_DESIRE) list into (BIG_GAME_MODE_DESIRE) and (SMALL_GAME_MODE_DESIRE) lists, and send all three up in the request.
        // If either the BIG or SMALL desired values are missing, then we will cleanly skip that subsession, and the scenario will not register an error.
        "selectiveSubsessions" = {
            totalDuration = "5s"
            subsessions = {

                // First try to find games in the combined modes: 
                "findAnySizeGame" = {                     
                    rulesList = [ "findAnyPlayerCountRule", "findGameModeRule" ]
                    matchmakingSettings = { sessionMode = "FindGame" }
                },

                // Then try to create a Big or Small game. 
                // Both of these succeed at the same time, so the result will be random as to which game is chosen.
                "createBigGame" = {                        
                    sessionStartTime = "3s"
                    skipSubSessionIfNotSetAttributes = [ "BIG_GAME_MODE_DESIRE" ]    // Only create a 40 player game if BIG_GAME_MODE_DESIRE is set.

                    rulesList = [ "createBigGameTotalPlayerSlotsRule", "findBigGameModeRule" ]
                    matchmakingSettings = { sessionMode = "CreateGame" }

                    createGameAttributes = {
                        "GameCreationData.maxPlayerCapacity"      = { default = 40 }       // Max Capacity the game can be set to.
                        "GameCreationData.networkTopology"        = { default = "PEER_TO_PEER_PARTIAL_MESH" }
                        "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                        "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                                "openToMatchmaking", 
                                                                                "openToInvites", 
                                                                                "openToJoinByPlayer",
                                                                                "joinInProgressSupported",
                                                                                "hostMigratable",     
                                                                                "allowAnyReputation"] }
                        "GameCreationData.externalSessionTemplateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
                        "GameCreationData.gameAttribs[ISmap]"  = { default = "1" }
                    }
                }

                "createSmallGame" = {                        
                    sessionStartTime = "3s"
                    skipSubSessionIfNotSetAttributes = [ "SMALL_GAME_MODE_DESIRE" ]    // Only create a 20 player game if SMALL_GAME_MODE_DESIRE is set. 
                    
                    rulesList = [ "createSmallGameTotalPlayerSlotsRule", "findSmallGameModeRule" ]
                    matchmakingSettings = { sessionMode = "CreateGame" }

                    createGameAttributes = {
                        "GameCreationData.maxPlayerCapacity"      = { default = 20 }
                        "GameCreationData.networkTopology"        = { default = "PEER_TO_PEER_PARTIAL_MESH" }
                        "GameCreationData.voipNetwork"            = { default = "VOIP_DISABLED" }
                        "GameCreationData.gameSettings"           = { default = ["openToBrowsing",
                                                                                "openToMatchmaking", 
                                                                                "openToInvites", 
                                                                                "openToJoinByPlayer",
                                                                                "joinInProgressSupported",
                                                                                "hostMigratable",     
                                                                                "allowAnyReputation"] }
                        "GameCreationData.externalSessionTemplateName" = { attrName = "XONE_GAME_SESSION_TEMPLATE", default = "" }
                        "GameCreationData.gameAttribs[ISmap]"  = { default = "1" }
                    }
                }
            }
        }
    }
}
