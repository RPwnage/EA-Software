// Originally based on NAnt - A .NET build tool
// Copyright (C) 2003-2018 Electronic Arts Inc.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// 
// As a special exception, the copyright holders of this software give you 
// permission to link the assemblies with independent modules to produce 
// new assemblies, regardless of the license terms of these independent 
// modules, and to copy and distribute the resulting assemblies under terms 
// of your choice, provided that you also meet, for each linked independent 
// module, the terms and conditions of the license of that module. An 
// independent module is a module which is not derived from or based 
// on these assemblies. If you modify this software, you may extend 
// this exception to your version of the software, but you are not 
// obligated to do so. If you do not wish to do so, delete this exception 
// statement from your version. 
// 
// Electronic Arts (Frostbite.Team.CM@ea.com)

//-----------------------------------------------------------------------------
// GenerateBulkBuildFiles.cs
//
// NAnt custom task which creates a bulkbuild '.cpp' file for every given
// input fileset.
//
// Required:
//	FileSetName    - Name of fileset containing files to be added to the bulk 'unit'.
//  OutputFilename - Filename for generated CPP.
//
// Optional
//	OutputDir	- This is where the BuildBuild files get generated to.
//
//-----------------------------------------------------------------------------

using NAnt.Core;
using NAnt.Core.Attributes;
using NAnt.Core.Util;
using NAnt.Core.Logging;
using NAnt.Core.Tasks;

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Reflection;
using System.Linq;
using EA.Eaconfig;
using EA.Eaconfig.Core;
using EA.Eaconfig.Build;

namespace EA.GenerateBulkBuildFiles
{
	[TaskName("GenerateBulkBuildFiles")]
	public class generatebulkbuildfiles : Task
	{
		string _maxSize = null;
		string _minSplitFiles = null;
		string _deviateMaxSizeAllowance = null;
		string _bulkBuildFileHeader = null;
		int _maxSizeInt = -1;
		int _minSplitFilesInt = 0;
		int _deviateMaxSizeAllowanceInt = 0;

		private string mAutoGenComments = "//-- AutoGenerated BulkBuild File.";

		[TaskAttribute("FileSetName", Required = true)]
		public string FileSetName { get; set; } = null;

		[TaskAttribute("OutputFilename", Required = true)]
		public string OutputFilename { get; set; } = null;

		[TaskAttribute("OutputDir", Required = false)]
		public string OutputDir { get; set; } = null;

		[TaskAttribute("MaxSize", Required = false)]
		public string MaxSize
		{
			get { return _maxSize; }
			set
			{
				_maxSize = StringUtil.Trim(value); 

				if(!Int32.TryParse(_maxSize, out _maxSizeInt))
				{
					_maxSizeInt = -1;
				}
			}
		}

		[TaskAttribute("pch-header", Required = false)]
		public string PchHeader { get; set; } = null;

		[TaskAttribute("SplitByDirectories", Required = false)]
		public bool SplitByDirectories { get; set; } = false;

		[TaskAttribute("MinSplitFiles", Required = false)]
		public string MinSplitFiles
		{
			get { return _minSplitFiles; }
			set
			{
				_minSplitFiles = StringUtil.Trim(value);

				if (!Int32.TryParse(_minSplitFiles, out _minSplitFilesInt))
				{
					_minSplitFilesInt = 0;
				}
				if (_minSplitFilesInt < 0)
				{
					_minSplitFilesInt = 0;
				}
			}
		}

		[TaskAttribute("DeviateMaxSizeAllowance", Required = false)]
		public string DeviateMaxSizeAllowance
		{
			get {  return _deviateMaxSizeAllowance; }
			set
			{
				_deviateMaxSizeAllowance = StringUtil.Trim(value);
				if (!Int32.TryParse(_deviateMaxSizeAllowance, out _deviateMaxSizeAllowanceInt))
				{
					_deviateMaxSizeAllowanceInt = 0;
				}
				if (_deviateMaxSizeAllowanceInt < 0)
				{
					_deviateMaxSizeAllowanceInt = 0;
				}
			}
		}

		[FileSet("output-bulkbuild-files", Required = false)]
		public FileSet OutputBulkBuildFiles { get; } = new FileSet();

		[FileSet("output-loose-files", Required = false)]
		public FileSet OutputLooseFiles { get; } = new FileSet();

		public static FileSet Execute(Project project, string fileSetName, string outputFilename, string dir, string maxBulkBuildSize, string pchheader, out FileSet looseFiles, bool splitByDirectories = false, string minSplitFiles = null, string deviateMaxSizeAllowance=null)
		{
			// find a task with the given name
			Task task = project.TaskFactory.CreateTask("GenerateBulkBuildFiles", project);

			task.Project = project;
			task.GetType().InvokeMember("FileSetName", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { fileSetName });
			task.GetType().InvokeMember("OutputFilename", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { outputFilename });            
			if (!string.IsNullOrEmpty(dir))
			{
				task.GetType().InvokeMember("OutputDir", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { dir });
			}
			if (null != task.GetType().GetProperty("MaxSize"))
			{
				task.GetType().InvokeMember("MaxSize", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { maxBulkBuildSize });
			}
			if (!String.IsNullOrWhiteSpace(pchheader) && null != task.GetType().GetProperty("PchHeader"))
			{
				task.GetType().InvokeMember("PchHeader", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { pchheader });
			}

			if (splitByDirectories && null != task.GetType().GetProperty("SplitByDirectories"))
			{
				task.GetType().InvokeMember("SplitByDirectories", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { splitByDirectories });
			}

			if (!String.IsNullOrEmpty(minSplitFiles) && null != task.GetType().GetProperty("MinSplitFiles"))
			{
				task.GetType().InvokeMember("MinSplitFiles", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { minSplitFiles });
			}

			if (!String.IsNullOrEmpty(deviateMaxSizeAllowance) && null != task.GetType().GetProperty("DeviateMaxSizeAllowance"))
			{
				task.GetType().InvokeMember("DeviateMaxSizeAllowance", BindingFlags.SetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, new object[] { deviateMaxSizeAllowance });
			}

			task.Execute();

			FileSet result = null;

			if (null != task.GetType().GetProperty("OutputBulkBuildFiles"))
			{
				result = (FileSet)task.GetType().InvokeMember("OutputBulkBuildFiles", BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, null);
			}
			else
			{
				result = new FileSet();
				FileSetUtil.FileSetInclude(result, dir + Path.DirectorySeparatorChar + outputFilename);
			}

			if (null != task.GetType().GetProperty("OutputLooseFiles"))
			{
				looseFiles = (FileSet)task.GetType().InvokeMember("OutputLooseFiles", BindingFlags.GetProperty | BindingFlags.Public | BindingFlags.Instance, null, task, null);
			}
			else
			{
				looseFiles = null;
			}
			
			result.SetFileDataFlags(FileData.BulkBuild);
			
			return result;
		}


		/// <summary>Execute the task.</summary>
		protected override void ExecuteTask()
		{
			// This is where the output BulkBuild files get generated to.
			string buildDir = Project.Properties["package.builddir"];

			bool exclude_writable = Project.Properties.GetBooleanPropertyOrDefault("bulkbuild.exclude-writable", false);

			if (String.IsNullOrEmpty(OutputDir) && buildDir != null)
			{
				OutputDir = buildDir;
			}

			if (String.IsNullOrEmpty(OutputDir))
			{
				OutputDir = System.Environment.CurrentDirectory;
			}
			else
			{
				OutputDir = PathNormalizer.Normalize(OutputDir);
			}

			// Create the output directory if it doesn't exist.
			if (!System.IO.Directory.Exists(OutputDir))
			{
				System.IO.Directory.CreateDirectory(OutputDir);
			}

			string bulkbuildtemplate = (Project.Properties["bulkbuild.template"] ?? "#include \"%filename%\"").TrimWhiteSpace();

			// Do some error check to make sure that any custom modified bulkbuild.template doesn't contain multiple include lines
			string[] bbTemplateSplit = bulkbuildtemplate.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
			System.Collections.Generic.IEnumerable<string> incLines = bbTemplateSplit.Where(ln => ln.Trim().StartsWith("#include"));
			if (incLines.Count() > 1)
			{
				// Our current code won't handle the use case with user modifying bulkbuild.template to have multiple #include.  
				// So, throw an error and have to get user to fix that before continuing with the build.
				StringBuilder errMsg = new StringBuilder();
				errMsg.AppendLine("ERROR: The 'bulkbuild.template' property override cannot contain multiple '#include' lines.  It currently contains:");
				foreach (string ln in incLines)
				{
					errMsg.AppendLine(ln);
				}
				errMsg.AppendLine("Please correct your property override.");
				throw new BuildException(errMsg.ToString());
			}

			string bulkbuildHeaderTemplate = (Project.Properties["bulkbuild.header.template"] ?? "#include \"%pchheader%\"").TrimWhiteSpace();
			if (!String.IsNullOrEmpty(bulkbuildHeaderTemplate) && !String.IsNullOrWhiteSpace(PchHeader))
			{
				_bulkBuildFileHeader = bulkbuildHeaderTemplate.Replace("%pchheader%", PchHeader.TrimWhiteSpace());
			}

			FileSet currentfileset = Project.NamedFileSets[FileSetName];

			// In case fileset was expanded in build script - force expansion again.
			currentfileset.Includes.AddRange(new List<FileSetItem>());

			OutputBulkBuildFiles.BaseDirectory = OutputDir; 
			OutputLooseFiles.BaseDirectory = currentfileset.BaseDirectory;

			bool isPortable = Project.Properties.GetBooleanPropertyOrDefault("eaconfig.generate-portable-solution", false);
			bool isGeneration = Project.Properties.GetBooleanPropertyOrDefault("eaconfig.build.process-generation-data", false);
			string cacheMode = Project.Properties.GetPropertyOrDefault("package.SnowCache.mode", "");
			bool isDeterministic = (cacheMode == "upload" || cacheMode == "uploadanddownload" || cacheMode == "download" || cacheMode == "forceupload");

			// If there are existing BB files, load them up first and get the complete distribution of existing filelist
			// to make it easier for later use to decide if we want to deviate from that list.
			// HOWEVER, don't waste time reading previous files if we didn't activate this feature.
			Dictionary<string, List<string>> existingBBDist = new Dictionary<string, List<string>>();
			if (!isDeterministic && _deviateMaxSizeAllowanceInt > 0)
			{
				int fileidx = 0;
				string bbFname = GetBBOutputFileNameFullPath(fileidx);
				if (!System.IO.File.Exists(bbFname))
				{
					++fileidx;
					bbFname = GetBBOutputFileNameFullPath(fileidx);
				}
				while (System.IO.File.Exists(bbFname))
				{
					bbFname = GetBBOutputFileNameFullPath(fileidx);
					List<string> includeList = GetCurrentBulkBuildIncludeList(bbFname);
					existingBBDist.Add(bbFname, includeList);
					++fileidx;
				}
			}

			var filegroups = SplitByDirs(currentfileset.FileItems, this._minSplitFilesInt, SplitByDirectories);

			int groupindex = 0;

			foreach (var fg in filegroups)
			{
				if (fg.Count() == 1)
				{
					bool frameworkAutoExcludedFileWithOptionset = false;
					var first_fi = fg.FirstOrDefault();
					if (first_fi != null)
					{
						if (!String.IsNullOrEmpty(first_fi.OptionSetName))
							frameworkAutoExcludedFileWithOptionset = true;
					}
					if (Log.WarningLevel >= Log.WarnLevel.Advise && !frameworkAutoExcludedFileWithOptionset)
					{
						DoOnce.Execute(String.Format("single.include.bulkbuild.warning.{0}", OutputFilename), () =>
						{
							Project.Log.Warning.WriteLine("Attempting to generate a bulk-build file [{0}] with only one include.  Reverting to a loose file. Consider changing the build script for package [{1}]", OutputFilename, Project.Properties["package.name"]);
						});
					}
					var fi = fg.FirstOrDefault();
					if (fi != null)
					{
						OutputLooseFiles.Include(fi, failonmissing: false);
					}
				}
				else if(fg.Count() > 0)
				{
					if ( (filegroups.Count() > 1 || 
						 (_maxSizeInt > 0 && fg.Count() > _maxSizeInt)) && 
						groupindex == 0)
					{
						// Start with 1 when we have multiple bulkbuild files. The GetBBFileName function will create
						// a different filename if groupindex is zero.
						++groupindex;
					}

					string currentBBFile = GetBBOutputFileNameFullPath(groupindex);

					// split by file extension
					var splitFileGroups = new Dictionary<string, List<FileItem>>();
					foreach (var file in fg)
					{
						var ext = Path.GetExtension(file.Path.Path);
						if (!splitFileGroups.ContainsKey(ext))
							splitFileGroups[ext] = new List<FileItem>();
						splitFileGroups[ext].Add(file);
					}

					foreach (var splitFileGroup in splitFileGroups)
					{
						var group = splitFileGroup.Value;

						// Rename the bb file extension to match the files it is bulk building.  This is required for some platforms.
						// If we are splitting the original file item list then we had a bulk build that had two different file extensions(languages) under one bulk build.
						// If that is the case then we rename the bb file to include the language at the end of the file name to make sure build artifact names do not collide.
						if(splitFileGroups.Count > 1)
							currentBBFile = Path.ChangeExtension(currentBBFile, null) + splitFileGroup.Key.Replace('.','_') + splitFileGroup.Key;
						else
							currentBBFile = Path.ChangeExtension(currentBBFile, splitFileGroup.Key);

						List<string> existingBBIncludeList = null;
						if (existingBBDist.ContainsKey(currentBBFile))
						{
							existingBBIncludeList = existingBBDist[currentBBFile];
						}

						// Write out the file contents to a string. 
						int count = 0;
						string optionsetname = null;

						StringBuilder fileoutput = new StringBuilder(mAutoGenComments + Environment.NewLine);

						var first_fi = group.FirstOrDefault();
						if (first_fi != null)
						{
							optionsetname = first_fi.OptionSetName;
						}

						if (String.IsNullOrEmpty(optionsetname) && !String.IsNullOrEmpty(_bulkBuildFileHeader))
						{
							fileoutput.AppendLine(_bulkBuildFileHeader);
						}

						List<string> newIncludeList = new List<string>();
						foreach (FileItem fi in group)
						{
							bool commentThisInclude = false;
							if (exclude_writable && !PathUtil.IsPathInDirectory(fi.Path.Path, NAnt.Core.PackageCore.PackageMap.Instance.BuildRoot))
							{
								if (File.Exists(fi.Path.Path) && (FileAttributes.ReadOnly != (File.GetAttributes(fi.Path.Path) & FileAttributes.ReadOnly)))
								{
									OutputLooseFiles.Include(fi, failonmissing: false);
									commentThisInclude = true;
								}
							}

							var filepath = (isPortable && isGeneration) ? PathUtil.RelativePath(fi.FileName, OutputDir) : fi.FileName;

							// The %filename% parameter will be used under quote.  Make sure that the path use forward slash to make the include line universal.
							string includeLine = bulkbuildtemplate.Replace("%filename%", filepath.Replace("\\", "/"));
							string realIncludeLine = (!commentThisInclude ? includeLine : "// " + includeLine.Replace(Environment.NewLine, Environment.NewLine + "// "));

							// We have use case where the bulkbuildtempalte is overridden to include extra #pragma stuff.  Get the line that only contains #include
							string[] incMultiLines = includeLine.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
							foreach (string ln in incMultiLines)
							{
								string lnTrim = ln.Trim();
								if (lnTrim.StartsWith("#include"))
								{
									includeLine = lnTrim;
									// We're not expecting user to modify the template to have more than one #include line.
									// So we can break out of this loop now.
									break;
								}
							}

							string includeToAddAfterSplit = null;
							bool fileInNextBB_SplitNow = false;
							bool fileInCurrentBB_DontSplit = false;
							if (existingBBIncludeList != null)
							{
								if (!existingBBIncludeList.Contains(includeLine))
								{
									// Check if this include gets pushed to next BB master file.  This happens if 
									// user delete old files.
									string nextBBFilename = GetBBOutputFileNameFullPath(groupindex + 1);
									List<string> bbfilelist = null;
									if (existingBBDist.TryGetValue(nextBBFilename, out bbfilelist))
									{
										if (bbfilelist != null && bbfilelist.Contains(includeLine))
										{
											// This include show up in the next BB master file.  Since the purpose is to 
											// minimize cascading changes during incremental build, we'll just do the 
											// split now and not doing any threshold check!
											fileInNextBB_SplitNow = true;
											includeToAddAfterSplit = realIncludeLine;
										}
									}
								}
								else
								{
									fileInCurrentBB_DontSplit = true;
								}
							}

							bool doOutputToFile = false;
							if (existingBBIncludeList == null)
							{
								// We're not doing previous BulkBuild files check.  So just add this file now.
								fileoutput.AppendLine(realIncludeLine);
								count++;
								doOutputToFile = _maxSizeInt > 0 && count >= _maxSizeInt;
							}
							else if (!fileInNextBB_SplitNow)
							{
								if (fileInCurrentBB_DontSplit)
								{
									fileoutput.AppendLine(realIncludeLine);
									count++;
									// Note that we're not doing the "doOutputToFile" check becasue we're forcing to stay using
									// current BB file.  So we may actually exceed the limit.  But to minimize cascading changings
									// to the following BB files, we let it go over if it happened.
								}
								else
								{
									// If both fileInNextBB_SplitNow and fileInCurrentBB_DontSplit are false, this
									// must be a new file (or we have too much cascading changes).  Check against split limit.
									doOutputToFile = _maxSizeInt > 0 && count >= (_maxSizeInt + _deviateMaxSizeAllowanceInt);
									if (doOutputToFile)
									{
										// Current count is already over the limit, add this new file after the split.
										includeToAddAfterSplit = realIncludeLine;
									}
									else
									{
										fileoutput.AppendLine(realIncludeLine);
										count++;
										doOutputToFile = _maxSizeInt > 0 && count >= (_maxSizeInt + _deviateMaxSizeAllowanceInt);
									}
								}
							}

							if (doOutputToFile || fileInNextBB_SplitNow)
							{
								fileoutput.AppendLine(mAutoGenComments);
								UpdateBulkBuildFile(fileoutput, optionsetname, currentBBFile);
								++groupindex;

								currentBBFile = GetBBOutputFileNameFullPath(groupindex);
								existingBBIncludeList = null;
								if (existingBBDist.ContainsKey(currentBBFile))
									existingBBIncludeList = existingBBDist[currentBBFile];

								fileoutput = new StringBuilder(mAutoGenComments + Environment.NewLine);
								if (String.IsNullOrEmpty(optionsetname) && !String.IsNullOrEmpty(_bulkBuildFileHeader))
								{
									fileoutput.AppendLine(_bulkBuildFileHeader);
								}

								count = 0;

								if (includeToAddAfterSplit != null)
								{
									fileoutput.AppendLine(includeToAddAfterSplit);
									++count;
									includeToAddAfterSplit = null;
								}
							}
						}

						if (count > 0)
						{
							// We reached end of current "group" by directory thing.  Have to start a new bulkbuild file.
							fileoutput.AppendLine(mAutoGenComments);
							UpdateBulkBuildFile(fileoutput, optionsetname, currentBBFile);
							++groupindex;

							currentBBFile = GetBBOutputFileNameFullPath(groupindex);
							existingBBIncludeList = null;
							if (existingBBDist.ContainsKey(currentBBFile))
								existingBBIncludeList = existingBBDist[currentBBFile];
						}
					}
				}
			}
		}

		private IEnumerable<IEnumerable<FileItem>> SplitByDirs(IEnumerable<FileItem> input, int minSize, bool split)
		{
			foreach (var optiongrp in input.GroupBy(fi => fi.OptionSetName))
			{
				if (split)
				{
					var group = new List<FileItem>();
					foreach (var dirgrp in optiongrp.GroupBy(fi => Path.GetDirectoryName(fi.Path.Path)))
					{
						group.AddRange(dirgrp);
						if (group.Count >= minSize)
						{
							yield return group;
							group = new List<FileItem>();
						}
					}
					if (group.Count > 0)
						yield return group;
				}
				else
				{
					yield return optiongrp;
				}
			}
		}

		private List<string> GetCurrentBulkBuildIncludeList(string filename)
		{
			List<string> includeList = new List<string>();

			// If existing BB file exists, load the existing file list (including the commented files.)
			if (File.Exists(filename))
			{
				string[] lines = File.ReadAllLines(filename);

				for (int i = 0; i < lines.Length; ++i)
				{
					string line = lines[i];

					if (line.StartsWith(mAutoGenComments))
						continue;
					if (line.StartsWith("//"))
						line = line.Substring(2);

					// We're only interested in the include lines
					line = line.Trim();
					if (!line.StartsWith("#include"))
						continue;

					includeList.Add(line);
				}
			}
			return (includeList.Count == 0 ? null : includeList);
		}

		private void UpdateBulkBuildFile(StringBuilder fileoutput, string optionSetName, string outputfilenameFullPath)
		{
			string oldfilecontents = "";
			// If existing BB file exists, load the existing file list (including the commented files.)
			if (System.IO.File.Exists(outputfilenameFullPath))
			{
				oldfilecontents = File.ReadAllText(outputfilenameFullPath);
			}
			string newOutput = fileoutput.ToString();
			if (!String.Equals(oldfilecontents, newOutput, StringComparison.Ordinal))
			{
				File.WriteAllText(outputfilenameFullPath, newOutput);
				if (oldfilecontents.IsNullOrEmpty())  // only log the Updating info to minimal channel if you are actually updating the bulkbuild file, if it didn't pre-exist then we are likely in a clean situation and don't want to spam the user
					Project.Log.Status.WriteLine("{0}\"{1}/{2}\": Updating '{3}.cpp'", LogPrefix, Project.Properties["package.name"], Project.Properties["build.module"], System.IO.Path.GetFileNameWithoutExtension(outputfilenameFullPath));
				else
					Project.Log.Minimal.WriteLine("{0}\"{1}/{2}\": Updating '{3}.cpp'", LogPrefix, Project.Properties["package.name"], Project.Properties["build.module"], System.IO.Path.GetFileNameWithoutExtension(outputfilenameFullPath));
			}

			if (optionSetName == null)
				FileSetUtil.FileSetInclude(OutputBulkBuildFiles, outputfilenameFullPath);
			else
				FileSetUtil.FileSetInclude(OutputBulkBuildFiles, outputfilenameFullPath, OutputBulkBuildFiles.BaseDirectory, optionSetName, true);
		}

		private string GetBBOutputFileNameFullPath(int index)
		{
			string outputfilenameFullPath;
			string outputFilename = GetBBFileName(index);

			if ((OutputDir[OutputDir.Length - 1] == Path.DirectorySeparatorChar) || (OutputDir[OutputDir.Length - 1] == Path.AltDirectorySeparatorChar))
			{
				outputfilenameFullPath = OutputDir + outputFilename;
			}
			else
			{
				outputfilenameFullPath = OutputDir + Path.DirectorySeparatorChar + outputFilename;
			}

			return outputfilenameFullPath;
		}

		private string GetBBFileName(int index)
		{
			if (index < 1)
				return OutputFilename;

			if (_bulkBuildautoSplitTemplate == null)
				_bulkBuildautoSplitTemplate = PropertyUtil.GetPropertyOrDefault(Project, "bulkbuild.autosplit.template", "%filename%.Auto%index%%ext%");

			return _bulkBuildautoSplitTemplate
				.Replace("%filename%", Path.GetFileNameWithoutExtension(OutputFilename))
				.Replace("%index%", String.Format("{0:00}", index))
				.Replace("%ext%", Path.GetExtension(OutputFilename));
		}

		private string _bulkBuildautoSplitTemplate;
	}
}
