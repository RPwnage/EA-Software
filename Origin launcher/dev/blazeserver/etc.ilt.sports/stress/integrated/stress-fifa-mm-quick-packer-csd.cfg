
// Configuration file for the stress tester
//

// Define the connection and protocol parameters
connection-info = {
    protocol = fire2
    encoder = heat2
    decoder = heat2

    // Total number of connections to use
    num-connections = #NUM_CONNECTIONS#

    // Control whether SSL is used or not
    secure = #STRESS_SECURE#
}

//
//This following block controls how instances are started up.
//
startup = {
    //Number of instances to start up in a given pass
    //A block size of 0 will start all instances simultaneously
    
    // parser does not allow expressions in variable value 
    #define SERVER_NUCLEUS_POOL_SIZE_TIMES_INT #SERVER_NUCLEUS_POOL_SIZE# * 4
    block-size = #SERVER_NUCLEUS_POOL_SIZE_TIMES_INT#

    //Delay between starting instances in milliseconds
    instance-delay = #CONN_INSTANCE_DELAY#

    //Delay between starting blocks in milliseconds
    // parser does not allow expressions in variable value 
    #define SERVER_NUCLEUS_POOL_SIZE_INT #SERVER_NUCLEUS_POOL_SIZE# * 4 * #CONN_INSTANCE_DELAY#
    block-delay = #SERVER_NUCLEUS_POOL_SIZE_INT#
}

// 
// Define the account/authentication parameters used for account creation and authentication
// 
#include "../etc.ilt.sports/stress/stress-account.cfg"

// 
// Define the list of stress modules that will be instantiated
// 
modules = [ matchmaker ]

// 
// Define how the available instances/connections are distributed amongst the different modules
// 
distribution = {
    matchmaker = 1.0
}

#if PLATFORM == "common"
// define the distribution of platform types for available instances/connections used in shared cluster testing
platform-distribution = {
    pc = 0.2
    ps4 = 0.4
    xone = 0.3
    steam = 0.1
}
#else
// define the specification of platform type for available instances/connections used in single platform testing
platform-specification = {
    platform = "#PLATFORM#"
}
#endif

#define MM_QM_BASE_FACTOR 30
#ifndef MM_QM_BASE_RATE
#define MM_QM_BASE_RATE 2000
#endif
#define MM_QM_DELAY MM_QM_BASE_RATE*MM_QM_BASE_FACTOR
#define MM_QM_GM_LIFESPAN 600*MM_QM_BASE_RATE
#define MM_QM_GM_LIFECPAN_CYCLES MM_QM_GM_LIFESPAN/(MM_QM_DELAY)


#ifndef MM_DURATION
#define MM_DURATION "short"
#endif

#if (MM_DURATION == "short")
#define MM_TIMEOUT_DURATION_MS 90000
#define FUT_SKILL_RATING_FIT_THRESHOLD "OSDK_matchRelax"
#define FUT_SKILL_RATING_RULE_FREQUENCY 100
#elif (MM_DURATION == "medium")
#define MM_TIMEOUT_DURATION_MS 4500000
#define FUT_SKILL_RATING_FIT_THRESHOLD "mediumDurationRelax"
#define FUT_SKILL_RATING_RULE_FREQUENCY 100
#endif


// 
// Configuration data specific to the dummy module
// 
matchmaker = {
    useScenarios = #USE_SCENARIOS#
    scenarioName = "ILT_Packer_CSD"
    pingPeriod_ms = #PING_PERIOD_MS#
    inactivityTimeout_ms = #INACTIVITY_TIMEOUT_MS#
    useServerQosSettings = #USE_SERVER_QOS#

    // Define the number of milliseconds between RPC calls
    delay= #MM_QM_DELAY#
    login = true
    logout = false
    opt_in_chance = 100
    delay_per_trial = 0
    num_execs_per_trial = 900000000 // NOTE: This number must be very high to avoid having clients perform restart the trials periodically during ILT run (manifests as a slowing rate of MM)

    // define the delay before starting matchmaking
    matchmakerDelay= #MM_QM_BASE_RATE#
    forcedMmRetryCount = 3 // number of times random non-host players will be force kicked by the host to matchmake again
    forcedMmRetryChance = 25 // 0 disables forced retry, rolled once per game
    legacyReports = true
    legacyGameTypeId = 0 // normal type

    
    // the chance that a user will log out during execute
    logoutChance = 0
    
    // Define which action to execute
    // action = noop
    action = findOrCreateGameSession // NOTE: ILT scenario allows client to override the sessionMode, so we must pass up the right mode here!
    // action = createGameSession // NOTE: Create game only
    
    //matchmaking session timeout in MS
    matchmakingTimeout = #MM_TIMEOUT_DURATION_MS#
    //game state durations in MS
    initStateDurationMs = 1000
    preGameStateDurationMs = 1000
    inGameStateDurationMs = #MM_QM_GM_LIFESPAN#
    inGameStateDeviationMs = 1000
    
    minPlayersForInGameTransition = 1 // minimum number of players before host transitions to IN_GAME
    maxReloginDelaySec = 1200   // wait 20m since last logout to relogin (only occurs outside MM/Game)
    
    // no roles for h2h matches in FIFA

    // predefined rule preferences
    
    // game protocol version rule
    // disabling game protocol version rule is part of the game manager configuration
    useRandomizedGameProtocolVersionString = false
    // if false, use this game protocol version string for matchmaking
    gameProtocolVersionString = FIFA11_1.00
    gameNetworkTopology = CLIENT_SERVER_DEDICATED
    
    // Game size rule type to use new slot based rules
    sizeRule = PLAYER_SLOTS_RULES
    
    teamCount = 2 // NOTE: Needed by game packer!
    
    // Player count rule
    // comment out threshold name to disable rule
    // maxPlayerCountSeed, adds random value between 0 and seed
    // minPlayerCountSeed, adds random value between 0 and seed
    // maxPlayerCount, the lowerbound max desired size (added with random value between 0 and seed)
    // minPlayerCount, the lowerbound min desired size (added with random value between 0 and seed)
    playerCountRuleRangeList = OSDK_matchExact
    minValuePlayerCountRuleLowerBound = 2
    minValuePlayerCountRuleSeed = 0
    maxValuePlayerCountRuleLowerBound = 2
    maxValuePlayerCountRuleSeed = 0
    // this is the percentage of the difference between min & max player count to use as the desired player count
    desiredValuePlayerCountRulePercent = 100
    
    // Total Player slots rule
    totalPlayerSlotsRuleRangeList = OSDK_matchRelax
    minTotalPlayerSlotsLowerBound = 2
    minTotalPlayerSlotsSeed = 0
    maxTotalPlayerSlotsLowerBound = 2
    maxTotalPlayerSlotsSeed = 0
    desiredTotalPlayerSlotsPercent = 100
    
#ifdef __DUMMY__
    // ranked game rule
    // possible values
    // OSDK_matchExact = [0:1.0]
    // OSDK_matchAny = [0:0.0]
    rankedGameFitThresholdName = OSDK_matchExact
    unrankedFrequency = 0
    rankedFrequency = 100
    randomFrequency = 0
    abstainFrequency = 0
    
    // skill rule
    skillRuleName = skillLevel
    // possible values
    // fitFormula FIT_FORMULA_GAUSSIAN, fiftyPercentFitValueDifference = 40
    // OSDK_matchExact    = [0:1.0]
    // OSDK_matchAny      = [0:0.0]
    // OSDK_matchRelax    = [0:REM, 1:INF]
    // OSDK_skillWithin5  = [0:5]
    // OSDK_skillWithin10 = [0:10]
    // OSDK_skillWithin20 = [0:20]
    // OSDK_skillWithin30 = [0:30]
    // OSDK_skillWithin40 = [0:40]
    skillRuleFitThresholdName = OSDK_matchRelax
    userSkillValueOverrride = true
    minimumSkill = 1
    maximumSkill = 99
    // Rete3.04, note: assuming skill within 100 for now, come back and check actual max range
    
    // dnf rule
    // the maximum acceptable DNF value
    maxDNFValue = 131

    // host balancing rule
    // comment out threshold name to disable rule
    // possible values
    // matchAny = [ 0:HOSTS_UNBALANCED ]
    hostBalancingFitThresholdName = matchAny
    
    // host viability rule
    // comment out threshold name to disable rule
    // possible values
    // OSDK_connAssured = [0:CONNECTION_ASSURED]
    // OSDK_connLikely = [0:CONNECTION_LIKELY]
    // OSDK_connUnlikely = [0:CONNECTION_UNLIKELY]
    hostViabilityFitThresholdName = OSDK_connUnlikely
    
    // expanded ping site rule
    // comment out range offset list name to disable rule
    // possible values
    // OSDK_matchExact    = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }]
    // OSDK_matchAny      = [{ t=0, offset=["INF"]}]
    // OSDK_matchRelax    = [{ t=0, offset=[100]}, { t=5, offset=[200]}]
    pingSiteRangeOffsetListName = OSDK_matchRelax
    
    // geolocation rule
    geoLocationFitThresholdName = OSDK_matchRelax

    // setup game mod rule (using lowest 4 bits to represent 4 mods)
    useGameModRule = false
    maxModRegisterValue = 3
#endif
    
    pingSiteRangeOffsetListName = OSDK_matchRelax // TODO: currently this rule still gets used when validating MM criteria in packer games because scenario.cfg has: Predefined_ExpandedPingSiteRule enabled in global rules that still get blindly applied to packer matchmaknig requests. Once the legacy mm criteria validation for packer mm sessions is removed we can get rid of this setting!
    
    // generic rule configs
    #include "../etc.ilt.sports/stress/integrated/generic-rules.cfg"

    // generic attribute configs
    #include "../etc.ilt.sports/stress/integrated/generic-attributes.cfg"

    // UED values for each user, used in TeamUEDBalanceRule, and UedRule
    // Key 1 is teamSkill. Key 2 is for futSkillRating. Key 3 is for fifaSkillLevel. See usersessions.cfg
    clientUED = [
        {
            key = 1,
            minValue = 1,
            maxValue = 1000
        }
        {
            key = 2,
            minValue = 0,
            maxValue = 3000
        }
        {
            key = 3,
            minValue = 0,
            maxValue = 100
        }
    ]
    
     uedRules = {
#ifdef __DUMMY__
        futSkillRating = {
            ruleFrequency = #FUT_SKILL_RATING_RULE_FREQUENCY#
            minFitThresholdValues = {
                #FUT_SKILL_RATING_FIT_THRESHOLD# = 100    
            }
        },
#endif
        fifaSkillLevel = {
            ruleFrequency = 100
            minFitThresholdValues = {
                OSDK_matchRelax = 100
            }
        }
    }
    
    //
    // Game Manager utility configuration
    //
    
    // percent chance of a settings update on the ame
    gmGameSettingsRandomUpdates = 0.1
    // percent chance of a external session status update on the game
    gmGameExternalStatusRandomUpdates = 0.05
    // Number of cycles a game should last
    gmGameLifespan = #MM_QM_GM_LIFECPAN_CYCLES#
    // Number of cycles a player should last
    gmGamePlayerLifespan = #MM_QM_GM_LIFECPAN_CYCLES#
    // Max number of players for a game (random number from min to this)
    gmGamePlayerSeed = 10
    // Minimum number of player in a game.
    gmGamePlayerLowerLimit = 6
    // Game Mode Attribute Name
    gmGameModeAttributeName = "OSDK_gameMode"
    
    // game groups configuration
    // chance a stress instance will be a gg leader
    ggLeaderFreq = 0
    // chance a stress instance will be a gg follower
    ggJoinerFreq = 0
    // Control the fraction of instances that create game groups for the test.  The remaining fraction execute the test action RPCs
    ggGamegroupsFreq = 0.02
    ggCapacity = 1    
    // Control the how long the group remains alive - a scalar to delay (so time = grouptimescalar * delay) 
    ggLifespan = #MM_QM_GM_LIFECPAN_CYCLES#
    ggMemberLifespan = #MM_QM_GM_LIFECPAN_CYCLES#


    //
    // Game Reporting utility configuration
    //
    
    // the game types to use to send reports
    // NOTE: currently we only have a single H2H report creator registered for gameType0 with the CustomGameReporterFactory,
    // before adding more report types here you'll need to register more report creators/handlers
    onlineReportGameTypes = [ 
        { typeName = "gameType0",  weight = 100 }
    ]

    // NOTE: currently we only have a single Solo report creator registered for gameType7 with the CustomGameReporterFactory,
    // before adding more report types here you'll need to register more report creators/handlers
    offlineReportGameTypes = [ 
        { typeName = "gameType7", weight = 100 }
    ]

    grSubmitReports = true
    
    overrideUserGeoIpSampleDbFilename = "#GEOIP_SAMPLES_DB#"
}

