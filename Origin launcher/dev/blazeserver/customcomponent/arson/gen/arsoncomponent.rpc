[ headername="gamemanager/tdf/gamemanager.h" ]
#include "gamemanager/gen/gamemanager.tdf"

[
  client_include = false,
  headername="arson/tdf/usersetdefs_server.h"
]
#include "arson/gen/usersetdefs_server.tdf"

[ headername="arson/tdf/arson.h" ]
#include "arson/gen/arson.tdf"

[ headername="stats/tdf/stats.h" ]
#include "stats/gen/stats.tdf"

[headername="achievements/tdf/achievements.h"]
#include "achievements/gen/achievements.tdf"

[
  client_include = false,
  headername="arson/tdf/arson_server.h"
]
#include "arson/gen/arson_server.tdf"

[ headername="authentication/tdf/authentication.h" ]
#include "authentication/gen/authentication.tdf"

[headername="framework/tdf/oauth.h"]
#include "framework/gen/oauth.tdf"

[
  client_include = false,
  headername="framework/tdf/oauth_server.h"
]
#include "framework/gen/oauth_server.tdf"

[headername="bytevault/tdf/bytevault.h"]
#include "bytevault/gen/bytevault.tdf"

[headername="arson/identity/tdf/arsonidentitytypes.h"]
#include "arson/gen/identity/arsonidentitytypes.tdf"

[ headername="gdprcompliance/tdf/gdprcompliancetypes.h" ]
#include "gdprcompliance/gen/gdprcompliancetypes.tdf"

namespace Blaze
{
namespace Arson
{

[
  id = custom/1,
  description = "A helper component for the ARSON framework.  Not to be used by clients.",
  details = "This component has no production use, and is used only for testing." ,
  configurationType = ArsonConfig
]
component Arson
{
    permissions
    {
        PERMISSION_ARSON_POKE_PERMISSION_TEST = 1;
    }

    errors
    {
        [ description = "Invalid parameter." ]
        ARSON_ERR_INVALID_PARAMETER = 1;
        [ description = "Key is not found for user extended data." ]
        ARSON_ERR_KEY_NOT_FOUND = 2;
        [ description = "Data is not found in user extended data." ]
        ARSON_ERR_DATA_NOT_FOUND = 3;
        [ description = "The blazeServer wasn't able to find a game with the supplied gameId." ]
        ARSON_ERR_INVALID_GAME_ID = 4;
        [ description = "The game doesn't have enough available slots of the requested SlotType.  Note: this error is specific SlotType you are joining with; if you need a public slot and none are available, you'll get GAME_FULL, even if there are open private slots." ]
        ARSON_ERR_GAME_FULL = 5;
        [ description = "The game is full, and there's not enough room in the game's queue for you (or your entire group would overflow the queue)." ]
        ARSON_ERR_QUEUE_FULL  = 6;
        [ description = "The player's game join failed because the game doesn't allow players to join using the supplied JoinMethod." ]
        ARSON_ERR_JOIN_METHOD_NOT_SUPPORTED = 7;
        [ description = "The player wasn't found in a game, or the player may not exist at all (Note: we don't hit the user DB to validate a user's existence)." ]
        ARSON_ERR_PLAYER_NOT_FOUND = 8;
        [ description = "The player's joinGame failed; he doesn't satisfy the game's EntryCriteria formula.  See the JoinGameCb's entry criteria string for details." ]
        ARSON_ERR_GAME_ENTRY_CRITERIA_FAILED = 9;
        [ description = "There was a mismatch in game protocol versions" ]
        ARSON_ERR_GAME_PROTOCOL_VERSION_MISMATCH = 10;
        [ description = "The player can't join the game; the game's GameSettings::setEnforceSingleGroupJoin flag is set and the game already has 2 game groups in it." ]
        ARSON_ERR_ENFORCING_SINGLE_GROUP_JOINS = 11;
        [ description = "The gamemanager component was not found on this slave." ]
        ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND = 12;
        [ description = "The Specified category was unknown." ]
        ARSON_ERR_STATS_UNKNOWN_CATEGORY = 19;
        [ description = "Invalid operation on stats." ]
        ARSON_ERR_STATS_INVALID_OPERATION = 20;
        [ description = "The component was not found." ]
        ARSON_ERR_COMPONENT_NOT_FOUND = 21;
        [ description = "The server failed to reload the config." ]
        ARSON_ERR_CONFIG_RELOAD_FAILED = 22;
        [ description = "Interval requested is not being tracked." ]
        ARSON_ERR_CTRL_ERROR_INVALID_INTERVAL = 23;
        [ description = "The server failed to validate the config" ]
        ARSON_ERR_CONFIG_VALIDATION_FAILED = 24;
        [ description = "A reconfigure is already in progress" ]
        ARSON_ERR_CONFIG_RECONFIGURE_IN_PROGRESS = 25;
        [ description = "The reconfigure was skipped" ]
        ARSON_ERR_CONFIG_RECONFIGURE_SKIPPED = 26;
        [ description = "In valid game capacity settings, the desired capacity of the game to be created is less than the number of people that need to join the game." ]
        ARSON_ERR_GAME_CAPACITY_TOO_SMALL = 27;
        [ description = "An invalid action was attempted, this action is only available for individual player instead of a group." ]
        ARSON_ERR_INVALID_ACTION_FOR_GROUP = 28;
        [ description = "The game failed to parse the game entry criteria." ]
        ARSON_ERR_INVALID_GAME_ENTRY_CRITERIA = 29;
        [ description = "The capacity changes are invalid, it's above the maximum players capacity of the game." ]
        ARSON_ERR_PLAYER_CAPACITY_TOO_LARGE = 30;
        [ description = "The blazeServer has a compile-time limit of SLOT_ID_MAX_COUNT players in a game (256 by default).  See gamesessionmaster.h on the server." ]
        ARSON_ERR_MAX_PLAYER_CAPACITY_TOO_LARGE = 31;
        [ description = "The blazeServer wasn't able to find a user group with the supplied id." ]
        ARSON_ERR_INVALID_GROUP_ID = 32;
        [ description = "The player is not a member of the specified group." ]
        ARSON_ERR_PLAYER_NOT_IN_GROUP = 33;
        [ description = "The capacity changes are invalid, it can't be 0." ]
        ARSON_ERR_PLAYER_CAPACITY_IS_ZERO = 34;
        [ description = "vector should be empty, or contain 2+ teams. a single team makes no sense." ]
        ARSON_ERR_INVALID_TEAM_CAPACITIES_VECTOR_SIZE = 35;
        [ description = "vector contains multiple nodes for a single teamId." ]
        ARSON_ERR_DUPLICATE_TEAM_CAPACITY = 36;
        [ description = "INVALID_TEAM_ID is reserved, and cannot be used in the team capacities vector." ]
        ARSON_ERR_INVALID_TEAM_ID_IN_TEAM_CAPACITIES_VECTOR = 37;
        [ description = "trying to perform a team operation on a game or player for a team that isn't allowed (not present in capacity vector)" ]
        ARSON_ERR_TEAM_NOT_ALLOWED = 38;
        [ description = "sum of all teams is not equal to the game's total capacity." ]
        ARSON_ERR_TOTAL_TEAM_CAPACITY_INVALID = 39;
        [ description = "trying to join a full team, or a team that you cannot fit your entire game group into." ]
        ARSON_ERR_TEAM_FULL = 40;
        [ description = "The secret does not match with the guid." ]
        ARSON_ERR_INVALID_PERSISTED_GAME_ID_OR_SECRET = 41;
        [ description = "The persisted game id is in use." ]
        ARSON_ERR_PERSISTED_GAME_ID_IN_USE = 42;
        [ description = "Reserved ids are only allowed if dynamically created dedicated server mode is enabled and the ID isn't already taken by an existing game." ]
        ARSON_ERR_RESERVED_GAME_ID_INVALID = 43;
        [ description = "Dynamic dedicated server creation or a game reset (or a matchmaking session) depending on dynamic dedicated server creation failed because the job timed out before the server was created." ]
        ARSON_ERR_DYNAMIC_GAME_CREATION_TIMED_OUT = 44;
        [ description = "Invalid team capcacity.  All teams must have the same maximum capcity." ]
        ARSON_ERR_INVALID_TEAM_CAPACITY = 45;
        [ description = "The type of entry requested is not valid for the join method.  Matchmaking does not allow claiming reservations." ]
        ARSON_ERR_INVALID_GAME_ENTRY_TYPE = 46;
        [ description = "You must have admin rights on the game to issue this RPC." ]
        ARSON_ERR_PERMISSION_DENIED = 47;
        [ description = "System Error: a player was banned from the game, but couldn't be removed." ]
        ARSON_ERR_REMOVE_PLAYER_FAILED = 48;
        [ description = "This RPC cannot be issued while the game is in its current state (GameState)." ]
        ARSON_ERR_INVALID_GAME_STATE_ACTION = 49;
        [ description = "Attempting to take an action on an existing (but invalid) player.  For example, banning or kicking yourself out of a game." ]
        ARSON_ERR_INVALID_PLAYER_PASSEDIN = 50;
        [ description = "The banned players have exceed the max banned users numable that setting at configuration file." ]
        ARSON_ERR_BANNED_LIST_MAX = 51;
        [ description = "The player isn't found in the banned list of the game, remove the banned player failure." ]
        ARSON_ERR_BANNED_PLAYER_NOT_FOUND = 52;
        [ description = "The capacity changes are invalid, it's less than current players count of the game." ]
        ARSON_ERR_PLAYER_CAPACITY_TOO_SMALL = 53;
        [ description = "The user could not be found." ]
        ARSON_ERR_USER_NOT_FOUND = 54;
        [ description = "Master not available." ]
        ARSON_ERR_NO_MASTER = 55;
        [ description = "Collection ID in use." ]
        ARSON_ERR_COLLECTION_ID_IN_USE = 56;
        [ description = "Collection ID in use." ]
        ARSON_ERR_OBJECT_ID_IN_USE = 57;
        [ description = "Collection not found." ]
        ARSON_ERR_COLLECTION_ID_NOT_FOUND = 58;
        [ description = "Object not found." ]
        ARSON_ERR_OBJECT_ID_NOT_FOUND = 59;
        [ description = "An invalid action was attempted, this action is only available for dedicated server network topology" ]
        ARSON_ERR_DEDICATED_SERVER_ONLY_ACTION = 60;
        [ description = "A DB query timed out" ]
        ARSON_ERR_DB_QUERY_TIMEOUT = 61;
        [ description = "Bad period type" ]
        ARSON_ERR_STATS_BAD_PERIOD_TYPE = 62;
        [ description = "Scope defination is not right." ]
        ARSON_ERR_STATS_BAD_SCOPE_INFO = 63;
        [ description = "Stat not found" ]
        ARSON_ERR_STAT_NOT_FOUND = 64;
        [ description = "Invalid update type" ]
        ARSON_ERR_STATS_INVALID_UPDATE_TYPE = 65;
        [ description = "Command fiber error" ]
        ARSON_ERR_COMMAND_FIBER_ERROR = 66;
        [ description = "XML encoding failed" ]
        ARSON_ERR_XML_ENCODING_FAILED = 67;
        [ description = "JSON encoding failed" ]
        ARSON_ERR_JSON_ENCODING_FAILED = 68;
        [ description = "The num field was invalid." ]
        ARSON_ERR_BAD_NUM = 69;
        [ description = "Unknown identity type." ]
        ARSON_ERR_UNKNOWN_IDENTITY_TYPE = 70;
        [ description = "Database error." ]
        ARSON_ERR_DB = 71;
        [ description = "Userset error." ]
        ARSON_ERR_USERSET = 72;
        [ description = "Mail error." ]
        ARSON_ERR_MAIL = 73;
        [description = "Unknown error occurred." ]
        ARSON_ERR_UNKNOWN = 74;
        [ description = "Feature is disabled on the messaging server." ]
        ARSON_ERR_FEATURE_DISABLED = 75;
        [ description = "Exceeded maximum number of message attributes." ]
        ARSON_ERR_MAX_ATTR_EXCEEDED = 76;
        [ description = "Messaging database error." ]
        ARSON_ERR_DATABASE = 77;
        [ description = "Message target not found." ]
        ARSON_ERR_TARGET_NOT_FOUND = 78;
        [ description = "Message target type is invalid." ]
        ARSON_ERR_TARGET_TYPE_INVALID = 79;
        [ description = "Target message inbox is full." ]
        ARSON_ERR_TARGET_INBOX_FULL = 80;
        [ description = "Cannot create user/persona because email/displayname already exists." ]
        ARSON_ERR_AUTH_EXISTS = 81;
        [ description = "The value is missing." ]
        ARSON_ERR_AUTH_FIELD_MISSING = 82;
        [ description = "The clubs component was not found on this slave." ]
        ARSON_ERR_CLUBS_COMPONENT_NOT_FOUND = 83;
        [ description = "Required privilege for the operation is missing." ]
        ARSON_CLUBS_ERR_NO_PRIVILEGE = 84;
        [ description = "The user with this blaze Id does not exist." ]
        ARSON_CLUBS_ERR_INVALID_CLUB_ID = 85;
        [ description = "Only one of the two can be non-empty string, either news text or string id." ]
        ARSON_CLUBS_ERR_NEWS_TEXT_OR_STRINGID_MUST_BE_EMPTY = 86;
        [ description = "When publishing non-associate news, associate club id must be 0." ]
        ARSON_CLUBS_ERR_ASSOCIATE_CLUB_ID_MUST_BE_ZERO = 87;
        [ description = "The name is not appropriate." ]
        ARSON_CLUBS_ERR_PROFANITY_FILTER = 88;
        [ description = "Invalid request argument." ]
        ARSON_CLUBS_ERR_INVALID_ARGUMENT = 89;
        [ description = "Invalid leaderboard ID" ]
        ARSON_STATS_ERR_INVALID_LEADERBOARD_ID = 90;
        [ description = "No data returned by DB" ]
        ARSON_STATS_ERR_DB_DATA_NOT_AVAILABLE = 91;
        [ description = "Bad period offset" ]
        ARSON_STATS_ERR_BAD_PERIOD_OFFSET = 92;
        [ description = "Scope defination is not right." ]
        ARSON_STATS_ERR_BAD_SCOPE_INFO = 93;
        [ description = "Failed to obtain DB connection" ]
        ARSON_STATS_ERR_NO_DB_CONNECTION = 94;
        [ description = "Invalid object ID is supplied" ]
        ARSON_STATS_ERR_INVALID_OBJECT_ID = 95;
        [ description = "The stats component was not found on this slave." ]
        ARSON_ERR_STATS_COMPONENT_NOT_FOUND = 96;
        [ description = "Config data is not loaded" ]
        ARSON_STATS_ERR_CONFIG_NOTAVAILABLE = 97;
        [ description = "The user does not exist or is invalid" ]
        ARSON_ERR_INVALID_USER = 98;
        [ description = "Groupname is required" ]
        ARSON_ERR_GROUPNAME_REQUIRED = 99;
        [description="Entitlement tag is required"]
        ARSON_ERR_ENTITLEMENT_TAG_REQUIRED = 100;
        [ description = "Group name failed whilelist test" ]
        ARSON_ERR_WHITELIST = 101;
        [ description = "Failed linking persona and entitlement" ]
        ARSON_ERR_LINK_PERSONA = 102;
        [ description = "The user is not authorized" ]
        ARSON_ERR_NOT_AUTHORIZED = 103;
        [ description = "This command requires the user to log in." ]
        ARSON_ERR_AUTHENTICATION_REQUIRED = 104;
        [ description = "The specified access group was not found." ]
        ARSON_ERR_ACCESS_GROUP_ERR_INVALID_GROUP = 105;
        [ description = "The specified access group is default group for the referenced user." ]
        ARSON_ERR_ACCESS_GROUP_ERR_DEFAULT_GROUP = 106;
        [ description = "The referenced user does not belong to the specified group." ]
        ARSON_ERR_ACCESS_GROUP_ERR_NOT_CURRENT_GROUP = 107;
        [ description = "The referenced user already belong to the specified group." ]
        ARSON_ERR_ACCESS_GROUP_ERR_CURRENT_GROUP = 108;
        [ description = "There is no group is found for specified external id and client type." ]
        ARSON_ERR_ACCESS_GROUP_ERR_NO_GROUP_FOUND = 109;
        [ description = "The entity type is not recognized by the component." ]
        ARSON_ERR_ERR_ENTITY_TYPE_NOT_FOUND = 110;
        [ description = "no entity is found matching the type name and name provided." ]
        ARSON_ERR_ERR_ENTITY_NOT_FOUND = 111;
        [ description = "the entity provided is recognized, but searching by name is not supported." ]
        ARSON_ERR_ERR_NOT_SUPPORTED = 112;
        [ description = "The record payload can be found at the location specified in the Location header" ]
        ARSON_ERR_BYTEVAULT_RECORD_REDIRECT = 113;
        [ description = "The context name does not correspond to any contexts in ByteVault" ]
        ARSON_ERR_BYTEVAULT_INVALID_CONTEXT = 114;
        [ description = "The context name is missing" ]
        ARSON_ERR_BYTEVAULT_MISSING_CONTEXT = 115;
        [ description = "The label is missing" ]
        ARSON_ERR_BYTEVAULT_MISSING_LABEL = 116;
        [ description = "The description is missing" ]
        ARSON_ERR_BYTEVAULT_MISSING_DESCRIPTION = 117;
        [ description = "The category name does not correspond to any categories in ByteVault" ]
        ARSON_ERR_BYTEVAULT_INVALID_CATEGORY = 118;
        [ description = "The category name is missing" ]
        ARSON_ERR_BYTEVAULT_MISSING_CATEGORY = 119;
        [ description = "The record payload is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_PAYLOAD = 120;
        [ description = "The Content-Type header is missing from the request" ]
        ARSON_ERR_BYTEVAULT_MISSING_CONTENT_TYPE = 121;
        [ description = "The Content-Length header is missing from the request" ]
        ARSON_ERR_BYTEVAULT_MISSING_CONTENT_LENGTH = 122;
        [ description = "The record name is missing" ]
        ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME = 123;
        [ description = "The specified user type is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE = 124;
        [ description = "Exceeding max record size" ]
        ARSON_ERR_BYTEVAULT_MAX_RECORD_SIZE_EXCEEDED = 125;
        [ description = "Exceeding max record count" ]
        ARSON_ERR_BYTEVAULT_MAX_RECORD_COUNT_EXCEEDED = 126;
        [ description = "Creation time is missing" ]
        ARSON_ERR_BYTEVAULT_MISSING_CREATION_TIME = 127;
        [ description = "This operation is not allowed" ]
        ARSON_ERR_BYTEVAULT_NOT_ALLOWED = 128;
        [ description = "User is invalid or user authentication failed" ]
        ARSON_ERR_BYTEVAULT_INVALID_USER = 129;
        [ description = "No records match the specified criteria" ]
        ARSON_ERR_BYTEVAULT_NO_MATCHING_RECORD = 130;
        [ description = "The max record size is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_MAX_RECORD_SIZE = 131;
        [ description = "The max record count is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_MAX_RECORD_COUNT = 132;
        [ description = "The specified action type is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_ACTION_TYPE = 133;
        [ description = "The specified action requires authentication" ]
        ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED = 134;
        [ description = "The specified token type is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE = 135;
        [ description = "The specified trusted source IP is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_TRUSTED_SOURCE = 136;
        [ description = "Invalid JSON format string" ]
        ARSON_ERR_BAD_JSON = 137;
        [ description = "The specified deletion time is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_LASTUPDATETIME = 138;
        [ description = "The specified role is full" ]
        ARSON_ERR_ROLE_FULL = 139;
        [ description = "The role entry criteria is not met" ]
        ARSON_ERR_ROLE_CRITERIA_FAILED = 140;
        [ description = "The specified role is invalid" ]
        ARSON_ERR_ROLE_NOT_ALLOWED = 141;
        [ description = "The specified blaze id cannot be authenticated" ]
        ARSON_ERR_UNKNOWN_BLAZE_ID = 142;
        [ description = "The referenced session was not found." ]
        ARSON_USER_ERR_SESSION_NOT_FOUND = 143;
        [ description = "The max history record count is invalid" ]
        ARSON_ERR_BYTEVAULT_INVALID_MAX_HISTORY_RECORD_COUNT = 144;
        [ description = "The BlazeId provided is invalid." ]
        ARSON_INVALID_BLAZE_ID = 145;
        [ description = "XML decoding failed" ]
        ARSON_ERR_XML_DECODING_FAILED = 146;
        [ description = "No XBL token is available for the user. This is likely due to the user being externally available in MS, but not 'known' to Nucleus." ]
        ARSON_ERR_NO_XBLTOKEN = 147;
        [ description = "Xbox Live Multiplayer Session Directory returned general/unknown failure" ]
        ARSON_ERR_EXTERNAL_SESSION_FAILED = 148;
        [ description = "The external session service had an unspecified internal error. Check with Microsoft for potential issues." ]
        ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR = 149; //http 500
        [ description = "The external session service is currently unavailable, possibly due to momentary downtime, updates or service maintenance." ]
        ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE = 150; //http 503
        [ description = "The external session service call failed due to possible bad gateway." ]
        ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY = 151; //http 502
        [ description = "The specified item's object exists in Blaze but was expected not to." ]
        ARSON_ERR_ARSON_UNEXPECTED_EXISTING_ENTITY = 152;
        [ description = "The Blaze Game's members or external session tracking is incorrect or out of sync with the first party external session. Check logs for details."]
        ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC = 153;
        [ description = "A generic problem with the combination of game settings you're trying to use.  For example, you might be trying to change a game's ranked setting on the 360 after game creation (not allowed by XBL)." ]
        ARSON_ERR_INVALID_GAME_SETTINGS = 154;

        // Redis errors
        ARSON_REDIS_ERR_NOT_FOUND = 155;
        ARSON_REDIS_ERR_INVALID_CONFIG = 156;
        ARSON_REDIS_ERR_TIMEOUT = 157;
        ARSON_REDIS_ERR_NOT_CONNECTED = 158;
        ARSON_REDIS_ERR_ALREADY_CONNECTED = 159;
        ARSON_REDIS_ERR_DNS_LOOKUP_FAILED = 160;
        ARSON_REDIS_ERR_CONNECT_FAILED = 161;
        ARSON_REDIS_ERR_SEND_COMMAND_FAILED = 162;
        ARSON_REDIS_ERR_SERVER_AUTH_FAILED = 163;
        ARSON_REDIS_ERR_UNEXPECTED_TYPE = 164;
        ARSON_REDIS_ERR_COMMAND_FAILED = 165;
        ARSON_REDIS_ERR_OBJECT_NOT_FOUND = 166;
        ARSON_REDIS_ERR_MOVED = 167;

        [ description = "The Blaze Game was tracked as having an associated external session but no such external session was found on the first party side. This can occur due to timing or network issues, that cause things to get out of sync with the first party service."]
        ARSON_ERR_EXTERNAL_SESSION_NOT_FOUND = 170;
        [ description = "The number of calls by the user for has exceeded the command's rate limit. Check error info/logs for details and required wait time." ]
        ARSON_ERR_EXTERNAL_SERVICE_BUSY = 171;
        [ description = "JSON decoding failed" ]
        ARSON_ERR_JSON_DECODING_FAILED = 172;

        //SecretVault errors
        [ description = "Invalid request, missing or invalid data." ]
        ARSON_SECRETVAULT_ERR_INVALID_REQUEST = 173;
        [ description = "Forbidden, your authentication details are either incorrect or you don't have access to this feature." ]
        ARSON_SECRETVAULT_ERR_FORBIDDEN = 174;
        [ description = "Invalid path. This can both mean that the path truly doesn't exist or that you don't have permission to view a specific path. We use 404 in some cases to avoid state leakage." ]
        ARSON_SECRETVAULT_ERR_INVALID_PATH = 175;
        [ description = "Rate limit exceeded. Try again after waiting some period of time." ]
        ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED = 176;
        [ description = "Internal server error. An internal error has occurred, try again later. If the error persists, report a bug." ]
        ARSON_SECRETVAULT_ERR_INTERNAL = 177;
        [ description = "The secret vault is down for maintenance or is currently sealed. Try again later." ]
        ARSON_SECRETVAULT_ERR_SEALED = 178;

        [ description = "Request to the resource or operation was refused. This may be due to the client or Blaze Server configuration not using the correct title id, the title not having its service properly configured, or, the client being currently signed out from 1st party etc." ]
        ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN = 190;      //typically from an http 403
        [ description = "Invalid or malformed request parameters." ]
        ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST = 191;           //typically from an http 400
        [ description = "The request's parameters were incorrect/invalid." ]
        ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST = 192;   //typically from an http 409
    }

    slave
    {
        methods
        {
            [
              errors = {ARSON_ERR_KEY_NOT_FOUND, ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_DATA_NOT_FOUND},
              id = 1,
              description = "Debug tool to test retrieving the user extended data by name and id"
            ]
            GetUEDResponse getUserExtendedData(GetUEDRequest);

            [
              errors = {ARSON_ERR_KEY_NOT_FOUND, ARSON_ERR_INVALID_PARAMETER},
              id = 2,
              description = "Debug tool to update the user extended data by name and id"
            ]
            void updateUserExtendedData(UpdateUEDRequest);

            [
              id = 3,
              description = "Shutdown one, some or all server instances.",
              generate_command_class = false,
              blocking = true
            ]
            void shutdown(ShutdownRequest);

            [
              errors = {
                    ARSON_ERR_COMPONENT_NOT_FOUND,
                    ARSON_ERR_CONFIG_RELOAD_FAILED,
                    ARSON_ERR_CONFIG_VALIDATION_FAILED,
                    ARSON_ERR_CONFIG_RECONFIGURE_IN_PROGRESS,
                    ARSON_ERR_CONFIG_RECONFIGURE_SKIPPED
              },
              errortype = ReconfigureResponse,
              id = 4,
              description = "Reconfigure Blaze Master"
            ]
            void reconfigure(ReconfigureRequest);

            [
              id = 10,
              description = "Set Component State"
            ]
            SetComponentStateResponse setComponentState(SetComponentStateRequest);

            [
                id=12,
                description = "Echos back the tdf passed in to test nested open variable tdfs."
            ]
            EchoTdfRequestResponse echoTdf(EchoTdfRequestResponse);

            [
              id = 13,
              description = "Testing enum parameter passing.",
              requires_authentication = false,
              client_export = false
            ]
            TestEnumResponse testEnum(TestEnumRequest);

            [
              errors = {
                    ARSON_ERR_STATS_UNKNOWN_CATEGORY,
                    ARSON_ERR_STATS_INVALID_OPERATION
              },
              id = 15,
              description = "Wipe the statistics data"
            ]
            void wipeStats(Blaze::Stats::WipeStatsRequest);

            [
              id = 16,
              description = "Enables or disables Nucleus bypass",
              requires_authentication = false
            ]
            void bypassNucleus(BypassNucleusRequest);

            [
              id = 17,
              errors = { ARSON_ERR_CTRL_ERROR_INVALID_INTERVAL },
              description = "Get the Component Metrics"
            ]
            ComponentMetricsResponse getComponentMetrics(ComponentMetricsRequest);

            [
              id = 18,
              errors = {
              ARSON_ERR_STATS_BAD_PERIOD_TYPE,
              ARSON_ERR_STATS_UNKNOWN_CATEGORY,
              ARSON_ERR_STATS_BAD_SCOPE_INFO,
              ARSON_ERR_STAT_NOT_FOUND,
              ARSON_ERR_STATS_INVALID_UPDATE_TYPE
              },
              description = "Updates stats."
             ]
             void updateStats(Blaze::Stats::UpdateStatsRequest);

             [
               id = 19,
               description = "Retrieves User rank"
             ]
             GetUserRankResponse getUserRank(GetUserRankRequest);

            [
              errors = { ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_PLAYER_NOT_FOUND, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND },
              id = 20,
              description = "Allows the current player to override matchmaking and always attempt to match into the provided game. ARSON: Provides access to Blazeserver's GameManager::matchmakingDedicatedServerOverride (non-SDK rpc)"
            ]
            void arsonMatchmakingDedicatedServerOverride(Blaze::GameManager::MatchmakingDedicatedServerOverrideRequest);

            [
              id = 21,
              description = "LookUp Geographical location of the user's IP"
            ]
            LookUpIpResponse LookUpIp(LookUpIpRequest);

            [
              id = 22,
              description = "Encode a TDF into XML format",
              errors = {
                ARSON_ERR_XML_ENCODING_FAILED
              }
            ]
            XMLEncodeTDFResponse xmlEncodeTDF(XMLEncodeTDFRequest);

            [
              id = 23,
              description = "Returns a summary of stat period configurations."
            ]
            PeriodIds getPeriodIds();

            [
              errors = {
                    ARSON_ERR_GAME_CAPACITY_TOO_SMALL,
                    ARSON_ERR_INVALID_ACTION_FOR_GROUP,
                    ARSON_ERR_INVALID_GAME_ENTRY_CRITERIA,
                    ARSON_ERR_PLAYER_CAPACITY_TOO_LARGE,
                    ARSON_ERR_MAX_PLAYER_CAPACITY_TOO_LARGE,
                    ARSON_ERR_GAME_FULL,
                    ARSON_ERR_INVALID_GROUP_ID,
                    ARSON_ERR_PLAYER_NOT_IN_GROUP,
                    ARSON_ERR_PLAYER_CAPACITY_IS_ZERO,
                    ARSON_ERR_INVALID_TEAM_CAPACITIES_VECTOR_SIZE,
                    ARSON_ERR_DUPLICATE_TEAM_CAPACITY,
                    ARSON_ERR_INVALID_TEAM_ID_IN_TEAM_CAPACITIES_VECTOR,
                    ARSON_ERR_TEAM_NOT_ALLOWED,
                    ARSON_ERR_TOTAL_TEAM_CAPACITY_INVALID,
                    ARSON_ERR_TEAM_FULL,
                    ARSON_ERR_INVALID_GAME_SETTINGS,
                    ARSON_ERR_INVALID_PERSISTED_GAME_ID_OR_SECRET,
                    ARSON_ERR_PERSISTED_GAME_ID_IN_USE,
                    ARSON_ERR_RESERVED_GAME_ID_INVALID,
                    ARSON_ERR_DYNAMIC_GAME_CREATION_TIMED_OUT,
                    ARSON_ERR_INVALID_TEAM_CAPACITY,
                    ARSON_ERR_INVALID_GAME_ENTRY_TYPE,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 24,
              description = "Creates a game"
            ]
            Blaze::GameManager::CreateGameResponse createGame(Blaze::Arson::ArsonCreateGameRequest);

            [
              errors = {
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_REMOVE_PLAYER_FAILED,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 25,
              description = "Destroys a game"
            ]
            Blaze::GameManager::DestroyGameResponse destroyGame(Blaze::Arson::DestroyGameRequest);

            [
              errors = {
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_INVALID_GAME_STATE_ACTION,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 26,
              description = "Updates the game settings for the game.  This replaces the entire game settings, not the delta, on error no settings are updated."
            ]
            void setGameSettings(Blaze::Arson::SetGameSettingsRequest);

            [
              errors = {
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_INVALID_GAME_STATE_ACTION,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 27,
              description = "Updates the game attributes for the game."
            ]
            void setGameAttributes(Blaze::Arson::SetGameAttributesRequest);

            [
              errors = {
                    ARSON_ERR_PLAYER_NOT_FOUND,
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_REMOVE_PLAYER_FAILED,
                    ARSON_ERR_INVALID_PLAYER_PASSEDIN,
                    ARSON_ERR_BANNED_LIST_MAX,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 28,
              description = "Ban player from a game session. Bans the account from the game session.  Kicks player from game if already in."
            ]
            void banPlayer(Blaze::Arson::BanPlayerRequest);

            [
              errors = {
                    ARSON_ERR_PLAYER_NOT_FOUND,
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_BANNED_PLAYER_NOT_FOUND,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 29,
              description = "Remove a player from the game sessions banned list for game session admins."
            ]
            void removePlayerFromBannedList(Blaze::Arson::RemovePlayerFromBannedListRequest);

            [
              errors = {
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 30,
              description = "Clear the game session banned list, removing all bans for game session admins."
            ]
            void clearBannedList(Blaze::Arson::ClearBannedListRequest);

            [
              errors = {
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 31,
              description = "Rename the game session name for game session admins."
            ]
            void updateGameName(Blaze::Arson::UpdateGameNameRequest);

            [
              errors = {
                    ARSON_ERR_INVALID_GAME_ID,
                    ARSON_ERR_INVALID_GAME_STATE_ACTION,
                    ARSON_ERR_PLAYER_CAPACITY_TOO_SMALL,
                    ARSON_ERR_PLAYER_CAPACITY_TOO_LARGE,
                    ARSON_ERR_PLAYER_CAPACITY_IS_ZERO,
                    ARSON_ERR_PERMISSION_DENIED,
                    ARSON_ERR_INVALID_TEAM_CAPACITIES_VECTOR_SIZE,
                    ARSON_ERR_DUPLICATE_TEAM_CAPACITY,
                    ARSON_ERR_INVALID_TEAM_ID_IN_TEAM_CAPACITIES_VECTOR,
                    ARSON_ERR_TEAM_NOT_ALLOWED,
                    ARSON_ERR_TOTAL_TEAM_CAPACITY_INVALID,
                    ARSON_ERR_INVALID_TEAM_CAPACITY,
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND
              },
              id = 32,
              description = "Set the player capacity for a game."
            ]
            void setPlayerCapacity(Blaze::Arson::SetPlayerCapacityRequest);

            [
              id = 33,
              description = "Retrieve a list of reconfigurable components"
            ]
            ReconfigurableFeaturesResponse getReconfigurableFeatures();

            [
              id = 34,
              description = "Check for Profanity in the text and return true or false.",
              requires_authentication = false
            ]
            ProfanityCheckResponse ProfanityCheck(ProfanityCheckRequest);

            [
              id = 35,
              passthrough = createGameMaster,
              description = "Creates a game"
            ]
            Blaze::GameManager::CreateGameResponse createGamePassthrough(Blaze::Arson::ArsonCreateGameRequest);

            [
              id = 36,
              errors = {ARSON_ERR_BAD_NUM, ARSON_ERR_NO_MASTER},
              errortype = ArsonError,
              description = "This command will poke the Blaze server and return a response.",
              details = "If a negative number is passed in the num field, this command will return an error.",
              requires_authentication = false
            ]
            ArsonResponse pokeSlave(ArsonRequest);

            [
              id = 37,
              description = "Copies the request directly into the response.",
              details = "Used to test successful decoding of various types.",
              requires_authentication = false
            ]
            MyTest echo(MyTest);

            [
              id = 38,
              requires_authentication = false,
              errors = {ARSON_ERR_DB}
            ]
            void queryDb(QueryRequest);

            [
              id = 39,
              requires_authentication = false,
              errors = {ARSON_ERR_DB}
            ]
            void httpRequest(HttpRequest);

            [
              id = 40,
              description = "Deletes stats",
              requires_authentication = false
            ]
            void deleteStats(Blaze::Arson::DeleteStatsRequest);

            [
              id = 41,
              description = "Debug tool to test Clubs component method for updating club info.",
              requires_authentication = false
            ]
            void reportResultToClubs(ReportResultToClubsRequest);

            [
              id = 42,
              description = "Debug tool to test Clubs component method for updating club recordbook.",
              requires_authentication = false
            ]
            void updateClubRecordbook(UpdateClubRecordbookRequest);

            [
              id = 43,
              description = "Debug tool to test Clubs component method for awarding club.",
              requires_authentication = false
            ]
            void awardClub(AwardClubRequest);

            [
              id = 44,
              description = "Debug tool to publish club ticker message.",
              requires_authentication = false
            ]
            void publishClubTickerMessage(PublishClubTickerMessageRequest);

            [
              id = 45,
              description = "This sends a message to the client."
            ]
            void sendMessage(SendMessageRequest);

            [
              id = 46,
              errors = {
                    ARSON_ERR_UNKNOWN,
                    ARSON_ERR_FEATURE_DISABLED,
                    ARSON_ERR_MAX_ATTR_EXCEEDED,
                    ARSON_ERR_DATABASE,
                    ARSON_ERR_TARGET_NOT_FOUND,
                    ARSON_ERR_TARGET_TYPE_INVALID,
                    ARSON_ERR_TARGET_INBOX_FULL},
              description = "This command will send the provided message to recepients defined by MessageTarget."
            ]
            Blaze::Messaging::SendMessageResponse sendSourceMessage(Blaze::Messaging::SendSourceMessageRequest);

            [
              id = 47,
              errors = {
                     ARSON_ERR_AUTH_EXISTS,
                     ARSON_ERR_AUTH_FIELD_MISSING},
              description = "Backdoor arson helper, bypasses Nucleus validation. login the session simulating any specified LoginUserSessionRequest params (e.g. use this to fake external ids, external system id etc).",
              details = "This RPC should only be enabled for testing and will bypass any Nucleus validation",
              requires_authentication = false,
              client_export = true
            ]
            Blaze::Authentication::LoginResponse arsonLoginUserSession(Blaze::Arson::ArsonLoginSessionRequest);

            [
              id = 48,
              description = "Posts news for club.",
              details = "Posts news for the club. Only GMs can post news.",
              errors = {
                    ARSON_CLUBS_ERR_NO_PRIVILEGE,
                    ARSON_CLUBS_ERR_INVALID_CLUB_ID,
                    ARSON_CLUBS_ERR_NEWS_TEXT_OR_STRINGID_MUST_BE_EMPTY,
                    ARSON_CLUBS_ERR_PROFANITY_FILTER,
                    ARSON_CLUBS_ERR_ASSOCIATE_CLUB_ID_MUST_BE_ZERO,
                    ARSON_ERR_CLUBS_COMPONENT_NOT_FOUND}
            ]
            void postNews(Blaze::Arson::PostNewsRequest);

            [
              id = 49,
              description = "Gets membership information for the list of users",
              details = "Gets membership information for the list of users",
              errors = {
                    ARSON_CLUBS_ERR_INVALID_ARGUMENT,
                    ARSON_ERR_CLUBS_COMPONENT_NOT_FOUND
                }
            ]
            GetClubMembershipForUsersResponse getClubMembershipForUsers(GetClubMembershipForUsersRequest);

            [
              id = 50,
              errors = {
                ARSON_STATS_ERR_INVALID_LEADERBOARD_ID,
                ARSON_STATS_ERR_DB_DATA_NOT_AVAILABLE,
                ARSON_STATS_ERR_BAD_PERIOD_OFFSET,
                ARSON_STATS_ERR_BAD_SCOPE_INFO, ARSON_STATS_ERR_NO_DB_CONNECTION,
                ARSON_STATS_ERR_INVALID_OBJECT_ID,ARSON_ERR_STATS_COMPONENT_NOT_FOUND},
              description = "Returns an ordered list of filtered leaderboard rows,",
              details = "Each row contains string values for all stats including the ranked one."
            ]
            LeaderboardStatValues getFilteredLeaderboard(FilteredLeaderboardStatsRequest);

            [
              id = 51,
              errors = {
                ARSON_STATS_ERR_CONFIG_NOTAVAILABLE,
                ARSON_STATS_ERR_INVALID_LEADERBOARD_ID,
                    ARSON_ERR_STATS_COMPONENT_NOT_FOUND },
              description = "Returns description of leaderboard group.",
              details = "Input is a leaderboard ID, result is a description of a leaderboard."
            ]
            LeaderboardGroupResponse getLeaderboardGroup(LeaderboardGroupRequest);

            [
              id = 53,
              description = "Grant an entitlement to the logged in account and optionally link it with the logged in persona",
              details = "Grant an entitlement to the logged in account and optionally link it with the logged in persona",
              requires_authentication = true,
              requiresUserSession = false,
              errors = {
                    ARSON_ERR_INVALID_USER,
                    ARSON_ERR_GROUPNAME_REQUIRED,
                    ARSON_ERR_ENTITLEMENT_TAG_REQUIRED,
                    ARSON_ERR_WHITELIST,
                    ARSON_ERR_LINK_PERSONA}
            ]
            Blaze::Authentication::GrantEntitlement2Response grantEntitlement2(Blaze::Arson::GrantEntitlement2Request);

            [
              id = 55,
              description="get PSU mapped by client type and GeoIP data"
            ]
            GetPSUResponse getPSUByClientType(GetMetricsByGeoIPDataRequest);

            [
              id = 56,
              description="get PSU mapped by game network topology and GeoIP data"
            ]
            GetPSUResponse getPSUByGameNetworkTopology(GetMetricsByGeoIPDataRequest);

            [
              id = 57,
              requires_authentication = false
            ]
            void slaveException();

            [
              id = 58,
              requires_authentication = false
            ]
            void masterException();

            [
              id = 59,
              requires_authentication = false
            ]
            void slaveNotificationException();

            [
              id = 60,
              requires_authentication = false
            ]
            void replicationException();

            [
              id = 61,
              passthrough = createMapMaster,
              requires_authentication = false
            ]
            void createMap(ExceptionMapRequest);

            [
              id = 62,
              passthrough = destroyMapMaster,
              requires_authentication = false
            ]
            void destroyMap(ExceptionMapRequest);

            [
              id = 63,
              passthrough = mapInsertMaster,
              requires_authentication = false
            ]
            void mapInsert(ExceptionMapUpdateRequest);

            [
              id = 64,
              passthrough = mapUpdateMaster,
              requires_authentication = false
            ]
            void mapUpdate(ExceptionMapUpdateRequest);

            [
              id = 65,
              errors = { ARSON_ERR_COLLECTION_ID_NOT_FOUND, ARSON_ERR_OBJECT_ID_NOT_FOUND },
              generate_command_class = false,
              requires_authentication = false
            ]
            ExceptionMapEntry mapGet(ExceptionMapValueRequest);

            [
              id = 66,
              passthrough = mapEraseMaster,
              requires_authentication = false
            ]
            void mapErase(ExceptionMapValueRequest);

            [
              id = 67,
              description = "Issues a DB query with a 1 ms timeout value to simulate query timeout.",
              details = "Issues a DB query with a 1 ms timeout value to simulate query timeout.",
              errors = {
                ARSON_ERR_DB_QUERY_TIMEOUT
              }
            ]
            void simulateDbQueryTimeout();

            [
              id = 68,
              description = "Retrieves the server's ARSON component config TDF",
              details = "Retrieves the server's ARSON component config TDF"
            ]
            GetConfigResponse getArsonConfig();

            [
              id = 69,
              description = "Simulates streaming db query feature in server",
              details = "Simulates streaming db query feature in server",
              errors = {
                ARSON_ERR_DB_QUERY_TIMEOUT
              }
            ]
            StreamingDbQueryResponse simulateStreamingDbQuery();

            [
              id = 70,
              description = "Returns a command fiber error",
              details = "Returns a command fiber error",
              errors = {
                ARSON_ERR_COMMAND_FIBER_ERROR
              }
            ]
            void generateCommandFiberError();

            [
              id = 71,
              description = "Simulates a long RPC call",
              details = "Simulates a long RPC call by counting to 1000000"
            ]
            void simulateLongRPCCall();

            [
              id = 72,
              description = "Triggers a notification to the second slave listener",
              details = "A passthrough to the master that will send a notification, triggering the second slave to send a notification to the client",
              passthrough = secondSlaveMasterNotification
            ]
            void secondSlaveNotification();

            [
              id = 73,
              description = "Sends back a custom error as indicated by the request"
            ]
            void generateCustomError(GenerateCustomErrorRequest);

            [
              id = 74,
              requires_authentication = false
            ]
            void slaveExceptionMemAllocator();

            [
              id = 75,
              description = "Test the XML2 encoder by encoding nested union tdf"
            ]
            void testXml2Encoder();

            [
              id = 76,
              description = "Encode a TDF into JSON format",
              errors = {
                ARSON_ERR_JSON_ENCODING_FAILED
              }
            ]
            JSONEncodeTDFResponse jsonEncodeTDF(JSONEncodeTDFRequest);

            [
                id = 77,
                description = "Test to run a command from another command."
            ]
            void runCommandFromAnotherCommand();

            [
                id = 78,
                description = "Command run from runCommandFromAnotherComamnd"
            ]
            void commandToRunFromAnotherCommand();

            [
              id = 79,
              description = "Get User Profile Info from Nucleus",
              requires_authentication = false
            ]
            GetUserProfilesResponse getUserProfiles(GetUserProfilesRequest);

            [
              id = 80,
              description = "look up entity by type and name",
              errors = {
                  ARSON_ERR_ERR_ENTITY_TYPE_NOT_FOUND,
                  ARSON_ERR_ERR_ENTITY_NOT_FOUND,
                  ARSON_ERR_ERR_NOT_SUPPORTED
              },
              requires_authentication = true
            ]
            EntityLookupResponse lookupEntityByName(EntityLookupRequest);

            [
              id = 81,
              description = "look up entity name by id",
              errors = {
                  ARSON_ERR_ERR_ENTITY_TYPE_NOT_FOUND,
                  ARSON_ERR_ERR_ENTITY_NOT_FOUND,
                  ARSON_ERR_ERR_NOT_SUPPORTED
              },
              requires_authentication = true
            ]
            EntityLookupByIdResponse lookupEntityById(EntityLookupByIdRequest);

            [
              id = 82,
              description = "look up entity names by ids",
              errors = {
                  ARSON_ERR_ERR_ENTITY_TYPE_NOT_FOUND,
                  ARSON_ERR_ERR_NOT_SUPPORTED
              },
              requires_authentication = true
            ]
            EntitiesLookupByIdsResponse lookupEntitiesByIds(EntitiesLookupByIdsRequest);

            [
              id = 83,
              description = "Test Blaze MySQL DB Prepared Statement"
            ]
            void testPreparedStatement();

            [
              id = 84,
              description = "Test UpdateStatsHelper"
            ]
            void testUpdateStatsHelper(TestUpdateStatsHelperRequest);

            [
              id = 85,
              description = "Forces a client connection to be lost",
              details = "Force closes a client connection with a resumable reason"
            ]
            void forceLostConnection();

            [
              id = 86,
              description = "Check the connectivity of a user session's connection",
              requires_authentication = false,
              requiresUserSession = false
            ]
            void checkConnectivity(CheckConnectivityREQ);

            [
              id = 87,
              description = "Adds or removes an admin from a context",
              details = "Adds or removes an admin from a context.  Use ADMIN_TYPE_INVALID to remove an admin from a context.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_NOT_ALLOWED,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT
              },
              requestPayloadMember = "map"
            ]
            Blaze::ByteVault::UpsertAdminResponse bvUpsertAdmin(Blaze::ByteVault::UpsertAdminRequest);

            [
              id = 88,
              description = "Fetches an admin and their permissions per context",
              details = "Fetches an admin user and their corresponding permissions per context.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetAdminResponse bvGetAdmin(Blaze::ByteVault::GetAdminRequest);

            [
              id = 89,
              description = "Creating or updating a context",
              details = "Creates a context if it doesn't exist; replaces existing context if it does exist.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_MISSING_LABEL,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_DESCRIPTION,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE,
                  ARSON_ERR_BYTEVAULT_NOT_ALLOWED
              }
            ]
            Blaze::ByteVault::UpsertContextResponse bvUpsertContext(Blaze::ByteVault::UpsertContextRequest);

            [
              id = 90,
              description = "Fetching context(s)",
              details = "Fetches specific context by name if one is specified or all contexts if no name is specified.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetContextsResponse bvGetContexts(Blaze::ByteVault::GetContextsRequest);

            [
              id = 91,
              description = "Fetching context",
              details = "Fetches specific context by name",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::Context bvGetContext(Blaze::ByteVault::GetContextsRequest);

            [
              id = 92,
              description = "Deleting a context",
              details = "Deletes a specific context and the underlying categories and records by context name.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            void bvDeleteContext(Blaze::ByteVault::DeleteContextRequest);

            [
              id = 93,
              description = "Creating or updating a category",
              details = "Creates a category if it doesn't exist; replaces the existing category if it does exist",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_MAX_RECORD_COUNT,
                  ARSON_ERR_BYTEVAULT_INVALID_MAX_RECORD_SIZE,
                  ARSON_ERR_BYTEVAULT_MISSING_DESCRIPTION,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE,
                  ARSON_ERR_BYTEVAULT_INVALID_TRUSTED_SOURCE,
                  ARSON_ERR_BYTEVAULT_NOT_ALLOWED,
                  ARSON_ERR_BYTEVAULT_INVALID_MAX_HISTORY_RECORD_COUNT
              }
            ]
            Blaze::ByteVault::UpsertCategoryResponse bvUpsertCategory(Blaze::ByteVault::UpsertCategoryRequest);

            [
              id = 94,
              description = "Fetching categories by criteria",
              details = "Returns a list of categories matching supplied context and category name",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetCategoriesResponse bvGetCategories(Blaze::ByteVault::GetCategoriesRequest);

            [
              id = 95,
              description = "Fetching a category",
              details = "Returns a category",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::Category bvGetCategory(Blaze::ByteVault::GetCategoriesRequest);

            [
              id = 96,
              description = "Delete a category",
              details = "Deletes a category specified by context name and category name",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            void bvDeleteCategory(Blaze::ByteVault::DeleteCategoryRequest);

            [
              id = 97,
              description = "Create a new record or update an existing record",
              details = "Creates a record if it doesn't exist; partial or full update of a record that exists",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_PAYLOAD,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTENT_TYPE,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTENT_LENGTH,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_MAX_RECORD_SIZE_EXCEEDED,
                  ARSON_ERR_BYTEVAULT_MAX_RECORD_COUNT_EXCEEDED,
                  ARSON_ERR_BYTEVAULT_NOT_ALLOWED,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::UpsertRecordResponse bvUpsertRecord(Blaze::ByteVault::UpsertRecordRequest);

            [
              id = 98,
              description = "Fetch specified record",
              details = "Fetches the specified record including payload data",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_RECORD_REDIRECT,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetRecordResponse bvGetRecord(Blaze::ByteVault::GetRecordRequest);

            [
              id = 99,
              description = "Fetch specified record info",
              details = "Fetches the specified record but without the payload data",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_RECORD_REDIRECT,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::HeadRecordResponse bvHeadRecord(Blaze::ByteVault::GetRecordRequest);

            [
              id = 100,
              description = "Fetch record info for records across owners that match the context, category and record name",
              details = "Fetch record info for records across owners that match the context, category and record name",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetRecordInfoResponse bvGetRecordsInfo(Blaze::ByteVault::GetRecordInfoRequest);

            [
              id = 101,
              description = "Deletes a record",
              details = "Deletes a specified record",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE,
                  ARSON_ERR_BYTEVAULT_NO_MATCHING_RECORD
              }
            ]
            void bvDeleteRecord(Blaze::ByteVault::DeleteRecordRequest);

            [
              id = 102,
              description = "Soft-deletes record(s)",
              details = "Soft-deletes records that match the specified criteria",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            void bvArchiveRecords(Blaze::ByteVault::ArchiveRecordsRequest);

            [
              id = 103,
              description = "Fetches admin change history that matches criteria",
              details = "Fetches admin change history that matches criteria",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetAdminChangeHistoryResponse bvGetAdminChangeHistory(Blaze::ByteVault::GetAdminChangeHistoryRequest);

            [
              id = 104,
              description = "Deletes soft-deleted record(s)",
              details = "Deletes soft-deleted records that match the specified criteria",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE,
                  ARSON_ERR_BYTEVAULT_NO_MATCHING_RECORD
              }
            ]
            void bvDeleteHistoryRecord(Blaze::ByteVault::DeleteHistoryRecordRequest);

            [
              id = 105,
              description = "Test of getting user and other user info by blaze id",
              requires_authentication = false
            ]
            GetUserInfoByBlazeIdResponse getUserInfoByBlazeId(GetUserRequest);

            [
              id = 106,
              description = "Specifically for GOS-12576 in small usersession cache scenario",
              requires_authentication = false
            ]
            GetUserInfoByBlazeIdResponse getUserInfoByBlazeIdGOS12576(GetUserInfoByBlazeIdGOS12576Request);

            [
              id = 107,
              description = "Backdoor for getAchievements Util"
            ]
            Blaze::Achievements::GetAchievementsResponse getAchievements(Blaze::Achievements::GetAchievementsRequest);

            [
              id = 109,
              description = "Backdoor for grantAchievement Util"
            ]
            Blaze::Achievements::AchievementData grantAchievement(Blaze::Achievements::GrantAchievementRequest);

            [
              id = 111,
              description = "Fetch specified soft-deleted record",
              details = "Fetches the specified soft-deleted record including the payload data",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_INVALID_LASTUPDATETIME,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_NO_MATCHING_RECORD,
                  ARSON_ERR_BYTEVAULT_RECORD_REDIRECT,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetHistoryRecordResponse bvGetHistoryRecord(Blaze::ByteVault::GetHistoryRecordRequest);

            [
              id = 112,
              description = "Fetch specified soft-deleted record",
              details = "Fetches the specified soft-deleted record but without the payload data",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_INVALID_LASTUPDATETIME,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_NO_MATCHING_RECORD,
                  ARSON_ERR_BYTEVAULT_RECORD_REDIRECT,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
                }
            ]
            Blaze::ByteVault::HeadHistoryRecordResponse bvHeadHistoryRecord(Blaze::ByteVault::GetHistoryRecordRequest);

            [
              id = 113,
              description = "Fetch record info for all the soft-deleted versions of the record identified by the record address.",
              details = "Fetch record info for all the soft-deleted versions of the record identified by the record address.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetHistoryRecordInfoResponse bvGetArchivedRecordsInfo(Blaze::ByteVault::GetRecordInfoRequest);

            [
              id = 114,
              description = "Fetches data rates for record fetches and uploads.",
              details = "Fetches data rates, including overall and broken down by context/category for record fetches and uploads.",
              internal = true,
              requires_authentication = true,
              errors = {
              }
            ]
            Blaze::ByteVault::GetDataRatesResponse bvGetDataRates(Blaze::ByteVault::GetDataRatesRequest);

            [
              id = 115,
              description = "Fetches error rates for Bytevault RPCs",
              details = "Fetches error rates broken down by context/category for each Bytevaylt RPC",
              internal = true,
              requires_authentication = true,
              errors = {
              }
            ]
            Blaze::ByteVault::GetErrorRatesResponse bvGetErrorRates(Blaze::ByteVault::GetErrorRatesRequest);

            [
              id = 116,
              description = "Restores the specified history record as the active record",
              details = "Restores the specified history record as the active record",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_INVALID_LASTUPDATETIME,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_NO_MATCHING_RECORD,
                  ARSON_ERR_BYTEVAULT_RECORD_REDIRECT,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::UpsertRecordResponse bvRestoreRecord(Blaze::ByteVault::GetHistoryRecordRequest);

            [
              id = 117,
              description = "Fetch record info for all the history versions of the record identified by the specified record address.",
              details = "Fetch record info for all the history versions of the record identified by the specified record address.",
              requires_authentication = false,
              errors = {
                  ARSON_ERR_BYTEVAULT_AUTHENTICATION_REQUIRED,
                  ARSON_ERR_BYTEVAULT_INVALID_CONTEXT,
                  ARSON_ERR_BYTEVAULT_INVALID_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_CONTEXT,
                  ARSON_ERR_BYTEVAULT_MISSING_CATEGORY,
                  ARSON_ERR_BYTEVAULT_MISSING_RECORD_NAME,
                  ARSON_ERR_BYTEVAULT_INVALID_USER,
                  ARSON_ERR_BYTEVAULT_INVALID_USER_TYPE,
                  ARSON_ERR_BYTEVAULT_INVALID_TOKEN_TYPE
              }
            ]
            Blaze::ByteVault::GetHistoryRecordInfoResponse bvGetHistoryRecordsInfo(Blaze::ByteVault::GetRecordRequest);

            [
              id = 118,
              description = "Localize function that takes in substitution params"
            ]
            LocalizeStringRsp LocalizeString(LocalizeStringReq);

            [
              id = 120,
              requires_authentication = false,
              description = "Trusted Login for Blaze Services e.g. GOS-CC"
            ]
            Blaze::Authentication::LoginResponse trustedLogin(Blaze::Arson::TrustedLoginRequest);

            [
              id = 122,
              description = "Decode an XML payload into TDF",
              errors = {
                 ARSON_ERR_XML_DECODING_FAILED
              }
            ]
            XMLDecodeTDFResponse xmlDecodeTDF(XMLDecodeTDFRequest);

            // Redis test RPCs
            [
              errors = {},
              id = 123,
              description = "Redis test RPC"
            ]
            RedisResponse redis(RedisRequest);

            [
              errors = {},
              id = 124,
              description = "Inserting 64 bit integer into arson_test_data table"
            ]
            void Query64BitInt(Query64BitIntRequest);

            [
              errors = {},
              id = 125,
              description = "Make a session-less call to Utils userSetting RPCs"
            ]
            void ScheduleFibreCallToUtilsRPC();

            [
              errors = {},
              id = 126,
              description = "get user ids",
              requires_authentication = false
            ]
            GetUserIdsResponse GetUserIds(GetUserIdsRequest);

            [
              errors = {},
              id = 127,
              description = "http call from the blaze server that sets xmlpayload",
              requires_authentication = false
            ]
            void HttpCallWithXMLpayload();

            [
              errors = {},
              id = 128,
              description = "look for all the usersession ids local to the aux slave",
              requires_authentication = false
            ]
            LookupUserSessionIdResponse arsonAuxlookupLocalUserSessionId();

            [
              id = 129,
              description = "look up user access token for nucleus 2.0 through arsoncomponent",
              requires_authentication = false,
              errors = {
                    ARSON_ERR_INVALID_USER
                }
            ]
            Blaze::OAuth::GetUserAccessTokenResponse GetUserAccessToken (Blaze::OAuth::GetUserAccessTokenRequest);

            [
              id = 130,
              description = "Wrapper for REST GET,PUT,POST,DELETE requests to test service",
              requires_authentication = false,
              errors = {}
            ]
            SlowTxnObject SlowHttpTransaction(SlowTxnObject);

            [
              id = 131,
              description = "Wrapper for GetSensitiveInfo requests to test service",
              requires_authentication = false,
              errors = {}
            ]
            SlowTxnSensitiveInfoObject SlowHttpSensitiveInfoTxn(SlowTxnSensitiveInfoObject);

            [
              id = 132,
              description = "Get Unique Device Id for UserSession via framework interface",
              errors = {
                     ARSON_USER_ERR_SESSION_NOT_FOUND,
                     ARSON_ERR_COMPONENT_NOT_FOUND
                }
            ]
            GetUniqueDeviceIdForUserSessionResponse GetUniqueDeviceIdForUserSession(GetUniqueDeviceIdForUserSessionRequest);

            [
              id = 133,
              description = "Trigger the draining of blazeserver instances",
              requires_authentication = false,
              errors = {}
            ]
            void ArsonDrainServer(ArsonDrainRequest);

            /////////////////////////////////////////////////////////////////////////////////////////
            //       Nucleus Requests
            /////////////////////////////////////////////////////////////////////////////////////////

            [
              id = 135,
              requires_authentication = false
            ]
            GetPersonaStatusRSP GetPersonaStatus(GetPersonaStatusREQ);

            [
              id = 140,
              requires_authentication = false
            ]
            GetPersonaIdRSP GetPersonaId(GetPersonaIdREQ);

            [
              id = 145,
              requires_authentication = false
            ]
            void updateEntitlement(UpdateEntitlementREQ);

            [
              id = 155,
              requires_authentication = false
            ]
            GetPersonaRSP getPersona(GetPersonaREQ);

            [
              id = 156,
              requires_authentication = false
            ]
            TriggerTdfEchoResponse triggerBlazeTdfEcho(TriggerTdfEchoRequest);

            [
              errors = {},
              id = 157,
              description = "Test TDF String Map",
              requires_authentication = false
            ]
            void TestTdfStringMap();

            [
              errors = {},
              id = 158,
              description = "Clears all lists for a set of users"
            ]
            void ClearAssociationListsForUsers(ClearAssociationListRequest);

            [
              id = 159,
              description = "validate token format"
            ]
            void validateAccessTokenFormat(AccessTokenFormatValidationRequest);

            [
                id = 160,
                description = "Compare Nucleus API response of OPAQUE token with info of JWT token"
            ]
            CompareNucleusApiResponsesResponse CompareNucleusApiResponses(CompareNucleusApiResponsesRequest);

            /////////////////////////////////////////////////////////////////////////////////////////
            //       Multiplayer Session Directory
            /////////////////////////////////////////////////////////////////////////////////////////

            [
              id = 161,
              description = "Retrieve external session using ARSON's back door component. (This rpc is exposed to clients)",
              details = "Retrieve external session",
              errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC}
            ]
            GetXblMultiplayerSessionResponse getXblMultiplayerSession(GetXblMultiplayerSessionRequest);

            // Http RESTful method, wrapped by getXblMultiplayerSession.
            [
              id = 162,
              description = "Retrieve session via HTTP (blazeserver side only)",
              details = "Retrieve session",
              requires_authentication = false,
              client_export = false,
              //generate_command_class = false,
              http = {
                  resource = "serviceconfigs/{scid}/sessiontemplates/{sessionTemplateName}/sessions/{sessionName}",
                  method = "GET",
                  custom_request_headers = {
                      "x-xbl-contract-version" = "GetRestXblSessionRequestHeader.contractVersion",
                      "Authorization"          = "GetRestXblSessionRequestHeader.authToken"
                  },
                  addEncodedPayload = false
              }
            ]
            GetRestXblSessionResponse getRestXblSession(GetRestXblSessionRequest);

            [
              id = 163,
              description = "If present, clears external session. Return ARSON_ERR_INVALID_PARAMETER if failed loading params for external session  call. Returns ARSON_ERR_ARSON_UNEXPECTED_EXISTING_ENTITY if entity id wasnt removed by blaze in the first place (aborts remove from external session in this case).",
              details = "If present, clears external session. Return ARSON_ERR_INVALID_PARAMETER if failed loading params for external session  call. Returns ARSON_ERR_ARSON_UNEXPECTED_EXISTING_ENTITY if entity id wasnt removed by blaze in the first place (aborts remove from external session in this case).",
              errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_ARSON_UNEXPECTED_EXISTING_ENTITY, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC}
            ]
            GetXblMultiplayerSessionResponse clearXblMultiplayerSession(GetXblMultiplayerSessionRequest);

            /////////////////////////////////////////////////////////////////////////////////////////
            //       XBL Users/People Social
            /////////////////////////////////////////////////////////////////////////////////////////

            [
              id = 164,
              description = "retrieve user's social relationships",
              details = "retrieve user's social relationships. This is the actual rpc to XBL.",
              requires_authentication = false,
              client_export = false,
              errors = { ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR, ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE, ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY },
              http = {
                  resource = "users/xuid({externalId})/people",
                  method = "GET",
                  custom_request_headers = {
                      "x-xbl-contract-version" = "header.contractVersion",
                      "Authorization"          = "header.authToken"
                  },
                  status_code_errors = {
                      400 = ARSON_ERR_EXTERNAL_SESSION_FAILED,// bad request usually internal err
                      401 = ARSON_ERR_AUTHENTICATION_REQUIRED,
                      403 = ARSON_ERR_NOT_AUTHORIZED,         // forbidden on external session side
                      404 = ARSON_ERR_COMPONENT_NOT_FOUND,    // possible xbl network issues, retryable
                      503 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE,
                      500 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR,
                      502 = ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY
                  }
                  // No payload
              }
            ]
            GetRestXblUsersPeopleResponse getRestXblUsersPeople(GetRestXblUsersPeopleRequest);

            [
              id = 165,
              description = "retrieve user's social relationships",
              details = "retrieve user's social relationships. Wraps getRestXblUsersPeople for ARSON tests.",
              errors = {ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR, ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE, ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY }
            ]
            ArsonGetXblUsersPeopleResponse getXblUsersPeople(ArsonGetXblUsersPeopleRequest);

            [
              id = 166,
              description = "retrieve user's current primary external session",
              details = "retrieve user's current primary 'activity' external session. This is the actual rpc to XBL.",
              requires_authentication = false,
              client_export = false,
              errors = { ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR, ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE, ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY },
              http = {
                  resource = "handles/query?include=relatedInfo",
                  method = "POST",
                  custom_request_headers = {
                      "x-xbl-contract-version" = "header.contractVersion",
                      "Authorization"          = "header.authToken"
                  },
                  status_code_errors = {
                      400 = ARSON_ERR_EXTERNAL_SESSION_FAILED,// bad request usually internal err
                      401 = ARSON_ERR_AUTHENTICATION_REQUIRED,
                      403 = ARSON_ERR_NOT_AUTHORIZED,         // forbidden on external session side
                      404 = ARSON_ERR_COMPONENT_NOT_FOUND,    // possible xbl network issues, retryable
                      503 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE,
                      500 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR,
                      502 = ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY
                  },
                  addEncodedPayload = true,
                  requestPayloadMember = "body"
              }
            ]
            PostRestXblGetActivityResponse postRestXblGetActivity(PostRestXblGetActivityRequest); // analogous to Blaze's PostHandlesGetActivityResponse postHandlesGetActivity(PostHandlesGetActivityRequest);

            [
              id = 167,
              description = "retrieve user's current primary external session",
              details = "retrieve user's current primary 'activity' external session. Wraps postRestXblActivityForUser for ARSON.",
              errors = {ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR, ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE, ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY }
            ]
            ArsonGetXblActivityForUserResponse getXblActivityForUser(ArsonGetXblActivityForUserRequest);

            /////////////////////////////////////////////////////////////////////////////////////////
            //       Xbox One reputation support
            /////////////////////////////////////////////////////////////////////////////////////////
            [
              id = 168,
              description = "Send feedback to a single user",
              details = "Send feedback to a single user to make its reputation flip"
            ]
            void xblPostFeedback(PostFeedbackRequest);

            [
              id = 169,
              description = "Get reputation helper"
            ]
            GetReputationResponse xblGetReputation(GetReputationRequest);

            [
              id = 170,
              description = "Updates reputation for the given user session list."
            ]
            DoReputationUpdateResponse xblDoReputationUpdate(DoReputationUpdateRequest);

            [
              id = 171,
              description = "Reset reputation by user"
            ]
            void xblPostResetReputation(PostResetReputationRequest);

            [
              id = 172,
              description = "Get user xbl token",
              errors = {
               ARSON_ERR_INVALID_USER,
               ARSON_ERR_NO_XBLTOKEN
              }
            ]
            Blaze::OAuth::GetUserXblTokenResponse getUserXblToken(Blaze::OAuth::GetUserXblTokenRequest);

            [
              id = 173,
              generate_command_class = false,
              description = "Test Lilbcurl with SSL using SFtp",
              requires_authentication = false
            ]
            PullRemoteXmlFilesResponse pullRemoteXmlFiles();

            [
              id = 174,
              description = "A configurable command which has a timed sleep",
              requires_authentication = false
            ]
            TimedSleepRequestResponse timedSleep(TimedSleepRequestResponse);

            [
              id = 175,
              description = "Override usersession's geoip data",
                requires_authentication = true,
                errors = {
                    ARSON_ERR_USER_NOT_FOUND
                }
            ]
            void sessionOverrideGeoIPById(Blaze::GeoLocationData);

            [
              id = 176,
              description = "Retrieve geographical coordinates of a given user",
              requires_authentication = true
            ]
            GetCoordsRSP getUserCoordinates(GetCoordsREQ);

            [
              id = 178,
              errors = { ARSON_ERR_UNKNOWN_IDENTITY_TYPE, ARSON_ERR_INVALID_PARAMETER },
              description = "Test identity lookups",
              requires_authentication = false
            ]
            IdentityResponse lookupIdentity(IdentityRequest);

            [
                id = 179,
                errors = {},
                description = "Retrieve SessionUserInfo from the gCurrentUserSession"
            ]
            SessionUserInfoData getSessionUserInfo();

            [
                id = 180,
                errors = {},
                description = "Retrieve Product Name from the gCurrentUserSession"
            ]
            UserSessionProductNameData getUserSessionProductName();

            [
                id = 181,
                errors = {},
                description = "Retrieve ClientIp from the gCurrentUserSession"
            ]
            GetClientIpResponse getUserSessionClientIp();

            [
                id = 182,
                errors = {},
                description = "Retrieve ClientIp from the gCurrentUserSession"
            ]
            void sendCustomPinEvent(SendCustomPinEventRequest);

            [
                id = 184,
                passthrough = sendTestNotificationToClientMaster,
                description = "Send test notification to client"
            ]
            void sendTestNotificationToClient();

            [
                id = 185,
                description = "Encode a TDF into Http format"
            ]
            HttpEncodeTDFResponse httpEncodeTDF(HttpEncodeTDFRequest);

            [
                id = 186,
                description = "Encode a TDF to binary, decode it and do verification"
            ]
            EchoTdfRequestResponse echoBinaryTDF(EchoTdfRequestResponse);

            [
              id = 187,
              errors = {ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND },
              description = "Get the list of matchmaking server overrides that currently exist for all players. ARSON: Provides access to Blazeserver's GameManager::getMatchmakingDedicatedServerOverrides (non-SDK rpc)"
            ]
            Blaze::GameManager::GetMatchmakingDedicatedServerOverrideResponse arsonGetMatchmakingDedicatedServerOverrides();

            [
              id = 188,
              errors = { ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND },
              description = "Allows GOSCC to override matchmaking for all players and always attempt to match into the provided games first. ARSON: Provides access to Blazeserver's GameManager::matchmakingDedicatedServerOverride (non-SDK rpc)"
            ]
            void arsonMatchmakingFillServersOverride(Blaze::GameManager::MatchmakingFillServersOverrideList);

            [
              id = 189,
              errors = {ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND },
              description = "Get the list of matchmaking server fill overrides that currently exist. ARSON: Provides access to Blazeserver's GameManager::getMatchmakingFillServerOverride (non-SDK rpc)"
            ]
            Blaze::GameManager::MatchmakingFillServersOverrideList  arsonGetMatchmakingFillServersOverride();

            [
              id = 190,
              requires_authentication = false,
              description = "Get the sliver ids assigned to an instance"
            ]
            Blaze::Arson::GetSliversResponse getSlivers(Blaze::Arson::GetSliversRequest);

            [
              id = 191,
              description = "Subscribe or unsubscribe a user session"
            ]
            void UpdateUserSessionSubscription(UpdateUserSessionSubscriptionRequest);

            [
              id = 192,
              description = "Check if blazeserver is IN-SERIVCE",
              requires_authentication = false
            ]
            BlazeServerInServiceRSP IsBlazeServerInService();

            [
              id = 193,
              description = "Fetch user session data"
            ]
            UserSessionData FetchUserSessionData(FetchUserSessionDataRequest);

            [
                id = 194,
                description = "Insert into redis or get data from redis",
                errors = {
                    ARSON_REDIS_ERR_NOT_FOUND,
                    ARSON_REDIS_ERR_INVALID_CONFIG,
                    ARSON_REDIS_ERR_TIMEOUT,
                    ARSON_REDIS_ERR_NOT_CONNECTED,
                    ARSON_REDIS_ERR_ALREADY_CONNECTED,
                    ARSON_REDIS_ERR_DNS_LOOKUP_FAILED,
                    ARSON_REDIS_ERR_CONNECT_FAILED,
                    ARSON_REDIS_ERR_SEND_COMMAND_FAILED,
                    ARSON_REDIS_ERR_SERVER_AUTH_FAILED,
                    ARSON_REDIS_ERR_UNEXPECTED_TYPE,
                    ARSON_REDIS_ERR_COMMAND_FAILED,
                    ARSON_REDIS_ERR_OBJECT_NOT_FOUND,
                    ARSON_REDIS_ERR_MOVED
                }
            ]
            RedisMapData RedisOperation(RedisMapData);

            [
                id = 195,
                description = "Get user's clientVersion"
            ]
            GetClientVersionRSP GetClientVersion(GetClientVersionREQ);

            [
                id = 196,
                description = "Fetch map that tracks whether a leaving client & dedicated server host are receiving packets from each other. Map is keyed by game id",
                requires_authentication = false
            ]
            Blaze::Arson::GetPktReceivedMetricsResponse arsonGetPktReceivedMetrics(Blaze::Arson::GetPktReceivedMetricsRequest);

            [
                id = 197,
                errors = {},
                description = "Retrieve SessionUserInfo from usersession by usersession Id"
            ]
            SessionUserInfoData getUserInfoBySessionId(GetUserInfoBySessionIdReq);


            [
                id = 198,
                errors = {},
                description = "Get sliver instance Id"
            ]
            GetSliverInstanceIdResponse getSliverInstanceId(GetSliverInstanceIdRequest);

            [
                id = 199,
                errors = {},
                description = "Get owned sliver count"
            ]
            GetOwnedSliverCountResponse getOwnedSliverCount(GetOwnedSliverCountRequest);

            /////////////////////////////////////////////////////////////////////////////////////////
            //       PS4 NP Sessions
            /////////////////////////////////////////////////////////////////////////////////////////
            [
                id = 200,
                description = "retrieve the external session",
                details = "retrieve user's PS4 NP session. Wraps REST call for ARSON.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_EXTERNAL_SERVICE_BUSY}
            ]
            GetPs4NpSessionResponse getPs4NpSession(GetPs4NpSessionRequest); // side: the platform prefix in the naming just to avoid any confusion with stock Blaze methods.

            [
                id = 201,
                description = "retrieve user's current primary external session",
                details = "retrieve user's current primary PS4 NP session, via PSN GET NP session ids for user method. Wraps REST call for ARSON.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SERVICE_BUSY}
            ]
            GetPs4PrimaryNpSessionForUserResponse getPs4PrimaryNpSessionForUser(GetPs4PrimaryNpSessionForUserRequest);

            [
                id = 202,
                description = "If present, clears user's primary external session. Return ARSON_ERR_INVALID_PARAMETER if failed loading params for external session call.",
                details = "retrieves 1st party PS4 NP session via PSN GET NP Session Ids for user call, and leaves any returned. Used for clean test setup.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC}
            ]
            GetPs4PrimaryNpSessionForUserResponse clearPs4PrimaryNpSessionForUser(ClearPs4PrimaryNpSessionForUserRequest);

            [
                id = 203,
                description = "Leaves all the user's external sessions. Multi platform.",
                details = "Used for test cleanup. If present, attempts to leave all the user's external sessions. Uses request's caller's client platform info, to determine which platform to leave sessions for.",
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED}
            ]
            void leaveAllExternalSessionsForUser(LeaveAllExternalSessionsForUserRequest);

            [
              id = 204,
              description = "Decode JSON format string to a TDF",
              errors = {
                ARSON_ERR_JSON_DECODING_FAILED
              }
            ]
            JSONDecodeTDFResponse jsonDecodeTDF(JSONDecodeTDFRequest);

            [
                id = 205,
                description = "Reads a secret from the secret vault.",
                details = "Reads a secret from the secret vault.",
                errors = {
                    ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                    ARSON_SECRETVAULT_ERR_FORBIDDEN,
                    ARSON_SECRETVAULT_ERR_INVALID_PATH,
                    ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                    ARSON_SECRETVAULT_ERR_INTERNAL,
                    ARSON_SECRETVAULT_ERR_SEALED
                },
                requires_authentication = false,
                client_export = false,
                errortype = SecretVaultErrorResponse,
                http = {
                    resource = "/v1/{path}",
                    method = "GET",
                    contentType = "application/json",
                    custom_request_headers = {
                        "X-Vault-Token" = "vaultToken",
                        "X-Vault-Namespace" = "vaultNamespace"
                    },
                    status_code_errors = {
                        400 = ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                        403 = ARSON_SECRETVAULT_ERR_FORBIDDEN,
                        404 = ARSON_SECRETVAULT_ERR_INVALID_PATH,
                        429 = ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                        500 = ARSON_SECRETVAULT_ERR_INTERNAL,
                        503 = ARSON_SECRETVAULT_ERR_SEALED
                    },
                    addEncodedPayload = false
                }
            ]
            SecretVaultSecret read(SecretVaultReadRequest);

            [
                id = 206,
                description = "Renews a lease with the secret vault.",
                details = "Renews a lease with the secret vault.",
                errors = {
                    ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                    ARSON_SECRETVAULT_ERR_FORBIDDEN,
                    ARSON_SECRETVAULT_ERR_INVALID_PATH,
                    ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                    ARSON_SECRETVAULT_ERR_INTERNAL,
                    ARSON_SECRETVAULT_ERR_SEALED
                },
                requires_authentication = false,
                client_export = false,
                errortype = SecretVaultErrorResponse,
                http = {
                    resource = "/v1/sys/leases/renew",
                    method = "PUT",
                    contentType = "application/json",
                    custom_request_headers = {
                        "X-Vault-Token" = "vaultToken",
                        "X-Vault-Namespace" = "vaultNamespace"
                    },
                    status_code_errors = {
                        400 = ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                        403 = ARSON_SECRETVAULT_ERR_FORBIDDEN,
                        404 = ARSON_SECRETVAULT_ERR_INVALID_PATH,
                        429 = ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                        500 = ARSON_SECRETVAULT_ERR_INTERNAL,
                        503 = ARSON_SECRETVAULT_ERR_SEALED
                    },
                    addEncodedPayload = true,
                    requestPayloadMember = "requestBody"
                }
            ]
            RenewLeaseResponse renewLease(SecretVaultRenewLeaseRequest);

            [
                id = 207,
                description = "Renews a token with the secret vault.",
                details = "Renews a token with the secret vault.",
                errors = {
                    ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                    ARSON_SECRETVAULT_ERR_FORBIDDEN,
                    ARSON_SECRETVAULT_ERR_INVALID_PATH,
                    ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                    ARSON_SECRETVAULT_ERR_INTERNAL,
                    ARSON_SECRETVAULT_ERR_SEALED
                },
                requires_authentication = false,
                client_export = false,
                errortype = SecretVaultErrorResponse,
                http = {
                    resource = "/v1/auth/token/renew-self",
                    method = "POST",
                    contentType = "application/json",
                    custom_request_headers = {
                        "X-Vault-Token" = "vaultToken",
                        "X-Vault-Namespace" = "vaultNamespace"
                    },
                    status_code_errors = {
                        400 = ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                        403 = ARSON_SECRETVAULT_ERR_FORBIDDEN,
                        404 = ARSON_SECRETVAULT_ERR_INVALID_PATH,
                        429 = ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                        500 = ARSON_SECRETVAULT_ERR_INTERNAL,
                        503 = ARSON_SECRETVAULT_ERR_SEALED
                    },
                    addEncodedPayload = true,
                    requestPayloadMember = "requestBody"
                }
            ]
            RenewTokenResponse renewToken(SecretVaultRenewTokenRequest);
            [
                id = 208,
                description = "Authenticate with secret vault.",
                details = "Uses the Approle Vault authentication method.",
                errors = {
                    ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                    ARSON_SECRETVAULT_ERR_FORBIDDEN,
                    ARSON_SECRETVAULT_ERR_INVALID_PATH,
                    ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                    ARSON_SECRETVAULT_ERR_INTERNAL,
                    ARSON_SECRETVAULT_ERR_SEALED
                },
                requires_authentication = false,
                errortype = SecretVaultErrorResponse,
                http = {
                    resource = "/v1/auth/approle/login",
                    method = "POST",
                    contentType = "application/json",
                    custom_request_headers = {
                        "X-Vault-Namespace" = "vaultNamespace"
                    },
                    status_code_errors = {
                        400 = ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                        403 = ARSON_SECRETVAULT_ERR_FORBIDDEN,
                        404 = ARSON_SECRETVAULT_ERR_INVALID_PATH,
                        429 = ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                        500 = ARSON_SECRETVAULT_ERR_INTERNAL,
                        503 = ARSON_SECRETVAULT_ERR_SEALED
                    },
                    addEncodedPayload = true,
                    requestPayloadMember = "requestBody"
                }
            ]
            ApproleLoginResponse approleLogin(SecretVaultApproleLoginRequest);
            [
                id = 209,
                description = "Reads a secret from the secret vault kv2 engine.",
                details = "Reads a secret from the secret vault kv2 engine.",
                errors = {
                    ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                    ARSON_SECRETVAULT_ERR_FORBIDDEN,
                    ARSON_SECRETVAULT_ERR_INVALID_PATH,
                    ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                    ARSON_SECRETVAULT_ERR_INTERNAL,
                    ARSON_SECRETVAULT_ERR_SEALED
                },
                requires_authentication = false,
                client_export = false,
                errortype = SecretVaultErrorResponse,
                http = {
                    resource = "/v2/{path}",
                    method = "GET",
                    contentType = "application/json",
                    custom_request_headers = {
                        "X-Vault-Token" = "vaultToken",
                        "X-Vault-Namespace" = "vaultNamespace"
                    },
                    status_code_errors = {
                        400 = ARSON_SECRETVAULT_ERR_INVALID_REQUEST,
                        403 = ARSON_SECRETVAULT_ERR_FORBIDDEN,
                        404 = ARSON_SECRETVAULT_ERR_INVALID_PATH,
                        429 = ARSON_SECRETVAULT_ERR_RATE_LIMIT_EXCEEDED,
                        500 = ARSON_SECRETVAULT_ERR_INTERNAL,
                        503 = ARSON_SECRETVAULT_ERR_SEALED
                    },
                    addEncodedPayload = false
                }
            ]
            SecretVaultKv2Secret kv2Read(SecretVaultReadRequest);



            /////////////////////////////////////////////////////////////////////////////////////////
            //       Identity Component
            /////////////////////////////////////////////////////////////////////////////////////////
            [
                id = 210,
                description = "Wraps Blazeserver's get identities command",
                client_export = true,
                errors = { ARSON_ERR_COMPONENT_NOT_FOUND },
                requiresUserSession = false
            ]
            IdentitiesResponse arsonGetIdentities(IdentitiesRequest);

            [
                id = 211,
                description = "Wraps Blazeserver's get identity by name command",
                client_export = true,
                errors = { ARSON_ERR_COMPONENT_NOT_FOUND },
                requiresUserSession = false
            ]
            IdentityInfo arsonGetIdentityByName(IdentityByNameRequest);

            [
                id = 212,
                description = "Tests mergeLists external data source functionality",
                errors = {
                    ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND,
                    ARSON_ERR_INVALID_PARAMETER,
                    ARSON_ERR_JSON_DECODING_FAILED
                }
            ]
            void testExternalDataSourceMergeLists(ExternalDataSourceMergeListsRequest);

            [
              id = 213,
              description = "Add a DB entry with the given values",
              requiresUserSession = false,
              requires_authentication = false
            ]
            void testAddDbEntry(TestDbEntry);

            [
              id = 214,
              description = "Get a DB entry with the given id value",
              requiresUserSession = false,
              requires_authentication = false,
              errors = { ARSON_ERR_DATA_NOT_FOUND }
            ]
            TestDbEntry testGetDbEntry(GetDbEntryRequest);
            
            /////////////////////////////////////////////////////////////////////////////////////////
            //      GDPR Custom Component Fuctions
            /////////////////////////////////////////////////////////////////////////////////////////
            [
                id = 215,
                errors = {},                      // Only ERR_OK is treated as success.  Everything else is failure. 
                internal = true,
                client_export = false,
                description = "Get all Blaze data for a specific user",
                details = "Get all Blaze data for a specific user",
                requires_authentication = false,
                blocking = true                  
            ]
            Blaze::GdprCompliance::CustomComponentGetDataResponse getUserData(Blaze::GdprCompliance::CustomComponentGetDataRequest);
 
            [
                id = 216,
                errors = {},                      // Only ERR_OK is treated as success.  Everything else is failure. 
                internal = true,
                client_export = false,
                description = "Get all Blaze data for a specific user",
                details = "Get all Blaze data for a specific user",
                requires_authentication = false,
                blocking = true                  
            ]
            void deactivateUserData(Blaze::GdprCompliance::CustomComponentGetDataRequest);   // No return value.  Just send an ERR to indicate failure. 

            [
              id = 217,
              description = "Wrapper for GetSensitiveInfo requests to test service with a complex query specification",
              requires_authentication = false,
              errors = {}
            ]
            SlowTxnSensitiveInfoObject SlowHttpSensitiveInfoTxn2(SlowTxnSensitiveInfoObject);
 


            /////////////////////////////////////////////////////////////////////////////////////////
            //       PS5 PlayerSessions
            /////////////////////////////////////////////////////////////////////////////////////////
            [
                id = 330,
                description = "retrieve the external session",
                details = "retrieve 1st party PS5 PlayerSession. Wraps Blaze's REST call for ARSON.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            GetPs5PlayerSessionResponse getPs5PlayerSession(GetPs5PlayerSessionRequest);

            [
                id = 331,
                description = "retrieve user's current primary external session",
                details = "retrieve 1st party PS5 PlayerSession via Blaze's PSN GET PlayerSessionIds for user call. Wraps Blaze's REST call for ARSON.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            GetPs5PrimaryPlayerSessionForUserResponse getPs5PrimaryPlayerSessionForUser(GetPs5PrimaryPlayerSessionForUserRequest);

            [
                id = 332,
                description = "If present, clears user's primary external session. Return ARSON_ERR_INVALID_PARAMETER if failed loading params for external session call.",
                details = "retrieve 1st party PS5 PlayerSession via Blaze's PSN GET PlayerSessionIds for user call. Used for clean test setup.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            GetPs5PrimaryPlayerSessionForUserResponse clearPs5PrimaryPlayerSessionForUser(ClearPs5PrimaryPlayerSessionForUserRequest);

            [
                id = 335,
                description = "Invite users to a PS5 PlayerSession",
                details = "send 1st party PS5 PlayerSession invites via PSN command. Wraps the server side only S2S REST call to PSN, for client.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            SendPs5PlayerSessionInvitationsResponse sendPs5PlayerSessionInvitations(SendPs5PlayerSessionInvitationsRequest);

            [
              id = 336,
              description = "Http call to Invite Users to a PSN PlayerSession",
              details = "Call to PSN to send a PSN Invite to a PlayerSession. This is the actual server side only rpc to PSN.",
              requires_authentication = false,
              client_export = false,
              errortype = Blaze::PSNServices::PsnErrorResponse,
              errors = { ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR, ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE, ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST },
              http = {
                    resource = "v1/playerSessions/{sessionId}/invitations", //Note: playerSessions apparently case sensitive
                    method = "POST",
                    custom_request_headers = {
                        "Authorization"  = "header.authToken"
                    },
                    status_code_errors = {
                        400 = ARSON_ERR_EXTERNAL_SESSION_FAILED,// bad request usually internal err
                        401 = ARSON_ERR_AUTHENTICATION_REQUIRED,
                        403 = ARSON_ERR_NOT_AUTHORIZED, // forbidden on external session side
                        404 = ARSON_ERR_COMPONENT_NOT_FOUND, // resource not found on external session side
                        429 = ARSON_ERR_EXTERNAL_SERVICE_BUSY, // PSNSESSIONMANAGER_TOO_MANY_REQUESTS on external session side
                        500 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR,
                        502 = ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY,
                        503 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE
                    },
                    requestPayloadMember = "body"
                }
            ]
            SendPlayerSessionInvitationsResponse sendPlayerSessionInvitations(SendPlayerSessionInvitationsRequest);

            [
                id = 338,
                description = "Get User's Invites to PS5 PlayerSessions",
                details = "gets 1st party PS5 PlayerSession invites via PSN command. Wraps the server side only S2S REST call to PSN, for client.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST }
            ]
            GetPs5PlayerSessionInvitationsResponse getPs5PlayerSessionInvitations(GetPs5PlayerSessionInvitationsRequest);

            [
              id = 339,
              description = "Http call to get User's Invites to a PSN PlayerSessions",
              details = "Call to PSN to get caller's PSN Invites to PlayerSessions. This is the actual server side only rpc to PSN.",
              requires_authentication = false,
              client_export = false,
              errortype = Blaze::PSNServices::PsnErrorResponse,
              errors = { ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR, ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE, ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST },
              http = {
                    resource = "v1/users/{accountId}/playerSessionsInvitations?fields=invitationId,from,sessionId,supportedPlatforms,receivedTimestamp,invitationInvalid&invitationInvalidFilter=true,false", //Note: apparently 'fields' must be specified or this may fail
                    method = "GET",
                    custom_request_headers = {
                        "Authorization"  = "header.authToken"
                    },
                    status_code_errors = {
                        400 = ARSON_ERR_EXTERNAL_SESSION_FAILED,// bad request usually internal err
                        401 = ARSON_ERR_AUTHENTICATION_REQUIRED,
                        403 = ARSON_ERR_NOT_AUTHORIZED, // forbidden on external session side
                        404 = ARSON_ERR_COMPONENT_NOT_FOUND, // resource not found on external session side
                        429 = ARSON_ERR_EXTERNAL_SERVICE_BUSY, // PSNSESSIONMANAGER_TOO_MANY_REQUESTS on external session side
                        500 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_INTERNAL_ERROR,
                        502 = ARSON_ERR_EXTERNAL_SESSION_BAD_GATEWAY,
                        503 = ARSON_ERR_EXTERNAL_SESSION_SERVICE_UNAVAILABLE
                    }
                    // No payload
                }
            ]
            GetPlayerSessionInvitationsResponse getPlayerSessionInvitations(GetPlayerSessionInvitationsRequest);


            [
              errors = {},
              id = 337,
              description = "Invokes a command handler designed specifically to see if the DB query returns expected UTF-8 characters"
            ]
            void QueryUtf8ChineseCharacters();


            /////////////////////////////////////////////////////////////////////////////////////////
            //       PS5 Matches
            /////////////////////////////////////////////////////////////////////////////////////////
            [
                id = 340,
                description = "retrieve the external session",
                details = "retrieve 1st party PS5 Match. Wraps REST call for ARSON.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            GetPs5MatchResponse getPs5Match(GetPs5MatchRequest);

            [
                id = 341,
                description = "retrieve user's current Matches its in",
                details = "retrieve 1st party PS5 Matches via GM get games and checking which have a MatchId with the player tracked in the GameSessionMaster's mTrackedExtSessMembers. Wraps REST call for ARSON.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_AUTHENTICATION_REQUIRED, ARSON_ERR_NOT_AUTHORIZED, ARSON_ERR_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SERVICE_BUSY, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            GetPs5MatchesForUserResponse getPs5MatchesForUser(GetPs5MatchesForUserRequest);

            [
                id = 342,
                description = "If present, clears user's current Matches. Return ARSON_ERR_INVALID_PARAMETER if failed loading params for external session call.",
                details = "retrieve 1st party PS5 Matches via GameManager. Used for clean test setup.",
                errortype = ExternalSessionErrorInfo,
                errors = {ARSON_ERR_INVALID_PARAMETER, ARSON_ERR_EXTERNAL_SESSION_FAILED, ARSON_ERR_EXTERNAL_SESSION_OUT_OF_SYNC, ARSON_ERR_INVALID_GAME_ID, ARSON_ERR_GAMEMANAGER_COMPONENT_NOT_FOUND, ARSON_ERR_EXTERNAL_SESSION_ACCESS_FORBIDDEN, ARSON_ERR_EXTERNAL_SESSION_BAD_REQUEST, ARSON_ERR_EXTERNAL_SESSION_CONFLICTING_REQUEST }
            ]
            GetPs5MatchesForUserResponse clearPs5MatchesForUser(ClearPs5MatchesForUserRequest);

            [
                id = 350,
                description = "This WAL-only, non-client-exposed, internal RPC is for testing permission control and does not do any real work",
                client_export = false,
                internal = true,
                requires_authentication = true,
                requiresUserSession = true
            ]
            PokePermissionTestResponse pokePermissionTest();

            /////////////////////////////////////////////////////////////////////////////////////////
            //       Token Management
            /////////////////////////////////////////////////////////////////////////////////////////
            [
                id = 380,
                description = "Check user and server token retrieval and refreshment under certai situation"
            ]
            void CheckTokenRetrievalAndRefreshment(CheckTokenRetrievalAndRefreshmentRequest);
 
        }

        notifications
        {
            [
              id = 1,
              description = "Reconfigure completed.",
              details = "This notification is sent by the slave to the initiating client session."
            ]
            NotifyReconfigureCompleted();

            [
              id = 2,
              description = "Validation completed.",
              details = "This notification is sent by the slave to the initiating client session."
            ]
            NotifyValidationCompleted();

            [
              id = 3,
              description = "A notification.",
              details = "This notification is spawned when the server is poked."
            ]
            ResponseNotification(ArsonResponse);

            [
              id = 4,
              description = "A notification with no payload.",
              details = "This notification is spawned when the server is poked."
            ]
            VoidNotification();

            [
              id = 5,
              description = "Second slave listener called.",
              details = "This notification is sent by the second slave listener after receiving a notification from the master."
            ]
            NotifySecondSlave();

            [
              id = 6,
              description = "Test notification"
            ]
            NotifyTestNotification(TestNotification);
        }

        events
        {
            [ id = 1000 ]
            ArsonEvent(ArsonRequest);
        }
    }

    master
    {
        methods
        {
            [
              id = 1,
              description = "Forces a master exception to occur"
            ]
            void generateMasterException();

            [
              id = 2,
              description = "Forces the master to generate a slave notification that will trigger an exception"
            ]
            void generateSlaveNotificationException();

            [
              id = 3,
              errors = { ARSON_ERR_COLLECTION_ID_IN_USE },
              requires_authentication = false
            ]
            void createMapMaster(ExceptionMapRequest);

            [
              id = 4,
              errors = { ARSON_ERR_COLLECTION_ID_NOT_FOUND },
              requires_authentication = false
            ]
            void destroyMapMaster(ExceptionMapRequest);

            [
              id = 5,
              errors = { ARSON_ERR_COLLECTION_ID_NOT_FOUND, ARSON_ERR_OBJECT_ID_IN_USE },
              requires_authentication = false
            ]
            void mapInsertMaster(ExceptionMapUpdateRequest);

            [
              id = 6,
              errors = { ARSON_ERR_COLLECTION_ID_NOT_FOUND, ARSON_ERR_OBJECT_ID_NOT_FOUND },
              requires_authentication = false
            ]
            void mapUpdateMaster(ExceptionMapUpdateRequest);

            [
              id = 7,
              errors = { ARSON_ERR_COLLECTION_ID_NOT_FOUND, ARSON_ERR_OBJECT_ID_NOT_FOUND },
              requires_authentication = false
            ]
            void mapEraseMaster(ExceptionMapValueRequest);

            [
              id = 8,
              errors = {ARSON_ERR_BAD_NUM},
              errortype = ArsonError,
              requires_authentication = false
            ]
            ArsonResponse pokeMaster(ArsonRequest);

            [
              id = 9,
              requires_authentication = false
            ]
            void pokeMasterVoid();

            [
              id = 10
            ]
            void secondSlaveMasterNotification();

            [
              id = 11,
              description = "Creates a game"
            ]
            Blaze::GameManager::CreateGameResponse createGameMaster(Blaze::Arson::ArsonCreateGameRequest);

            [
                id = 12,
                description = "Send test notification to client"
            ]
            void sendTestNotificationToClientMaster();

            [
                id = 13,
                description = "Inserting 64 bit integer into arson_test_data table"
            ]
            void query64BitIntMaster();
        }

        notifications
        {
            [
              id = 0,
              description = "A notification with no payload.",
              details = "This notification is spawned when the master generates an exception"
            ]
            VoidNotification();

            [
              id = 1,
              description = "Notification to trigger exception in slave handler",
              details = "This notification is sent to the slave when it requests a notification exception"
            ]
            SlaveExceptionNotification();

            [
              id = 2,
              description = "A notification.",
              details = "This notification is spawned when the server is poked."
            ]
            ResponseMasterNotification(ArsonResponse);

            [
              id = 3,
              description = "A notification with no payload.",
              details = "This notification is spawned when the server is poked."
            ]
            VoidMasterNotification();

            [
              id = 4,
              description = "Test notification",
              passthrough=NotifyTestNotification
            ]
            NotifyTestNotification(TestNotification);
        }

        replication
        {
            [
              tdf_type = ExceptionMapEntry,
              context_type = ExceptionReplicationReason,
              start_id = 0,
              end_id = 100
            ]
            dynamic_map ExceptionEntries;
        }
    }
}
}
}
