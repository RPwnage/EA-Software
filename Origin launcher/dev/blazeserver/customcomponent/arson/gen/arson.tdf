[headername="framework/tdf/userextendeddatatypes.h"]
#include "framework/gen/userextendeddatatypes.tdf"

[headername="framework/tdf/userdefines.h"]
#include "framework/gen/userdefines.tdf"

[headername="framework/tdf/externalsessiontypes.h"]
#include "framework/gen/externalsessiontypes.tdf"

[headername="authentication/tdf/authentication.h"]
#include "authentication/gen/authentication.tdf"

[headername="framework/tdf/nucleuscodes.h"]
#include "framework/gen/nucleuscodes.tdf"

[headername="framework/tdf/attributes.h"]
#include "framework/gen/attributes.tdf"

[headername="framework/tdf/oauth.h"]
#include "framework/gen/oauth.tdf"

[headername="stats/tdf/stats.h"]
#include "stats/gen/stats.tdf"

[headername="clubs/tdf/clubs_base.h"]
#include "clubs/gen/clubs_base.tdf"

[headername="clubs/tdf/clubs.h"]
#include "clubs/gen/clubs.tdf"

[headername="gamemanager/tdf/gamemanager.h"]
#include "gamemanager/gen/gamemanager.tdf"

[headername="messaging/tdf/messagingtypes.h"]
#include "messaging/gen/messagingtypes.tdf"

[headername="arson/tdf/arsonxblsessiondirectorycommontypes.h"]
#include "arson/gen/arsonxblsessiondirectorycommontypes.tdf"

[headername="framework/tdf/metricsdatatypes.h"]
#include "framework/gen/metricsdatatypes.tdf"

[headername="arson/identity/tdf/arsonidentitytypes.h"]
#include "arson/gen/identity/arsonidentitytypes.tdf"

[headername="framework/tdf/frameworkconfigtypes_server.h"]
#include "framework/gen/frameworkconfigtypes_server.tdf"

namespace Blaze
{
[usePtrOption=true]
namespace Arson
{

typedef Blaze::ComponentName ComponentName; // Need to keep this typedef around for backward compatibility with runtime code using this typedef
typedef list<ComponentName> ComponentNameList;
typedef string(64) StringId;
typedef list<string(512)> StringIdParamList;
const uint16_t INVALID_SLIVER_INSTANCE_ID = 0;

[tdfid="hash"]
class Foo
{
    [tag="fa"] int32_t mFooInt;
};

[tdfid="hash"]
class Bar
{
    [tag="ba"] int32_t mBarInt;
    [tag="bb"] Foo mBarFoo;
};

[description="Gets the User Extended Data given the User Extended Data Name or Component Name and User Extended Data Key."]
class GetUEDRequest
{
    [tag="uedn", description="User Extended Data Name in the form component.data (ie. stats.dnf)."]
        UserExtendedDataName mUserExtendedDataName;
    [tag="cnam", description="Name of the component, only needs to be specified if mUserExtendedDataName is empty string."]
        ComponentName mComponentName;
    [tag="uedk", description="User Extended Data Key, only needs to be specified if mUserExtendedDataName is empty string."]
        uint16_t mUserExtendedDataId;
};

[description="Container for the User Extended Data of the logged in user returned by a getUserExtendedData"]
class GetUEDResponse
{
    [tag="ued", description="User Extended Data for the logged in user."]
        UserExtendedDataValue mUserExtendedData;
};

[description="Updates the User Extended Data for the logged in user given the User Extended Data Name or Component Name and User Extended Data Key."]
class UpdateUEDRequest
{
    [tag="uedn", description="User Extended Data Name in the form component.data (ie. stats.dnf)."]
        UserExtendedDataName mUserExtendedDataName;
    [tag="cnam", description="Name of the component, only needs to be specified if mUserExtendedDataName is empty string."]
        ComponentName mComponentName;
    [tag="uedk", description="User Extended Data Key, only needs to be specified if mUserExtendedDataName is empty string."]
        uint16_t mUserExtendedDataId;
    [tag="ued", description="User Extended Data to be updated for the logged in user."]
        UserExtendedDataValue mUserExtendedData;
};

typedef map<string(512), uint32_t, ignorecase> PSUMap;
[description="Contains local user session counts mapped by client type and geoip data (country, timezone, and, optionally, ISP)."]
class GetPSUResponse
{
    [tag="psum"] PSUMap mPSUMap;
};

[description="Indicates whether to include ISP data in an RPC response."]
class GetMetricsByGeoIPDataRequest
{
    [tag="isp", default=true] bool mIncludeISP;
};


[description="Request class for Arson Component's setComponentState RPC (copied from controllertypes_server.tdf) "]
class SetComponentStateRequest
{
    enum Action
    {
        [description="Disable the component."]   ENABLE,
        [description="Enable the component."]    DISABLE
    };
    [tag="name"] ComponentName mComponentName;
    [tag="actn"] Action mAction;
    [tag="err"] uint32_t mErrorCode;
};

typedef map<string(128),uint64_t, ignorecase> ErrorCountMap;

//need to keep this Arson TDF in-sync with the Blaze's server-only equivalent tdf
//if you want to verify for all of the metrics members
//also need to manually copy Blaze's TDF values into Arson's in getcomponentmetrics_command.cpp
//source: framework/gen/controllertypes_server.tdf
class CommandMetricInfo
{
    [tag="comp"] uint16_t mComponent;
    [tag="cmd"]  uint16_t mCommand;
    [tag="cmpn"] ComponentName mComponentName;
    [tag="cmdn"] string(64) mCommandName;
    [tag="cnt"]  uint64_t mCount;
    [tag="csuc"] int64_t mSuccessCount;
    [tag="cfil"] int64_t mFailCount;
    [tag="ttim"] int64_t mTotalTime;
    [tag="gctm"] int64_t mGetConnTime;
    [tag="txct"] uint64_t mTxnCount;
    [tag="dbct"] uint64_t mQueryCount;
    [tag="mdct"] uint64_t mMultiQueryCount;
    [tag="pstc"] uint64_t mPreparedStatementCount;
    [tag="dbtm"] int64_t mQueryTime;
    [tag="dbst"] int64_t mQuerySetupTimeOnThread;
    [tag="dbet"] int64_t mQueryExecutionTimeOnThread;
    [tag="dbcu"] int64_t mQueryCleanupTimeOnThread;

    [tag="cpu", default=0, description="time spent in a fiber, in microseconds"]
    int64_t mFiberTime;

    [tag="err", description="tally of errors returned"]
    ErrorCountMap mErrorCountMap;
};
[description="Request class for getComponentMetrics RPC"]
class ComponentMetricsRequest
{
    [tag="comp"] uint16_t mComponentId;
    [tag="cmd"]  uint16_t mCommandId;
};
[description="Response class for getComponentMetrics RPC"]
class ComponentMetricsResponse
{
    [tag="comp"] list<CommandMetricInfo> mMetrics;
};

[description="Response class for Arson Component's setComponentState RPC"]
class SetComponentStateResponse
{
    [tag="errc", description = "The component's disable error return code"]
    uint32_t mDisableErrorReturnCode;
};

[tdfid="hash", description="user profile info"]
class UserProfileInfo
{
    [tag="blid", description="blaze id"]
    BlazeId mBlazeId;
    [tag="info", description="additional user info"]
    variable mAdditionalInfo;
};

[tdfid="hash", description="user address"]
class UserAddress
{
    [tag="addr", descrption="street address"]
    string(256) mStreetAddress;
    [tag="ctry", description="country"]
    string(32) mCountry;
};

[tdfid="hash", description="user date of birth"]
class UserDOB
{
    [tag="year"]
    uint32_t mYear;
    [tag="mon"]
    uint32_t mMonth;
    [tag="day"]
    uint32_t mDay;
};

enum TestConfigEnum
{
    TC_ALPHA,
    TC_BETA
};

typedef list<int32_t> ListTestType;
typedef map<string(32), int32_t, ignorecase> MapTestType;

[tdfid="hash",description="Simple TDF Class"]
class SimpleTDFClassTest
{
    [tag="taga"]
    string(32) mSimpleString;
};

[description="Testing autoconfiguration"]
class TestConfiguration
{
    // uint test
    [tag="taga"]
    uint8_t mValUInt8;
    [tag="tagb"]
    uint16_t mValUInt16;
    [tag="tagc"]
    uint32_t mValUInt32;
    [tag="tagd"]
    uint64_t mValUInt64;

    // int test
    [tag="tage"]
    int8_t mValInt8;
    [tag="tagf"]
    int16_t mValInt16;
    [tag="tagg"]
    int32_t mValInt32;
    [tag="tagh"]
    int64_t mValInt64;

    [tag="tagi"]
    string(32) mString;

    [tag="tagj"]
    bool mBool;

    [tag="tagk"]
    TestConfigEnum mEnum;

    [tag="tagl"]
    ListTestType mTestList;

    [tag="tagm"]
    MapTestType mTestMap;

    [tag="tago"]
    SimpleTDFClassTest mSimpleTDFClassTest;

    [tag="tagp"]
    ObjectId mBlazeObjectIdTest;

    [tag="tagq"]
    ObjectType mBlazeObjectTypeTest;
};

enum TestEnum
{
   TEST_ENUM_ALPHA,
   TEST_ENUM_BETA
};

class TestEnumRequest
{
    [tag="enum", description="Test enum"]
    TestEnum mTestEnum;
};

class TestEnumResponse
{
    [tag="enum", description="Test enum response"]
    TestEnum mTestEnumResp;
};

[tdfid="hash", description="unlimited max string length"]
class TestUnlimitedStringLength
{
    [tag="stri", description="String with unlimited max length"]
    string(-1) mUnlimitedLengthString;
};

typedef string(256) ValidateConfigErrorMessage;
typedef string(128) ConfigFeature;

class ValidateConfigErrors
{
    [tag="attr",description="A list of errors flagged when validating the feature's configuration."]
    list<ValidateConfigErrorMessage> errorMessages;

    [tag="ctdf",description="The configuration TDF that failed validation."]
    variable configTdf;
};

typedef map<ConfigFeature, ValidateConfigErrors, ignorecase> ReconfigurationFailureMap;

class ReconfigureRequest
{
    [tag="comp", description="List of components to reconfigure"]
    ComponentNameList mComponents;

    [tag="vald", description="Perform config validation only"]
    bool mValidateOnly;

    [tag="wait", default=true, description="Whether ArsonCommand waits for the call's Blaze RPC title callback to hit, before returning. If false, will do fire and forget"]
    bool mWaitForRpcCb;
};

class ReconfigureResponse
{
    [tag="errs", description="Map of validation errors"]
    ReconfigurationFailureMap mReconfigErrors;
};

// TDF Encode/Decode testing TDF classes

enum OutOfClassEnum
{
   OUT_OF_CLASS_ENUM_VAL_INVALID = 0,
   OUT_OF_CLASS_ENUM_VAL_1 = 1,
   OUT_OF_CLASS_ENUM_VAL_2 = 2,
   OUT_OF_CLASS_ENUM_VAL_3 = 3
};

[tdfid="hash"]
class AllPrimitivesClass
{

    [tag="tagj"]
    bool mBool;

    [tag="taga"]
    uint8_t mUInt8;

    [tag="tagb"]
    uint16_t mUInt16;

    [tag="tagc"]
    uint32_t mUInt32;

    [tag="tagd"]
    uint64_t mUInt64;

    [tag="tage"]
    int8_t mInt8;

    [tag="tagf"]
    int16_t mInt16;

    [tag="tagg"]
    int32_t mInt32;

    [tag="tagh"]
    int64_t mInt64;

    [tag="flt"]
    float mFloat;

    [tag="tagi"]
    string(32) mString;

    [tag="oenu"]
    OutOfClassEnum mOutOfClassEnum;

    enum InClassEnum
    {
       IN_OF_CLASS_ENUM_VAL_INVALID = 0,
       IN_OF_CLASS_ENUM_VAL_1 = 1,
       IN_OF_CLASS_ENUM_VAL_2 = 2,
       IN_OF_CLASS_ENUM_VAL_3 = 3
    };

    [tag="ienu"]
    InClassEnum mInClassEnum;
};

typedef list<list<int32_t>> ListOfListOfInt32;
[tdfid="hash"]
class ListOfList
{
    [tag="llst", description="List of lists of int32_t's"]
    ListOfListOfInt32 mListOfLists;
};

typedef list<map<string(32),int32_t, ignorecase>> ListOfMapOfStringToInt32;
[tdfid="hash"]
class ListOfMap
{
    [tag="lmap", description="List of maps of int32_t's", nameoverride="list-of-maps"]
    ListOfMapOfStringToInt32 mListOfMaps;
};

union StringOrInt32
{
    uint32_t mInt;
    string(32) mString;
};

typedef list<list<StringOrInt32>> ListOfListOfUnions;
[tdfid="hash"]
class ListOfUnionList
{
    [tag="llst", description="List of lists of unions"]
    ListOfListOfUnions mListOfLists;
};

typedef map<string(32),map<string(32),int32_t, ignorecase>, ignorecase> MapOfStringToMapOfStringToInt32;
[tdfid="hash"]
class MapOfMap
{
    [tag="mmap", description="Map of maps of int32_t's"]
    MapOfStringToMapOfStringToInt32 mMapOfMaps;
};

typedef map<string(32),list<int32_t>, ignorecase> MapOfStringToListOfInt32;
[tdfid="hash"]
class MapOfList
{
    [tag="mlst", description="Map of lists of int32_t's"]
    MapOfStringToListOfInt32 mMapOfLists;
};

typedef map<string(32),Foo, ignorecase> FooMap;

[tdfid="hash"]
class MapOfClass
{
    [tag="cmap"] FooMap mFooMap;
};

enum ValueEnum
{
    VALUE0,
    VALUE1,
    VALUE2
};

[tdfid="hash"]
class simpleVaribleTdf
{
    [tag="vtdf", description="variable tdf"]
    variable mVariableTdf;
};

[tdfid="hash"]
class SimpleGeneric
{
    [tag="gene", description="generic"]
    generic mGeneric;
};

typedef list<ValueEnum> ListOfEnumValue;
[tdfid="hash"]
class ListOfEnum
{
    [tag="lenu", description="List of enums"]
    ListOfEnumValue mListOfEnums;
};

typedef map<string(32),ValueEnum, ignorecase> MapOfStringToEnum;
[tdfid="hash"]
class MapOfEnum
{
    [tag="menu", description="Map of enums"]
    MapOfStringToEnum mMapOfEnums;
};

typedef map<string(32),list<ValueEnum>, ignorecase> MapOfStringToListOfEnum;
[tdfid="hash"]
class MapOfListOfEnum
{
    [tag="mlst", description="Map of lists of enums"]
    MapOfStringToListOfEnum mMapOfLists;
};

typedef map<string(32),map<string(32),map<string(32), int32_t, ignorecase>, ignorecase>, ignorecase> MapsOfMapsOfMapsOfStringToInt32;
[tdfid="hash"]
class MapOfMapsOfMaps
{
    [tag="mmm", description="map of map of map of string to int32"]
    MapsOfMapsOfMapsOfStringToInt32 mMapsOfMapsOfMaps;
};

typedef list<list<list<int32_t>>> ListOfListsOfOfListsOfInt32;
[tdfid="hash"]
class ListOfListsOfLists
{
    [tag="lll", description="list of list of list of int32"]
    ListOfListsOfOfListsOfInt32 mListofListofList;
};

typedef list<map<string(32),Foo, ignorecase>> ListOfMapOfStringToClassFoo;
[tdfid="hash"]
class ListOfMapsOfClasses
{
    [tag="lmc", description="list of map of class foo"]
    ListOfMapOfStringToClassFoo mListOfMapOfFoo;
};

typedef list<Foo> listOfFooClass;
[tdfid="hash"]
class ListOfClass
{
    [tag="lfcl", description="List of class foo"]
    listOfFooClass mListOfFooClass;
};

[tdfid="hash"]
class ListOfUnion
{
    [tag="luni", description="List of Unions"]
    list<StringOrInt32> mListofUnion;
};

[tdfid="hash"]
class ListOfBlob
{
    [tag="lblb", description="List of Blobs"]
    list<blob> mListofBlobs;
};

[tdfid="hash"]
class NestedClassNoPrimitives
{
    [tag="ntcl", description="nested Class"]
    AllPrimitivesClass mNestedClass;
};

[tdfid="hash"]
class NestedClassWithPrimitives
{
    [tag="ntcl", description="nested Class"]
    AllPrimitivesClass mNestedClass;
    [tag="prmt", description="primitive"]
    bool mBool;
};

[tdfid="hash"]
class EchoList
{
    [tag="nest"]
    list<ListOfList> mEchoList;
};

[description="Request and response to test nested open variable EA::TDF::Tdf"]
class EchoTdfRequestResponse
{
    [tag="tdf", description="variable tdf"]
    variable mTdf;

    [tag="elst", description="List of lists of lists of int32_t's"]
    EchoList mEchoList;

    [tag="vlst", description="List of variable TDFs."]
    list<variable> mVariableList;

    [tag="vmap", description="Map of variable TDFs."]
    map<string(32), variable> mVariableMap;

    [tag="imap", description="Map of int TDFs."]
    map<string(32), uint32_t> mIntMap;
};

class BypassNucleusRequest
{
    [tag="byps", description="Whether to enable or disable Nucleus bypass"]
    bool mBypass;
};

class GetUserRankRequest
{
     [tag="uid", description="user is for which the rank is requested"]
     BlazeId userId;
     [tag="nme", description="rank name for which the rank is requested"]
     string(32) name;
};

[description="Response class for getUserRank RPC"]
class GetUserRankResponse
{
    [tag="urk", description="The user rank"]
    int32_t userRank;
};

class LookUpIpRequest
{
    [tag="uip", description="the user's IP"]
    uint32_t mUserIp;
};

class LookUpIpResponse
{
    [tag="gloc", description="the geographical location of the IP"]
    string(128) mGeoLoc;
};

class ArsonData
{
    [tag="name", default="", description = "The Arson's name."]
    string(64) mName;

    [tag="key", default=0, description = "The key of the extendedDatat."]
    uint16_t mKey;

    [tag="valu", default=0, description = "The value of the extendedData."]
    uint16_t mValue;
};

[tdfid="hash", description="A tdf containing a large value"]
class SomeLargeValueConfigSection
{
    [tag="valu", default=100, description = "The value of a large value"]
    uint64_t mValue;
};


typedef list<ArsonData> ArsonDataList;

class VaultConfig
{
    [tag="srid", description="The secret id (aka password) to authenticate.", printFormat="censor", reconfigurable="yes"]
    string(-1) mSecretId;
};
class ChildConfig
{
    [tag="rstr", description="Reconfigurable string", reconfigurable="yes"]
    string(32) reconfigurable;

    [tag="dstr", description="Default reconfigurable string", reconfigurable="default"]
    string(32) defaultReconfigurable;

    [tag="nstr", description="Non-reconfigurable string", reconfigurable="no"]
    string(32) noReconfigurable;
};

class ParentConfig
{
    [tag="ccfg", description="Child config for reconfigure testing", reconfigurable="yes"]
    ChildConfig childReconfigure;

    [tag="ncfg", description="Child config for reconfigure testing", reconfigurable="no"]
    ChildConfig childNoReconfigure;
};

class VariableContainingConfig
{
    [tag="int", description="Child config for reconfigure testing", reconfigurable="yes"]
    uint32_t anInt;

    [tag="cvar", description="Child varible tdf for reconfigure testing", reconfigurable="yes"]
    variable innerVariableTdf;
};


class TimedSleepRequestResponse
{
    [tag="wait", description="Specifies how long the command sleep is (response reuses the same type)", reconfigurable="yes"]
    uint32_t waitSecs;

    [tag="blob"] blob mBlob;
    [tag="bsiz", description="Size of random blob data to return"]  int32_t mReturnedBlobSize;
};


class SftpConfig
{
    [tag="ftpv", default=true, reconfigurable="yes"] bool mFtpIsVerbose;
    [tag="ftpt", default=true, reconfigurable="yes"] bool mFtpThrottlingEnabled;
    [tag="dlpf", default=false, reconfigurable="yes"] bool mDeletePulledFiles;
    [tag="fhos", default="bur1-twang3.eac.ad.ea.com", reconfigurable="yes"] string(32) mFtpHostname;
    [tag="fmfi", default=1575, reconfigurable="yes"] uint32_t mFtpMaxFilesPerInterval;
    [tag="fpas", default="unused", reconfigurable="yes"] string(32) mFtpPassword;
    [tag="fusr", default="ea_notifications", reconfigurable="yes"] string(32) mFtpUsername;
    [tag="ftpr", default="home/guest", reconfigurable="yes"] string(32) mFtpRemotePath;
};

[description = "FTP response message string."]
typedef string(255) FtpResponseString;

[description = "List of responses from the FTP server."]
typedef list<FtpResponseString> FtpResponseList;

class PullRemoteXmlFilesResponse
{
    [tag="ftpr", description="Reponse for PullRemoteFiles", reconfigurable="no"]
    FtpResponseList ftpResponseList;
};

class ArsonConfig
{
    [tag="dbnp", reconfigurable="no", description = "DB to use per platform."]
    DbNameByPlatformTypeMap mDbNamesByPlatform;

    enum TestEnum
    {
        TEST1,
        TEST2
    };

    [tag="taga", description = "Arson extended data"]
    ArsonDataList mExtendedData;

    [tag="tlcs", description = "Test of large define"]
    SomeLargeValueConfigSection someLargeValueConfigSection;

    [tag="tstm", description = "Test of map to enums"]
    map<string(32), TestEnum, ignorecase> someEnumValues;

    [tag="tstl", description = "Test of list of enums"]
    list<TestEnum> someOtherEnumValues;

    [tag="cmap", description = "Test of map to class"]
    FooMap mFooMap;

    [tag="lfcl", description = "Test of list of class"]
    listOfFooClass mFooList;

    [tag="pcfg", description="Parent config for reconfigure testing", reconfigurable="yes"]
    ParentConfig parentConfig;

    [tag="rstr", description="Reconfigurable string", reconfigurable="yes"]
    string(32) reconfigurableString;

    [tag="rint", description="Reconfigurable int", reconfigurable="yes"]
    uint32_t reconfigurableInt;

    [tag="nint", description="Non-reconfigurable int", reconfigurable="no"]
    uint32_t noReconfigurableInt;

    [tag="nvld", description="Option to force this config to be invalid", reconfigurable="yes"]
    bool isInvalidConfig;

    [tag="bvs", description="ByteVault Component host for REST protocol", reconfigurable="yes"]
    string(256) bytevaultServer;

    [tag="vart", reconfigurable="yes", description="Variable TDF in configuration"]
    variable variableTDF;

    [tag="vlst", reconfigurable="yes", description="Variable TDF list in configuration"]
    list<variable> variableTDFList;

    [tag="vcnt", reconfigurable="yes", description="TDF containing variable TDF in configuration"]
    VariableContainingConfig variableContainingTdf;

    [tag="vcls", reconfigurable="yes", description="TDF list containing variable TDF in configuration"]
    list<VariableContainingConfig> variableTDFChildList;

    [tag="rdnm", reconfigurable="no", description = "Redis server hostname and port to use.", default="127.0.0.1:6379"]
    string(MAX_HOSTNAME_LENGTH) mRedisHostAndPort;

    [tag="rdcn", reconfigurable="no", description = "Redis connection pool size.", default=4]
    uint32_t mRedisConnPoolSize;

    [tag="mpss", description="xbl mpsd service address", reconfigurable="yes"]
    string(MAX_HOSTNAME_LENGTH) mXblMpsdHost;

    [tag="sftp", description="SFTP Config", reconfigurable="yes"]
    SftpConfig mSftpConfig;

    [tag="vcfg", description="The secret id as a config.", printFormat="censor"]
    VaultConfig vaultConfig;
};

class GetConfigResponse
{
    [tag="cfg", description="Arson server config TDF"]
    ArsonConfig mConfig;
};

class PeriodIds
{
    [tag="dly", description="Daily period ID."] int32_t mCurrentDailyPeriodId;
    [tag="wly", description="Weekly period ID."] int32_t mCurrentWeeklyPeriodId;
    [tag="mly", description="Monthly period ID."] int32_t mCurrentMonthlyPeriodId;

    [tag="dhou", description="Daily rollover: hour."] int32_t mDailyHour;
    [tag="dret", description="Daily rollover: retention."] int32_t mDailyRetention;
    [tag="dbuf", description="Daily rollover: future period buffer.", default=9] int32_t mDailyBuffer;
    [tag="whou", description="Weekly rollover: hour."] int32_t mWeeklyHour;
    [tag="wday", description="Weekly rollover: day."] int32_t mWeeklyDay;
    [tag="wret", description="Weekly rollover: retention."] int32_t mWeeklyRetention;
    [tag="wbuf", description="Weekly rollover: future period buffer.", default=2] int32_t mWeeklyBuffer;
    [tag="mhou", description="Monthly rollover: hour."] int32_t mMonthlyHour;
    [tag="mday", description="Monthly rollover: day.", default=1] int32_t mMonthlyDay;
    [tag="mret", description="Monthly rollover: retention."] int32_t mMonthlyRetention;
    [tag="mbuf", description="Monthly rollover: future period buffer.", default=1] int32_t mMonthlyBuffer;
};

class StreamingDbQueryResponse
{
    [tag="rows", description="Number of rows retrieved", reconfigurable="no"]
    uint32_t noRows;
};

class XMLEncodeTDFRequest
{
    [tag="tdf", description="Variable TDF to encode"]
    variable mTdf;
};

class XMLEncodeTDFResponse
{
    [tag="etdf", description="XML encoded TDF"]
    string(-1) mEncodedTdf;
};

class XMLDecodeTDFResponse
{
    [tag="tdf", description="Decoded Variable TDF"]
    variable mTdf;
};

class XMLDecodeTDFRequest
{
    [tag="etdf", description="XML encoded TDF"]
    string(-1) mEncodedTdf;
};

typedef map<string(32),StringOrInt32> MapOfUnionTest;
[tdfid="hash"]
class MapofUnion
{
    [tag="umap", description="map of unions", nameoverride="map-of-union-test"]
    MapOfUnionTest mMapOfUnionTest;
};
[tdfid="hash"]
class JsonUnion
{
    [tag="uni", description="Json Union Test"]
    StringOrInt32 mJsonUnionTest;
};

class JSONEncodeTDFRequest
{
    [tag="tdf", description="Variable TDF to encode"]
    variable mTdf;

    [tag="indt", default=4, description="size of indents in encoded JSON"]
    int32_t mIndent;

    [tag="endl", default=10, description="0 omits new line. 10 specifies ascii newline char."]
    char8_t mLineEnd;
};

class JSONEncodeTDFResponse
{
    [tag="etdf", description="JSON encoded TDF"]
    string(-1) mEncodedTdf;
};

class JSONDecodeTDFRequest
{
    [tag="etdf", description="JSON decode string"]
    string(-1) mDecodedTdf;
    [tag="tdf", description="Variable TDF to decode to"]
    variable mTdf;
};

class JSONDecodeTDFResponse
{
    [tag="tdf", description="Variable TDF to decode to"]
    variable mTdf;
};

class HttpEncodeTDFRequest
{
    [tag="tdf", description="Variable TDF to encode"]
    variable mTdf;
};

class HttpEncodeTDFResponse
{
    [tag="etdf", description="HTTP encoded TDF"]
    string(-1) mEncodedTdf;
};

typedef int32_t Typedef_NamespaceScope_Int;

class UserId2
{
    [tag="uid"] uint64_t mUserId;
};

typedef list<UserId2> Typedef_NamespaceScope_ListOf_Class;

union MyUnion
{
    Foo mFoo;
    Bar mBar;
    uint32_t mInt;
    string(32) mString;
};

class Nested
{
    [tag="num", description="A number value greater than 0."]
    int32_t mNum;

    [tag="text", description="Text to send up to the server."]
    string(256) mText;

    [tag="nmpa"] map<string(32),string(32), ignorecase> mStringMap;

    [tag="nmpl"] list<string(32)> mStringList;
};

[description="Request class for testXml2Encoder RPC"]
class TestXml2EncoderRequest
{
    [tag="num", description="A number value greater than 0."]
    int32_t mNum;

    [tag="text", description="Text to send up to the server."]
    string(256) mText;

    [tag="smap"] map<string(32),string(32), ignorecase> mStringMap;

    [tag="nmap"] map<string(32),Nested, ignorecase> mNestedMap;

    [tag="slst"] list<string(32)> mStringList;

    [tag="nlst"] list<Nested> mNestedList;

    [tag="ulst"] list<MyUnion> mUnionList;

    [tag="lllt"] list<ListOfListOfInt32> mLoLoInt32List;
    [tag="llin"] ListOfListOfInt32 mLoLoInt32;

    [tag="uni1"] MyUnion mUnion1;
    [tag="uni2"] MyUnion mUnion2;
    [tag="uni3"] MyUnion mUnion3;
    [tag="uatt"] bool mUseAttributes;
};

const uint32_t MAIL_PARAMETER_SIZE = 64;
typedef string(MAIL_PARAMETER_SIZE) MailParameterName;
typedef string(MAIL_PARAMETER_SIZE) MailParameterValue;
typedef map<MailParameterName, MailParameterValue, ignorecase> MailParameterMap;

class ArsonError
{
    [tag="msg"] string(256) mMessage;
};

class ArsonRequest
{
    [
     description="An inner enum type ArsonResponse uses.",
     details = "This inner enum doesn't really do anything."
    ]
    enum InnerEnum
    {
        [description="The first argument in the enumeration."] ARSON_INNER_ENUM_ARG_1 = 0,
        ARSON_INNER_ENUM_ARG_3 = 3854
    };

    class InnerClass
    {
    };

    bitfield InnerBitfield
    {
        mFlag : 1;
    };

    [tag="inn"] InnerClass mInnerClass;
    [tag="num", description="A number value greater than 0."]  int32_t mNum;
    [tag="bsiz", default=0, description="Size of random blob data to return"]  int32_t mReturnedBlobSize;
    [tag="mbsz", default=0, description="Size of random blob data to return from Arson Master to Slave"]  int32_t mMasterReturnedBlobSize;
    [tag="text", description="Text to send up to the server."] string(256) mText;
    [tag="slp", default=0, description="Amount of time the server should wait in milli-seconds before responding"] int32_t mSleepMs;
    [tag="mslp", default=0, description="Amount of time the Arson Master should wait in milli-seconds before responding"] int32_t mMasterSleepMs;

    // Include one of each element type to test out the type compiler

    [tag="i8"] int8_t mInt8;
    [tag="i16"] int16_t mInt16;
    [tag="i32"] int32_t mInt32;
    [tag="i64"] int64_t mInt64;

    [tag="ui8"] uint8_t mUint8;
    [tag="ui16"] uint16_t mUint16;
    [tag="ui32"] uint32_t mUint32;
    [tag="ui64"] uint64_t mUint64;

    [tag="str"] string(32) mString;
    [tag="list"] list<int32_t> mList;
    [tag="blob"] blob mBlob;

    // test simple typedefs
    typedef int64_t Typedef_Int;
    [tag="uid"] Typedef_Int mTypedef_Int; // simple typedef (int) declared in class
    [tag="tdef"] Typedef_NamespaceScope_Int mTypedef_NamespaceScope_Int; // simple typedef (int) declared in namespace


    // test lists defined in a variety of ways
    [tag="lst1"] list<uint32_t> mListTest1; // list of int
    [tag="lst2"] list<UserId2> mListTest2;  // list of class

    //[tag="lst3"] list<Typedef_Int> mListTest3; // list of typedef (int)
    //[tag="lst4"] list<Typedef_NamespaceScope_Int> mListTest4; // list of namespace-defined-typedef (int)

    typedef list<int32_t> Typedef_ListOf_Int;
    [tag="lst5"] Typedef_ListOf_Int mListTest5; // typdef (list of int)

    typedef list<Typedef_Int> Typedef_ListOf_Typedef;
    [tag="lst6"] Typedef_ListOf_Typedef mListTest6; // typedef (list of typedef(int))

    typedef list<Typedef_NamespaceScope_Int> Typedef_ListOf_NamespaceTypedef;
    [tag="lst7"] Typedef_ListOf_NamespaceTypedef mListTest7; // typedef (list of namespace-defined-typedef(int) )

    [tag="lst8"] Typedef_NamespaceScope_ListOf_Class mListTest8; // namespace-defined-typedef( list of class )

    [tag="los"] list<string(32)> mListOfStrings;
    [tag="mos"] map<string(32),uint32_t, ignorecase> mMapOfStrings;
    [tag="mos2"] map<uint32_t,string(32)> mMapOfStrings2;

    [tag="gene"] bool mGenerateEvent;
};

class ArsonResponse
{
    [description="A namespace string constant."]
    const char8_t *ARSON_CONST_2 = "Hello";

    [
     description="An enum type ArsonResponse uses.",
     details = "This enum doesn't really do anything."
    ]
    enum ArsonResponseEnum
    {
        [description="The first argument in the enumeration."] ARSON_ENUM_ARG_1 = 0,
        [description="The second argument in the enumeration (no explicit value)."] ARSON_ENUM_ARG_2,
        ARSON_ENUM_ARG_3 = 3854
    };


    [
     description="A bitfield type ArsonResponse uses.",
     details = "This bitfield doesn't really do anything."
    ]
    bitfield ArsonResponseBitfield
    {
        mFlag : 1;
        mField : 4;
    };


    [tag="msg"] string(256) mMessage;
    [
        tag="btf",
        description="A bitfield parameter."
    ]
    ArsonResponseBitfield mBitfield;
    [tag="elst"] list<ArsonResponseEnum> mEnumList;

    [
        tag="enum",
        description="Enum type parameter."
    ]
    ArsonResponseEnum mRegularEnum;

    [tag="blob"] blob mBlob;
};

typedef map<int32_t, bool> IntBoolMap;

class MyTest
{
    [tag="a"] int32_t mInt;
    [tag="b"] Bar mBar;
    [tag="c"] Foo mFoo;
    [tag="d"] list<Bar> mBarList;
    [tag="e"] int32_t mInt2;
    [tag="f"] list<int32_t> mIntList;
    [tag="g"] int32_t mInt3;
    [tag="h"] list<string(32)> mStringList;
    [tag="i"] int32_t mInt4;
    [tag="j"] map<string(32),Bar, ignorecase> mBarMap;
    [tag="k"] int32_t mInt5;
    [tag="l"] map<int32_t,Bar> mBarMapInt;
    [tag="m"] int32_t mInt6;
    [tag="n"] map<int32_t,int32_t> mBarMapIntInt;
    [tag="o"] int32_t mInt7;
    [tag="p"] map<string(32),string(32), ignorecase> mBarMapStrStr;
    [tag="q"] int32_t mInt8;
    [tag="r"] MyUnion mUnion1;
    [tag="s"] int32_t mInt9;
    [tag="t"] MyUnion mUnion2;
    [tag="u"] int32_t mInt10;
    [tag="v"] MyUnion mUnion3;
    [tag="w"] int32_t mInt11;
    [tag="x"] MyUnion mUnion4;
    [tag="yyy"] string(32) mString3;
    [tag="yy"] string(32) mString2;
    [tag="y"] string(32) mString;
    [tag="z"] blob mBlob;
    [tag="smap", description="Map of ints to bools"]
    IntBoolMap mTestIntBoolMap;
};

class GetBlobRequest
{
    [tag="size"] uint32_t mSize;
};

class GetBlobResponse
{
    [tag="blob"] blob     mBlob;
};

[tdfid = "hash", trackChanges = true]
class ArsonEntry
{
    [tag="int"] int32_t mInt;
    [tag="str"] string(32) mString;
};

class ArsonExtendedData
{
    [tag="key"] uint16_t mKey;
    [tag="valu"] int32_t mValue;
};

[tdfid = "hash"]
class ArsonReplicationReason
{
    enum Reason
    {
        MAP_CREATED = 0,
        MAP_DESTROYED,
        OBJECT_CREATED,
        OBJECT_UPDATED,
        OBJECT_DESTROYED
    };

    [tag="rsn"] Reason mReason;
};

typedef map<string(64), string(-1)> ProfileInfoElements;
typedef map<string(32), ProfileInfoElements> ProfileInfoElementsByCategory;

class GetUserProfilesRequest
{
    [tag="int", description="Account ID used in nucleus request"]
    AccountId mAccountId;

    [tag="cate", description="Category used in nucleus request"]
    string(32) mCategory;
};

class GetUserProfilesResponse
{
    [tag="uid", description="Nucleus mAccountId"] AccountId mAccountId;
    [tag="elem", description="A map of profile entry elements"] ProfileInfoElementsByCategory mProfileInfoElementsByCategory;
};

class GetUserByPersonaNameRequest
{
    [tag="user"] string(MAX_PERSONA_LENGTH) mPersonaName;
};

class GetUserByPersonaIdRequest
{
    [tag="user"] PersonaId mPersonaId;
};

class GetUserRequest
{
    [tag="user"] uint32_t mId;
};

class GetUserInfoByBlazeIdGOS12576Request
{
    [tag="usr1"] BlazeId mId1;
    [tag="usr2"] BlazeId mId2;
    [tag="usr3"] BlazeId mId3;
};

class GetUserInfoByBlazeIdResponse
{
    [tag="uid", description = "The Blaze/Persona ID of the user."]
    BlazeId mId;

    [tag="mail", description="The Account name/e-mail address of the user.", printFormat="hash"]
    string(MAX_EMAIL_LENGTH) mEmail;

    [tag="nid", description="The Account id of the user's master account."]
    ExternalId mAccountId;

    [tag="name", description="The name of the logged in persona."]
    string(MAX_PERSONA_LENGTH) mPersonaName;
};

class IdentityResponse
{
    [tag="ids"] map<EntityId,string(128)> mNamesById;
};

class SendCustomPinEventRequest
{
    [tag="cet"] string(256) mCustomEventType;
};

class QueryRequest
{
    [tag="name"] string(64) mDbName;
    [tag="q"] string(1024) mQuery;
    [tag="sess", default=false] bool mAccessUserSession;
    [tag="txn"] int32_t mTransaction;
    [tag="ro"] int32_t mReadOnly;
    [tag="num"] int32_t mCount;
    [tag="strm", default=false] bool mIsStreaming;
};

class HttpRequest
{
    [tag="addr"] string(256) mAddress;
    [tag="uri"] string(256) mUri;
    [tag="num"] int32_t mCount;
};

class ReportResultToClubsRequest
{
    [tag="ucid"] Clubs::ClubId mUpperClubId;
    [tag="ures"] string(32) mLastResultUpper;
    [tag="lcid"] Clubs::ClubId mLowerClubId;
    [tag="Lres"] string(32) mLastResultLower;
};

class UpdateClubRecordbookRequest
{
    [tag="clid"] Clubs::ClubId mClubId;
    [tag="rcid"] Clubs::ClubRecordId mRecordId;
    [tag="rtyp"] Clubs::RecordStatType mStatType;
    [tag="stat"] string(32) mStatValue;
    [tag="usid"] BlazeId mRecordHolder;
};

class ArsonClubTickerMessage
{
    [tag="titx", description="Ticker message"]
    Clubs::ClubTickerMessageText mText;

    [tag="timd", description="Ticker message metadata"]
    Clubs::ClubTickerMetadata mMetadata;

    [tag="tstm", description="Ticker message timestamp"]
    uint32_t mTimestamp;
};

class AwardClubRequest
{
    [tag="clid"] Clubs::ClubId mClubId;
    [tag="awid"] Clubs::ClubAwardId mAwardId;
};

class PublishClubTickerMessageRequest
{
    [tag="clid", description="Club to fetch msg history for"]
    Clubs::ClubId mClubId;

    [tag="inui", description="Private message for this user"]
    BlazeId mIncludeUserId;

    [tag="exui", description="Exclude this user"]
    BlazeId mExcludeUserId;

    [tag="prms", description="Message parameters"]
    string(256) mParams;

    [tag="ctms", description="Club ticker message to publish"]
    ArsonClubTickerMessage mMessage;
};

class SendMessageRequest
{
    [tag="uid"] BlazeId mBlazeId;
    [tag="msg"] string(64) mMessage;
};

class SubscriptionRequest
{
    [tag="buid"] BlazeId mBlazeId;
    [tag="oper"] bool mIsSubscribed;
};

class ReconfigurableFeaturesResponse
{
    [tag="feat", description="List of reconfigurable features"]
    ComponentNameList mFeatureNames;
};

class ProfanityCheckRequest
{
    [tag="text", description="Text to check for profanity"]
    string(128) mText;
};

class ProfanityCheckResponse
{
    [tag="ispr", description="Result of profanity check"]
    bool mIsProfanity;
};

class ArsonCreateGameRequest
{
    [tag="cgrq"] Blaze::GameManager::CreateGameRequest mCreateGameRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class DestroyGameRequest
{
    [tag="dgrq"] Blaze::GameManager::DestroyGameRequest mDestroyGameRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class SetGameSettingsRequest
{
    [tag="sgsr"] Blaze::GameManager::SetGameSettingsRequest mSetGameSettingsRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class SetGameAttributesRequest
{
    [tag="sgar"] Blaze::GameManager::SetGameAttributesRequest mSetGameAttributesRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class BanPlayerRequest
{
    [tag="bprq"] Blaze::GameManager::BanPlayerRequest mBanPlayerRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class RemovePlayerFromBannedListRequest
{
    [tag="rprq"] Blaze::GameManager::RemovePlayerFromBannedListRequest mRemovePlayerFromBannedListRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class ClearBannedListRequest
{
    [tag="cblr"] Blaze::GameManager::BannedListRequest mBannedListRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class UpdateGameNameRequest
{
    [tag="ugnr"] Blaze::GameManager::UpdateGameNameRequest mUpdateGameNameRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class SetPlayerCapacityRequest
{
    [tag="spcr"] Blaze::GameManager::SetPlayerCapacityRequest mSetPlayerCapacityRequest;
    [tag="issu"] bool mNullCurrentUserSession;
};

class GenerateCustomErrorRequest
{
    [tag="cuer", description="Custon error id."]
        int32_t mCustomError;
};

[ description = "The request class for the command. 'Wraps/clones' server-side only settable fields from usersessiontypes_server.tdf's LoginSessionRequest, such as external ids" ]
class ArsonLoginSessionRequest
{
    // Basic Login fields:
    [tag="blid"] BlazeId mBlazeId;
    [tag="mail", description="The email address of the account to login"]
    string(MAX_EMAIL_LENGTH) mEmail;
    [tag="pnam", description="The persona name to login"]
    string(MAX_PERSONA_LENGTH) mPersonaName;
    [tag="onam", description="The Origin persona name to login"]
    string(MAX_PERSONA_LENGTH) mOriginPersonaName;
    [tag="opid", description="The Origin persona id"]
    uint64_t mOriginPersonaId;

    [tag="nuid"] uint64_t mAccountId;

    [tag="copt"] bool mCrossPlatformOptIn;

    // Debug-only fields (from LoginUserSessionRequest::mUserData):

    [tag="xtyp", default=INVALID, description="External system type of the ExternalId"]
    ClientPlatformType mClientPlatformType;

    [tag="exid", description="The binary 1st party external id of the user."]
    ExternalId mExternalId;

    [tag="exst", description="The external string associated with switches"]
    string(256) mExternalString;

    [tag="ctyp", default=CLIENT_TYPE_INVALID, description="(Optional) Specifies the ClientType for the created UserSession. If left as default(CLIENT_TYPE_INVALID), then the ClientType defined on the Connection will be used."]
    ClientType mClientType;
};

enum ShutdownReason
{
    [description="Null shutdown reason"]
    SHUTDOWN_NONE,
    [description="Server shutdown normally - invoked by user action"]
    SHUTDOWN_NORMAL,
    [description="Server shutdown during startup."]
    SHUTDOWN_BOOTSTRAP_ERROR,
    [description="Server process shut down after drained of users."]
    SHUTDOWN_DRAINED,
    [description="Server shutdown to be restarted - invoked by user action"]
    SHUTDOWN_REBOOT
};

enum ShutdownTarget
{
    [description="Shutdown only local server instance"]
    SHUTDOWN_TARGET_LOCAL,
    [description="Shutdown all server instances"]
    SHUTDOWN_TARGET_ALL,
    [description="Shutdown a list of server instances"]
    SHUTDOWN_TARGET_LIST
};

class ShutdownRequest
{
    typedef list<uint16_t> InstanceIdList;

    [tag="reas", description="(DEPRECATED - replaced by mRestart) Shutdown reason", default=SHUTDOWN_NORMAL]
    ShutdownReason mReason;
    [tag="trgt", description="Shutdown target", default=SHUTDOWN_TARGET_LOCAL]
    ShutdownTarget mTarget;
    [tag="lint", description="List of instance IDs to shutdown if target is list (SHUTDOWN_TARGET_LIST); otherwise, ignored"]
    InstanceIdList mInstanceIds;
    [tag="rtrt", default=false, description="Whether we want the monitor to restart us once we're done shutting down"]
    bool mRestart;
    [tag="drin", default=false, description="Drain or not drain before shutting down"]
    bool mDrain;
    typedef map<ClientType, uint32_t> ThresholdByClientType;
    [tag="minu", description="Minimum local user sessions threshold for this drain.  Only applicable for drain.  Will be ignored for MASTER instances as no user sessions are local to MASTERs.  When local user sessions are below the thresholds for the specified client types, server will shutdown."]
    ThresholdByClientType mDrainLocalUserThresholdByClientType;
    [tag="time", default="0s", description="Timeout value for user threshold.  Only applies to drain.  When timeout expires, server will perform the shutdown sequence. (Default to 0s, which means no timeout)"]
    TimeValue mDrainTimeout;
};

class LocalizeStringReq
{
    [tag="stid", description="the string to localize"]
    StringId mStringId;

    [tag="lprm", description="Optional, to omit leave empty"]
    StringIdParamList mParams;

    [tag="lang", description="Locale of the string"] uint32_t mLocale;
};

class LocalizeStringRsp
{
    [tag="smap"]
    string(4096) mLocalizedString;
};

class PostNewsRequest
{
    [tag="mpnr"] Blaze::Clubs::PostNewsRequest mPostNewsRequest;
    [tag="ncus"] bool mNullCurrentUserSession;
};

class GetClubMembershipForUsersRequest
{
    [tag="gcur"] Blaze::Clubs::GetClubMembershipForUsersRequest mGetClubMembershipForUsersRequest;
    [tag="ncus"] bool mNullCurrentUserSession;
};

class GetClubMembershipForUsersResponse
{
    [tag="cmsr"] Blaze::Clubs::GetClubMembershipForUsersResponse mGetClubMembershipForUsersResponse;
};

class FilteredLeaderboardStatsRequest
{
    [tag="gcur"] Blaze::Stats::FilteredLeaderboardStatsRequest mFilteredLeaderboardStatsRequest;
    [tag="ncus"] bool mNullCurrentUserSession;
};

class LeaderboardStatValues
{
    [tag="cmsr"] Blaze::Stats::LeaderboardStatValues mLeaderboardStatValues;
};


class LeaderboardGroupRequest
{
    [tag="gcur"] Blaze::Stats::LeaderboardGroupRequest mLeaderboardGroupRequest;
    [tag="ncus"] bool mNullCurrentUserSession;
};

class LeaderboardGroupResponse
{
    [tag="cmsr"] Blaze::Stats::LeaderboardGroupResponse mLeaderboardGroupResponse;
};

class GrantEntitlement2Request
{
    [tag="gran"] Blaze::Authentication::GrantEntitlement2Request mGrantEntitlement2Request;
    [tag="ncus"] bool mNullCurrentUserSession;
};

[description="String for external key" ]
typedef string(255) ExternalKey;

class UserKeyTypeInfo
{
    [tag="etky"] ExternalKey mExternalKey;
    [tag="clty"] ClientType  mClientType;
};

class SetByteVaultUseRestProtocolRequest
{
    [tag="rest"] bool mByteVaultUseRestProtocol;
};

class TestUpdateStatsHelperRequest
{
    [tag="pid", description="Player Blaze Entity Id"]
    BlazeId mPlayerId;
};

class OutboundConnMgrStatus
{
    [tag="host"] string(256) mHost;
    [tag="port"] uint16_t mPort;
    [tag="tcon"] uint32_t mTotalConnections;
    [tag="acon"] uint32_t mActiveConnections;
    [tag="pcon"] uint32_t mPeakConnections;
    [tag="mcon"] uint32_t mMaxConnections;
    [tag="pctr"] string(32) mPercentReconnect;
    [tag="pctt"] string(32) mPercentReconnectTime;
};

class ComponentStatus
{
    [tag="id"]   uint16_t mComponentId;
    [tag="name"] ComponentName mComponentName;
    [tag="st"]   string(64) mState;
    typedef map<string(128),string(1024)> InfoMap ;
    typedef map<ServiceName, InfoMap, ignorecase> InfoByServiceName;
    [tag="info"] InfoMap mInfo;
    [tag="sinf"] InfoByServiceName mInfoByServiceName;
    [tag="pool"] map<string(128),OutboundConnMgrStatus, ignorecase> mPoolInfo;
    [tag="rlod", default=false] bool mIsReloadableComponent;
};

[description="Class that describes the current timing information stored on a per-fiber basis"]
class ServerVersion
{
    [tag="vers"] string(128) mVersion;
    [tag="time"] string(64) mBuildTime;
    [tag="loc"]  string(256) mBuildLocation;
    [tag="btgt"] string(256) mBuildTarget;
    [tag="p4"]   string(256) mP4DepotLocation;
    [tag="msrc"] uint32_t mModifiedSourceFiles;
};

class DbInstancePoolStatus
{
    [tag="host"] string(256) mHost;
    [tag="port"] uint16_t mPort;
    [tag="user"] string(64) mUser;
    [tag="tcon"] uint32_t mTotalConnections;
    [tag="acon"] uint32_t mActiveConnections;
    [tag="pcon"] uint32_t mPeakConnections;
    [tag="tacn"] uint32_t mTotalAvailableConnections;
    [tag="sqlc"] bool mSquelching;
    [tag="dran"] bool mDraining;
    [tag="terr"] uint64_t mTotalErrors;
    [tag="tq"] uint64_t mTotalQueries;
    [tag="tmq"] uint64_t mTotalMultiQueries;
    [tag="tps"] uint64_t mTotalPreparedStatementQueries;
    [tag="tcmt"] uint64_t mTotalCommits;
    [tag="trb"] uint64_t mTotalRollbacks;
    [tag="qta"] int64_t mQueryTimeAverageMs;
    [tag="qtd"] int64_t mQueryTimeDeviationMs;
    [tag="qtba"] int64_t mQueryTimeBaselineAverageMs;
    [tag="qtbd"] int64_t mQueryTimeBaselineDeviationMs;
    [tag="qtca"] int64_t mTotalQueryTimeThresholdCrosses;
};

class DbConnPoolStatus
{
    [tag="name"] string(256) mName;
    [tag="db"]   string(256) mDatabase;
    [tag="mstr"] DbInstancePoolStatus mMaster;
    [tag="qfms"] uint32_t mQueuedFibersMaster;
    [tag="qfsl"] uint32_t mQueuedFibersSlaves;
    [tag="slav"] list<DbInstancePoolStatus> mSlaves;
};

class DatabaseStatus
{
    [tag="tthr"] uint32_t mTotalWorkerThreads;
    [tag="athr"] uint32_t mActiveWorkerThreads;
    [tag="pthr"] uint32_t mPeakWorkerThreads;
    [tag="pool"] map<uint32_t, DbConnPoolStatus> mConnectionPools;
};

class ConnectionStatus
{
    [tag="id"]   int32_t mIdent;
    [tag="addr"] string(64) mAddress;
    [tag="port"] uint16_t mPort;
    [tag="padr"] string(64) mPeerAddress;
    [tag="pprt"] uint16_t mPeerPort;
    [tag="prot"] string(32) mProtocol;
    [tag="enc"]  string(32) mEncoder;
    [tag="dec"]  string(32) mDecoder;
    [tag="rebt"] uint64_t mRecvBytes;
    [tag="rect"] uint64_t mRecvCount;
    [tag="sebt"] uint64_t mSendBytes;
    [tag="sect"] uint64_t mSendCount;
    [tag="oqsz"] uint32_t mOutputQueueSize;
    [tag="oqbt"] uint32_t mOutputQueueBytes;
};

class ConnectionManagerStatus
{
    [tag="ocnt"] uint32_t mOutboundConnectionCount;
    [tag="orbt"] uint64_t mOutboundTotalRecvBytes;
    [tag="orct"] uint64_t mOutboundTotalRecvCount;
    [tag="osbt"] uint64_t mOutboundTotalSendBytes;
    [tag="osct"] uint64_t mOutboundTotalSendCount;
    [tag="oqsz"] uint64_t mOutboundTotalOutputQueueSize;
    [tag="oqbt"] uint64_t mOutboundTotalOutputQueueBytes;
    [tag="ocon"] list<ConnectionStatus> mOutboundConnections;

    [tag="icnt"] uint32_t mInboundConnectionCount;
    [tag="irbt"] uint64_t mInboundTotalRecvBytes;
    [tag="irct"] uint64_t mInboundTotalRecvCount;
    [tag="isbt"] uint64_t mInboundTotalSendBytes;
    [tag="isct"] uint64_t mInboundTotalSendCount;
    [tag="iqsz"] uint64_t mInboundTotalOutputQueueSize;
    [tag="iqbt"] uint64_t mInboundTotalOutputQueueBytes;
    [tag="icon"] list<ConnectionStatus> mInboundConnections;

    [tag="rjet", default=0, description="The total number of connections rejected due to exceeding maxConnection limit."]
    uint32_t mTotalRejectMaxInboundConnections;

    [tag="trml", default=0, description="The total number of connections rejected due to exceeding Rate Limit."]
    uint32_t mTotalRejectMaxRateLimitInboundConnections;

    [tag="edrn"] map<string(64), uint32_t> mEndpointDrainStatus;
};

class SelectorStatus
{
    [tag="tqct"] int64_t mTimerQueueTasks;
    [tag="tqti"] int64_t mTimerQueueTime;
    [tag="tqsz"] int64_t mTimerQueueSize;
    [tag="jqct"] int64_t mJobQueueTasks;
    [tag="jqti"] int64_t mJobQueueTime;
    [tag="nepo"] int64_t mNetworkPolls;
    [tag="neta"] int64_t mNetworkTasks;
    [tag="neti"] int64_t mNetworkTime;
    [tag="nppo"] int64_t mNetworkPriorityPolls;
    [tag="npta"] int64_t mNetworkPriorityTasks;
    [tag="npti"] int64_t mNetworkPriorityTime;
    [tag="sele"] int64_t mSelects;
    [tag="wake"] int64_t mWakes;
};

class MemoryStatus
{
    class Stats
    {
        [tag="used", description="Amount of memory in use"] uint64_t mUsedMemory;
        [tag="max", description="Max amount of memory ever in use"] uint64_t mMaxUsedMemory;
        [tag="core", description="Amount of core memory available"] uint64_t mAllocatedCoreMemory;
    };

    class AllocatorStatus
    {
        [tag="id", description="Unique id of the allocator"] uint32_t mId;
        [tag="name", description="Descriptive name of this allocator"] string(32) mName;
        [tag="stat", description="Memory stats for this allocator"] Stats mStats;
    };

    [tag="totl", description="Memory totals for the server as a whole."] Stats mTotals;
    [tag="allc", description="List of statuses for all allocators."] list<AllocatorStatus> mPerAllocatorStats;
};

[description="Class that describes the current timing information stored on a per-fiber basis"]
class FiberManagerStatus
{
    class FiberPoolInfo
    {
        [tag="ufz"] uint32_t mUsedFiberListSize;
        [tag="npf"] uint32_t mNumPooledFibers;
        [tag="mxpf"] uint32_t mMaxPooledFibers;
        [tag="stkz"] uint32_t mStackSize;
    };
    [tag="flst"] list<FiberPoolInfo> mFiberPoolInfoList;

    [tag="smsz"] uint32_t mUsedSemaphoreMapSize;
    [tag="smul"] uint32_t mUnusedSemaphoreListSize;
    [tag="smid"] uint64_t mSemaphoreIdCounter;
};

[description="Class that describes the current timing information stored on a per-fiber basis"]
class ServerStatus
{
    class RpcLatency
    {
        [tag="tola"] int64_t mTotalLatency;
        [tag="topi"] int64_t mTotalPingCount;
    };
    [tag="vers"] ServerVersion mVersion;
    [tag="iid"]  uint32_t mInstanceId;
    [tag="inam"] string(64) mInstanceName;
    [tag="isid"] SlaveSessionId mInstanceSessionId;
    [tag="clst"] list<ComponentStatus> mComponents;
    [tag="stim"] string(64) mStartupTime;
    [tag="stmp"] uint64_t mUptime;
    [tag="ctim"] string(64) mConfigReloadTime;
    [tag="cfgt"] uint64_t mConfigUptime;
    [tag="db"]   DatabaseStatus mDatabase;
    [tag="rpcl"] map<string(64), RpcLatency> mPeerLatencies;
    [tag="conn"] ConnectionManagerStatus mConnectionManager;
    [tag="sele"] SelectorStatus mSelector;
    [tag="mem"]  MemoryStatus mMemory;
    [tag="fmgr"] FiberManagerStatus mFiberManagerStatus;
    [tag="insv"] bool mInService;
    [tag="pid"] uint32_t mProcessId;
};

class RedisRequest
{
    enum Operation
    {
       REDIS_OP_GET,
       REDIS_OP_SET,
       REDIS_OP_REMOVE
    };

    [tag="op"] Operation op;
    [tag="key"] string(256) key;
    [tag="val"] string(8192) value;
    [tag="tdf"] ArsonRequest tdf;
    [tag="flag"] uint32_t flags;
    [tag="keys"] list<string(256)> keys;
    [tag="utdf", default=false ] bool useTdf;
    [tag="expy"] int32_t expiry;
};

class RedisEntry
{
    [tag="key"] string(256) key;
    [tag="val"] string(8192) value;
    [tag="flag"] uint32_t flags;
};

class RedisResponse
{
    [tag="elst"] list<RedisEntry> results;
    [tag="tdf"] ArsonRequest tdf;
};

class ClearAssociationListRequest
{
    [tag="ids"] list<BlazeId> users;
};

class GetUserIdsRequest
{
    [tag="boid", description="Unique blaze object id for the association list."]
    ObjectId mBlazeObjId;
};

class GetUserIdsResponse
{
    [tag="ids"] list<BlazeId> userIds;
};

class TestNotification
{
    [tag="text"] string(64) mText;
};

class SlowTxnSensitiveInfoObject
{
    [tag="dsec", description="response delay secs"]
    uint32_t mDelaySecs;

    [tag="metd", description="method of the request"]
    string(64) mMethod;

    [tag="emil", description="sensitive info"]
    string(64) mEmail;

    [tag="pswd", description="sensitive info"]
    string(64) mPassword;
};

class SlowTxnObject
{
    [tag="dsec", description="response delay secs"]
    uint32_t mDelaySecs;

    [tag="metd", description="method of the request"]
    string(64) mMethod;
};

class ArsonDrainRequest
{
    enum ArsonDrainTarget
    {
        [description="Drain only local server instance"]
        DRAIN_TARGET_LOCAL,
        [description="Drain all server instances"]
        DRAIN_TARGET_ALL,
        [description="Drain a list of server instances"]
        DRAIN_TARGET_LIST
    };

    typedef list<uint16_t> InstanceIdList;

    [tag="trgt", default=DRAIN_TARGET_LOCAL, description="What to drain"]
    ArsonDrainTarget mTarget;

    [tag="inst", description="If target specified DRAIN_TARGET_LIST, drain the instances in this list."]
    InstanceIdList mInstanceIdList;

    [tag="time", default="0s", description="Timeout value for this drain.  Only applicable when draining to shutdown.  When timeout expires, server will shutdown. (Default to 0s, which means no timeout)"]
    TimeValue mTimeout;

    typedef map<ClientType, uint32_t> ThresholdByClientType;
    [tag="minu", description="Minimum local user sessions threshold for this drain.  Only applicable when draining to shutdown.  When local user sessions are below the thresholds for the specified client types, server will shutdown."]
    ThresholdByClientType mLocalUserThresholdByClientType;
};

/////////////////////////////////////////////////////////////////////////////////////////
//       Multiplayer Session Directory
/////////////////////////////////////////////////////////////////////////////////////////

class GetXblMultiplayerSessionRequest
{
    [tag="etyp", description="Blaze object type."] ObjectType mEntityType;
    [tag="eid", description="entity id, e.g. game or pg id."] int64_t mEntityId;
    [tag="exi", description="player who will be making the call (uses its auth key). DEPRECATED: use mOnBehalfOfUserIdentifications"] Blaze::UserIdentification mExternalIdent;
    [tag="usrs"] Blaze::UserIdentificationList mOnBehalfOfUserIdentifications;

    [tag="exsn"] Blaze::XblSessionName sessionName;
    [tag="scid"] Blaze::XblScid scid;
    [tag="extn"] Blaze::XblSessionTemplateName sessionTemplateName;

    [tag="cur", default=false, description="Whether to override the mExternalIdent with 'current user' who makes rpc call."]
    bool mUseCurrentUserForExternalSessionCall;
};

class GetXblMultiplayerSessionResponse
{
    [tag="xble"] int32_t mXblServicesErrorCode;
    [tag="blze"] int32_t mBlazeErrorCode;

    //ARSON_TODO when poss: [tag="xblr"] Blaze::XBLServices::ArsonMultiplayerSessionResponse mMultiplayerSessionResponse;
    [tag="xblr"] ArsonMultiplayerSessionResponse mMultiplayerSessionResponse;
};

/////////////////////////////////////////////////////////////////////////////////////////
//       XBL Users/People Social
/////////////////////////////////////////////////////////////////////////////////////////

[description="Call arson custom helper, to get XBL people/follow lists for the requested user."]
class ArsonGetXblUsersPeopleRequest
{
    [tag="xuid", description="DEPRECATED: use mUserIdent, to support XBSX"]
    Blaze::ExternalId mExternalId;

    [tag="user", description="user's identification, to fetch people lists for"]
    Blaze::UserIdentification mForUser;
};

class ArsonXblUserPerson
{
    [tag="xuid", description=""]
    string(Blaze::MAX_EXTERNAL_ID_CHAR_LEN) mXuid;

    [tag="fold", description="Whether the caller is following the user."]
    bool isFollowedByCaller;

    [tag="folg", description="Whether the user is following the caller."]
    bool isFollowingCaller;
};
typedef list<ArsonXblUserPerson> ArsonXblUsersPeople;

class ArsonGetXblUsersPeopleResponse
{
    [tag="ppl", description="people of the REST response"]
    ArsonXblUsersPeople mPeople;
};

/////////////////////////////////////////////////////////////////////////////////////////
//       XBL Handles Get Activiy For User
/////////////////////////////////////////////////////////////////////////////////////////

class ArsonGetXblActivityForUserRequest
{
    [tag="xuid", description="user's identification"]
    Blaze::UserIdentification mExternalIdent;
};

class ArsonGetXblActivityForUserResponse
{
    [tag="xblr"] ArsonMultiplayerSessionResponse mMultiplayerSessionResponse;
    [tag="hand"] XblActivityHandleId mHandleId;
};

class ReputationRequestsHeader
{
    [tag="atkn", description=""]
    string(-1) mAuthToken;
};

class PostFeedbackRequestBody
{
    [tag="snam", description="The Name of the Session the user sent this feedback from. If there is no associated session, this field is 0."]
    string(-1) mSessionName;

    [tag="fbtp", description="The type of feedback."]
    string(-1) mFeedbackType;

    [tag="trsn", description="User-supplied text that the sender added to the feedback."]
    string(-1) mTextReason;

    [tag="vrid", description="The ID of a user-supplied voice file from Kinect that the sender added to the feedback."]
    string(-1) mVoiceReasonId;

    [tag="edid", description="The ID of a resource that can be used as evidence of the feedback being submitted. For example, the ID can indicate a video file recorded during game play."]
    string(-1) mEvidenceId;
};

class PostFeedbackRequest
{
    [tag="xuid", description="Xbox User ID (XUID) of the user being reported"]
    ExternalXblAccountId mXuid;

    [tag="pfrb", description="Feedback body"]
    PostFeedbackRequestBody mPostFeedbackRequestBody;
};

class ServiceErrorResponse
{
   [tag="code", description="The type of error"]
   int32_t mCode;
   [tag="srce", description="The name of the service that raised the error."]
   string(-1) mSource;
   [tag="desp", description="A description of the error."]
   string(-1) mDescription;
};

class DoReputationUpdateRequest
{
   [tag="uids", description=""]
   UserSessionIdList mUserSessionIdList;
   [tag="xids", description=""]
   ExternalIdList mExternalIds;
};

class DoReputationUpdateResponse
{
  [tag="prep", description=""]
   bool  mFoundPoorReputation;
};

class PostResetReputationRequestBody
{
    [tag="fapr", default=75, description="The desired new base Fairplay Reputation score for the user. (valid range 0 to 75)"]
    uint32_t mFairplayReputation;

    [tag="comr", default=75, description="The desired new base Comms Reputation score for the user. (valid range 0 to 75)"]
    uint32_t mCommsReputation;

    [tag="uscr", default=75, description="The desired new base UserContent Reputation score for the user. (valid range 0 to 75)"]
    uint32_t mUserContentReputation;
};

class PostResetReputationRequest
{
    [tag="xuid", description="Xbox User ID (XUID) of the user being reported"]
    ExternalXblAccountId mXuid;

    [tag="prrb", description=""]
    PostResetReputationRequestBody mPostResetReputationRequestBody;
};

typedef string(64) XblScid;
typedef string(64) StatName;
typedef string(64) StatType;
typedef string(MAX_PERSONA_LENGTH) GamerTag;

class Stat
{
    [tag="name", description=""]
    StatName mStatname;

    [tag="type", description=""]
    StatType mType;

    [tag="valu", description=""]
    string(64) mValue;
};

typedef list<Stat> StatsList;

class User
{
    [tag="xuid", description=""]
    uint64_t mXuid;

    [tag="gtag", description=""]
    GamerTag mGamertag;

    [tag="stat", description=""]
    StatsList mStats;
};

class GetReputationRequest
{
    [tag="xuid", description="external ID"]
    ExternalXblAccountId mXuid;

    [tag="scid", description="SCID"]
    XblScid mScid;

    [tag="uvat", description="use valid authentication token or not"]
    bool mUseValidAuthToken;
};

class GetReputationResponse
{
    [tag="user", description=""]
    User mUser;
};

class GetUniqueDeviceIdForUserSessionRequest
{
    [tag="uid", description="The User Session of the user."]
    UserSessionId mUserSessionId;
};

class GetUniqueDeviceIdForUserSessionResponse
{
    [tag="udid", description="The unique console id (not MAC)."]
    string(UNIQUE_DEVICE_ID_MAX) mUniqueDeviceId;
};

class TrustedLoginRequest
{
    [tag="tokn", description="Nucleus 2.0 Access Token"]
    string(-1) mAccessToken;

    [tag="clid", description="The clientId used to generate the access token"]
    string(-1) mClientId;

    [tag="id", description="Optional ID that can be provided for logging purposes"]
    string(256) mId;

    [tag="ityp", description="Optional ID type that can be provided for logging purposes"]
    string(256) mIdType;
};

const uint32_t MAX_PERSONA_STATUS_LENGTH = 20;
const uint32_t MAX_ACCOUNT_STATUS_LENGTH = 20;
const uint32_t MAX_WEB_SERVER_ADDRESS_LENGTH = 64;
const uint32_t MAX_EXTERNAL_REF_LENGTH = 64;
const uint32_t MAX_EXTERNALREF_ID_LENGTH = 64;
const uint32_t MAX_ENTITLEMENT_ID_LENGTH = 64;

typedef Blaze::AccountId AccountId;
typedef Blaze::PersonaId PersonaId;
typedef string(Blaze::MAX_EMAIL_LENGTH) NucleusEmail;
typedef string(Blaze::Authentication::MAX_PASSWORD_LENGTH) NucleusPassword;
typedef string(Blaze::MAX_PERSONA_LENGTH) NucleusPersona;

typedef string(MAX_EXTERNAL_REF_LENGTH) ExternalRefValue;

typedef string(MAX_EXTERNALREF_ID_LENGTH) externalRefId;
typedef int64_t ExternalRef;
typedef string(MAX_WEB_SERVER_ADDRESS_LENGTH) WebServer;
typedef int32_t statusCode_t;

typedef uint64_t TosId;
typedef uint64_t EntitlementId;
typedef list<AccountId> AccountIdList;
typedef list<PersonaId> PersonaIdList;
typedef list<TosId> TosIdList;
typedef list<EntitlementId> EntitlementIdList;

enum TOSType
{
    COMBINED,
    PRIVACY_POLICY,
    TERMS_AND_CONDITIONS
};

class GetPersonaStatusREQ
{
    [tag="nuid"] AccountId mAccountId;
    [tag="pid"] PersonaId mPersonaId;
};

class GetPersonaStatusRSP
{
    [tag="stat"] Blaze::Nucleus::PersonaStatus::Code mPersonaStatus;
};

class GetPersonaIdREQ
{
    [tag="name"] NucleusPersona mPersonaName;
    [tag="nsnm", default="description"] string(Blaze::Authentication::MAX_NAMESPACE_LENGTH) mNamespaceName;
};

class GetPersonaIdRSP
{
    [tag="pid"] PersonaId mPersonaId;
};

class UpdateEntitlementREQ
{
    [tag="nuid"] AccountId mAccountId;
    [tag="enid"] EntitlementId mEntitlementId;
    [tag="code"] Blaze::Nucleus::EntitlementStatus::Code mEntitlementStatusCode;
    [tag="rson"] Blaze::Nucleus::StatusReason::Code mStatusReasonCode;
    [tag="ver"] uint32_t mVersion;
    [tag="term"] string(32) mTerminationDate;
};

class TOSInfo
{
    [tag="tid"] TosId mTOSId;
    [tag="ttyp"] TOSType mTOSType;
    [tag="nuid"] AccountId mAccountId;
    [tag="lang"] string(2) mLanguage;
    [tag="ctry"] string(2) mCountry;
    [tag="pfrm"] string(7) mPlatform;
    [tag="date"] string(32) mDateAccepted;
};
typedef list<TOSInfo> TOSInfoList;

class TriggerTdfEchoRequest
{
    [tag="tdf", description="Variable TDF to encode"]
    variable mTdf;

    [tag="ucle", default=false, description="Optional XML Encoding Frame param"]
    bool mXMLEncUseCommonListEntryName;

    enum EncodingType
    {
        [description="Triggers Json Encoder."]  JSON_ENCODING,
        [description="Triggers XML Encoder"]    XML_ENCODING
    };
    [tag="tdft"] EncodingType mEncodingType;
};

class TriggerTdfEchoResponse
{
    [tag="etdf", description="encoded TDF"]
    string(-1) mEncodedTdf;

    [tag="tdf", description="Decoded Variable TDF"]
    variable mDecodedTdf;
};

class AccessTokenFormatValidationRequest
{
    [tag="stft", description="The format of server access token is expected to be in."]
    Blaze::OAuth::TokenFormat mServerTokenFormat;

    [tag="utft", description="The format of user access token is expected to be in."]
    Blaze::OAuth::TokenFormat mUserTokenFormat;
};

class CompareNucleusApiResponsesRequest
{
    [tag = "auth", description = "Nucleus 2.0 Auth Code"]
    string(-1) mAuthCode;

    [tag = "tokn", description = "Nucleus 2.0 Access Token. Token format must be JWT."]
    string(-1) mAccessToken;
};

class CompareNucleusApiResponsesResponse
{
    [tag = "emsg", description = "Error message"]
    string(-1) mErrorMessage;
};

class CheckTokenRetrievalAndRefreshmentRequest
{
    [tag = "ctui", description = "Expected config CachedTokenUpdateInterval used on blazeserver"]
    TimeValue mCachedTokenUpdateInterval;
    
    [tag = "ckst", default = false, description = "Check against user token or server token"]
    bool mCheckServerToken;

    [tag = "trai", default = false, description = "If token should be refreshed after the CachedTokenUpdateInterval"]
    bool mIsTokenRefreshedAfterInterval;

    [tag = "nuav", default = false, description = "If nucleus service is available"]
    bool mIsNucleusAvailable;
};

class SimpleClass
{
    [tag="int"] uint32_t mInteger;
};

[tdfid="hash"]
class SimpleNestedClass
{
    [tag="ncla", description="Nested Class"]
    SimpleClass mSimpleNestedClass;
};

[tdfid="hash"]
class SimpleList
{
    [tag="list", description="integer list"]
    list<int32_t> mIntList;
};

[tdfid="hash"]
class SimpleMap
{
    [tag="map", description="string integer map"]
    map<string(128),int32_t, ignorecase> mStringIntMap;
};

[tdfid="hash"]
class SimpleStringMap
{
    [tag="map", description="string integer map"]
    map<string(128),string(128), ignorecase> mStringStringMap;
};

[tdfid="hash"]
class SimpleUnion
{
    [tag="unin", description="string or int32 union"]
    StringOrInt32 mStringOrInt32Union;
};

[tdfid="hash"]
class SimpleEnum
{
    [tag="enum", description="enum value"]
    ValueEnum mEnumValue;
};

[tdfid="hash"]
class SimpleBlob
{
    [tag="blob", description="blob"]
    blob mBlob;
};

[tdfid="hash"]
class SimpleTimevalue
{
    [tag="time", description="time value"]
    TimeValue mTime;
};

class GetPersonaREQ
{
    [tag="pid"] PersonaId mPersonaId;
};

class GetPersonaRSP
{
    [tag="nuid"] AccountId mAccountId;
    [tag="dspn"] string(32) mDisplayName;
    [tag="nsnm", default="description"] string(Blaze::Authentication::MAX_NAMESPACE_LENGTH) mNamespaceName;
    [tag="stat"] Blaze::Nucleus::PersonaStatus::Code mPersonaStatus;
};

class GetCoordsREQ
{
    [tag="blid"] BlazeId mBlazeId;
};

class GetCoordsRSP
{
    [tag="lati"] float mLatitude;
    [tag="long"] float mLongitude;
};

class CheckConnectivityREQ
{
    [tag="sid", description="The session ID for the connection to check"]
    UserSessionId mUserSessionId;

    [tag="cnto", description="Timeout (relative) to wait for connectivity"]
    TimeValue mConnectivityTimeout;
};



[tdfid="hash", trackChanges = true]
class ExceptionMapEntry
{
    [tag="int"] int32_t mInt;
    [tag="str"] string(32) mString;
};

class ExceptionMapUpdateRequest
{
    [tag="cid"] uint32_t mCollectionId;
    [tag="oid"] uint32_t mObjectId;
    [tag="val"] ExceptionMapEntry mEntry;
};

class ExceptionMapValueRequest
{
    [tag="cid"] uint32_t mCollectionId;
    [tag="oid"] uint32_t mObjectId;
};

class ExceptionMapRequest
{
    [tag="cid"] uint32_t mCollectionId;
};

typedef list<int32_t> PeriodTypeList;
typedef list<uint32_t> OffsetList;
typedef map<string(32), int64_t, ignorecase> ScopeNameValueMap;
class StatDelete
{
    [tag="cat", description="Category name."] string(32) mCategory;
    [tag="eid", description="Entity ID."] EntityId mEntityId;
    [tag="dall", description="Flags the server to delete all stats."] bool mDeleteAll;
    [tag="ptyp", description="List of period types."] PeriodTypeList mPeriodTypes;
    [tag="pero", description="List of offsets for periods to delete (empty list means all)."] OffsetList mPerOffsets;
    [tag="ksum", description="Key scope name/value pairs for the group defined in the stats config."] ScopeNameValueMap mKeyScopeNameValueMap;
};

class DeleteStatsRequest
{
    [tag="dele", description="List of stats to be deleted."] list<StatDelete> mStatDeletes;
};

class UEDDefinition
{
    [tag="uedn", description="User Extended Data Name in the form component.data (ie. stats.dnf)."]
        UserExtendedDataName mUserExtendedDataName;
    [tag="uedk", description="User Extended Data Key, this is the key used in the UED map to look up UED values."]
        UserExtendedDataKey mDataKey;
    [tag="defv", description="Default value for this UED map entry, for reference."]
        UserExtendedDataValue mDefaultValue;
};

typedef list<UEDDefinition> UEDDefinitionList;

class ComponentUEDDefinitions
{
    [tag="comp", description="Component Id for the definitions."]
        ComponentId mComponentId;
    [tag="uedl", description="List of all UED this component generates."]
        UEDDefinitionList mComponentUedList;
};

typedef map<ComponentName, ComponentUEDDefinitions, ignorecase> ComponentUEDDefinitionsMap;
class GetUEDInformationMapResponse
{
    [tag="uedm", description="Map of component names to UED defined on this Blaze instance.."]
        ComponentUEDDefinitionsMap mComponentUEDDefinitionsMap;
};

// This is pulled from UserInfoData in userinfotypes_server.tdf
class SessionUserInfoData
{
    [tag="uid", description = "The Blaze/Persona ID of the user."]
    BlazeId mId;

    [tag="nid", description="The Account id of the user's master account."]
    AccountId mAccountId;

    [tag="name", description="The name of the logged in persona."]
    string(256) mPersonaName;

    [tag="nasp", description="The persona namespace."]
    PersonaNamespace mPersonaNamespace;

    [tag="exid", description="The binary 1st party external id of the user."]
    ExternalId mExternalId;

    [tag="plat", default=INVALID, description="Client platform type"]
    ClientPlatformType mClientPlatform;

    [tag="aloc", description="Account locale settings for this user."]
    Locale mAccountLocale;

    [tag="cnty", description="Account country setting for this user."]
    uint32_t mAccountCountry;

    [tag="uatt", description="Custom user info attribute."]
    UserInfoAttribute mUserInfoAttribute;

    [tag="stat", default=1, description="account status active/disabled"]
    uint32_t mStatus;

    [tag="flog", default=0, description="the date/time of the users first login to the title"]
    int64_t mFirstLoginDateTime;

    [tag="llog", default=0, description="the date/time of the users last login to the title"]
    int64_t mLastLoginDateTime;

    [tag="plog", default=0, description="the date/time of the users previous login to the title"]
    int64_t mPreviousLoginDateTime;

    [tag="lout", default=0, description="the date/time of the users last logout from the title"]
    int64_t mLastLogoutDateTime;

    [tag="lsal", description="Last connection locale settings used."]
    Locale mLastLocaleUsed;

    [tag="err", description="Last auth error."]
    uint32_t mLastAuthErrorCode;

    [tag="cacc", default=false, description="Child account."]
    bool mIsChildAccount;

    [tag="orig", description="The Origin persona id of the user."]
    OriginPersonaId mOriginPersonaId;

    [tag="pidi", description="The Pid Id of the user."]
    int64_t mPidId;
};

// This is pulled from UserSessionata
class UserSessionProductNameData
{
    [tag="prdt", description="The product name as configured in products.cfg that user authenticates against."]
    ProductName mProductName;
};

class GetClientIpResponse
{
    [tag="clip", description="Client IP for this user is retrived from the user session existance data."]
    string(-1) mClientIp;
};

[tdfid="hash"]
class EncodeDecodeTestClass
{
    [tag="int"]
    uint32_t mInt;

    [tag="str"]
    string(64) mString;

    [tag="bool"]
    bool mBool;

    [tag="uni"]
    StringOrInt32 mUnion;

    enum InClassEnum
    {
       IN_OF_CLASS_ENUM_VAL_INVALID = 0,
       IN_OF_CLASS_ENUM_VAL_1 = 1,
       IN_OF_CLASS_ENUM_VAL_2 = 2,
       IN_OF_CLASS_ENUM_VAL_3 = 3
    };

    [tag="ienu"]
    InClassEnum mInClassEnum;

    [tag="oenu"]
    OutOfClassEnum mOutOfClassEnum;

    [tag="blob"]
    blob mBlob;

    [tag="list"]
    list<uint32_t> mList;

    [tag="map"]
    map<string(32), uint32_t, ignorecase> mMap;

    [tag="ulis"]
    list<StringOrInt32> mUnionList;

    [tag="umap"]
    map<string(32), StringOrInt32, ignorecase> mUnionMap;

    [tag="var"]
    variable mVariable;

    [tag="gen"]
    generic mGeneric;
};

class GetSliversRequest
{
    [tag="name"]
    string(128) mSliverNamespace;

    [tag="frid", default=INVALID_SLIVER_INSTANCE_ID]
    uint16_t mFromInstanceId;
};

class GetSliversResponse
{
    [tag="list"]
    list<uint16_t> mSliverIdList;
};

[description="Stores 256 bits in 64-bit parts.", trackChanges = true]
class Int256Buffer
{
    [tag="prt1"]
    int64_t mPart1;
    [tag="prt2"]
    int64_t mPart2;
    [tag="prt3"]
    int64_t mPart3;
    [tag="prt4"]
    int64_t mPart4;
};

typedef uint16_t NotificationId;

[tdfid = "hash", description = "This class defines all the data that describes the session of a logged in user."]
class NotificationData
{
    enum EncoderType
    {
        HEAT2 = 0,
        HTTP,
        JSON,
        XML2,
        EVENTXML
    };

    enum EncoderSubType
    {
        NORMAL = 0,
        DEFAULTDIFFERNCE
    };

    enum EncoderResponseFormat
    {
        FORMAT_USE_TDF_NAMES = 0,
        FORMAT_USE_TDF_RAW_NAMES,
        FORMAT_USE_TDF_TAGS
    };

    [tag="cmpt"]
    ComponentId mComponentId;

    [tag="ntfn"]
    NotificationId mNotificationId;

    [tag="logc"]
    int32_t mLogCategory;

    [tag="etyp"]
    EncoderType mEncoderType;

    [tag="esub"]
    EncoderSubType mEncoderSubType;

    [tag="rfmt"]
    EncoderResponseFormat mEncoderResponseFormat;

    [tag="data"]
    blob mData;
};
typedef list<NotificationData> NotificationDataList;

// TODO: Proto generation is disabled for UserSessionExtendedData
[tdfid = "hash", description = "This class defines all the data that describes the session of a logged in user.", generateProto=false]
class UserSessionData
{
    [tag="id", description="The globally unique id of the user's session."]
    UserSessionId mUserSessionId;

    [tag="cids", description="The child session id linked to this session."]
    UserSessionId mChildSessionId;

    [tag="pids", description="The parent session id linked to this session."]
    UserSessionId mParentSessionId;

    [tag="ctim", description="The time the session was created."]
    TimeValue mCreationTime;

    [tag="xdat", description="The extended data for this session."]
    UserSessionExtendedData mExtendedData;

    [tag="lat", default = 360.0f, description="The latitude of the user provided by GeoIP; may be overridden."]
    float mLatitude;

    [tag="lon", default = 360.0f, description="The longitude of the user provided by GeoIP; may be overridden."]
    float mLongitude;

    [tag="cmet", description="Upnp client metrics."]
    Blaze::ClientMetrics mClientMetrics;

    [tag="cume", description="Contains metrics gathered by the console."]
    Blaze::ClientUserMetrics ClientUserMetrics;

    [tag="umap", description="A map of server data associated with user."]
    Blaze::UserSessionAttributeMap mServerAttributes;

    [tag="cong", description="The connection group associated with this user."]
    Blaze::ConnectionGroupId mConnectionGroupId;

    [tag="addr", description="The connection IP/port associated with this user."]
    string(64) mConnectionAddr;

    [tag="dsui", description="The dirty sock user index associated with this user."]
    int32_t mDirtySockUserIndex;

    [tag="cndx", description="The connection user index that RPCs from the BlazeSDK are using for this session."]
    uint32_t mConnectionUserIndex;

    [tag="clst", description="The current state of the client, as provided/indicated by the client itself."]
    ClientState mClientState;

    [tag="rand", description="A random number that was generated for this session alone, and can be used in calls to createSHA256Sum, for example."]
    Int256Buffer mRandom;

    typedef map<UserSessionId, int32_t> Int32ByUserSessionId;
    [tag="subs", description="A map of subscribed UserSessions paired with the number of time they have subscribed."]
    Int32ByUserSessionId mSubscribedSessions;

    typedef map<BlazeId, int32_t> Int32ByBlazeId;
    [tag="subu", description="A map of BlazeIds this UserSession has added to it."]
    Int32ByBlazeId mSubscribedUsers;

    [tag="pntf", description="A list of notifications sent to this UserSession while there was no Connection to write to."]
    NotificationDataList mPendingNotificationList;

    [tag="udid"]
    string(UNIQUE_DEVICE_ID_MAX) mUniqueDeviceId;

    [tag="dvtp", description="Device Locality: local vs cloud."]
    DeviceLocality mDeviceLocality;

    [tag="clnt"]
    Blaze::ClientInfo mClientInfo;
};

typedef list<UserSessionData> UserSessionDataList;

class FetchUserSessionDataRequest
{
    [tag="sid"] UserSessionId mUserSessionId;
};

class UpdateUserSessionSubscriptionRequest
{
    [tag="sid"] UserSessionId mUserSessionId;
    [tag="isub"] bool mIsSubscribed;
};

[tdfid="hash"]
class BlazeServerInServiceRSP
{
    [tag="insv"] bool mIsInService;
};

[tdfid="hash"]
class RedisMapData
{
    enum OpType
    {
        HSET,
        HGET
    };

    [tag="type"]
    OpType mOpType;

    [tag="key"]
    uint32_t mKey;

    [tag="fied"]
    string(256) mField;

    [tag="valu"]
    string(256) mValue;
};

class GetUserInfoBySessionIdReq
{
    [tag="uid"] UserSessionId mUserSessionId;
};

class GetClientVersionREQ
{
   [tag="usid"] UserSessionId mUserSessionId;
};

class GetClientVersionRSP
{
   [tag="clve"] string(256) mClientVersion;
};
class PktReceivedMetrics
{
 [tag="cnpr",description="Total counts of leaving clients not receiving packets from dedicated server host."]
 int64_t mClientNoPktReceived;
 [tag="cpre",description="Total counts of leaving clients receiving packets from dedicated server host."]
 int64_t mClientPktReceived;
 [tag="cnre",description="Total counts of clients not sending pkt information to blaze server."]
 int64_t mClientNoResp;
 [tag="hnpr",description="Total counts of dedicated server host not receiving packets from a leaving client."]
 int64_t mDedicatedServerHostNoPktReceived;
 [tag="hpre",description="Total counts of dedicated server host receiving packets from a leaving client."]
 int64_t mDedicatedServerHostPktReceived;
 [tag="hnre",description="Total counts of dedicated server host not sending pkt information to blaze server."]
 int64_t mDedicatedServerHostNoResp;
};

typedef map<Blaze::GameManager::GameId, PktReceivedMetrics> PktReceivedMetricsByGameIdMap;

class GetPktReceivedMetricsResponse
{
    [tag="dspr",description="Map that tracks whether a leaving client & dedicated server host are receiving packets from each other. Map is keyed by dedicated server host."]
    PktReceivedMetricsByGameIdMap mPktReceivedMetricsByGameIdMap;
};

class GetPktReceivedMetricsRequest
{
    [tag="gid",description="Filter metrics by game id. If not specified, then all metrics will be returned."]
     Blaze::GameManager::GameId mGameId;
};

/////////////////////////////////////////////////////////////////////////////////////////
//       PS4 NP Sessions
/////////////////////////////////////////////////////////////////////////////////////////

// Arson version of Blaze Server's PsnOnlineId
typedef string(16) ArsonPsnOnlineId;

// Arson version of Blaze Server's PSNServices::NpSessionMember
class ArsonNpSessionMember
{
    [tag="psid", description="The PSN SCE Online Id."]
    ArsonPsnOnlineId mOnlineId;

    [tag="acid", description="The PSN SCE Account Id."]
    string(Blaze::MAX_EXTERNAL_ID_CHAR_LEN) mAccountId;
};

// Arson version of the Blaze Server's GetNpSessionResponse.
class ArsonNpSession
{
    [tag="ssid", description="The NP Session Id."]
    NpSessionId mSessionId;

    [tag="tim", description="time of session's creation in epoch milliseconds."]
    uint64_t mSessionCreateTimestamp;
    [tag="crt", description="session creator, 16 ASCII chars"]
    string(16) mSessionCreator;
    [tag="lock", description="session lock"]
    bool mSessionLockFlag;
    [tag="mau", description="max users for display"]
    uint16_t mSessionMaxUser;
    [tag="nam", description="session name"]
    string(256) mSessionName;
    [tag="pri", description="public or private"]
    string(7) mSessionPrivacy;  //MAX_NPSESSION_PRIVACY_LEN
    [tag="sta", description="session status"]
    Ps4NpSessionStatusString mSessionStatus;
    [tag="typ", description="owner-bind or owner-migration"]
    string(15) mSessionType;
    [tag="flst", description="The NP session's members."]
    list<ArsonNpSessionMember> mMembers;
};

// Retrieve the NP session and its data. Side: similar to X1's GetXblMultiplayerSessionRequest
class GetPs4NpSessionRequest
{
    [tag="esid", description="The user's identification to fetch for."]
    Blaze::UserIdentification mExternalIdent;

    [tag="eid", description="game id."]
    Blaze::GameManager::GameId mGameId;

    [tag="lang", description="The language code to retrieve multilingual results for."]
    string(5) mLanguage;

    [tag="gdat", default=true, description="Whether to fetch the session-data also (which includes the game id, game type, plus title custom data blob)."]
    bool mFetchExternalSessionSessionData;

    [tag="gcha", default=false, description="Whether to fetch the changeable-session-data also (which includes the game mode)."]
    bool mFetchExternalSessionChangeableSessionData;

    [tag="rate", default=true, description="Whether to fail on rate limit error. Check the response's rate limit info to verify whether there was a rate limiting."]
    bool mFailOnRateLimitError;
};
class GetPs4NpSessionResponse
{
    [tag="resp"]
    ArsonNpSession mNpSession;
    [tag="gdat", description="NP session's session-data. Includes the Blaze header and title custom data. Only populated if request specified mFetchExternalSessionSessionData."]
    Blaze::ExternalSessionCustomData mSessionData;
    [tag="gcha", description="NP session's changeable-session-data. Includes the Blaze header. Only populated if request specified mFetchExternalSessionChangeableSessionData."]
    Blaze::ExternalSessionCustomData mChangeableSessionData;
    [tag="rate", description="Rate limit info."]
    RateLimitInfo mRateLimitInfo;
};

// side: similar to X1's ArsonGetXblActivityForUserRequest
class GetPs4PrimaryNpSessionForUserRequest
{
    [tag="esid", description="The user's identification to fetch for. Used by ARSON command only if mUseCurrentUserForExternalSessionCall false."]
    Blaze::UserIdentification mExternalIdent;

    [tag="cur", default=false, description="Whether to override the mUserIdent with current user who makes rpc call."]
    bool mUseCurrentUserForExternalSessionCall;

    [tag="gprp", default=false, description="Whether to fetch the session's basic properties."]
    bool mFetchExternalSessionSessionProperties;

    [tag="gdat", default=false, description="Whether to fetch the session-data also (which includes the game id, game type, plus title custom data blob)."]
    bool mFetchExternalSessionSessionData;

    [tag="gcha", default=false, description="Whether to fetch the changeable-session-data also (which includes the game mode)."]
    bool mFetchExternalSessionChangeableSessionData;

    [tag="rate", default=true, description="Whether to fail on rate limit error. Check the response's rate limit info to verify whether there was a rate limiting."]
    bool mFailOnRateLimitError;
};

class GetPs4PrimaryNpSessionForUserResponse
{
    [tag="ssid", description="The NP Session Id."]
    NpSessionId mSessionId;
    [tag="resp", description="The NP session's basic properties. Only populated if request specified mFetchExternalSessionSessionProperties."]
    ArsonNpSession mNpSession;
    [tag="gdat", description="NP session's session-data. Includes the Blaze header and title custom data. Only populated if request specified mFetchExternalSessionSessionData."]
    Blaze::ExternalSessionCustomData mSessionData;
    [tag="gcha", description="NP session's changeable-session-data. Includes the Blaze header. Only populated if request specified mFetchExternalSessionChangeableSessionData."]
    Blaze::ExternalSessionCustomData mChangeableSessionData;
    [tag="rate", description="Rate limit info."]
    RateLimitInfo mRateLimitInfo;
};

class ClearPs4PrimaryNpSessionForUserRequest
{
    [tag="esid", description="The user's identification to fetch for. Used by ARSON command only if mUseCurrentUserForExternalSessionCall false."]
    Blaze::UserIdentification mExternalIdent;

    [tag="chek", default=true, description="Whether to check was already cleared up. If true, will log a warning if this isn't the case."]
    bool mExpectWasAlreadyCleared;

    [tag="rate", default=true, description="Whether to fail on rate limit error. Check the response's rate limit info to verify whether there was a rate limiting."]
    bool mFailOnRateLimitError;
};



/////////////////////////////////////////////////////////////////////////////////////////
//       PS5 PlayerSessions
/////////////////////////////////////////////////////////////////////////////////////////

[description="Arson version of Blaze Server's PSNServices::PlayerSessions::PlayerSessionMember"]
class ArsonPsnPlayerSessionMember
{
    [tag="psid", description="The PSN SCE Online Id."]
    ArsonPsnOnlineId mOnlineId;

    [tag="acid", description="The PSN SCE Account Id."]
    string(Blaze::MAX_EXTERNAL_ID_CHAR_LEN) mAccountId;

    [tag="plat", description="The platform"]
    string(-1) mPlatform;

    [tag="jtim", description="Date and time when the member joined the session (Unix Timestamp ms)."]
    string(-1) mJoinTimestamp;

    [tag="cst1", description="session custom data"]
    string(-1) mCustomData1;
};

[description="Arson version of the Blaze Server's GetPlayerSessionResponseItem."]
class ArsonPsnPlayerSession
{
    [tag="ssid", description="The PSN PlayerSession Id."]
    Blaze::PsnPlayerSessionId mSessionId;

    [tag="tim", description="time of session's creation in epoch milliseconds."]
    uint64_t mCreationTimestamp;
    [tag="ldr", description="session leader"]
    ArsonPsnPlayerSessionMember mLeader;
    [tag="lock", description="session lock"]
    bool mJoinDisabled;
    [tag="mau", description="max players"]
    int32_t mMaxPlayers;
    [tag="maxs", description="max spectators"]
    int32_t mMaxSpectators;
    [tag="nam", description="session name"]
    string(-1) mSessionName;
    [tag="joit", description="Specifies what non-invited users can join. NO_ONE: Nobody can join without an invitation, FRIENDS: Friends of the leader can join without invitations, FRIENDS_OF_FRIENDS: Friends of friends of the leader can join without invitations, ANYONE: Anybody can join."]
    string(-1) mJoinableUserType;
    [tag="invt", description="Specifies what members who can send invitations to the Player Session."]
    string(-1) mInvitableUserType;
    [tag="swap", description="Whether members can switch from players to spectators and vice versa themselves, via the system UX, without leaving."]
    bool mSwapSupported;

    [tag="flst", description="The PSN PlayerSession players."]
    list<ArsonPsnPlayerSessionMember> mPlayers;
    
    [tag="slst", description="The PSN PlayerSession spectators."]
    list<ArsonPsnPlayerSessionMember> mSpectators;

    [tag="ldrp", description="leader privileges."]
    list<string(-1)> mLeaderPrivileges;

    [tag="aplt", description="session available platforms."]
    list<string(-1)> mSupportedPlatforms;
    
    [tag="cst1", description="session custom data"]
    string(Blaze::MAX_PSN_EXTERNALSESSION_CUSTOMDATA_LEN) mCustomData1;

    [tag="cst2", description="session custom data"]
    string(Blaze::MAX_PSN_EXTERNALSESSION_CUSTOMDATA_LEN) mCustomData2;
};

[description="ARSON command's request to retrieve the PSN PlayerSession and its data."]
class GetPs5PlayerSessionRequest
{
    [tag="esid", description="The user's identification to fetch for."]
    Blaze::UserIdentification mExternalIdent;

    [tag="eid", description="game id."]
    Blaze::GameManager::GameId mGameId;

    [tag="lang", description="The language code to retrieve multilingual results for."]
    string(5) mLanguage;
};

class GetPs5PlayerSessionResponse
{
    [tag="resp"]
    ArsonPsnPlayerSession mPsnPlayerSession;

    [tag="cda1", description="For convenience, decoded Blaze data for arson tests to validate"]
    ExternalSessionBlazeSpecifiedCustomDataPs5 mDecodedCustomData1;
    [tag="cda2"]
    ExternalSessionCustomData mDecodedCustomData2;

    [tag="esid", description="External Session identification. (Grabbed for ARSON from Blaze, not from PSN)"]
    ExternalSessionIdentification mSessionIdentification;

    [tag="gmid", description="Blaze GameId (Grabbed for ARSON from Blaze, not from PSN)", default=Blaze::GameManager::INVALID_GAME_ID]
    Blaze::GameManager::GameId mGameId;
};

class GetPs5PrimaryPlayerSessionForUserRequest
{
    [tag="esid", description="The user's identification to fetch for. Used by ARSON command only if mUseCurrentUserForExternalSessionCall false."]
    Blaze::UserIdentification mExternalIdent;

    [tag="cur", default=false, description="Whether to override the mUserIdent with current user who makes rpc call."]
    bool mUseCurrentUserForExternalSessionCall;
};

class GetPs5PrimaryPlayerSessionForUserResponse
{
    [tag="ssid", description="The PSN PlayerSessionId."]
    Blaze::PsnPlayerSessionId mSessionId;

    [tag="resp", description="The PSN PlayerSession"]
    ArsonPsnPlayerSession mPsnPlayerSession;
    
    [tag="cda1", description="For convenience, decoded Blaze data for arson tests to validate"]
    ExternalSessionBlazeSpecifiedCustomDataPs5 mDecodedCustomData1;
    [tag="cda2"]
    ExternalSessionCustomData mDecodedCustomData2;
};

class ClearPs5PrimaryPlayerSessionForUserRequest
{
    [tag="esid", description="The user's identification to fetch for. Used by ARSON command only if mUseCurrentUserForExternalSessionCall false."]
    Blaze::UserIdentification mExternalIdent;

    [tag="chek", default=true, description="Whether to check was already cleared up. If true, will log a warning if this isn't the case."]
    bool mExpectWasAlreadyCleared;
};


/////////////////////////////////////////////////////////////////////////////////////////
//       PS5 PlayerSessions Invites
/////////////////////////////////////////////////////////////////////////////////////////

[description="Arson Send PlayerSession Invitations request.", trackChanges = true]
class SendPs5PlayerSessionInvitationsRequest
{
    [tag="gmid"] Blaze::GameManager::GameId mGameId;
    [tag="send"] Blaze::UserIdentification mSender;
    [tag="invs"] Blaze::UserIdentificationList mInvitees;
};

[description="Arson Send PlayerSession Invitations response invite id container.", trackChanges = true]
class SendPs5PlayerSessionInvitationsResponse
{
    [tag="ssid"] Blaze::PsnPlayerSessionId mPlayerSessionIdSentFor;
    [tag="invs"] list<string(-1)> mInvitationIds;
};

[description="request for retrieving PS5 first party invites"]
class GetPs5PlayerSessionInvitationsRequest
{
};

[description="Wraps the Blaze Server side's GetPlayerSessionInvitationsResponseItem, which isn't 'exposed' client side.", trackChanges = true]
class GetPs5PlayerSessionInvitationsResponseItem
{
    [tag="iid", description="PSN Invitation ID. (1-396231988968875)"]
    string(-1) mInvitationId;

    [tag="from", description="Sender information"]
    Blaze::ExternalPsnAccountId mFrom;

    [tag="ssid", description="The PlayerSessionId."]
    Blaze::PsnPlayerSessionId mSessionId;

    [tag="aplt", description="session supported platforms."]
    list<string(-1)> mSupportedPlatforms;

    [tag="time", description="Date and time of receiving (Unix Timestamp) ms"]
    string(-1) mReceivedTimestamp;

    [tag="invl", description="Flag for whether the invitation is valid or invalid. If the session to which the invitation belongs does not exist, or if the sender of the invitation has left the Player Session, the invitation will be invalid."]
    bool mInvitationInvalid;
};
class GetPs5PlayerSessionInvitationsResponse
{
    [tag="list"] list<GetPs5PlayerSessionInvitationsResponseItem> mInvites;
};


/////////////////////////////////////////////////////////////////////////////////////////
//       PS5 Matches
/////////////////////////////////////////////////////////////////////////////////////////

[description="Arson version of Blaze Server's PSNServices::Matches::MatchPlayer"]
class ArsonPsnMatchPlayer
{
    [tag="plid", description="Application-defined player ID alpha numeric match player id"]
    string(-1) mPlayerId;

    [tag="plnm", description="Application-defined name of player used when displaying match results on the platform. If nothing is specified, the default name will be displayed by the system software"]
    string(-1) mPlayerName;
    
    [tag="plty", description="PSN_PLAYER indicates a PlayStation Network player, NON_PSN_PLAYER a player other than a PlayStation Network player, and NPC a non-player character"]
    string(-1) mPlayerType;
    
    [tag="psid", description="The PSN SCE Online Id."]
    string(-1) mOnlineId;

    [tag="acid", description="The PSN SCE Account Id."]
    string(-1) mAccountId;

    [tag="join", description="Whether the player is currently participating in a match."]
    bool mJoinFlag;

    [tag="tmid", description="Application-defined team ID alpha numeric match team id"]
    string(-1) mTeamId;
};

[description="Arson version of Blaze Server's PSNServices::Matches::MatchTeamMember", trackChanges = true]
class ArsonPsnMatchTeamMember
{
    [tag="plid", description="Application-defined player ID alpha numeric match player id"]
    string(-1) mPlayerId;

    [tag="join", description="Whether the player belongs to the currently specified team."]
    bool mJoinFlag;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchTeam", trackChanges = true]
class ArsonPsnMatchTeam
{
    [tag="tmid", description="Application-defined team ID alpha numeric match team id"]
    string(-1) mTeamId;

    [tag="tmnm", description="Application-defined name of team used when displaying match results on the platform. If nothing is specified, the default name will be displayed by the system software"]
    string(-1) mTeamName;

    [tag="mbrs", description="List of players belonging to the team"]
    list<ArsonPsnMatchTeamMember> mMembers;
};

[description="Arson version of Blaze Server's PSNServices::Matches::MatchInGameRoster", trackChanges = true]
class ArsonPsnMatchInGameRoster
{
    [tag="plyr", description="List of players participating in the match"]
    list<ArsonPsnMatchPlayer> mPlayers;

    [tag="team", description="List of teams participating in the match"]
    list<ArsonPsnMatchTeam> mTeams;
};

/////////////////////////////////////////////////////////////////////////////////////////
//      Common PSN Match Result Structures
/////////////////////////////////////////////////////////////////////////////////////////

[description="Arson version of Blaze Server's PSNServices::Matches::MatchPlayerResult", trackChanges = true]
class ArsonPsnMatchPlayerResult
{
    [tag="plid", description="Application-defined player ID alpha numeric match player id"]
    string(-1) mPlayerId;
    
    [tag="rank", description="Value indicating the ranking of the player/team"]
    int32_t mRank;

    [tag="scor", description="Score of the player/team. Required if the match resultType is SCORE."]
    float mScore;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchTeamMemberResult", trackChanges = true]
class ArsonPsnMatchTeamMemberResult
{
    [tag="plid", description="Application-defined player ID alpha numeric match player id"]
    string(-1) mPlayerId;

    [tag="scor", description="Scores of each member who contributed to the team's overall score."]
    float mScore;
};

[description="Arson version of Blaze Server's PSNServices::Matches::MatchTeamResult", trackChanges = true]
class ArsonPsnMatchTeamResult
{
    [tag="tmid", description="Application-defined team ID alpha numeric match player id"]
    string(-1) mTeamId;

    [tag="rank", description="Value indicating the ranking of the player/team"]
    int32_t mRank;

    [tag="scor", description="Score of the player/team. Required if the match resultType is SCORE."]
    float mScore;

    [tag="memb", description="Results for each member of the team. Used to display the scores (degree of contribution to the team) of each member of the team."]
    list<ArsonPsnMatchTeamMemberResult> mTeamMemberResults;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchCompetitiveResult", trackChanges = true]
class ArsonPsnMatchCompetitiveResult
{
    [tag="plrs", description="Results for each player that competed. Only set when the match's groupingType is NON_TEAM_MATCH."]
    list<ArsonPsnMatchPlayerResult> mPlayerResults;

    [tag="tmrs", description="Results for each team that competed. Only set when the match's groupingType is TEAM_MATCH."]
    list<ArsonPsnMatchTeamResult> mTeamResults;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchResults", trackChanges = true]
class ArsonPsnMatchResults
{
    [tag="vers", default="1", description="Version of the results."]//Sony spec currently the only possible value is 1.
    string(-1) mVersion;

    [tag="coop", description="Results of cooperative play. Possible Values: SUCCESS, UNFINISHED, FAILED"]
    string(-1) mCooperativeResult;

    [tag="comp", description="Results of competitive play"]
    ArsonPsnMatchCompetitiveResult mCompetitiveResult;
};

/////////////////////////////////////////////////////////////////////////////////////////
//      Common PSN Match Statistics Structures
/////////////////////////////////////////////////////////////////////////////////////////

[description="Arson version of Blaze Server's PSNServices::Matches::MatchStat", trackChanges = true]
class ArsonPsnMatchStat
{
    [tag="stak", description="Additional stats key"]
    string (-1) mStatsKey;

    [tag="stav", description="Additional stats value"]
    string (-1) mStatsValue;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchPlayerStats", trackChanges = true]
class ArsonPsnMatchPlayerStats
{
    [tag="plid", description="Application-defined player ID alpha numeric match player id"]
    string(-1) mPlayerId;

    [tag="stat", description="Additional stats of a player. (See Sony docs for max items)"]
    list<ArsonPsnMatchStat> mStats;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchTeamStats", trackChanges = true]
class ArsonPsnMatchTeamStats
{
    [tag="tmid", description="Application-defined team ID alpha numeric match team id"]
    string(-1) mTeamId;

    [tag="stat", description="Additional stats of a team. (See Sony docs for max items)"]
    list<ArsonPsnMatchStat> mStats;

    [tag="memb", description="Stats of each member of the team. (See Sony docs for max items)"]
    list<ArsonPsnMatchPlayerStats> mTeamMemberStatistics;
};
[description="Arson version of Blaze Server's PSNServices::Matches::MatchTeamStats", trackChanges = true]
class ArsonPsnMatchStatistics
{
    [tag="plyr", description="Additional stats per player. (See Sony docs for max items)"]
    list<ArsonPsnMatchPlayerStats> mPlayerStatistics;

    [tag="team", description="Additional stats per team. (See Sony docs for max items)"]
    list<ArsonPsnMatchTeamStats> mTeamStatistics;
};


[description="ARSON command's request to retrieve the PSN Match and its data), via the Blaze Game", trackChanges = true]
class GetPs5MatchRequest
{
    [tag="eid", description="The user's identification to fetch for."]
    Blaze::UserIdentification mExternalIdent;

    [tag="esid", description="External Session identification. If mGameId is INVALID_GAME_ID, use this to fetch session directly from 1st party."]
    ExternalSessionIdentification mSessionIdentification;

    [tag="gmid", description="Blaze GameId used to fetch game info for session identification to fetch by", default=Blaze::GameManager::INVALID_GAME_ID]
    Blaze::GameManager::GameId mGameId;
};

[description="ARSON command's request to retrieve the PSN Match and its data). Analogous to Blaze Server's PSNServices::Matches::GetMatchDetailResponse", trackChanges = true]
class ArsonPsnMatch
{
    [tag="stau", description="If SCHEDULED: will later begin at the specified time (see Sony docs). WAITING: waiting for players to participate. PLAYING: underway. ONHOLD: temporarily paused. CANCELLED: terminated without it reporting results. COMPLETED: concluded with results reported. A match created as SCHEDULED may automatically change to the WAITING once the time arrives (see Sony docs)."]
    string(-1) mStatus;

    [tag="rost", description="Information about the players and teams participating in a match."]
    ArsonPsnMatchInGameRoster mInGameRoster;

    [tag="grty", description="Whether the match is a team match. If the value of isTeamActivity is true in the activity, the groupingType is TEAM_MATCH. Otherwise, it will be NON_TEAM_MATCH."]
    string(-1) mGroupingType;

    // Fields included for potential Match Results handling below

    [tag="cmty", description="Whether a match is a competitive match. If the value of category is Competitive in the activity, the competitionType is COMPETITIVE. Otherwise, it will be COOPERATIVE."]
    string(-1) mCompetitionType;

    [tag="rsty", description="Whether there are scores in the match results. If a value for scoreStatistics exists in the activity, the resultType is SCORE. Otherwise, it will be RESULT."]
    string(-1) mResultType;

    [tag="rslt", description="Match results."]
    ArsonPsnMatchResults mMatchResults;

    [tag="stat", description="Additional stats of a match. Only playerStatistics is specified if the match's competitionType is COOPERATIVE, or COMPETITIVE and groupingType is NON_TEAM_MATCH. Only teamStatistics is specified if the match's competitionType is COMPETITIVE and groupingType is TEAM_MATCH."]
    ArsonPsnMatchStatistics mMatchStatistics;

    [tag="acid", description="objectId of an activity relating to a match. These values are determined by the activity's definition: groupingType, competitionType, resultType"]
    PsnUdsObjectId mActivityId; //included for logging and debugging

    [tag="exti", description="Grace period until a match is canceled in seconds, starting when the status of the match becomes either WAITING or ONHOLD, if neither the status nor expirationTime are updated by the period specified for expirationTime, the match may be canceled (see Sony docs, including min, max and default values)."]
    int32_t mExpirationTime;

    [tag="stti", description="Date and time the match was started (the date and time status first became PLAYING)."]
    string(-1) mMatchStartTimestamp; //included for logging and debugging

    [tag="enti", description="Date and time the match concluded (the date and time status became either CANCELLED or COMPLETED)."]
    string(-1) mMatchEndTimestamp;
};

class GetPs5MatchResponse
{
    [tag="resp"]
    ArsonPsnMatch mPsnMatch;

    [tag="esid", description="External Session identification. (Grabbed for ARSON from Blaze, not from PSN)"]
    ExternalSessionIdentification mSessionIdentification;

    [tag="gmid", description="Blaze GameId (Grabbed for ARSON from Blaze, not from PSN)", default=Blaze::GameManager::INVALID_GAME_ID]
    Blaze::GameManager::GameId mGameId;
};


class GetPs5MatchesForUserRequest
{
    [tag="esid", description="The user's identification to fetch for. Used by ARSON command only if mUseCurrentUserForExternalSessionCall false."]
    Blaze::UserIdentification mExternalIdent;

    [tag="cur", default=false, description="Whether to override the mUserIdent with current user who makes rpc call."]
    bool mUseCurrentUserForExternalSessionCall;
};
typedef list<GetPs5MatchResponse> GetPs5MatchResponseList;
class GetPs5MatchesForUserResponse
{
    [tag="mats", description="The PSN Matches."]
    GetPs5MatchResponseList mMatches;
    
    [tag="jond", description="The PSN Matches for which the member explicitly had its joinFlag true."]
    list<Blaze::PsnMatchId> mMatchesWithJoinFlagTrue;
    
    [tag="jfls", description="The PSN Matches for which the member explicitly had its joinFlag false."]
    list<Blaze::PsnMatchId> mMatchesWithJoinFlagFalse;
};

class ClearPs5MatchesForUserRequest
{
    [tag="esid", description="The user's identification to fetch for. Used by ARSON command only if mUseCurrentUserForExternalSessionCall false."]
    Blaze::UserIdentification mExternalIdent;

    [tag="chek", default=true, description="Whether to check was already cleared up. If true, will log a warning if this isn't the case."]
    bool mExpectWasAlreadyCleared;
};



class LeaveAllExternalSessionsForUserRequest
{
    [tag="esid", description="The user's identification to leave all external sessions for."]
    Blaze::UserIdentification mUserIdent;
};

class GetSliverInstanceIdRequest
{
    [tag="usid", description="The usersessionid used to get sliverInstanceId"]
    UserSessionId mUserSessionId;
    [tag="snsp", description="Sliver namespace gamemananger or usersession"]
    uint16_t mSliverNamespace;
};

class GetSliverInstanceIdResponse
{
    [tag="inid", description="The instance id which owns the sliver"]
    uint16_t mInstanceId;
};

class GetOwnedSliverCountRequest
{
    [tag="snsp", description="Sliver namespace gamemananger or usersession"]
    uint16_t mSliverNamespace;
    [tag="inid", description="The instance id which owns the slivers"]
    uint16_t mInstanceId;
};

class GetOwnedSliverCountResponse
{
    [tag="cout", description="Sliver namespace gamemananger or usersession"]
    uint32_t mCount;
};

class Query64BitIntRequest
{
    [tag="mast", default=false, description="Whether to execute the db operations on arson master, rather than at the arson slave instance. If true calls query64BitIntMaster"]
    bool mExecuteOnArsonMaster;
};

//SecretVault

[description="List of Secret Vault error messages."]
typedef list<string(-1)> SecretVaultErrorMessages;

[description="List of Secret Vault warning messages."]
typedef list<string(-1)> SecretVaultWarningMessages;

[description="Secret Vault data map."]
typedef map<string(-1), string(-1), ignorecase> SecretVaultDataMap;

[description="Secret Vault data map from the renew token call."]
typedef map<string(-1), string(-1), ignorecase> AuthTokenMetadataMap;

[description="The Secret Vault namespace."]
typedef string(256) SecretVaultNamespace;

[description="The Secret Vault token id."]
typedef string(64) SecretVaultTokenId;

[description="The Secret Vault token accessor id. Used to reference the token id without exposing it."]
typedef string(64) SecretVaultTokenAccessorId;

[description="The Secret Vault lease id."]
typedef string(64) SecretVaultLeaseId;

class SecretVaultErrorResponse
{
    [tag="errs", description="The associated error messages."]
    SecretVaultErrorMessages mErrors;
};

typedef string(256) SecretVaultPolicy;

[description="Connection profiles data."]
typedef list<SecretVaultPolicy> SecretVaultPolicyList;

class RenewTokenAuth
{
    [tag="mtok", nameoverride="client_token", description="The client token used to authenticate.", printFormat="censor"]
    SecretVaultTokenId mClientToken;

    [tag="pol", description="The token's policies."]
    SecretVaultPolicyList mPolicies;

    [tag="mdta", description="The token metadata."]
    AuthTokenMetadataMap mMetadata;

    [tag="ldur", nameoverride="lease_duration", description="The duration of the lease."]
    uint32_t mLeaseDuration;

    [tag="rnew", description="If the token is renewable."]
    bool mRenewable;
};

class SecretVaultWrapInfo
{
    [tag="ctim", nameoverride="creation_time", description="The id of the original request for which we received the response."]
    string(64) mCreationTime;

    [tag="mtok", description="The id of the original request for which we received the response."]
    SecretVaultTokenId mToken;

    [tag="ttl", description="The status code of the error."]
    uint32_t mTTL;

    [tag="mwra", nameoverride="wrapped_accessor", description="The id of the original request for which we received the response."]
    SecretVaultTokenAccessorId mWrappedAccessor;
};

class SecretVaultSecret
{
//    [tag="auth", description="The auth token.  (The varies depending on the Auth source, and cannot be reliably decoded.)"]
//    SecretVaultAuth mAuth;

    [tag="data", description="The map of secret values.", printFormat="censor"]
    SecretVaultDataMap mData;

    [tag="ldur", nameoverride="lease_duration", description="The length of the lease duration."]
    uint32_t mLeaseDuration;

    [tag="lid", nameoverride="lease_id", description="The lease id."]
    SecretVaultLeaseId mLeaseId;

    [tag="rnew", description="Returns if the secret is renewable."]
    bool mRenewable;
};


[description="Secret Vault version metadata."]
class SecretVaultKv2Metadata   
{
    [tag="crtm", nameoverride="created_time", description="Time of creation of the data. (UTC)"]
    TimeValue mCreatedTime;

    [tag="dltm", nameoverride="deletion_time", description="Time of deletion of the data. Empty if not destroyed yet. (UTC)"]
    TimeValue mDeletionTime;

    [tag="dest", description="Was the data destroyed?"]
    bool mDestroyed;

    [tag="vers", description="Version of the data"]
    int32_t mVersion;
};

class SecretVaultKv2Data
{
    [tag="data", description="The secrets.", printFormat="censor"]
    SecretVaultDataMap mData;

    [tag="meta", description="The kv2 metadata."]
    SecretVaultKv2Metadata mMetadata;
};

class SecretVaultKv2Secret
{
    [tag="rid", nameoverride="request_id", description="The request id."]
    SecretVaultTokenId mRequestId;

    [tag="lid", nameoverride="lease_id", description="The lease id."]
    SecretVaultLeaseId mLeaseId;

    [tag="rnew", description="Returns if the secret is renewable."]
    bool mRenewable;

    [tag="ldur", nameoverride="lease_duration", description="The length of the lease duration."]
    uint32_t mLeaseDuration;

    [tag="data", description="The data."]
    SecretVaultKv2Data mData;

    [tag="wrap", nameoverride="wrap_info", description="The wrapped results."]
    SecretVaultWrapInfo mWrapInfo;

    [tag="warn", description="Warning messages returned from the operation."]
    SecretVaultWarningMessages mWarnings;

//    [tag="auth", description="The auth token.  (The varies depending on the Auth source, and cannot be reliably decoded.)"]
//    SecretVaultAuth mAuth;
};

class SecretVaultReadRequest
{
    [tag="nmsp", description="The vault namespace."]
    SecretVaultNamespace mVaultNamespace;

    [tag="path", description="The path to query from the vault for secrets."]
    string(-1) mPath;

    [tag="tokn", description="The token for the vault session.", printFormat="censor"]
    SecretVaultTokenId mVaultToken;
};

class SecretVaultRenewTokenRequestBody
{
    [tag="incr", nameoverride="increment", description="An optional requested lease increment can be provided. This increment may be ignored."]
    string(-1) mIncrement;
};

class SecretVaultRenewTokenRequest
{
    [tag="nmsp", description="The vault namespace."]
    SecretVaultNamespace mVaultNamespace;

    [tag="tokn", description="The token for the vault session.", printFormat="censor"]
    SecretVaultTokenId mVaultToken;
    
    [tag="body", description="The data to be sent in the body of the request."]
    SecretVaultRenewTokenRequestBody mRequestBody;
};

class RenewTokenResponse
{
    [tag="auth", description="The auth token."]
    RenewTokenAuth mAuth;
};

class SecretVaultRenewLeaseRequestBody
{
    [tag="incr", nameoverride="increment", description="(Optional) Specifies the requested amount of time (in seconds) to extend the lease."]
    uint32_t mIncrement;
    
    [tag="lsid", nameoverride="lease_id", description="Specifies the ID of the lease to extend. This can be specified as part of the URL or as part of the request body."]
    SecretVaultLeaseId mLeaseId;
};

class SecretVaultRenewLeaseRequest
{
    [tag="nmsp", description="The vault namespace."]
    SecretVaultNamespace mVaultNamespace;

    [tag="tokn", description="The token for the vault session.", printFormat="censor"]
    SecretVaultTokenId mVaultToken;

    [tag="body", description="The data to be sent in the body of the request."]
    SecretVaultRenewLeaseRequestBody mRequestBody;
};

class RenewLeaseResponse
{
    [tag="lid", nameoverride="lease_id", description="The lease id."]
    SecretVaultLeaseId mLeaseId;

    [tag="rnew", description="Returns if the secret is renewable."]
    bool mRenewable; 

    [tag="ldur", nameoverride="lease_duration", description="The length of the lease duration."]
    uint32_t mLeaseDuration;
};

class SecretVaultApproleLoginRequestBody
{
    [tag="role", nameoverride="role_id", description="The role id (aka application's user name) to authenticate."]
    string(-1) mRoleId;
 
    [tag="secr", nameoverride="secret_id", description="The secret id (aka password) to authenticate.", printFormat="censor"]
    string(-1) mSecretId;
};

class SecretVaultApproleLoginRequest
{
    [tag="nmsp", description="The vault namespace."]
    SecretVaultNamespace mVaultNamespace;
    
    [tag="path", description="The path to authenticate."]
    string(-1) mPath;

    [tag="body", description="The data to be sent in the body of the request."]
    SecretVaultApproleLoginRequestBody mRequestBody;
};

class ApproleLoginAuth
{
    [tag="rnew", description="If the token is renewable."]
    bool mRenewable; 
    
    [tag="ldur", nameoverride="lease_duration", description="The duration of the lease."]
    uint32_t mLeaseDuration;

    [tag="tpol", nameoverride="token_policies", description="The token's policies."]
    SecretVaultPolicyList mTokenPolicies;

    [tag="mdta", description="The token metadata."]
    AuthTokenMetadataMap mMetadata;

    [tag="acc", description="The accessor for the client token."]
    SecretVaultTokenAccessorId mAccessor;

    [tag="mtok", nameoverride="client_token", description="The client token used to authenticate.", printFormat="censor"]
    SecretVaultTokenId mClientToken;
};

class ApproleLoginResponse
{
    [tag="auth", description="The auth token."]
    ApproleLoginAuth mAuth;

    [tag="warn", description="Warning messages returned from the operation."]
    SecretVaultWarningMessages mWarnings;

    [tag="wrap", nameoverride="wrap_info", description="The wrapped results."]
    SecretVaultWrapInfo mWrapInfo;

    [tag="data", description="The map of secret values.", printFormat="censor"]
    SecretVaultDataMap mData;

    [tag="rid", nameoverride="request_id", description="The request id. May be missing"]
    SecretVaultTokenId mRequestId;

    [tag="lid", nameoverride="lease_id", description="The lease id."]
    SecretVaultLeaseId mLeaseId;

    [tag="rnew", description="Returns if the secret is renewable."]
    bool mRenewable; 

    [tag="ldur", nameoverride="lease_duration", description="The length of the lease duration."]
    uint32_t mLeaseDuration;
};

class ExternalDataSourceMergeListsRequest
{
    [tag="nlst", description="The list of external data sources to test"]
    Blaze::GameManager::ExternalDataSourceApiNameList mExternalDataSourceApiNameList;

    union TemplateAttributeValue
    {
      [tag="bool"] list<bool> mBoolList;
      [tag="int"] list<int64_t> mIntList;
      [tag="str"] list<string(64)> mStringList;
    };
    typedef map<Blaze::GameManager::TemplateAttributeName, TemplateAttributeValue> TemplateAttributeValueByNameMap;

    [tag="eres", description="The expected TemplateAttribute values after parsing the external data source responses."]
    TemplateAttributeValueByNameMap mExpectedResults;
};


class TestDbEntry
{
    [tag="id"] uint64_t id;
    [tag="d1"] string(-1) data1;
    [tag="d2"] string(-1) data2;
    [tag="d3"] string(-1) data3;
};

class GetDbEntryRequest
{
    [tag="id"] uint64_t id;
};

class PokePermissionTestResponse
{
    [tag="msg"] 
    string(256) mMessage;
};

} // Arson
} // Blaze
