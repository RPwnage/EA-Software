// Note: External endpoints use 'BIND_ALL' rather than 'BIND_EXTERNAL' as we're okay hitting "external" from anywhere but need to restrict who can hit internal.

endpoints = {
    // defines groups of endpoint types
    // which are referenced from server
    // instances defined in serverConfigs
    endpointGroups = {
        masterEndpoints = {
            endpoints = [
                "internalFire2",
                "internalHttp",
                "internalHttps",
                "internalEvent",
                "internalEventSecure",
                "internalRest",
                "internalRestSecure"
            ],
            grpcEndpoints = [
                "internalGrpcSecure"
            ]
        },
        slaveEndpoints = {
            endpoints = [
                "externalFire2",
                "externalFire2Secure",
                "externalHttp",
                "externalHttps",
                "internalFire2",
                "internalHttp",
                "internalHttps",
                "internalEvent",
                "internalEventSecure",
                "internalRest",
                "internalRestSecure"
            ],
            grpcEndpoints = [
#if (ENV == "dev" || ENV == "test")
                "externalGrpc",
#endif
                "externalGrpcSecure",
                "internalGrpcSecure"
            ]
        },
        auxMasterEndpoints = {
            endpoints = [
                "internalFire2",
                "internalAuxHttp",
                "internalAuxHttps",
                "internalEvent",
                "internalEventSecure",
                "internalRest",
                "internalRestSecure"
            ],
            grpcEndpoints = [
                "internalGrpcSecure"
            ]
        },
        auxSlaveEndpoints = {
            endpoints = [
                "internalFire2",
                "internalAuxHttp",
                "internalAuxHttps",
                "internalEvent",
                "internalEventSecure",
                "internalRest",
                "internalRestSecure"
            ],
            grpcEndpoints = [
                "internalGrpcSecure"
            ]
        }
    }

    rpcControlLists = {
        "whitelistAll" = ["*"],
//      "blacklistGetStatusExample" = [
//            "blazecontroller/getStatus"
//      ]
//      "blacklistGetStatusAndGrantEntitlementsExample" = [
//            "blazecontroller/getStatus",
//            "authentication/grantEntitlement",
//            "authentication/grantEntitlement2"
//      ]
        "blacklistGrantEntitlements" = [
              "authentication/grantEntitlement",
              "authentication/grantEntitlement2"
        ]    
    }

// Platform-specific control lists can be used to whitelist/blacklist different RPCs depending on the caller's platform (as determined by the service name the caller is connected to).
// Each entry in the platformSpecificRpcControlLists config associates control lists from rpcControlLists with a list of platforms.
// Platforms cannot be duplicated within the same entry (in the example below, "pc" cannot be added to the platform list for "blacklistGetStatusExample").
//
// Using the example below, endpoints configured with rpcBlackList = "platformSpecificBlacklistExample" will prevent callers on the 'pc', 'common', or 'xone' platform from executing the
// getStatus RPC, and will also prevent callers on the 'pc' platform from executing the grantEntitlement or grantEntitlement2 RPCs.

//    platformSpecificRpcControlLists = {
//        "platformSpecificBlacklistExample" = {
//            "blacklistGetStatusAndGrantEntitlementsExample" = [ "pc" ]
//            "blacklistGetStatusExample" = [ "xone", "common" ]
//        }
//    }

    // defines endpoint types that are
    // aggregated by endpoint groups
    endpointTypes = {
        internalFire2 = {
            channel = "tcp",
            protocol = "fire2",
            encoder = "heat2",
            decoder = "heat2",
            maxConnections = 2000
            commandTimeout = "#COMMAND_TIMEOUT#"
            maxFrameSize = 5000000
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS#, #DEDICATED_SERVER_NETWORKS# ]
            queuedOutputData = {
                max = 250000000
                highWatermark = 10000000 // 10MB
                lowWatermark = 1000000 // 1MB
                gracePeriod = "0s" // disable grace period check
            }
            bind = "BIND_INTERNAL"
            serializeRequests = false
            connectionType = "CONNECTION_TYPE_SERVER"
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
            rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        internalHttp = {
            channel = "tcp",
            protocol = "httpxml",
            encoder = "xml2",
            decoder = "http",
            maxConnections = 1000
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
	    rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        internalHttps = {
            channel = "ssl",
            sslContext = "internal_default",
            protocol = "httpxml",
            encoder = "xml2",
            decoder = "http",
            maxConnections = 1000
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
        },
        internalRest = {
            channel = "tcp",
            protocol = "rest",
            encoder = "json",
            decoder = "rest",
            maxConnections = 100
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
	    rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        internalRestSecure = {
            channel = "ssl",
            sslContext = "internal_default",
            protocol = "rest",
            encoder = "json",
            decoder = "rest",
            maxConnections = 100
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
        },
        internalAuxHttp = {
            channel = "tcp",
            protocol = "httpxml",
            encoder = "xml2",
            decoder = "http",
            maxConnections = 100
            maxFrameSize = 5000000
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "60s"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            queuedOutputData = {
                // The aux master has a non-default http endpoint queue size
                // because the gameManagerMaster get server status RPC returns a
                // list of all dedicated servers (instead of batching the requests),
                // so we need to enlarge the http rpc buffer to hold this large
                // rpc when there are prod levels of dedicated servers.
                max = 2000000
                highWatermark = 1800000
                lowWatermark = 1500000
            }
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
	    rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        internalAuxHttps = {
            channel = "ssl",
            sslContext = "internal_default",
            protocol = "httpxml",
            encoder = "xml2",
            decoder = "http",
            maxConnections = 100
            maxFrameSize = 5000000
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            queuedOutputData = {
                // The aux master has a non-default http endpoint queue size
                // because the gameManagerMaster get server status RPC returns a
                // list of all dedicated servers (instead of batching the requests),
                // so we need to enlarge the http rpc buffer to hold this large
                // rpc when there are prod levels of dedicated servers.
                max = 2000000
                highWatermark = 1800000
                lowWatermark = 1500000
            }
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
        },
        internalEvent = {
            channel = "tcp",
            protocol = "eventxml",
            encoder = "eventxml",
            decoder = "http",
            maxConnections = 100
            inactivityTimeout = "0s"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            queuedOutputData = {
                max = 20000000
                highWatermark = 18000000
                lowWatermark = 15000000
            }
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
			tcpKeepAlive = true
#if PLATFORM == "pc"
	    rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        internalEventSecure = {
            channel = "ssl",
            sslContext = "internal_default",
            protocol = "eventxml",
            encoder = "eventxml",
            decoder = "http",
            maxConnections = 100
            inactivityTimeout = "0s"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // Note: an 'allowedIpList' on an internal endpoint has no net effect unless it is more restrictive than IPV4_INTERNAL_ADDRESSES
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            queuedOutputData = {
                max = 20000000
                highWatermark = 18000000
                lowWatermark = 15000000
            }
            bind = "BIND_INTERNAL"
            rpcWhiteList = "whitelistAll"
            tcpKeepAlive = true
        },
        externalFire = {
            channel = "tcp",
            protocol = "fire",
            encoder = "heat2",
            decoder = "heat2",
            maxConnections = "#EXTERNAL_FIRE_MAX_CONNS#"
            maxFrameSize = 2000000
            enableInactivityTimeoutBypass = false
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // In any environment, we do NOT want to allow external access over a non-secure endpoint.
            // Add the 'trust' setting to restrict access to this non-secure endpoint
            trust = [ #TRUSTED_NETWORKS#, #DEDICATED_SERVER_NETWORKS# ]
            hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
            rateLimiter = "#EXTERNAL_FIRE_RATE_LIMITER#"
            allowResumeConnection = false
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
			rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        externalFire2 = {
            channel = "tcp",
            protocol = "fire2",
            encoder = "heat2",
            decoder = "heat2",
            maxConnections = "#EXTERNAL_FIRE_MAX_CONNS#"
            maxFrameSize = 2000000
            enableInactivityTimeoutBypass = false
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
			assumeResponsivePeriod = "15s"
            // In any environment, we do NOT want to allow external access over a non-secure endpoint.
            // Add the 'allowedIpList' setting to restrict access to this non-secure endpoint
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS#, #DEDICATED_SERVER_NETWORKS# ]
            hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
            rateLimiter = "#EXTERNAL_FIRE_RATE_LIMITER#"
            allowResumeConnection = false
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
			rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        externalFire2Secure = {
            channel = "ssl",
            protocol = "fire2",
            encoder = "heat2",
            decoder = "heat2",
            maxConnections = "#EXTERNAL_FIRE_MAX_CONNS#"
            maxFrameSize = 2000000
            enableInactivityTimeoutBypass = false
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
            rateLimiter = "#EXTERNAL_FIRE_RATE_LIMITER#"
            allowResumeConnection = false
            sslContext = "tls_v1_2"
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
			rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        externalHttp = {
            channel = "tcp",
            protocol = "httpxml",
            encoder = "xml2",
            decoder = "http",
            maxConnections = 1000
            enableInactivityTimeoutBypass = false
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            queuedOutputData = {
                max = 20000000
                highWatermark = 18000000
                lowWatermark = 15000000
            }
		hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
	    rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
			rpcBlackList = "blacklistGrantEntitlements"
#endif
        },
        // WAL PROXY communicated to blaze via externalHttps and endpoints are whitelisted using TRUSTED_NETWORKS.
        externalHttps = {
            channel = "ssl",
            protocol = "httpxml",
            encoder = "xml2",
            decoder = "http",
            maxConnections = 1000
            enableInactivityTimeoutBypass = false
            inactivityTimeout = "#INACTIVITY_TIMEOUT#"
            commandTimeout = "#COMMAND_TIMEOUT#"
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ]
            hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
            rpcWhiteList = "whitelistAll"
#if PLATFORM == "pc"
			rpcBlackList = "blacklistGrantEntitlements"
#endif
        }
    }

    grpcEndpointTypes = {
        externalGrpc = {
            channel = "tcp",
            commandTimeout = "#COMMAND_TIMEOUT#",
            rateLimiter = "#EXTERNAL_GRPC_RATE_LIMITER#",
            maxFrameSize = 2000000,
            maxConnections = "#EXTERNAL_GRPC_MAX_CONNS#",
            // In any environment, we do NOT want to allow external access over a non-secure endpoint.
            // Add the 'allowedIpList' setting to restrict access to this non-secure endpoint
            // TODO: Rename from `trust` to `allowedIpList`
            trust = [ #TRUSTED_NETWORKS# ],
            trustedClientIpList = [ #IPV4_INTERNAL_ADDRESSES# ]
            hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
            rpcWhiteList = "whitelistAll"
        },
        externalGrpcSecure = {
            channel = "ssl",
            commandTimeout = "#COMMAND_TIMEOUT#",
            rateLimiter = "#EXTERNAL_GRPC_RATE_LIMITER#",
            maxFrameSize = 2000000,
            maxConnections = "#EXTERNAL_GRPC_MAX_CONNS#",
            sslContext = "grpc",
            hasInternalNicAccess = [ #IPV4_INTERNAL_ADDRESSES# ]
            rpcWhiteList = "whitelistAll"
        },
        internalGrpcSecure = {
            channel = "ssl"
            bind = "BIND_INTERNAL",
            commandTimeout = "#COMMAND_TIMEOUT#",
            maxFrameSize = 5000000,
            maxConnections = 1000,
            sslContext = "internal_grpc",
            trustedClientIpList = [ #IPV4_INTERNAL_ADDRESSES# ]
            rpcWhiteList = "whitelistAll",
            envoyResourceName = "internalGrpcSecureEnvoy"
            // SHA 256 digest of each ENVOY_CLIENT_CERT_PUBLIC_KEY
            envoyXfccTrustedHashes = [ #EGRESS_ENVOY_CLIENT_CERT_XFCC_HASHES# ]
        }
    }
}
