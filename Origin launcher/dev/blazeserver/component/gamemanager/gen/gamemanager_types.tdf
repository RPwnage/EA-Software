/*! ************************************************************************************************/
/*!
    \file gamemanager_types.tdf
    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*! ************************************************************************************************/

[headername="framework/tdf/entrycriteria.h"]  // For RoleEntryCriteriaMap
#include "framework/gen/entrycriteria.tdf"

[headername="framework/tdf/attributes.h"]    // Attributes (Player/Game)
#include "framework/gen/attributes.tdf"

[headername="framework/tdf/userdefines.h"]      // Stuff like ExternalId, etc. 
#include "framework/gen/userdefines.tdf"

[headername="framework/tdf/externalsessiontypes.h"]  // TournamentId/Organizer
#include "framework/gen/externalsessiontypes.tdf"

[headername="framework/tdf/network.h"]   // Presence Mode
#include "framework/gen/network.tdf"

[headername="framework/tdf/networkaddress.h"]
#include "framework/gen/networkaddress.tdf"

namespace Blaze
{
namespace GameManager
{

////////////////////////////////////////////////////////////////////////////////
// Scenario/Packer Related Types ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef uint64_t MatchmakingScenarioId;
const MatchmakingScenarioId INVALID_SCENARIO_ID = 0;

typedef uint32_t ScenarioHash;
typedef uint32_t SubSessionHash;
typedef string(32) ScenarioName;
typedef string(32) SubSessionName;
typedef string(32) ScenarioVariantName;
typedef string(32) RecoTrackingTag;
typedef uint32_t ScenarioVersion;
typedef string(-1) DelineationGroupType;

typedef string(256) TemplateName;
typedef string(-1) TemplateAttributeName;               // Name of the attribute, as sent by client  (ex. GAME_MODE)
typedef map<TemplateAttributeName, generic> TemplateAttributes;
typedef TemplateAttributes ScenarioAttributes;

typedef list<PingSiteAlias> PingSiteAliasList;

typedef map<string(-1), float> GameFactorScoresMap;

[tdfid = "hash", trackChanges = true]
class ScenarioInfo
{
    [tag="scen", description="Scenario Name"]
    ScenarioName mScenarioName;
    [tag="subn", description="SubSession Name"]
    SubSessionName mSubSessionName;
    [tag="scev", description="Scenario Variant's Version"]
    ScenarioVersion mScenarioVersion;
    [tag="scva", description="Scenario's Variant"]
    ScenarioVariantName mScenarioVariant;
    [tag="attr", description="Scenario's Attributes"]
    ScenarioAttributes mScenarioAttributes;
    [tag="osid", default=INVALID_SCENARIO_ID, description="Indicates what Scenario was used to generate this request."]
    MatchmakingScenarioId mOriginatingScenarioId;
};

typedef list<SubSessionName> SubSessionNameList;
typedef string(255) ScenarioVariantCriteria;
typedef list<ScenarioVariantName> ScenarioVariantNameList;

class ScenarioVariantConfig 
{
    [tag="subs", reconfigurable="yes", description="The list of subsessions held by variant."]
    SubSessionNameList mSubSession;

    [tag="crit", reconfigurable="yes", description="The criteria used to select which variant to use.  See confluence for details on what are variables supported. (Ex. ppm > 150 &&  "]
    ScenarioVariantCriteria mCriteria;

    [tag="svof", reconfigurable="yes", description="The list of variants that are a parent to this variant.  If this list is set, then the variant will only be tested for if it's parent variant matches (and it will replace said parent if it matches)."]
    ScenarioVariantNameList mSubVariantOf;
};

typedef map<ScenarioVariantName, ScenarioVariantConfig> VariantsMap;
typedef map<BlazeId, ScenarioVariantName> UserVariantsMap;


////////////////////////////////////////////////////////////////////////////////
// Game/Player Related Enums //////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description="Enumeration of state of the game, 8th bit holds information about allowing user to join or not "]
enum GameState
{
    [description="Data structure just created"]
    NEW_STATE =    0x00,
    [description="Closed to joins/matchmaking"]
    INITIALIZING = 0x01,
    [description="Game will need topology host assigned when player joins."]
    INACTIVE_VIRTUAL = 0x02,
    [description="Game created via matchmaking is waiting for connections to be established and validated."]
    CONNECTION_VERIFICATION = 0x03,
    [description="Pre game state, obey joinMode flags"]
    PRE_GAME =     0x82,
    [description="Game available, obey joinMode flags"]
    IN_GAME =      0x83,
    [description="After game is done,closed to joins/matchmaking"]
    POST_GAME =    0x04,
    [description="Game migration state, closed to joins/matchmaking"]
    MIGRATING =    0x05,
    [description="Game destruction state, closed to joins/matchmaking"]
    DESTRUCTING =  0x06,
    [description="Game resetable state, closed to joins/matchmaking, but available to be reset"]
    RESETABLE =    0x07,
    [description="Unresponsive, closed to joins/matchmaking"]
    UNRESPONSIVE =    0x09,
    [description="Initialized state, intended for the use of game group"]
    GAME_GROUP_INITIALIZED =    0x10
};

[description="A collection of game settings flags: hostMigrationEnabled, rankedGame, gameEntryMethods (open to joins by: browser, matchmaking, invites, stalking), invite senders (admin only or open)"]
bitfield GameSettings
{
    [description="opens the game for browsing if this bit is set"]
    openToBrowsing : 1;
    [description="opens the game for matchmaking if this bit is set"]
    openToMatchmaking : 1;
    [description="opens the game for invite if this bit is set"]
    openToInvites : 1;
    [description="opens the game to join by player if this bit is set"]
    openToJoinByPlayer : 1;
    [description="If this bit is set then a game's host can be migrated."]
    hostMigratable : 1;
    [description="Bit to turn on/off the game as ranked"]
    ranked : 1;
    [description="If set, only game admins can invite players into the game.  (Requires openToInvites to be enabled.)"]
    adminOnlyInvites : 1;
    [description="If set, this game will only allow 2 game groups into the game (players in other game groups will be rejected from the game)."]
    enforceSingleGroupJoin : 1;
    [description="If set, this game supports join in progress."]
    joinInProgressSupported : 1;
    [description="If set, only a player invited into a game by a game admin bypasses the game entry criteria and ban list checks. This adds further restrictions to ignoreEntryCriteriaWithInvite."]
    adminInvitesOnlyIgnoreEntryChecks : 1;
    [description="If set, users joining by JoinMethod JOIN_BY_INVITES will bypass the game's entry criteria and ban list."]
    ignoreEntryCriteriaWithInvite : 1;
    [description="If set, create/reset game will examines/grants the persisted game Id/secret. If cleared on a game session with pre-existing persisted game id, joining via the persisted game id is disabled."]
    enablePersistedGameId : 1;
    [description="If set, the game will allow non-reserved TeamIds to be assigned to multiple teams within the game."]
    allowSameTeamId : 1;
    [description="If set, the game will persist after removal of dedicated server topology host."]
    virtualized : 1;
    [description="If set, the game report will send the orphaned game report event on the event stream."]
    sendOrphanedGameReportEvent : 1;
    [description="If set, the game will not validate the reputation of joiners. See etc/component/util/util.cfg."]
    allowAnyReputation  : 1;
    [description="If set, join game calls to the game, will have their join attempts internally suspended by GameManager for up to gamesession.cfg's joinWaitTimeOnBusy milliseconds, before they actually get executed. If this wait time expires and lockedAsBusy remains set, the join game call fails."]
    lockedAsBusy  : 1;
    [description="If set, a slot will be reserved for a configurable period for a player who disconnects from the game involuntarily."]
    disconnectReservation : 1;
    [description="If set, users joining by JoinMethod JOIN_BY_INVITES will not get their reputation validated by the game, regardless of allowAnyReputation's value. Also, if set, GameManager automatically sets allowAnyReputation whenever there is a member with poor reputation in the game, and clears allowAnyReputation when all members have good reputation."]
    dynamicReputationRequirement : 1;
    [description="If set, first party friends of someone in the game will be allowed to join by player, even if openToJoinByPlayer is cleared. This setting only affects joins by JoinMethod JOIN_BY_PLAYER. Ignored for other JoinMethods."]
    friendsBypassClosedToJoinByPlayer : 1;
    [description="DEPRECATED - Use Permissions system to control the actions available to players.  If set, non admin members part of the game can modify the game's attributes."]
    allowMemberGameAttributeEdit : 1;
    [description="Automatically demote reserved players into the Queue, if a queued player joins."]
    autoDemoteReservedPlayers : 1;
    [description="If set, reset game will update a dedicated server game's queue capacity to be the queue capacity specified in the request. False means the queue capacity can only be set at initial game creation."]
    updateQueueCapacityOnReset : 1;
    [description="If set, spectator joins are allowed for all join types, even if joinabilty is disabled for normal slots.  Does not affect discoverability."]
    spectatorBypassClosedToJoin : 1;
};

[description="enumeration for various join modes to the game, a game must be open to one of this join mode to be joined, check GameSettings enumeration."]
enum JoinMethod
{
    [description="SYSTEM INTERNAL USE ONLY. Specifies an invalid join type."]
    SYS_JOIN_TYPE_INVALID=0x0,
    
    [description="Joining game by browsing through the list of available games"]
    JOIN_BY_BROWSING    = 0x1,
    [description="Joining a game via matchmaking"]
    JOIN_BY_MATCHMAKING = 0x2,
    [description="Joining the game via invites.  Skips entry criteria and ban list check if IgnoreEntryCriteriaWithInvite is set on the game."]
    JOIN_BY_INVITES     = 0x4,
    [description="Joining the game via persisted game id."]
    JOIN_BY_PERSISTED_GAME_ID  = 0x5,
    [description="Joining the game by player, eg i found you (by id, name, etc.) and am joining your game."]
    JOIN_BY_PLAYER      = 0x8,

    [description="SYSTEM INTERNAL USE ONLY. Joining the game via following a group leader durring a create game."]
    SYS_JOIN_BY_FOLLOWLEADER_CREATEGAME = 0x0F,
    [description="SYSTEM INTERNAL USE ONLY. Joining the game via reset game on a dedicated server."]
    SYS_JOIN_BY_RESETDEDICATEDSERVER = 0x10,
    [description="SYSTEM INTERNAL USE ONLY. Joining the game via following a group leader durring a reset game."]
    SYS_JOIN_BY_FOLLOWLEADER_RESETDEDICATEDSERVER = 0x20,
    [description="SYSTEM INTERNAL USE ONLY. Creating the game via following a group leader. (Player is the host)"]
    SYS_JOIN_BY_FOLLOWLEADER_CREATEGAME_HOST = 0x40,
    [description="SYSTEM INTERNAL USE ONLY. Joined the game by creating it."]
    SYS_JOIN_BY_CREATE = 0x50,
    [description="SYSTEM INTERNAL USE ONLY. Player from the reservedExternalPlayers list is following a group leader into a game."]
    SYS_JOIN_BY_FOLLOWLEADER_RESERVEDEXTERNALPLAYER = 0x60,
    [description="SYSTEM INTERNAL USE ONLY. Joined the game another local user is in."]
    SYS_JOIN_BY_FOLLOWLOCALUSER = 0x70
};

[description="Enumeration of player slot types ", addProtoAlias = true]
enum SlotType
{
    [description="Public participant slot, usable by any participant"]
    SLOT_PUBLIC_PARTICIPANT  = 0x00,
    [description="Private participant slot, reserved for invited participant"]
    SLOT_PRIVATE_PARTICIPANT = 0x001,

    [description="Public spectator slot, usable by any spectator (Equals MAX_PARTICIPANT_SLOT_TYPE)"]
    SLOT_PUBLIC_SPECTATOR = 0x02,
    [description="Private spectator slot, reserved for invited spectators"]
    SLOT_PRIVATE_SPECTATOR = 0x03,

    // iteration sentinels
    [description="End of slot values, used for iteration purposes"]
    MAX_SLOT_TYPE,
    [description="(Equals SLOT_PUBLIC_SPECTATOR) Value used for iteration over the SlotCapacitiesVector in cases where only participant capacity is being examined."]
    MAX_PARTICIPANT_SLOT_TYPE = 0x02,

    [description="Invalid slot type, used for swap default. Indicates that the server should continue to use the player's current slot type."]
    INVALID_SLOT_TYPE  = -1,
};

[description="SlotCapacities allows segregation of game capacity into slot types, indexed by the SlotType enumeration."]
typedef list<uint16_t, MAX_SLOT_TYPE, true> SlotCapacitiesVector;
typedef map<SlotType, uint16_t> SlotCapacitiesMap;

const uint8_t DEFAULT_JOINING_SLOT = 255;

[description="Game destruction reason code"]
enum GameDestructionReason
{
    [description="Regular system-initiated end game sequence"]
    SYS_GAME_ENDING,

    [description="Creation failed"]
    SYS_CREATION_FAILED,

    [description="This game was destroyed because Blaze requests that the topology host recreate it."]
    SYS_GAME_RECREATE,

    [description="This game was destroyed because create game finalization's connection validation failed."]
    SYS_GAME_FAILED_CONNECTION_VALIDATION,

    [description="Host leaving, only for non-host migration case."]
    HOST_LEAVING,

    [description="Host selected for host injection of a virtual game."]
    HOST_INJECTION,

    [description="Topology host was ejected as the host, and the game will be virtualized again."]
    HOST_EJECTION,

    [description="The local game object is being destroyed because the local player is leaving the game."]
    LOCAL_PLAYER_LEAVING,

    [description="Title-specific destruction reason code(s)"]
    TITLE_REASON_BASE_GAME_DESTRUCTION_REASON
};


[description="enumeration for various states of player"]
enum PlayerState
{
    [description="Non active player. Just holding a slot for the player; no async messages sent. Player not considered 'joined'."]
    RESERVED,
    [description="Non active player. Player has been put into a queue."]
    QUEUED,
    [description="Active player. Player has joined the session, but hasn't constructed their peer mesh; all async messages sent."]
    ACTIVE_CONNECTING,
    [description="Active player. Same as ACTIVE_CONNECTING but is only applied to players who were active at the start of a host migration transaction."]
    ACTIVE_MIGRATING,
    [description="Active player. Player is good to go (mesh conditions satisfied)."]
    ACTIVE_CONNECTED,
    [description="A player who was once ACTIVE_CONNECTED, but lost one (or more) required peer connections.  The peer may be removed from the game soon (depending on the rest of the required peer connection mesh updates)."]
    ACTIVE_KICK_PENDING
};

[description="client's peer network connection status (also used for connections between clients and dedicated server)"]
enum PlayerNetConnectionStatus
{
    [description="I'm not connected to the peer or mesh (I've either given up trying to connect, or an existing connection was lost)."]
    DISCONNECTED,

    [description="I'm trying to connect to a peer or mesh.  NOTE: this is the initial state when a player joins a game"]
    ESTABLISHING_CONNECTION,

    [description="I've established a connection to a peer or mesh."]
    CONNECTED,

    [description="I'm not connected to the peer or mesh because a player was removed."]
    DISCONNECTED_PLAYER_REMOVED
};

[description="A collection of connection-specific flags"]
bitfield PlayerNetConnectionFlags
{
    [description="DEPRECATED, previously hosted game server flag"]
    _DEPRECATED : 1; 
    [description="set if demangler was attempted and succeeded"]
    connectionDemangled : 1;
    [description="set if client received a packet"]
    connectionPktReceived : 1;
};

[description="The reason why a player has been removed from a game."]
enum PlayerRemovedReason
{
    [description="The player's game join timed out."]
    PLAYER_JOIN_TIMEOUT,

    [description="The player's connection to another player (or a required peer) was too poor. This will happen as the result of MM connection validation."]
    PLAYER_CONN_POOR_QUALITY,

    [description="The player's connection to another player (or a required peer) was lost.  Could be a logout, cable pull, power down, misc network problem, etc."]
    PLAYER_CONN_LOST,

    [description="The player's connection to the blazeServer was lost.  Could be a logout, cable pull, power down, misc network problem, etc."]
    BLAZESERVER_CONN_LOST,

    [description="The player was unable to rejoin the game after host migration."]
    MIGRATION_FAILED,

    [description="The game was destroyed, disconnecting all players."]
    GAME_DESTROYED,

    [description="The game ended, disconnecting all players. (typically sent when a dedicated server game ends)."]
    GAME_ENDED,

    [description="The player left the game voluntarily."]
    PLAYER_LEFT,

    [description="The player is leaving the game voluntarily because his userGroup (game group) left."]
    GROUP_LEFT,

    [description="The player was kicked out of the game by a game admin."]
    PLAYER_KICKED,

    [description="The player was kicked out of the game by a game admin (and has been banned from this game session)."]
    PLAYER_KICKED_WITH_BAN,

    [description="The player was kicked out of the game by a game admin, due to the loss of connectivity with the peer."]
    PLAYER_KICKED_CONN_UNRESPONSIVE,

    [description="The player was kicked out of the game by a game admin, due to the loss of connectivity with the peer (and has been banned from this game session)."]
    PLAYER_KICKED_CONN_UNRESPONSIVE_WITH_BAN,

    [description="The player was kicked out of the game by a game admin, due to poor connectivity with the peer."]
    PLAYER_KICKED_POOR_CONNECTION,

    [description="The player was kicked out of the game by a game admin, due to poor connectivity with the peer (and has been banned from this game session)."]
    PLAYER_KICKED_POOR_CONNECTION_WITH_BAN,

    [description="The player was unable to join the game from the queue."]
    PLAYER_JOIN_FROM_QUEUE_FAILED,

    [description="The player failed to claim their player reservation before the timeout expired."]
    PLAYER_RESERVATION_TIMEOUT,

    [description="The host was ejected from a virtual game."]
    HOST_EJECTED,

    [description="Host injection failed to complete."]
    HOST_INJECTION_FAILED,

    [description="Failed to join player to the external game session."]
    PLAYER_JOIN_EXTERNAL_SESSION_FAILED,

    [description="The old placeholder player object's game reservation is now being transferred to the player's 'real' player object, after it logged in with a Blaze user account."]
    RESERVATION_TRANSFER_TO_NEW_USER,

    [description="The player left the game voluntarily and desire to make a disconnect reservation."]
    PLAYER_LEFT_MAKE_RESERVATION,

    [description="The player is leaving the game voluntarily because his userGroup (game group) left and desire to make a disconnect reservation."]
    GROUP_LEFT_MAKE_RESERVATION,

    [description="The player failed to claim their disconnect reservation before the timeout expired."]
    DISCONNECT_RESERVATION_TIMEOUT,

    [description="SYSTEM INTERNAL USE ONLY. A default invalid value for the player removed reason"]
    SYS_PLAYER_REMOVE_REASON_INVALID,

    [description="The player cancelled matchmaking while the join game request was in-flight."]
    PLAYER_LEFT_CANCELLED_MATCHMAKING,

    [description="The player left the game due to moving to a new game session."]
    PLAYER_LEFT_SWITCHED_GAME_SESSION

};

[description="The type of host migration occuring."]
enum HostMigrationType
{
    [description="Topology host migration.  The topology host is the actual host hardware for the game"]
    TOPOLOGY_HOST_MIGRATION,

    [description="Platform host migration.  The platform host is not actually hosting the game, but is usually the first game member to join the game."]
    PLATFORM_HOST_MIGRATION,

    [description="Both topology and platform host migration.  The host is both the topology and the platform host."]
    TOPOLOGY_PLATFORM_HOST_MIGRATION
};

////////////////////////////////////////////////////////////////////////////////
// Game Related Types //////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef uint64_t GameId;
typedef uint64_t GameReportingId;

[description="Game report type as specified via the game reporting configuration"]
typedef string(32) GameReportName;

typedef BlazeId PlayerId;
typedef uint32_t NumOfSessions;
typedef string(64) GameProtocolVersionString;
typedef list<PlayerId> PlayerIdList;
typedef list<UserSessionId> UserSessionIdList;
typedef string(64) GameName;
typedef ObjectId UserGroupId;
typedef string(255) GameStatusURL;
typedef string(64) PersistedGameId; //length increased to over UUID's to accommodate Blaze's PS5 boot to new game prefixes
typedef blob PersistedGameIdSecret;
typedef list<PersistedGameId> PersistedGameIdList;
typedef list<AccountId> AccountIdList;
typedef string(32) Region;

[description="An unsorted collection of GameIds."]
typedef list<GameId> GameIdList;
[description="A title-defined value to give context info when a player leaves (or is kicked out of) a game."]
typedef uint16_t PlayerRemovedTitleContext;
[description="Bitset used to describe active game mods, where each bit in the register corresponds to one game mod."]
typedef uint32_t GameModRegister;

const GameId INVALID_GAME_ID = 0;
const GameReportingId INVALID_GAME_REPORTING_ID = 0;

const uint32_t GAME_TYPE_ID_NONE = 0;

const char8_t *GAME_PROTOCOL_VERSION_MATCH_ANY = "match_any_protocol";
const char8_t *GAME_PROTOCOL_DEFAULT_VERSION = "";

const TimeValue JOINED_GAME_TIMESTAMP_NOT_JOINED = 0; // sentinel value; indicates player hasn't joined the game yet.
const TimeValue NO_RESERVATION_TIMESTAMP = 0; // sentinel value; indicates no disconnection reservation is made by this player in the game.

const uint32_t MAX_TUNNELKEY_LEN = 128;

[description="Tells whather the player is in the reservation queue or in the game."]
enum JoinState
{
    JOINED_GAME,
    IN_QUEUE,
    GROUP_PARTIALLY_JOINED,
    NO_ONE_JOINED
};

////////////////////////////////////////////////////////////////////////////////
// Teams Related Types /////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef uint16_t TeamId;
typedef uint16_t TeamIndex;
typedef list<TeamId> TeamIdVector;
typedef list<TeamIndex> TeamIndexList;

const TeamIndex UNSPECIFIED_TEAM_INDEX = UINT16_MAX;
const TeamIndex TARGET_USER_TEAM_INDEX = 65534;
const TeamId INVALID_TEAM_ID = UINT16_MAX;
const TeamId ANY_TEAM_ID = 65534;

////////////////////////////////////////////////////////////////////////////////
// Roles Related Types /////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description="Max RoleName length."]
const uint32_t ROLE_NAME_LENGTH = 32;

typedef string(ROLE_NAME_LENGTH) RoleName;
typedef list<RoleName> RoleNameList;
typedef map<RoleName,uint16_t,ignorecase> RoleMap; // map of role names to capacities or current sizes
typedef map<RoleName,PlayerIdList,ignorecase> RoleNameToPlayerMap; // map of role names to players
typedef map<RoleName,UserIdentificationList,ignorecase> RoleNameToUserIdentificationMap; // map of role names to external player identifications.
typedef map<RoleName,EntryCriteriaMap,ignorecase> RoleEntryCriteriaMap;

[description="Default role name."]
const char8_t* PLAYER_ROLE_NAME_DEFAULT = "";
[description="Any role name."]
const char8_t* PLAYER_ROLE_NAME_ANY = "ANY_PLAYER_ROLE";


[description="An individual Role's EntryCriteria and capacity.", trackChanges = true]
class RoleCriteria
{
    [tag="crit", description="EntryCriteria specific to players joining a particular role, players joining into (or switching to) this role must pass this criteria."]
        EntryCriteriaMap mRoleEntryCriteriaMap;
    [tag="rcap"] uint16_t mRoleCapacity;
};

[description="Per-role capacity and entry criteria map."]
typedef map<RoleName, RoleCriteria,ignorecase> RoleCriteriaMap;

[description="Contains the individual & compound role size data, as well as per-role EntryCriteria", trackChanges = true]
class RoleInformation
{
    [tag="crit", description="EntryCriteria specific to players joining a particular role."]
        RoleCriteriaMap mRoleCriteriaMap;
    [tag="rcrt", description="Criteria to apply against combined role sizes.",
        details = "MultiRoleCriteria consists of the role names to test, a value to test against, and an operator.
            For example, to create an expression to only allow 10 players total of a combination of roles, define the expression
            like so: 'defender' + 'forward' + 'midfield' <= 10.  Role criteria only support <= comparisons. See expression.h"]
        EntryCriteriaMap mMultiRoleCriteria;
};


////////////////////////////////////////////////////////////////////////////////
// Tournament Types ////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description="Helper Object for holding the tournament identification.", trackChanges = true]
class TournamentIdentification
{
    [tag="tid", description="Identification for the Tournament this game is part of."]
    TournamentId mTournamentId;

    [tag="torg", description="Name of the Organizer of the tournament (ESL, FaceIt, etc.)."]
    TournamentOrganizer mTournamentOrganizer;
};

////////////////////////////////////////////////////////////////////////////////
// Replicated Game State Types //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description="A collection of player settings flags: hasJoinFirstPartyGameSessionPermission, hasDisconnectReservation"]
bitfield PlayerSettings
{
    [description="Whether user joins first party sessions (360, PS4)"]
    hasJoinFirstPartyGameSessionPermission : 1;

    [description="Whether this player has made a disconnect reservation."]
    hasDisconnectReservation : 1;

    [description="Whether this player's VoIP capability is disabled."]
    hasVoipDisabled : 1;
};

const uint32_t INVALID_CCS_CONNECTIVITY_ID = 0;

enum GameType
{
    [description="A game session, which has the full set of game related features including Blaze game/netgamelink networking, game states, evaluation by matchmaking rules, etc."]
    GAME_TYPE_GAMESESSION,
    [description="A generic group, does not have Blaze game/netgamelink networking nor use game states, but does include most other game related features including attributes, permissions, and evaluation by matchmaking rules. etc."]
    GAME_TYPE_GROUP
};

[description = "Various modes that the game can be configured to leverage Connection Concierge service (CCS)."]
enum CCSMode
{
    [description = "Invalid value."]
    CCS_MODE_INVALID,
    
    [description = "No connections are attempted via the CCS(acts as disabled)."]
    CCS_MODE_PEERONLY,
    
    [description = "Connections are attempted via the CCS only(used for testing)."]
    CCS_MODE_HOSTEDONLY,
    
    [description = "CCS is used for making failed connections."]
    CCS_MODE_HOSTEDFALLBACK
};

typedef string(32) GamePermissionSystemName;

[description = "Enumeration of ways the user can enter into the game."]
enum GameEntryType
{
    [description = "Join a game directly."]
    GAME_ENTRY_TYPE_DIRECT = 0x00,

    [description = "Reserve a slot in a game to be claimed later."]
    GAME_ENTRY_TYPE_MAKE_RESERVATION = 0x01,

    [description = "Claim a reservation in a game.  Does not recognize any params passed up by the Join Game Request."]
    GAME_ENTRY_TYPE_CLAIM_RESERVATION = 0x02
};

const uint16_t BLAZE_DEFAULT_MAX_PLAYER_CAP = 0;

[trackChanges = true, description="Information needed to identify the host."]
class HostInfo
{
    [tag="hpid"] PlayerId mPlayerId;
    [tag="hses"] UserSessionId mUserSessionId;
    [tag="hslt"] SlotId mSlotId;
    [tag="cong"] ConnectionGroupId mConnectionGroupId;
    [tag="csid"] SlotId mConnectionSlotId;
};


////////////////////////////////////////////////////////////////////////////////
// External Data Source Related Types ///////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef string(128) DataSourceName;
typedef list<DataSourceName> DataSourceNameList;
typedef DataSourceName ExternalApiName;
typedef DataSourceNameList ExternalDataSourceApiNameList;

[description="The game's player's external session member data, for determining how player may be advertised in UX's session. Sent from client as part of UpdateExternalSessionPresenceForUserRequest.", trackChanges=true]
class PlayerPresenceData
{
    [tag="psta"] PlayerState mPlayerState;
    [tag="time"] TimeValue mJoinedGameTimestamp;
    [tag="team"] uint16_t mTeamIndex;
    [tag="slot"] SlotType mSlotType;
};

[description="game info used for updating external session presence for user"]
class GameActivity
{
    [tag="gid"] GameId mGameId;
    [tag="ggty"] GameType mGameType;
    [tag="stmn", description="DEPRECATED, use ExternalSessionIdentification."] XblSessionTemplateName mExternalSessionTemplateName;
    [tag="esnm", description="DEPRECATED, use ExternalSessionIdentification."] XblSessionName mExternalSessionName;
    [tag="esid"] ExternalSessionIdentification mSessionIdentification;
    [tag="psta", description="DEPRECATED, use mPlayer"] PlayerState mPlayerState;
    [tag="time", description="DEPRECATED, use mPlayer"] TimeValue mJoinedGameTimestamp;
    [tag="pres"] PresenceMode mPresenceMode;
    [tag="plyr"] PlayerPresenceData mPlayer;
};
typedef list<GameActivity> GameActivityList;

[description="Enumeration of reasons for user presence update.", addProtoAlias = true]
enum UpdateExternalSessionPresenceForUserReason
{
    [description="user created game"]
    UPDATE_PRESENCE_REASON_GAME_CREATE = 0x00,
    [description="user joined game"]
    UPDATE_PRESENCE_REASON_GAME_JOIN = 0x01,
    [description="user left game"]
    UPDATE_PRESENCE_REASON_GAME_LEAVE = 0x02,
    [description="user changed which team its in"]
    UPDATE_PRESENCE_REASON_TEAM_CHANGE = 0x03,
    [description="user's game entered a new replay round"]
    UPDATE_PRESENCE_REASON_GAME_NEWROUND = 0x04,

    [description="(DEPRECATED) Use UPDATE_PRESENCE_REASON_GAME_CREATE"] GAME_CREATE = 0x00,
    [description="(DEPRECATED) Use UPDATE_PRESENCE_REASON_GAME_JOIN"] GAME_JOIN = 0x01,
    [description="(DEPRECATED) Use UPDATE_PRESENCE_REASON_GAME_LEAVE"] GAME_LEAVE = 0x02
};
[description="(DEPRECATED: use UpdateExternalSessionPresenceForUserReason)"]
typedef UpdateExternalSessionPresenceForUserReason UpdatePrimaryExternalSessionReason;

////////////////////////////////////////////////////////////////////////////////
// Scenario Related TDFs ////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description = "Data needed to create a Game."]
class GameCreationData
{
    // Game Settings:
    [tag="gnam", description="Optional non-unique Game Name. Can be searched for with the GameNameRule."]
        GameName mGameName;
    [tag="gset", description="Bitfield with the settings for Joinability, and a variety of other settings."]
        GameSettings mGameSettings;
    [tag="gmrg", description="Game Mod register used to determine what mod(s) this game is currently running. Can be searched for with the GameModRule."]
        GameModRegister mGameModRegister;
    [tag="attr", description="Game Attribute map. Store custom attributes for the game. Can be searched for with various GameAttributeRules."]
        Collections::AttributeMap mGameAttribs;
    [tag="pres", default=PRESENCE_MODE_STANDARD, description="Presence mode used for 1st party display. May be set to private."]
        PresenceMode mPresenceMode;
    [tag="prdl", description="List of platforms on which presence mode is disabled for this game. Clients who join the game on these platforms will receive NotifyGameSetup notifications with PRESENCE_MODE_NONE, instead of the game's configured presence mode setting."]
        ClientPlatformTypeList mPresenceDisabledList;
    [tag="nini", default=false, description="Flag to indicate that this game will skip the initializing state. This applies only to the the NETWORK_DISABLED topology when hostless game sessions are enabled in gamemanager configuration. The game will skip directly to PRE_GAME (for GameSessions) or GAME_GROUP_INITIALIZED (for game groups)."]
        bool mSkipInitializing;

    // Networking Values:
    [tag="ntop", description="The topology used by the game. Typically either client-server, full or partial mesh. Game Groups must set this to NETWORK_DISABLED."]
        GameNetworkTopology mNetworkTopology;
    [tag="voip", description="The topology used for VOIP communication, which may be handled separate from the normal game messaging."]
        VoipTopology mVoipNetwork;
    [tag="stmn", description="(DEPRECATED use mExternalSessionIdentSetup) External Session template name used by Xbox to determine what MSPD template to use for the game."]
        XblSessionTemplateName mExternalSessionTemplateName;
    [tag="ssta", description="External Session status displayed for the session in the shell UX. For PS4."]
        ExternalSessionStatus mExternalSessionStatus;
    [tag="sdat", description="External Session custom data. For PS and Xbox."]
        ExternalSessionCustomData mExternalSessionCustomData;
    [tag="exts", description="External Session identification setup parameters."]
        ExternalSessionIdentification mExternalSessionIdentSetup;
    [tag="exrp", description="External Session recent players setup parameters. For Xbox."]
        ExternalSessionRecentPlayersSettings mExternalSessionRecentPlayers;
    [tag="xlrg", default=false, description="If true Xbox MPSD sessions are created as 'Large' MPSD sessions, which support over 100 members, but forgoes some other XBL features (see MS/Blaze docs)."]
        bool mXblLargeSession;
        
    // Capacities & Criteria
    [tag="pmin", default=1, description="Minimum player capacity that the game can be set to, if setGameCapacity is called. Also used when searching for valid dedicated servers."]
        uint16_t mMinPlayerCapacity;            // For MM, we just use default
    [tag="pmax", default=BLAZE_DEFAULT_MAX_PLAYER_CAP, description="Maximum player capacity that the game can be set to, if setGameCapacity is called. Also used when searching for valid dedicated servers."]
        uint16_t mMaxPlayerCapacity;
    [tag="qcap", description="Number of players that can enter the pre-game queue. Queued players are not yet in the game, and have not connected to the game's topology."]
        uint16_t mQueueCapacity;
    [tag="rnfo", description="The roles and capacities, and criteria, supported in this game session."]
        RoleInformation mRoleInformation;
    [tag="crit", description="Players must pass these entry criteria to join this game."]
        EntryCriteriaMap mEntryCriteriaMap;
    [tag="tids", description="List of team ids that are created for this game. Must match with other joining players."] 
        TeamIdVector mTeamIds;

    [tag="pcpm", description="Map of slot types to player capacity.  PRIVATE slots are ignored when matchmaking."]
        SlotCapacitiesMap mSlotCapacitiesMap;
    [tag="gtyp", description="Game report name as specified via the game reporting configuration"]
        GameReportName mGameReportName;      


    [tag="gpsn", description="Name of the permission system that will control what actions the Host, Admin(s), Players, and Spectators can perform, and whether admins are automatically assigned."] 
        GamePermissionSystemName mPermissionSystemName;


    // Overrides
    [tag="prto", default = "0s", description="Overrides the player reservation timeout for joining players.  (Joining Scenarios can override this.)"]
        TimeValue mPlayerReservationTimeout;
    [tag="drto", default = "0s", description="Overrides the player reservation timeout for disconnected players."]
        TimeValue mDisconnectReservationTimeout;

    [tag="edso", description="(internal) List of external data sources api's used to override this game."]
    DataSourceNameList mDataSourceNameList;

    [tag="eown", default=false, description="If true, the creating caller is omitted from the roster, game persists as long as its user session exists."]
        bool mIsExternalOwner;

    [tag="ocal", default=false, description="If true, the request's caller is explicitly omitted from the roster."]
        bool mIsExternalCaller;
};

[description = "Individual Player Join information."]
class PerPlayerJoinData
{
    [tag="usid", description="Identification for the user. Typically just a BlazeId. External players may use External Id / Blobs."]
        UserIdentification mUser;
    [tag="rlnm", description="(DEPRECATED) The game-defined Role that the user desires. The empty string is the default role, for games that do not use roles. This value is mutually exclusive from the role list below and will result in a validation error if both are specified."]
        RoleName mRole;
    [tag="rlst", description="The game-defined Roles that the user desires. The empty string is the default role, for games that do not use roles. This list is mutually exclusive with the role above and will result in a validation error if both are specified."]
        RoleNameList mRoles;
    [tag="plya", description="Player Attribute map. Store custom attributes for the player. Can be searched for with various GamePlayerRules."]
        Collections::AttributeMap mPlayerAttributes;

    [tag="irep", default=false, description="Optional players (typically External players, unknown to Blaze) attempt to join the game, but are not required. This setting is ignored when Matchmaking (all players are expected to join)."]
        bool mIsOptionalPlayer;

    
    // The defaults here indicate that the default should be used
    [tag="slot", default=INVALID_SLOT_TYPE, description="Slot type to join as. Public or private, participant or spectator. Matchmaking only supports public participant."]
        SlotType mSlotType;
    [tag="tidx", default=UNSPECIFIED_TEAM_INDEX, description="Team index used when multiple teams have the same team id. Not used by Matchmaking."]
        TeamIndex mTeamIndex;
    [tag="tid", default=INVALID_TEAM_ID, description="The TeamId I choose to join. By default, uses the default team set by the PlayerJoinData."]
        TeamId mTeamId;

    [tag="encr", description="The user's encrypted id. This may be exposed to external services instead a BlazeId."]
        EncryptedBlazeId mEncryptedBlazeId;
};
typedef list<PerPlayerJoinData> PerPlayerJoinDataList;

[description = "Full group listing of Player Join information."]
class PlayerJoinData
{
// Who else is joining: (Calling player is implicit)
    [tag="btpl", description="Used for group join only, holding component,type and groupid information."]
        UserGroupId mGroupId;

    [tag="slot", default=SLOT_PUBLIC_PARTICIPANT, description="Slot type to join as. Public or private, participant or spectator."]
        SlotType mDefaultSlotType;
    [tag="gent", default=GAME_ENTRY_TYPE_DIRECT, description="This value indicates if a player is joining, reserving, or claiming a reservation."]
        GameEntryType mGameEntryType;
    [tag="dfrl", description="Default role, used for players who cannot provide PerPlayerJoinData (those coming from a GroupId), or to set all player roles globally."]
        RoleName mDefaultRole;

    // Team Choice:
    // For matchmaking, only TeamId is supported  all players must use the same Team
    [tag="tidx", default=UNSPECIFIED_TEAM_INDEX, description="Team index used when multiple teams have the same team id. Not used by Matchmaking."]
        TeamIndex mDefaultTeamIndex;
    [tag="tid", default=ANY_TEAM_ID, description="The TeamId I choose to join. By default, ANY_TEAM_ID will be used in-game, since all games have at least one team. Do not set to INVALID_TEAM_ID."]
        TeamId mDefaultTeamId;

    // Per-player Data: (Includes Calling Player)
    [tag="pldl", description="Player Join Data for the individual joining players, whose blaze id, or external ids, are known."]
        PerPlayerJoinDataList mPlayerDataList;
};

[description = "Common settings that should be set by the SDK, and never by the player."]
class CommonGameRequestData
{
    [tag="gver", description="The gameProtocolVersion filter value.  You'll only match games or players who have the same gameProtocolVersion as you."]
        GameProtocolVersionString mGameProtocolVersionString;

    [tag="delg", description="If set, the matchmaking request will use a specific group for TTM/PMR lookups.  Only applies to Scenarios matchmaking."]
        DelineationGroupType mDelineationGroup;

    [tag="ggty", default=GAME_TYPE_GAMESESSION, description="Specifies the game type to join/create. If the user is a member of multiple instances of the specified game type, join the first one found."]
        GameType mGameType; 

    // From GameCreationData:
    [tag="pnet", description="Network address used by the player machine."]
        NetworkAddress mPlayerNetworkAddress;
};

////////////////////////////////////////////////////////////////////////////////
// Remote action TDFs ///////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description="Details of the player and user group that initiated a remote action, such as matchmaking or a game join."]
class RemoteInitiatorInformation
{
    [tag="inid", description="The BlazeId of the user who initiated this action."]
        PlayerId mInitiatorId;

    [tag="gid", description="The user group id associated with this action"]
        UserGroupId mAssociatedUserGroupId;
};


////////////////////////////////////////////////////////////////////////////////
// Template Types //////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

typedef string(64) PropertyName;
typedef list<PropertyName> PropertyNameList;
typedef map<PropertyName, generic, ignorecase> PropertyNameMap;

const uint32_t TEMPLATE_ATTR_VALUE_LENGTH = 256;
typedef string(TEMPLATE_ATTR_VALUE_LENGTH) TemplateAttributeTdfName;            // Name of the TDF.  (ex. Blaze::GameManager::StartMatchmakingRequest", or just "StartMatchmakingRequest")
typedef string(TEMPLATE_ATTR_VALUE_LENGTH) TemplateAttributeTdfMemberName;      // Name of the TDF member (either full like "Blaze::GameManager::StartMatchmakingRequest.mSessionData.mPseudoRequest", or partial "StartMatchmakingRequest.mSessionData.mPseudoRequest")

enum MergeOp
{
    MERGE_NONE = 0, 
    
    MERGE_MIN,      // ex. Convert a list<value> to a value.  Valid for integral/float, and map<key, integral/float>
    MERGE_MAX, 
    MERGE_SUM, 
    MERGE_SIZE,        // ".size()" Matching Packer implementation, just the # of elements. (per-map entry, if a map is used - useful for counting role usage)
    MERGE_AVERAGE, 
    MERGE_STDDEV, 
    MERGE_MIN_MAX_RANGE, 
    MERGE_MIN_MAX_RATIO,

    // Others:
    // MERGE_COUNT_ELEMENTS, // ex. Convert a list<string> to a map<string, int32_t>.  Only valid with non-map values.
    // MERGE_INTERSECT,      // ex. Convert a list<list<X>> to a single list<X>.
};

[ description = "Describes the variables, defaults, and possible mappings for template attributes.", trackChanges = true ]
class TemplateAttributeDefinition
{
  [tag="var", reconfigurable="yes", description="The template attribute name used.  The attribute name can be mapped to multiple values."]
  TemplateAttributeName mAttrName;
  [tag="def", reconfigurable="yes", description="The default values used.  If no default is set, and the value is not optional, an error will occur if no value is sent from the client."]
  generic mDefault;
  [tag="prop", reconfigurable="yes", description="The property name to use when filling out the value.  Overridden if a valid attribute is provided."]
  PropertyName mPropertyName;

  [tag="mgop", default = MERGE_NONE, reconfigurable="yes", description="Merge operation to apply to the input attribute/property, before putting it in the mapped member."]
  MergeOp mMergeOp;

  [tag="cdef", default = true, reconfigurable="yes", description="Can the value be set by the client."]
  bool mClientDefined;

  [tag="gscc", default = false, reconfigurable="yes", description="This value can only be set on non-PROD servers, or by GOSCC for testing."]
  bool mDebugOnly;

  [tag="iopt", default = false, reconfigurable="yes", description="Indicates that the attribute does not have to be sent from the client."]
  bool mIsOptional;
};

typedef map<TemplateAttributeTdfMemberName, TemplateAttributeDefinition> TemplateAttributeMapping;     // Uses syntax { "tdf.member" = { attrName = "FOO", default = 0 } }
typedef map<TemplateAttributeTdfName, TemplateAttributeMapping> TemplateAttributeTdfMapping;           // Uses syntax { "tdf" = {"member" = { attrName = "FOO", default = 0 }} }

class SanitizerDefinition
{
    [tag="oatt", reconfigurable="yes", description="TemplateAttribute that is overridden as output of the sanitizer."]
    TemplateAttributeName outAttr;
    [tag="oprp", reconfigurable="yes", description="Property that is overridden as output of the sanitizer."]
    PropertyName outProperty;

    [tag="san", reconfigurable="yes", description="The sanitizer definition itself.  Indicates what type of sanitizer is used by the Map Key."]
    TemplateAttributeTdfMapping sanitizer;
};
typedef string(-1) SanitizerName;
typedef list<SanitizerName> SanitizerNameList;
typedef map<SanitizerName, SanitizerDefinition> SanitizerDefinitionMap;


////////////////////////////////////////////////////////////////////////////////
// Matchmaking Filter Types /////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

[description="Max mm filter name length."]
const uint32_t FILTER_NAME_LENGTH = 32;

// filter expression map type
typedef string(FILTER_NAME_LENGTH) MatchmakingFilterName;


[ description = "A description of a template attribute which includes the tdfid it's mapped to, default value and whether the attribute is optional.", trackChanges = true ]
class TemplateAttributeDescription
{
  [tag="var", reconfigurable="yes", description="The TdfId of the tdf mapped to this attribute."]
  uint32_t mAttrTdfId;
 
  [tag="def", reconfigurable="yes", description="The default values used. If no default is set, and the value is not optional, an error will occur if no value is sent from the client."]
  generic mDefault;
 
  [tag="iopt", default = false, reconfigurable="yes", description="Indicates that the attribute does not have to be sent from the client."]
  bool mIsOptional;
};
 
typedef map<TemplateAttributeName, TemplateAttributeDescription> TemplateAttributeDescriptionMapping;
 


} // namespace GameManager
} // namespace Blaze
