/*****************************************************************************************
    (c) Electronic Arts. All Rights Reserved.
*****************************************************************************************/

[
  client_include = false,
  headername="gamemanager/tdf/gamepacker_internal_config_server.h" 
]
#include "gamemanager/gen/gamepacker_internal_config_server.tdf"

[
  client_include = false,
  headername="gamemanager/tdf/gamepacker_server.h" 
]
#include "gamemanager/gen/gamepacker_server.tdf"

namespace Blaze
{

namespace GamePacker
{

[ 
  id = core/500,
  configurationType = GamePackerConfig
]
component GamePacker
{
    errors 
    {
        [ description = "Worker (GamePackerSlave) in request is not known to Packer." ]
        GAMEPACKER_ERR_WORKER_NOT_FOUND                     = 1;

        [ description = "Failure related to the assignment of Layers by Packer." ]
        GAMEPACKER_ERR_LAYER_FAILURE                        = 50;


        [ description = "Session does not exist." ]
        GAMEPACKER_ERR_SESSION_NOT_FOUND                    = 100;
        [ description = "Session is not assigned to the instance trying to perform the operation." ]
        GAMEPACKER_ERR_SESSION_NOT_ASSIGNED                 = 101;
        [ description = "Sesssion is in an invalid state to perform the action requested." ]
        GAMEPACKER_ERR_SESSION_INVALID_STATE                = 102;

        [ description = "Scenario id has not found." ]
        GAMEPACKER_ERR_SCENARIO_NOT_FOUND                   = 150;
        [ description = "Scenario has already been locked for finalization (possibly by a sibling sub-session)." ]
        GAMEPACKER_ERR_SCENARIO_FINALIZING                  = 151;

        [ description = "Problem parsing your matchmaking criteria. See StartMatchmakingError's err msg for details." ]
        GAMEPACKER_ERR_INVALID_MATCHMAKING_CRITERIA         = 200;
        [ description = "Finalization job invalidated due to participant logout." ]
        GAMEPACKER_ERR_FINALIZATION_JOB_INVALIDATED         = 201;
        [ description = "Finalization job failed to join found game." ]
        GAMEPACKER_ERR_FINALIZATION_JOB_JOIN_GAME_FAILED    = 202;

        [ description = "The requested external session template name is not supported by the server." ]
        GAMEPACKER_ERR_SESSION_TEMPLATE_NOT_SUPPORTED       = 274;
        [ description = "General error returned when the external session service returns an unhandled error."]
        GAMEPACKER_ERR_EXTERNAL_SESSION_ERROR               = 275;

        [ description = "Missing a required filter type (ex. PlatformFilter)."]
        GAMEPACKER_ERR_MISSING_REQUIRED_FILTER              = 278;
        [ description = "Multiple Filters affecting the same value were provided."]
        GAMEPACKER_ERR_DUPLICATE_REQUIRED_FILTERS_PROVIDED  = 279;

     // Dupes of GameManager stuff:
        [ description = "The crossplay settings of the Game or Request prevent the action from occurring." ]
        GAMEPACKER_ERR_CROSSPLAY_DISABLED                   = 27;
        [ description = "The crossplay settings of the User prevent the action from occurring.  Can be fixed by changing the Crossplay Enabled setting of the User." ]
        GAMEPACKER_ERR_CROSSPLAY_DISABLED_USER              = 28;

        [ description = "The RPC template name provided does not exist." ]
        GAMEPACKER_ERR_INVALID_TEMPLATE_NAME                = 610;
        [ description = "The template being run requires an attribute that was not provided." ]
        GAMEPACKER_ERR_MISSING_TEMPLATE_ATTRIBUTE           = 611;
        [ description = "A template Attribute being used is currently invalid. (Generally indicates a config setup error.)" ]
        GAMEPACKER_ERR_INVALID_TEMPLATE_ATTRIBUTE           = 612;
    }
    
    [setCurrentUserSession=false, requiresMaster=false]
    slave
    {
        methods
        {
            [
                id = 5,
                description = "Get detailed packer metrics - these metrics will be in a histogram format.",
                ignoreShardingKey = true,
                client_export = false,
                generate_command_class = false,
                internal = true,
                requires_authentication = false,
                http = {
                    resource = "getDetailedMetrics",
                    method = "GET",
                    encodeEnumsAsStrings = true
                }
            ]
            Blaze::GameManager::GetDetailedPackerMetricsResponse getDetailedMetrics();
        } // methods
               
        notifications
        { 
        } // notifications

    } // slave
    
    [isSharded=true, shardingKey="packerScenarioId", useSlivers=true, setCurrentUserSession=false]
    master
    {
        methods
        {
          
            [
                id = 1,
                blocking = true,
                description = "Start a new packer scenario. Needs to be blocking because it calls external game session service. Wish it didn't have to...",
                errors = {
                    GAMEPACKER_ERR_INVALID_MATCHMAKING_CRITERIA,
                    GAMEPACKER_ERR_MISSING_REQUIRED_FILTER,            
                    GAMEPACKER_ERR_DUPLICATE_REQUIRED_FILTERS_PROVIDED,
                    GAMEPACKER_ERR_CROSSPLAY_DISABLED,                 
                    GAMEPACKER_ERR_CROSSPLAY_DISABLED_USER,            
                    GAMEPACKER_ERR_INVALID_TEMPLATE_NAME,              
                    GAMEPACKER_ERR_MISSING_TEMPLATE_ATTRIBUTE,         
                    GAMEPACKER_ERR_INVALID_TEMPLATE_ATTRIBUTE         
                },
                errortype = Blaze::GameManager::StartPackerSessionError,
                requires_authentication = false,
                requiresUserSession = false
            ]
            Blaze::GameManager::StartPackerSessionResponse startPackerScenario(Blaze::GameManager::StartPackerScenarioRequest);      // Not sure what needs to be returned here (PACKER_TODO - figure that out)

            // PACKER_TODO: Rename to cancelPackingScenario, and only call once per scenario rather than once per session
            [
                id = 2,
                description = "Called by the core slave to cancel an outstanding packer session owned by this master.",
                errors = {
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SCENARIO_FINALIZING
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void cancelPackerScenario(Blaze::GameManager::CancelPackerScenarioRequest);
            
            [
                id = 3,
                description = "Called by slave to obtain a session to pack.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND
                },
                requires_authentication = false,
                requiresUserSession = false,
                ignoreShardingKey = true
            ]
            Blaze::GameManager::WorkerObtainPackerSessionResponse workerObtainPackerSession(Blaze::GameManager::WorkerObtainPackerSessionRequest);
            
            [
                id = 4,
                description = "Called by packer slave to release obtained session due to inability to find a match of sufficient quality/viability.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED,
                    GAMEPACKER_ERR_SESSION_INVALID_STATE,
                    GAMEPACKER_ERR_SCENARIO_FINALIZING,
                    GAMEPACKER_ERR_LAYER_FAILURE
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerMigratePackerSession(Blaze::GameManager::WorkerMigratePackerSessionRequest); 
            
            [
                id = 5,
                description = "Called by packer slave to relinquish acquired session due to session state update.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND, 
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED,
                    GAMEPACKER_ERR_SESSION_INVALID_STATE
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerRelinquishPackerSession(Blaze::GameManager::WorkerRelinquishPackerSessionRequest); 

            [
                id = 6,
                description = "Called by packer slave to successfully complete a packer session previously locked by this instance.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND, 
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED,
                    GAMEPACKER_ERR_SCENARIO_FINALIZING
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerCompletePackerSession(Blaze::GameManager::WorkerCompletePackerSessionRequest);

            [
                id = 7,
                description = "Called by packer slave to abort a packer session(due to error) previously obtained by this instance.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED,
                    GAMEPACKER_ERR_SCENARIO_FINALIZING
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerAbortPackerSession(Blaze::GameManager::WorkerAbortPackerSessionRequest);

            [
                id = 8,
                description = "Called by the packer slave to lock the packer session's scenario for finalization.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED,
                    GAMEPACKER_ERR_SCENARIO_FINALIZING
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerLockPackerSession(Blaze::GameManager::WorkerLockPackerSessionRequest);

            [
                id = 9,
                description = "Called by the packer slave that has locked the packer session's scenario for finalization if finalization was unsuccessful. NOTE: Successful finalizations call completePackerSession() instead of unlockPackerSession().",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND, 
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED,
                    GAMEPACKER_ERR_SCENARIO_FINALIZING
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerUnlockPackerSession(Blaze::GameManager::WorkerUnlockPackerSessionRequest);

            [
                id = 10,
                description = "Called by packer slave to send a session status update to the packer master.",
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_FOUND,
                    GAMEPACKER_ERR_SESSION_NOT_ASSIGNED
                },
                requires_authentication = false,
                requiresUserSession = false
            ]
            void workerUpdatePackerSessionStatus(Blaze::GameManager::WorkerUpdatePackerSessionStatusRequest);

            [
                id = 11,
                description = "Called by the mmSlave to notify the master of which layer it is on.",
                requires_authentication = false,
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND,
                    GAMEPACKER_ERR_LAYER_FAILURE
                },                
                requiresUserSession = false,
                ignoreShardingKey = true
            ]
            Blaze::GameManager::WorkerLayerAssignmentResponse workerClaimLayerAssignment(Blaze::GameManager::WorkerLayerAssignmentRequest); // called by the matchmaking slave to inform master of the slave's layer index topology assignment
            
            [
                id = 12,
                description = "Obtain packer metrics.",
                requires_authentication = false,
                requiresUserSession = false,
                ignoreShardingKey = true
            ]
            Blaze::GameManager::GetPackerMetricsResponse getPackerMetrics(Blaze::GameManager::GetPackerMetricsRequest);

            [
                id = 13,
                description = "Called by the mmSlave to notify the master that it is being drained.",
                requires_authentication = false,
                errors = {
                    GAMEPACKER_ERR_WORKER_NOT_FOUND,
                    GAMEPACKER_ERR_LAYER_FAILURE
                },                
                requiresUserSession = false,
                ignoreShardingKey = true
            ]
            void workerDrainInstance();

            [
                id = 14,
                description = "Called by core slave to retrieve packer master instance status.", 
                requires_authentication = false,
                requiresUserSession = false
            ]
            Blaze::GameManager::PackerInstanceStatusResponse getPackerInstanceStatus();

        } // master methods

        notifications
        {
            [
              id = 1000, 
              description = "Sent to a specific packer slave",
              client_export = false
            ]
            NotifyWorkerPackerSessionAvailable(Blaze::GameManager::NotifyWorkerPackerSessionAvailable);
            
            [
              id = 1001, 
              description = "Sent to a specific packer slave",
              client_export = false
            ]
            NotifyWorkerPackerSessionRelinquish(Blaze::GameManager::NotifyWorkerPackerSessionRelinquish); // e.g.: session had its members updated...

            [
              id = 1002, 
              description = "Sent to a specific packer slave",
              client_export = false
            ]
            NotifyWorkerPackerSessionTerminated(Blaze::GameManager::NotifyWorkerPackerSessionTerminated); // e.g.: when session timed out on the master

            // PACKER_TODO: These notifications are currently sent to the GM slaves in order to mimic a the MM slave API, hopefully we can get rid of them eventually
            [
              id = 1,
              description = "Sent when a matchmaking session ends (either successfully or due to cancel/timeout/error).",
              details = "Note: if startMatchmaking failed, no session was created, so there's no finished notification.",
              client_export = false
            ]
            NotifyMatchmakingFailed(Blaze::GameManager::NotifyMatchmakingFinished);
            
            [
              id = 2,
              description = "Sent when a matchmaking session status changed or time due( when session started/rule decay/timeout/period set in config.)",
              details = "Player who start matchmaking session should listen to the notification and update it's local cached satus data.",
              client_export = false
            ]
            NotifyMatchmakingAsyncStatus(Blaze::GameManager::NotifyMatchmakingAsyncStatus);

            [
              id = 3,
              description = "Sent when a matchmaking session ends successfully.",
              details = "Note: we always send this, even if the matchmaking failed.",
              client_export = false
            ]
            NotifyMatchmakingFinished(Blaze::GameManager::NotifyMatchmakingFinished);
            
            [
              id = 4,
              description = "Sent when a matchmaking session has completed connection validation (either success or failure).",
              details = "This notification goes to the GameManager slave, which forwards it on as a GameManager notification",
              client_export = false
            ]
            NotifyMatchmakingSessionConnectionValidated(Blaze::GameManager::NotifyMatchmakingSessionConnectionValidated);

            [
              id = 5,
              description = "Sent after gamemanager has added a matchmaking session's reserved external players to the matched game.",
              details = "This notification is sent by matchmaking slaves to gamemanager slaves. Sends the list of players from the original matchmaking request's reserved external players list, who were reserved into the game. This notification is received after all players in the matchmup have issued their join to the external session.",
              client_export = false
            ]
            NotifyServerMatchmakingReservedExternalPlayers(Blaze::GameManager::NotifyServerMatchmakingReservedExternalPlayers);

        } // master notifications

        events
        {
            // TBD
        } // master events
        
     } // master

} // Component
} // GamePacker
} // Blaze
