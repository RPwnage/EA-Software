/*************************************************************************************************/
/*!
    \file   messagingslaveimpl.cpp


    \attention
        (c) Electronic Arts. All Rights Reserved.
*/
/*************************************************************************************************/

/*************************************************************************************************/
/*!
    \class MessagingSlaveImpl

    Messaging Slave implementation.

    \note

*/
/*************************************************************************************************/

/*** Include Files *******************************************************************************/
// main include
#include "framework/blaze.h"
#include "messagingslaveimpl.h"

// blaze includes
#include "framework/connection/selector.h"
#include "framework/usersessions/usersession.h"
#include "framework/usersessions/userinfo.h"
#include "framework/usersessions/usersessionmanager.h"
#include "framework/userset/userset.h"
#include "framework/event/eventmanager.h"
#include "framework/identity/identity.h"
#include "framework/controller/controller.h"
#include "framework/uniqueid/uniqueidmanager.h"
#include "framework/util/localization.h"
#include "framework/util/profanityfilter.h"
#include "framework/replication/replicator.h"
#include "framework/replication/replicatedmap.h"

#include "framework/database/dbrow.h"
#include "framework/database/dbconn.h"
#include "framework/database/dbscheduler.h"
#include "framework/database/dbconnpool.h"

// messaging includes
#include "messaging/tdf/messaging_server.h"
#include "messaging/tdf/messagingevents_server.h"

#include "framework/grpc/outboundgrpcmanager.h"
#include "eadp/profanity/profanity_filter.grpc.pb.h"

namespace Blaze
{
namespace Messaging
{
    const char8_t* MESSAGING_SWEEP_TASK_NAME = "MessagingSlaveImpl::doSweep";

/**
 * MessageLocalizer is a handy class that caches parameterizable, localized
 * attribute strings (and their parameters) once, and then can localize them any number
 * of times using a DIFFERENT locale. The storage used by MessageLocalizer is fixed and
 * determined by the number of localizable attributes in the AttrMap and their optional parameters.
 * MessageLocalizer depends on the AttrMap in order to perform the localization
 * process; however, once localization is performed, MessageLocalizer can be safely destroyed
 * even as the AttrMap continues to use the localized strings generated by MessageLocalizer.
 */
class MessageLocalizer
{
NON_COPYABLE(MessageLocalizer);

public:
    MessageLocalizer(MessageAttrMap& attrMap);
    ~MessageLocalizer();
    void localize(uint32_t locale);

private:
    struct AttrInfo
    {
        AttrValue attrVal;
        const char* params[PARAM_COUNT_LIMIT];
        uint32_t numParams;
    };

    typedef eastl::vector<AttrInfo> AttrInfoList;

    MessageAttrMap& mAttrMap;
    AttrInfoList mList;
};

MessageLocalizer::MessageLocalizer(MessageAttrMap& attrMap) : mAttrMap(attrMap)
{
    // walk the attribute map starting at first localizable attribute and populate the localizable attribute list
    MessageAttrMap::iterator mi = mAttrMap.begin();
    MessageAttrMap::iterator me = mAttrMap.lower_bound(PARAM_ATTR_MIN);
    for (; mi != me; ++mi)
    {
        // NOTE: its more efficient to construct an empty string and then set it, than to have the container copy-construct it
        mList.push_back();
        mList.back().attrVal.set(mi->second.c_str());
        const uint32_t paramMin = PARAM_ATTR_MIN + mi->first*PARAM_COUNT_LIMIT; // first parameter
        const uint32_t paramMax = PARAM_ATTR_MIN + mi->first*PARAM_COUNT_LIMIT + PARAM_COUNT_LIMIT - 1; // last parameter
        MessageAttrMap::const_iterator ps = mAttrMap.lower_bound(paramMin);
        MessageAttrMap::const_iterator pe = mAttrMap.upper_bound(paramMax);
        uint32_t param = 0;
        // iterate the parameters and add them to the parameter array required by Localization
        for (MessageAttrMap::const_iterator pi = ps; pi != pe; ++pi, ++param)
        {
            // duplicate the string because we have to erase the parameters before sending message to client
            mList.back().params[param] = blaze_strdup(pi->second.c_str());
        }
        mList.back().numParams = param; // set the count of parameters required by Localization
    }

    mi = me; // first parameter
    me = mAttrMap.upper_bound(PARAM_ATTR_MAX); // last parameter
    if (mi != me)
    {
        // erase all parameter attributes before we send the message down to the client
        mAttrMap.erase(mi, me);
    }
}

MessageLocalizer::~MessageLocalizer()
{
    for (AttrInfoList::iterator li = mList.begin(), le = mList.end(); li != le; ++li)
    {
        for (uint32_t i = 0; i < li->numParams; ++i)
        {
            // must deallocate blaze_strdup`d param strings here...
            BLAZE_FREE((char8_t*) li->params[i]);
        }
    }
}

void MessageLocalizer::localize(uint32_t locale)
{
    //////////////////////////////////////////////////////////
    // NOTE:
    // It's far more efficient to only translate the attributes once for each _locale_ and keep them in a hash;
    // however, this may take a longer to implement and since messages with localizable attributes should 
    // be sent infrequently by server components and mainly to individual users. That last bit is important, 
    // because sending messages to users individually is a lot slower because it requires the slave to perform Heat 
    // encoding of the TDF for each Blaze connection, instead of once for each locale.
    // With Dave O's blessing we went for the simpler solution you see below.
    // i.e.: each locale specific attribute is localized once for each message recepient.
    //
    // ALSO NOTE:
    // We are using a vector of EA::TDF::TdfString objects to store copies of localizable strings, even though currently
    // the Attributes in MessageAttrMap do not own their underlying strings, which means that we could have used 
    // some tricks with EA::TDF::TdfString::assignBuffer() to swap pointers around instead of allocating. This would have been
    // much more efficient but also somewhat dangerous because it would tie us to the implementation of character buffer
    // ownership by the EA::TDF::TdfString class. Ultimately this should be a non issue since localizable attributes should be
    // seldomly included in messages. But if performance becomes a problem, improving string allocation efficiency may be 
    // a good candidate...
    ///////////////////////////////////////////////////////////

    // set the attribute iterator to point to first localizable attribute
    MessageAttrMap::iterator mi = mAttrMap.begin();
    // iterate the localizable attribute list and look up attributes using session's locale
    for (AttrInfoList::iterator li = mList.begin(), le = mList.end(); li != le; ++li, ++mi)
    {
        // no substitution parameters, use faster localization
        const char8_t* localized = gLocalization->localize(li->attrVal.c_str(), locale);
        if (localized != nullptr)
        {
            char8_t localizedBuffer[MSG_ATTR_STR_MAX+1];
            if (li->numParams != 0)
            {
                // have substitution parameters, perform substitution
                int32_t result = gLocalization->localizeChar(
                    localized,
                    locale,
                    localizedBuffer,
                    MSG_ATTR_STR_MAX,
                    li->params,
                    li->numParams
                );
                if (result >= 0)
                {
                    localized = localizedBuffer;
                }
                else
                {
                    WARN_LOG("[MessageLocalizer].localize - failed to localize attribute(" << mi->first << "," << localized 
                             << "), err: " << result);
                }
            }
            // update the attribute map entry of the outging server message
            // with the localized version of the attribute
            mi->second.set(localized);
        }
        else
        {
            WARN_LOG("[MessageLocalizer].localize - failed to localize attribute(" << mi->first << "," << li->attrVal.c_str() << ")");
        }
    }
}

// static
MessagingSlave* MessagingSlave::createImpl()
{
    return BLAZE_NEW_NAMED("MessagingSlaveImpl") MessagingSlaveImpl();
}

/*** Public Methods ******************************************************************************/
MessagingSlaveImpl::MessagingSlaveImpl()
    : mSweepTaskId(INVALID_TASK_ID)
    , mForwardedRegularMessages(getMetricsCollection(), "slaveForwardedRegularMessages")
    , mForwardedPersistentMessages(getMetricsCollection(), "slaveForwardedPersistentMessages")
    , mDeliveredRegularMessages(getMetricsCollection(), "slaveDeliveredRegularMessages")
    , mDeliveredPersistentMessages(getMetricsCollection(), "slaveDeliveredPersistentMessages")
    , mProfanityFilteredMessages(getMetricsCollection(), "slaveProfanityFilteredMessages")
    , mLocalizedMessages(getMetricsCollection(), "slaveLocalizedMessages")
    , mDroppedInboundMessages(getMetricsCollection(), "slaveDroppedInboundMessages")
    , mPurgedMessages(getMetricsCollection(), "slavePurgedMessages")
    , mFetchedMessages(getMetricsCollection(), "slaveFetchedMessages")
    , mTouchedMessages(getMetricsCollection(), "slaveTouchedMessages")
    , mInvalidSenderIdentityWarnings(getMetricsCollection(), "slaveInvalidSenderIdentityWarnings")
    , mInvalidTargetWarnings(getMetricsCollection(), "slaveInvalidTargetWarnings")
    , mTargetNotFoundWarnings(getMetricsCollection(), "slaveTargetNotFoundWarnings")
    , mTargetInboxFullWarnings(getMetricsCollection(), "slaveTargetInboxFullWarnings")
    , mSweptStaleMessages(getMetricsCollection(), "sweptStaleMessages")
    , mMessageDbSweeps(getMetricsCollection(), "messageDbSweeps")
    , mEmptyMessageDbSweeps(getMetricsCollection(), "emptyMessageDbSweeps")
    , mFailedMessageDbSweeps(getMetricsCollection(), "failedMessageDbSweeps")
{
}

MessagingSlaveImpl::~MessagingSlaveImpl()
{
}

void MessagingSlaveImpl::getStatusInfo(ComponentStatus& status) const
{
    char8_t buf[32];
    ComponentStatus::InfoMap& map = status.getInfo();

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mForwardedRegularMessages.getTotal());
    map["TotalSlaveForwardedRegularMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mForwardedPersistentMessages.getTotal());
    map["TotalSlaveForwardedPersistentMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mDeliveredRegularMessages.getTotal());
    map["TotalSlaveDeliveredRegularMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mDeliveredPersistentMessages.getTotal());
    map["TotalSlaveDeliveredPersistentMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mProfanityFilteredMessages.getTotal());
    map["TotalSlaveProfanityFilteredMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mLocalizedMessages.getTotal());
    map["TotalSlaveLocalizedMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mDroppedInboundMessages.getTotal());
    map["TotalSlaveDroppedInboundMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mPurgedMessages.getTotal());
    map["TotalSlavePurgedMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mFetchedMessages.getTotal());
    map["TotalSlaveFetchedMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mTouchedMessages.getTotal());
    map["TotalSlaveTouchedMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mInvalidSenderIdentityWarnings.getTotal());
    map["TotalSlaveInvalidSenderIdentityWarnings"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mInvalidTargetWarnings.getTotal());
    map["TotalSlaveInvalidTargetWarnings"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mTargetNotFoundWarnings.getTotal());
    map["TotalSlaveTargetNotFoundWarnings"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mTargetInboxFullWarnings.getTotal());
    map["TotalSlaveTargetInboxFullWarnings"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mSweptStaleMessages.getTotal());
    map["TotalSweptStaleMessages"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mMessageDbSweeps.getTotal());
    map["TotalMessageDbSweeps"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mEmptyMessageDbSweeps.getTotal());
    map["TotalEmptyMessageDbSweeps"] = buf;

    blaze_snzprintf(buf, sizeof(buf), "%" PRIu64, mFailedMessageDbSweeps.getTotal());
    map["TotalFailedMessageDbSweeps"] = buf;

}

bool MessagingSlaveImpl::onValidateConfig(MessagingConfig& config, const MessagingConfig* referenceConfigPtr, ConfigureValidationErrors& validationErrors) const
{
    if (config.getPersistent().getEnabled())
    {
        if (config.getPersistent().getMessageLimit() == 0)
        {
            WARN_LOG("[MessagingSlaveImpl].onValidateConfig: User storage for persistent messages is UNLIMITED.");
        }

        if (config.getPersistent().getMessageSweepInterval() == 0LL)
        {
            WARN_LOG("[MessagingSlaveImpl].onValidateConfig: Inbox sweep is disabled.");
        }

        if (config.getPersistent().getMessageExpiryInterval() == 0LL)
        {
            WARN_LOG("[MessagingSlaveImpl].onValidateConfig: Message expiration is disabled.");
        }
    }

    return true;
}

bool MessagingSlaveImpl::onConfigure()
{
    if (gUniqueIdManager->reserveIdType(RpcMakeSlaveId(MessagingSlave::COMPONENT_ID), MESSAGING_IDTYPE_MESSAGE) != ERR_OK)
    {
        ERR_LOG("[MessagingSlaveImpl].onConfigure: Failed reserving message id " << 
            RpcMakeSlaveId(MessagingSlave::COMPONENT_ID) << " with unique id manager");
        return false;
    }

    BlazeRpcError rc = ERR_SYSTEM;
    TaskSchedulerSlaveImpl *sched = static_cast<TaskSchedulerSlaveImpl*>
        (gController->getComponent(TaskSchedulerSlave::COMPONENT_ID, true, true, &rc));
    if (sched == nullptr)
    {
        return false;
    }

    sched->registerHandler(COMPONENT_ID, this);

    return configure(false);
}  /*lint !e1961 - Avoid lint to check whether virtual member function could be made const*/

bool MessagingSlaveImpl::onReconfigure()
{
    configure(true);
    return true;
}

bool MessagingSlaveImpl::onPrepareForReconfigure(const MessagingConfig& config)
{
    if (config.getPersistent().getEnabled())
    {
        if (dbConfigure() != Blaze::ERR_OK)
        {
            return false;
        }
    }
    return true;
}

bool MessagingSlaveImpl::configure(bool reconfigure)
{
    const MessagingConfig &config = getConfig();
    TRACE_LOG("[MessagingSlaveImpl].configure");

    if (config.getPersistent().getEnabled())
    {
        if (config.getPersistent().getMessageLimit() > 0)
        {
            INFO_LOG("[MessagingSlaveImpl].configure: User storage limited to <" << config.getPersistent().getMessageLimit() 
                     << "> persistent messages.");
        }
        else
        {
            WARN_LOG("[MessagingSlaveImpl].configure: User storage for persistent messages is UNLIMITED.");
        }
        if (!reconfigure)
        {
            if (dbConfigure() != Blaze::ERR_OK)
            {
                ERR_LOG("[MessagingSlaveImpl].configure: Failed to get limits from db.");
                return false;
            }
        }
        mPersistentMessageAttributeLimit = mTempPersistentMessageAttributeLimit;
        TRACE_LOG("[MessagingSlaveImpl].configure: Db supports up to (" << mPersistentMessageAttributeLimit 
                 << ") persistent message attributes.");

        if (config.getPersistent().getMessageSweepInterval() != 0LL)
        {
            // build the sweep skip list:
            mSkipSweepTypeList.clear();
            const TypeDataList& typeDataList = getConfig().getPersistent().getTypes();
            for (TypeDataList::const_iterator it = typeDataList.begin(), itend = typeDataList.end(); it != itend; ++it)
            {
                if ((*it)->getSkipSweep())
                {
                    mSkipSweepTypeList.push_back((*it)->getType());
                }
            }

            if (mSweepTaskId != INVALID_TASK_ID)
            {
                TaskSchedulerSlaveImpl *sched = static_cast<TaskSchedulerSlaveImpl*>
                    (gController->getComponent(TaskSchedulerSlave::COMPONENT_ID, true, true, nullptr));
                if (sched == nullptr)
                {
                    return false;
                }

                // we already have a sweep task scheduled, but the sweep interval
                // might have been changed since we last scheduled it
                const ScheduledTaskInfo* scheduledTask = sched->getTask(mSweepTaskId);
                if (scheduledTask != nullptr)
                {
                    if (scheduledTask->getRecurrence() != config.getPersistent().getMessageSweepInterval().getSec())
                    {
                        // cancel the old sweep task and schedule new one with new sweep interval value
                        // -- the re-scheduling will be done in onCanceledTask
                        cancelSweep();
                    }
                }
            }
            else
            {
                scheduleSweep();
            }
        }
        else
        {
            // make sure sweeping is disabled
            cancelSweep();
        }
    }
    else
    {
        // make sure sweeping is disabled
        cancelSweep();
    }

    if (config.getProfanityConfig().getUseProfanityService())
    {
        if (config.getProfanityConfig().getProfanityServiceFilterId() == nullptr || config.getProfanityConfig().getProfanityServiceFilterId()[0] == '\0')
        {
            ERR_LOG("[MessagingSlaveImpl.configure]: Configuration failure. Trying to use profanity service with a null or empty filter id for service.");
            return false;
        }
        
        if (config.getProfanityConfig().getProfanityServiceFilterId() != nullptr &&
            strlen(config.getProfanityConfig().getProfanityServiceFilterId()) > (config.getProfanityConfig().getProfanityServiceFilterIdMaxStringLength()-1))
        {
            ERR_LOG("[MessagingSlaveImpl.configure]: Configuration failure. Trying to use profanity service with the filter id(" << config.getProfanityConfig().getProfanityServiceFilterId() << ") that is bigger than allowed length("
                << (config.getProfanityConfig().getProfanityServiceFilterIdMaxStringLength() - 1) << ").");
            return false;
        }
    }
    return true;
}

BlazeRpcError MessagingSlaveImpl::dbConfigure()
{
    // using lag free conn to avoid DB replication lag (especially on server starts where
    // dbmig is creating the messaging tables) which can prevent messaging slave from starting up
    DbConnPtr dbConn = gDbScheduler->getLagFreeReadConnPtr(getDbId(), LOGGING_CATEGORY);
    if (dbConn == nullptr)
    {
        // failed to obtain connection
        ERR_LOG("[MessagingSlaveImpl].dbConfigure: Failed to obtain connection");
        return Blaze::ERR_SYSTEM;
    }

    BlazeRpcError dbrc;
    QueryPtr query = DB_NEW_QUERY_PTR(dbConn);
    if (query != nullptr)
    {
        DbResultPtr dbResult;
        const char8_t* dbName = dbConn->getDbConnPool().getDbConfig().getDatabase();
        // query to obtain the maximum number of message attributes supported by the database
        // NOTE: use 'show columns' query because it is much faster than a query on information_schema.columns,
        // for details see: http://dev.mysql.com/doc/refman/5.1/en/information-schema-optimization.html
        query->append("show columns from messaging_inbox from `$s` like 'attr_key%';", dbName);

        dbrc = dbConn->executeQuery(query, dbResult); 
        if (dbrc == DB_ERR_OK)
        {
            if (!dbResult->empty())
            {
                // set the maximum number of message attributes supported by the database
                mTempPersistentMessageAttributeLimit = static_cast<uint32_t>(dbResult->size());
                if (mTempPersistentMessageAttributeLimit > 0)
                {
                    
                    TRACE_LOG("[MessagingSlaveImpl].dbConfigure: Database(" << dbName << ") "
                        "supports(" << mTempPersistentMessageAttributeLimit << ") persistent message attributes");
                    dbrc = DB_ERR_OK;
                }
                else
                {
                    ERR_LOG("[MessagingSlaveImpl].dbConfigure: Database(" << dbName << ") "
                        "does not support persistent message attributes");
                    dbrc = DB_ERR_SYSTEM;
                }
            }
            else
            {
                ERR_LOG("[MessagingSlaveImpl].dbConfigure: Query for persistent "
                    "message attribute limits returned empty resultset.");
                dbrc = DB_ERR_SYSTEM;
            }
        }
        else
        {
            // query failed
            ERR_LOG("[MessagingSlaveImpl].dbConfigure: Query failed reason(" << getDbErrorString(dbrc) << ")");
        }
    }
    else
    {
        // failed to create query
        ERR_LOG("[MessagingSlaveImpl].dbConfigure: Failed to create query");
        dbrc = DB_ERR_SYSTEM;
    }

    return (dbrc == DB_ERR_OK ? Blaze::ERR_OK : Blaze::ERR_SYSTEM);
}

void MessagingSlaveImpl::sendMessageToUserSessions(ServerMessage& serverMessage, const UserSessionIdVectorSet& userSessionIds)
{
    // if we get here means message will be delivered to sessions, the counts
    // are 'approximate' because one recepient may be filtered by noecho flag...
    if (serverMessage.getPayload().getFlags().getPersistent())
    {
        mDeliveredPersistentMessages.increment(userSessionIds.size());
    }
    else
    {
        mDeliveredRegularMessages.increment(userSessionIds.size());
    }

    if (!serverMessage.getPayload().getFlags().getLocalize() || serverMessage.getPayload().getAttrMap().empty())
    {
        // If no localizable attributes, then do a fast aggregate send
        sendNotifyMessageToUserSessionsById(userSessionIds.begin(), userSessionIds.end(), UserSessionIdIdentityFunc(), &serverMessage);
    }
    else
    {
        // Have localizable attributes; must localize the message for each session
        sendLocalizedMessageToSessions(serverMessage, userSessionIds);
    }
}

void MessagingSlaveImpl::broadcastMessage(ServerMessage& serverMessage, const UserSessionIdList& targetUserSessionIdList, const UserSessionIdList& sourceSessionIds)
{
    UserSessionIdVectorSet userSessionIdSet;

    // If the ClientMessage contained in the request is a non-persistent message and the TargetIds
    // contained in the request is empty, it means that this request need to send to all online users which
    // connect to the current slave. 
    if (serverMessage.getPayload().getTargetIds().empty())
    {
        // Get user ids of all online users using UserSessionManager
        for (UserSessionManager::UserSessionPtrByIdMap::const_iterator itr = gUserSessionManager->getUserSessionPtrByIdMap().begin(), end = gUserSessionManager->getUserSessionPtrByIdMap().end(); itr != end; ++itr)
        {
            userSessionIdSet.insert(itr->second->getUserSessionId());
        }
    }
    else
    {
        const bool omitSelf = !serverMessage.getPayload().getFlags().getIncludeSelf() && !serverMessage.getPayload().getFlags().getEcho();
        const EA::TDF::ObjectId source = serverMessage.getSource();
        for (UserSessionIdList::const_iterator it = targetUserSessionIdList.begin(), end = targetUserSessionIdList.end(); it != end; ++it)
        {
            UserSessionId userSessionId = *it;

            UserInfoPtr userInfo;
            UserSessionPtr userSession = gUserSessionManager->getSession(userSessionId);
            if ((userSession != nullptr) && (userSession->fetchUserInfo(userInfo) == ERR_OK))
            {
                EA::TDF::ObjectId id = userInfo->getBlazeObjectId();
                if (omitSelf && (source == id))
                    continue;

                // only add local sessions that must not be omitted
                userSessionIdSet.insert(*it);
            }
        }

        // If message had session ids by source, ensure echo targets its local sessions here.
        userSessionIdSet.insert(sourceSessionIds.begin(), sourceSessionIds.end());
    }
    
    if (userSessionIdSet.empty())
    {
        mDroppedInboundMessages.increment();
        return;
    }
    
    sendMessageToUserSessions(serverMessage, userSessionIdSet);
}


BlazeRpcError MessagingSlaveImpl::fillSourceName(ServerMessage& message)
{
    BlazeRpcError rc;
    IdentityInfo identityInfo;
    const EA::TDF::ObjectType entityType = message.getSource().type;
    const EntityId entityId = message.getSource().id;

    if (entityType == ENTITY_TYPE_USER)
    {
        UserInfoPtr userInfo;
        rc = gUserSessionManager->lookupUserInfoByBlazeId(entityId, userInfo);

        if (rc == ERR_OK && userInfo != nullptr)
        {
            UserInfo::filloutUserCoreIdentification(*userInfo, message.getSourceIdent());
        }
        else
        {
            mInvalidSenderIdentityWarnings.increment();
        }
        return rc;
    }

    rc = gIdentityManager->getIdentity(entityType, entityId, identityInfo);
    if (rc == Blaze::ERR_OK)
    {
        message.getSourceIdent().setName(identityInfo.getIdentityName());
    }
    else
    {
        mInvalidSenderIdentityWarnings.increment();
    }
    return rc;
}

Blaze::BlazeRpcError MessagingSlaveImpl::sendLocalizedMessageToSessions(ServerMessage& serverMessage, const UserSessionIdVectorSet& userSessionIds)
{
    MessageLocalizer localizer(serverMessage.getPayload().getAttrMap());

    // NOTE: Message has localizable attributes, then we need to localize message for each session
    for (UserSessionIdVectorSet::const_iterator it = userSessionIds.begin(), end = userSessionIds.end(); it != end; ++it)
    {
        UserSessionId userSessionId = *it;

        // write localized strings to AttrMap
        localizer.localize(gUserSessionManager->getSessionLocale(userSessionId));

        // send to session
        sendNotifyMessageToUserSessionById(userSessionId, &serverMessage);

        // count each send because we do them individually
        mLocalizedMessages.increment();
    }
    return Blaze::ERR_OK;
}

BlazeRpcError MessagingSlaveImpl::getNextUniqueMessageId(MessageId& messageId)
{
    BlazeRpcError error = gUniqueIdManager->getId(RpcMakeSlaveId(MessagingSlave::COMPONENT_ID), MESSAGING_IDTYPE_MESSAGE, messageId);
    if (error != ERR_OK)
    {
        WARN_LOG("[MessagingSlaveImpl].getNextUniqueMessageId: failed to get the next message id.");
    }

    return error;
}

struct SlaveSessionFunc
{
    SlaveSessionFunc(const SlaveSessionList* slaveSessionList)
        : mSlaveSessionList(slaveSessionList) {}

    SlaveSession *operator()(const SlaveSessionId slaveSessionId)
        { return mSlaveSessionList->getSlaveSession(slaveSessionId); }
        
    const SlaveSession *operator()(const SlaveSessionId slaveSessionId) const
        { return mSlaveSessionList->getSlaveSession(slaveSessionId); }

private:
    const SlaveSessionList* mSlaveSessionList; 
};

Blaze::BlazeRpcError MessagingSlaveImpl::sendMessage(const EA::TDF::ObjectId &source, ClientMessage& message, MessageIdList* messageIds, bool isGlobalMessage)
{
    bool overwriteFlag = getConfig().getPersistent().getMessageOverwrite();
    uint32_t messageLimit = getConfig().getPersistent().getMessageLimit();

    BlazeRpcError rc = ERR_OK;
    if (!(message.getFlags().getPersistent() ? getConfig().getPersistent().getEnabled() : getConfig().getRegular().getEnabled()))
    {
        return MESSAGING_ERR_FEATURE_DISABLED;
    }

    if (message.getFlags().getPersistent())
    {
        if (gCurrentUserSession != nullptr && gCurrentUserSession->isGuestSession())
        {
            WARN_LOG("[MessagingSlaveImpl].sendMessage - user session: " << gCurrentUserSession 
                << " is guest session which is not allowed to send persistent messages.");
            return Blaze::ERR_GUEST_SESSION_NOT_ALLOWED;
        }
    }

    const size_t numAttrs = message.getAttrMap().size();
    const uint32_t attrLimit = message.getFlags().getPersistent() ? mPersistentMessageAttributeLimit : getConfig().getRegular().getMessageAttributeLimit();
    if (numAttrs > attrLimit)
    {
        WARN_LOG("[MessagingSlaveImpl].sendMessage - # of message attributes(" << numAttrs << "), "
            "exceeded the maximum limit(" << attrLimit << ")");
        return MESSAGING_ERR_MAX_ATTR_EXCEEDED;       
    }

    if (message.getTargetType() == EA::TDF::OBJECT_TYPE_INVALID)
    {
        WARN_LOG("[SendMessageCommand].sendMessage - Message target type(" << message.getTargetType().toString().c_str() << ") is invalid");
        mInvalidTargetWarnings.increment();
        return MESSAGING_ERR_TARGET_TYPE_INVALID;
    } 
    
    if (message.getFlags().getFilterProfanity())
    {
        mProfanityFilteredMessages.increment();

        // Build the string list to be filtered: 
        eastl::vector<EA::TDF::TdfString*> filterBatch;
        for (auto iter = message.getAttrMap().begin(), end = message.getAttrMap().upper_bound(PARAM_ATTR_MIN - 1); iter != end; ++iter)
            filterBatch.push_back(&iter->second);

        // If a filterId is provided, the batchFilter will attempt to use it with the service:
        const char8_t* filterId = getConfig().getProfanityConfig().getUseProfanityService() ? getConfig().getProfanityConfig().getProfanityServiceFilterId() : nullptr;
        // The batch filter will work on either the old filter or the new service (depending on the config):
        int32_t results = gProfanityFilter->batchFilter(filterBatch, true, filterId);
        
        if (gProfanityFilter->usingProfanityService())
        {
            // Negative results means there was a system error 
            if (results < 0)
                return MESSAGING_ERR_PROFANITY_SYSTEM;
        }
    }

    const TypeDataList& typeDataList = getConfig().getPersistent().getTypes();
    for (TypeDataList::const_iterator it = typeDataList.begin(), itend = typeDataList.end(); it != itend; ++it)
    {
        if (message.getType() == (*it)->getType())
        {
            overwriteFlag = (*it)->getOverwrite();
            messageLimit = (*it)->getLimit(); 
            break;
        }
    }

    ServerMessage serverMessage;
    serverMessage.setTimestamp(static_cast<Timestamp>(TimeValue::getTimeOfDay().getSec()));
    
    // check whether or not we specify a source sender, before resolving it.
    if (!isMessageSourceOmitted(source))
    {
        serverMessage.setSource(source);
        rc = fillSourceName(serverMessage);
        if (rc != ERR_OK)
        {
            WARN_LOG(
                "[MessagingSlaveImpl].sendMessage - identity system "
                "failed to resolve source name for (" << source.toString().c_str() 
                << ") reason: " << (ErrorHelp::getErrorName(rc)));
            // possible session disconnect/timeout error, exit immediately (GOS-6064 fix)
            return rc;
        }
    }    
    serverMessage.setPayload(message); // link client message even on partial success

    TargetIdList& targetIds = message.getTargetIds();

    if (message.getFlags().getPersistent())
    {
        BlazeIdList blazeIds;

        // Validate the message target using UserSetManager
        if (message.getTargetType() == ENTITY_TYPE_USER)
        {
            blazeIds.reserve(targetIds.size());
            for (TargetIdList::iterator i = targetIds.begin(), e = targetIds.end(); i != e ; ++i)
            {
                BlazeId blazeId = *i;
                if ((blazeId != INVALID_BLAZE_ID) && !UserSessionManager::isStatelessUser(blazeId))
                    blazeIds.push_back(blazeId);
            }
        }
        else
        {
            for (TargetIdList::iterator it = targetIds.begin(), itEnd = targetIds.end(); it != itEnd; ++it)
            {
                EA::TDF::ObjectId targetId = EA::TDF::ObjectId(message.getTargetType(), *it);

                BlazeIdList ids;
                rc = gUserSetManager->getUserBlazeIds(targetId, ids);
                if (rc != ERR_OK)
                {
                    TRACE_LOG("[MessagingSlaveImpl].sendMessage - Message target("
                        << message.getTargetType().toString().c_str() << ") has no matching users, error: "
                        << ErrorHelp::getErrorName(rc));
                    mTargetNotFoundWarnings.increment();
                }

                blazeIds.insert(blazeIds.end(), ids.begin(), ids.end());
            }   
        }

        if (blazeIds.empty())
        {
            return MESSAGING_ERR_TARGET_NOT_FOUND;
        }
        
        bool selfTargetByEcho = false;
        // if message has a source, add/remove it from targets (local blaze id list), depending on echo/includeSelf flags
        if (!isMessageSourceOmitted(source))
        {
            if (message.getFlags().getEcho())
            {
                bool found = false;
                // add self unless already in the target list
                for (BlazeIdList::iterator i = blazeIds.begin(), e = blazeIds.end(); i != e; ++i)
                {
                    BlazeId blazeId = *i;
                    if (blazeId == source.id)
                    {
                        found = true;
                        break;
                    }
                }
                if (!found && !UserSessionManager::isStatelessUser(source.id))
                {
                    blazeIds.push_back(source.id);
                    selfTargetByEcho = true;
                }
            }
            else if (!message.getFlags().getIncludeSelf() && (blazeIds.size() > 1))
            {
                // remove self if already in the target list (local blaze id list), and we are not the only target
                BlazeIdList::iterator i = blazeIds.begin();
                while (i != blazeIds.end())
                {
                    BlazeId blazeId = *i;
                    if (blazeId == source.id)
                        i = blazeIds.erase(i);
                    else
                        ++i;
                }
            }
        }
        
        if (blazeIds.empty() || ((blazeIds.size() == 1) && selfTargetByEcho))
        {
            StringBuilder targetIdsString(nullptr);
            for (TargetIdList::iterator i = message.getTargetIds().begin(), e = message.getTargetIds().end(); i != e; ++i)
            {
                targetIdsString << *i;
                targetIdsString << ",";
            }

            targetIdsString.trim(1); // trim last comma
            targetIdsString << ")";

            WARN_LOG("[MessagingSlaveImpl].sendMessage - Message targetType("
                << message.getTargetType().toString().c_str() << "), " << "targetIds(" 
                << targetIdsString.get() << " has no matching users, error: "
                << ErrorHelp::getErrorName(rc));
            mTargetNotFoundWarnings.increment();
            return MESSAGING_ERR_TARGET_NOT_FOUND;
        }

        uint32_t inboxFullCount = 0;
        EA::TDF::ObjectId targetId;
        targetId.type = ENTITY_TYPE_USER;
        serverMessage.getPayload().setTargetType(ENTITY_TYPE_USER);
        for (BlazeIdList::const_iterator i = blazeIds.begin(), e = blazeIds.end(); i != e; ++i)
        {
            targetId.id = *i;

            UserSessionIdList targetUserSessionIdList;
            rc = gUserSetManager->getSessionIds(targetId, targetUserSessionIdList);
            if (rc != ERR_OK)
            {
                WARN_LOG("[MessagingSlaveImpl].sendMessage - Message target("
                    << targetId.toString().c_str() << ") has no matching sessions, error: "
                    << ErrorHelp::getErrorName(rc));
                mTargetNotFoundWarnings.increment();
                return MESSAGING_ERR_TARGET_NOT_FOUND;
            }//else
            // NOTE: Even if no sessions are found, we are writing a persistent message, so proceed anyway

            serverMessage.getPayload().getTargetIds().clear();
            serverMessage.getPayload().getTargetIds().push_back(targetId.id);

            MessageId messageId = MESSAGE_ID_INVALID;
            rc = getNextUniqueMessageId(messageId); // get unique message id from unique id manager
            if (rc != ERR_OK)
            {
                ERR_LOG("[MessagingSlaveImpl].sendMessage - Failed to get unique message id, error: " << ErrorHelp::getErrorName(rc));
                return rc;
            }
            serverMessage.setMessageId(messageId); 

            const bool suppressWriteToInbox = (selfTargetByEcho && targetId == source);
            if (!suppressWriteToInbox)
            {
                rc = writeMessageToDb(getDbId(), &serverMessage, overwriteFlag, messageLimit, mPersistentMessageAttributeLimit);
                if ((rc != ERR_OK) && (rc != MESSAGING_ERR_TARGET_INBOX_FULL))
                {
                    ERR_LOG("[MessagingSlaveImpl].sendMessage - Failed writing message to database, error: " << ErrorHelp::getErrorName(rc));
                    return rc;
                }
            }

            // Send to all the targets
            broadcastMessage(serverMessage, targetUserSessionIdList, UserSessionIdList());

            if (!suppressWriteToInbox)
            {
                // Populate messageIds if not nullptr
                if (messageIds != nullptr && !message.getFlags().getOmitMessageIds())
                {
                    messageIds->push_back(serverMessage.getMessageId());
                }
                mForwardedPersistentMessages.increment();
                if (rc == Blaze::MESSAGING_ERR_TARGET_INBOX_FULL)
                {
                    // only persistent messages go into a recepient's inbox
                    mTargetInboxFullWarnings.increment();
                    ++inboxFullCount;
                }
                // submit the message sent event
                genMessagingSentEvent(serverMessage);
            }
        }
        if (inboxFullCount > 0)
        {
            // even if we succeed writing some messages, if at least one failed due to
            // inbox full condition, we return the inbox full error code...
            rc = MESSAGING_ERR_TARGET_INBOX_FULL;
        }
    }
    else
    {
        UserSessionIdList targetUserSessionIdList;
        UserSessionIdList sourceUserSessionIdList;

        if (!isGlobalMessage)
        {
            if (!isMessageSourceOmitted(source) && message.getFlags().getEcho())
            {
                rc = gUserSetManager->getSessionIds(source, sourceUserSessionIdList);
                if (rc != Blaze::ERR_OK)
                {
                    TRACE_LOG("[MessagingSlaveImpl].sendMessage - Message source("
                        << source.toString().c_str() << ") has no matching users, error: "
                        << ErrorHelp::getErrorName(rc));
                    mTargetNotFoundWarnings.increment();
                    return MESSAGING_ERR_TARGET_NOT_FOUND;
                }

                // in this case, rc would be ERR_OK
                if (targetIds.empty())
                {
                    TRACE_LOG("[MessagingSlaveImpl].sendMessage - Message source("
                        << source.toString().c_str() << ") has no matching users.");
                    mTargetNotFoundWarnings.increment();
                    return MESSAGING_ERR_TARGET_NOT_FOUND;
                }

                targetUserSessionIdList.insert(targetUserSessionIdList.end(), sourceUserSessionIdList.begin(), sourceUserSessionIdList.end());
            }

            uint32_t validateIdCounter = 0;
            for (TargetIdList::iterator iterBlazeId = targetIds.begin(), iterEnd = targetIds.end(); iterBlazeId != iterEnd; ++iterBlazeId)
            {
                EA::TDF::ObjectId blazeObject;
                blazeObject.type = message.getTargetType();
                blazeObject.id = *iterBlazeId;

                UserSessionIdList userSessionIds;
                rc = gUserSetManager->getSessionIds(blazeObject, userSessionIds);
                if (userSessionIds.empty())
                {
                    TRACE_LOG("[MessagingSlaveImpl].sendMessage - Message target("
                        << blazeObject.toString().c_str() << ") has no matching users, error: "
                        << ErrorHelp::getErrorName(rc));
                    mTargetNotFoundWarnings.increment();
                    continue;
                }
                
                if (rc == Blaze::ERR_OK)
                {
                    targetUserSessionIdList.insert(targetUserSessionIdList.end(), userSessionIds.begin(), userSessionIds.end());
                    ++validateIdCounter;
                }
            }

            if (validateIdCounter == 0)
            {
                return MESSAGING_ERR_TARGET_NOT_FOUND;
            }
        }
                
        MessageId messageId = MESSAGE_ID_INVALID;
        rc = getNextUniqueMessageId(messageId); // get unique message id from unique id manager
        if (rc != ERR_OK)
        {
            ERR_LOG("[MessagingSlaveImpl].sendMessage - Failed to get unique message id, error: " 
                    << ErrorHelp::getErrorName(rc));
            return rc;
        }
        serverMessage.setMessageId(messageId);

        // Send message to all targets and echo to sources
        broadcastMessage(serverMessage, targetUserSessionIdList, sourceUserSessionIdList);
        
        // Populate messageIds if not nullptr
        if (messageIds != nullptr)
        {
            messageIds->push_back(serverMessage.getMessageId());
        }
        mForwardedRegularMessages.increment();
        // submit the message sent event
        if (isGlobalMessage)
        {
            genMessagingSentEvent(serverMessage, true);
        }
        else
        {
            genMessagingSentEvent(serverMessage);
        }
    }

    return rc;             
}

void MessagingSlaveImpl::genMessagingSentEvent(ServerMessage& message, bool isGlobalMessage) const
{
    MessageSent messageSentEvent;

    // global message event
    messageSentEvent.setGlobal(isGlobalMessage);

    // sender id(BlazeId if sender is a user)
    messageSentEvent.setSenderId(message.getSource().id);

    // sender type
    EA::TDF::ObjectType objectType = message.getSource().type;
    messageSentEvent.setSenderType(BlazeRpcComponentDb::getBlazeObjectTypeNameById(objectType));

    // sender name
    const char8_t* senderName = message.getSourceIdent().getName();
    if (senderName[0] != '\0')
        messageSentEvent.setSenderName(senderName);

    // target type
    messageSentEvent.setTargetType(message.getPayload().getTargetType());

    // target id
    messageSentEvent.setTargetIds(message.getPayload().getTargetIds());

    // persistence
    messageSentEvent.setPersistent(message.getPayload().getFlags().getPersistent());

    // recipients list
    TargetIdList::const_iterator itr = message.getPayload().getTargetIds().begin();
    TargetIdList::const_iterator end = message.getPayload().getTargetIds().end();
    for (; itr != end; ++itr)
    {
        EA::TDF::ObjectId targetObjId = EA::TDF::ObjectId(message.getPayload().getTargetType(), *itr);

        BlazeIdList ids;
        BlazeRpcError rc = gUserSetManager->getUserBlazeIds(targetObjId, ids);
        messageSentEvent.getRecipientList().insert(messageSentEvent.getRecipientList().end(), ids.begin(), ids.end());
        if (rc != ERR_OK)
        {
            WARN_LOG(
                "[MessagingSlaveImpl].genMessagingSentEvent - no target(" << targetObjId.toString().c_str() << ") recepient(s) "
                "found for message(" << message.getMessageId() << ")");
        }
    }

    // message attr
    messageSentEvent.setAttrMap(message.getPayload().getAttrMap());

    // timestamp
    messageSentEvent.setTimestamp(message.getTimestamp());

    gEventManager->submitEvent(EVENT_MESSAGESENTEVENT, messageSentEvent);    
}

BlazeRpcError MessagingSlaveImpl::buildInsertQuery(
    const ServerMessage* message,
    QueryPtr& query,
    bool messageOverwrite,
    uint32_t messageLimit,
    uint32_t attrLimit, 
    uint32_t* numQueries,
    uint32_t* insertQueryIndex) const
{
    const ClientMessage& clientMessage = message->getPayload();    
    if (messageLimit > 0)
    {
        if (messageOverwrite)
        {
            enum ExecutedQueries
            {
                QUERY_SELECT_MESSAGE_COUNT,
                QUERY_SET_MINID_NULL,
                QUERY_SET_GET_MINID,
                QUERY_INSERT_OR_UPDATE_MESSAGE,
                QUERY_COUNT
            };
            *numQueries = QUERY_COUNT;
            *insertQueryIndex = QUERY_INSERT_OR_UPDATE_MESSAGE;

            query->append("SELECT @message_count:=count(*) FROM messaging_inbox WHERE "
                "tgt_component=$u AND tgt_type=$u AND tgt_id=$D AND type=$u;\n"
                "SET @minid:=NULL;\n",
                clientMessage.getTargetType().component,
                                clientMessage.getTargetType().type,
                                *(clientMessage.getTargetIds().begin()),
                clientMessage.getType()
                );

           query->append("SELECT @minid:=message_id FROM messaging_inbox WHERE @message_count>=$u "
                "AND tgt_component=$u AND tgt_type=$u AND tgt_id=$D AND type=$u ORDER BY "
                "timestamp ASC, message_id ASC LIMIT 1;\n",
                messageLimit,
                clientMessage.getTargetType().component,
                clientMessage.getTargetType().type,
                *(clientMessage.getTargetIds().begin()),
                clientMessage.getType()
                );

            // NOTE: When @minid is nullptr we perform a standard INSERT
            // without triggering an ON DUPLICATE KEY UPDATE clause.
            query->append(
                "insert into messaging_inbox values\n"
                "(LAST_INSERT_ID(IFNULL(@minid, $D)),", message->getMessageId());
        }
        else
        {
            enum ExecutedQueries
            {
                QUERY_SELECT_MESSAGE_COUNT,
                QUERY_INSERT_MESSAGE_IF_COUNT_OK,
                QUERY_COUNT
            };
            *numQueries = QUERY_COUNT;
            *insertQueryIndex = QUERY_INSERT_MESSAGE_IF_COUNT_OK;
            query->append("select @message_count:=count(*) from messaging_inbox where "
                "tgt_component=$u and tgt_type=$u and tgt_id=$D and type=$u;\n",
                clientMessage.getTargetType().component,
                clientMessage.getTargetType().type,
                *(clientMessage.getTargetIds().begin()),
                clientMessage.getType()
            );
                query->append(
                    "insert into messaging_inbox select\n"
                    "LAST_INSERT_ID($D),", message->getMessageId());
        }
    }
    else
    {
        enum ExecutedQueries
        {
            QUERY_INSERT_MESSAGE_ALWAYS,
            QUERY_COUNT
        };
        *numQueries = QUERY_COUNT;
        *insertQueryIndex = QUERY_INSERT_MESSAGE_ALWAYS;
        query->append(
            "insert into messaging_inbox values\n"
            "(LAST_INSERT_ID($D),", message->getMessageId());
    }
    query->append(
        "$u,$u,$D,$u,$u,$D,$u,$u,$u,$u,$u,",
        message->getSource().type.component,
        message->getSource().type.type,
        message->getSource().id,
        clientMessage.getTargetType().component,
        clientMessage.getTargetType().type,
        *(clientMessage.getTargetIds().begin()),
        clientMessage.getFlags().getBits(),
        clientMessage.getType(),
        clientMessage.getTag(),
        clientMessage.getStatus(),
        message->getTimestamp()
    );
    // add attributes
    for (MessageAttrMap::const_iterator i = clientMessage.getAttrMap().begin(), e = clientMessage.getAttrMap().end(); i != e; ++i)
    {
        query->append("$u,'$s',", (*i).first, (*i).second.c_str());
    }
    for (size_t i = clientMessage.getAttrMap().size(); i < attrLimit; ++i)
    {
        query->append("0,NULL,");
    }
    query->trim(1); // get rid of comma (either way comma will be there because we always have 4 attributes)
    if (messageLimit > 0)
    {
        if (messageOverwrite)
        {
            // NOTE: we use field=VALUES(field) to avoid having
            // to repeat all the values when doing an update.
            query->append(
                ") ON DUPLICATE KEY UPDATE "
                "message_id=LAST_INSERT_ID(message_id)," // Re-seeding LAST_INSERT_ID only needed for MYSQL < 5.1.12
                "src_component=VALUES(src_component),"
                "src_type=VALUES(src_type),"
                "src_id=VALUES(src_id),"
                "tgt_component=VALUES(tgt_component),"
                "tgt_type=VALUES(tgt_type),"
                "tgt_id=VALUES(tgt_id),"
                "flags=VALUES(flags),"
                "type=VALUES(type),"
                "tag=VALUES(tag),"
                "status=VALUES(status),"
                "timestamp=VALUES(timestamp),");
            for (uint32_t i = 0; i < attrLimit; ++i)
            {
                query->append(
                    "attr_key$u=VALUES(attr_key$u),"
                    "attr_str$u=VALUES(attr_str$u),",
                    i, i, i, i);
            }
            query->trim(1); // get rid of comma (either way comma will be there because we always have 4 attributes)
        }
        else
        {
            // NOTE: We use the empty 'DUAL' table to avoid doing round trips, sweet optimization
            query->append(" from dual where @message_count < $u ", messageLimit);
        }
    }
    else
    {
        query->append(") ");
    }
    query->append(";");

    return Blaze::ERR_OK;
}

Blaze::BlazeRpcError MessagingSlaveImpl::writeMessageToDb(
    uint32_t dbId, ServerMessage* message, bool messageOverwrite, uint32_t messageLimit, uint32_t attrLimit) const
{
    BlazeRpcError rc;
    DbConnPtr dbConn = gDbScheduler->getConnPtr(dbId, LOGGING_CATEGORY);
    if (dbConn != nullptr)
    {
        QueryPtr query = DB_NEW_QUERY_PTR(dbConn);
        if (query != nullptr)
        {
            BlazeRpcError dbRc;
            uint32_t expectedNumQueries = 0;
            uint32_t insertQueryIndex = 0;
            // for now buildInsertQuery always returns Blaze::ERR_OK,
            // also sets outparams expectedNumQueries and insertQueryIndex...
            buildInsertQuery(message, query, messageOverwrite, messageLimit, attrLimit, &expectedNumQueries, &insertQueryIndex);
            dbRc = dbConn->startTxn();
            if (dbRc == DB_ERR_OK)
            {
                DbResultPtrs dbResults;
                dbRc = dbConn->executeMultiQuery(query, dbResults);
                if (dbRc == DB_ERR_OK)
                {
                    dbRc = dbConn->commit();
                    if (dbRc == DB_ERR_OK)
                    {
                        const uint32_t numQueries = static_cast<uint32_t>(dbResults.size());
                        if (numQueries == expectedNumQueries)
                        {
                            DbResultPtr& dbResult = dbResults.at(insertQueryIndex);
                            const uint32_t affected = dbResult->getAffectedRowCount();
                            // NOTE: MYSQL sets affected to 2 when ON DUPLICATE KEY UPDATE is invoked,
                            // dbResult->getLastInsertId() will still return the ID of the updated row.
                            if (affected == 1 || affected == 2)
                            {
                                if (dbResult->getLastInsertId() != MESSAGE_ID_INVALID)
                                {                                   
                                    message->setMessageId(static_cast<MessageId>(dbResult->getLastInsertId())); 
                                    TRACE_LOG("[MessagingSlaveImpl].writeMessageToDb: New Message ID(" << message->getMessageId() << ").");
                                    rc = Blaze::ERR_OK;
                                }
                                else
                                {
                                    ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Query failed to generate new Message ID (err=" << getDbErrorString(dbRc) << ")");
                                    rc = Blaze::MESSAGING_ERR_DATABASE;
                                }
                            }
                            else
                            {
                                TRACE_LOG("[MessagingSlaveImpl].writeMessageToDb: Target message inbox is full, "
                                    "attempted(" << affected << ").");
                                rc = Blaze::MESSAGING_ERR_TARGET_INBOX_FULL;
                            }                            
                        }
                        else
                        {
                            ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Number of results(" << numQueries << ") "
                                "does not match number of queries(" << expectedNumQueries << ").");
                            rc = Blaze::MESSAGING_ERR_DATABASE;
                        }
                    }
                    else
                    {
                        ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Commit failed.");
                        rc = Blaze::MESSAGING_ERR_DATABASE;
                    }
                }
                else
                {
                    ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Unable write persistent message to database.");
                    dbRc = dbConn->rollback(); // roll back changes
                    rc = Blaze::MESSAGING_ERR_DATABASE;
                }
            }
            else
            {
                ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Unable to start transaction.");
                rc = Blaze::MESSAGING_ERR_DATABASE;
            }
        }
        else
        {
            ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Unable to create a new query.");
            rc = Blaze::MESSAGING_ERR_DATABASE;
        }
    }
    else
    {
        ERR_LOG("[MessagingSlaveImpl].writeMessageToDb: Unable obtain database connection.");
        rc = Blaze::MESSAGING_ERR_DATABASE;    
    }
    return rc;
}

Blaze::BlazeRpcError MessagingSlaveImpl::fetchMessages(UserSessionId userSessionId, const FetchMessageRequest& request, uint32_t* count, uint32_t seqNo)
{
    ServerMessageList messages;
    BlazeRpcError rc = retrieveMessagesFromDb(userSessionId, request, &messages);
    if (rc == Blaze::ERR_OK)
    {
        for (ServerMessageList::const_iterator i = messages.begin(), e = messages.end(); i != e; ++i)
        {
            sendNotificationToUserSessionById(NOTIFICATION_INFO_NOTIFYMESSAGE, userSessionId, *i, NotificationSendOpts(false, seqNo));
        }

        if (count != nullptr)
            *count = static_cast<uint32_t>(messages.size());
    }

    return rc;
}

Blaze::BlazeRpcError MessagingSlaveImpl::getMessages(UserSessionId userSessionId, const FetchMessageRequest& request, ServerMessageList* messages)
{    
    return retrieveMessagesFromDb(userSessionId, request, messages);
}

Blaze::BlazeRpcError MessagingSlaveImpl::sendGlobalMessage(const EA::TDF::ObjectId &source, SendGlobalMessageRequest& message, MessageIdList* messageIds)
{
    if (gCurrentLocalUserSession)
    {
        TRACE_LOG("[MessagingSlaveImpl].sendGlobalMessage: User [" << gCurrentLocalUserSession->getBlazeId() << " " << gCurrentLocalUserSession->getUserInfo().getPersonaName() << "] try to send global message.");
    }
    else
    {
        TRACE_LOG("[MessagingSlaveImpl].sendGlobalMessage: Trying to send global message without a usersession.");
    }
    
    if (!UserSession::isCurrentContextAuthorized(Blaze::Authorization::PERMISSION_MESSAGING_ALL_ONLINE_USERS))
    {
        if (gCurrentLocalUserSession)
        {
            WARN_LOG("[MessagingSlaveImpl].sendGlobalMessage: User [" << gCurrentLocalUserSession->getBlazeId() << " " << gCurrentLocalUserSession->getUserInfo().getPersonaName() << "] doesn't have permission to send global message.");
        }
        else
        {
            WARN_LOG("[MessagingSlaveImpl].sendGlobalMessage: Super User permission was not set before trying to send global message without a usersession.");
        }

        return ERR_AUTHORIZATION_REQUIRED;
    }

    ClientMessage clientMessage;
    clientMessage.setTargetType(ENTITY_TYPE_USER); // Set target type

    clientMessage.getFlags().setBits(0); // Init message flag

    if (message.getFlags().getLocalize())
    {
        clientMessage.getFlags().setLocalize();
    }

    clientMessage.setType(message.getType()); // Set message type
    clientMessage.setTag(message.getTag()); // Set message tag
    clientMessage.setStatus(message.getStatus()); // Set message status

    // Set message attributes
    if (!message.getAttrMap().empty())
    {
        clientMessage.setAttrMap(message.getAttrMap());
    }

    BlazeRpcError rc = sendMessage(source, clientMessage, messageIds, true); // Start to send message to all online users

    return rc;
}

Blaze::BlazeRpcError MessagingSlaveImpl::retrieveMessagesFromDb(UserSessionId userSessionId, const FetchMessageRequest& request, ServerMessageList* messages)
{
    BlazeRpcError rc = ERR_OK;
    if (!getConfig().getPersistent().getEnabled())
    {
        return MESSAGING_ERR_FEATURE_DISABLED;
    }

    // Default: retrieve messages of current user
    EA::TDF::ObjectId owner(ENTITY_TYPE_USER, gUserSessionManager->getBlazeId(userSessionId));

    // If target is set in the request, check to see if user is authorized to retrieve target's messages
    if (request.getFlags().getMatchTarget())
    {
        // Safety net for user setting target to himself
        if (owner != request.getTarget())
        {
            if (!UserSession::isAuthorized(userSessionId, Blaze::Authorization::PERMISSION_GET_PERSISTENT_MESSAGES_BY_TARGET))
            {
                WARN_LOG("[MessagingSlaveImpl].retrieveMessagesFromDb: "
                    "Attempted to retrieve messages sent to different target: "
                    << request.getTarget().toString().c_str() << ", no permission!");
                return ERR_AUTHORIZATION_REQUIRED;
            }            
            owner = request.getTarget();
        }
    }

    BlazeIdList targetIds;
    if (owner.type == ENTITY_TYPE_USER)
    {
        targetIds.reserve(1);
        targetIds.push_back(owner.id);
    }
    else
    {
        rc = gUserSetManager->getUserBlazeIds(owner, targetIds);
        if (rc != ERR_OK || targetIds.empty())
        {
            TRACE_LOG("[MessagingSlaveImpl].retrieveMessagesFromDb: Message target("
                << owner.type.toString().c_str() << ") has no matching users, error: "
                << ErrorHelp::getErrorName(rc));
            return Blaze::MESSAGING_ERR_MATCH_NOT_FOUND;
        }
    }

    EA::TDF::ObjectType targetType = ENTITY_TYPE_USER;

    // Query the DB
    DbConnPtr dbConn = gDbScheduler->getReadConnPtr(getDbId());
    if (dbConn != nullptr)
    {        
        QueryPtr query = DB_NEW_QUERY_PTR(dbConn);
        if (query != nullptr)
        {
            query->append("select * from messaging_inbox where tgt_component=$u and tgt_type=$u and tgt_id in (",
                targetType.component,
                targetType.type
            );
            BlazeIdList::const_iterator itr = targetIds.begin();
            for (; itr != targetIds.end(); ++itr)
            {
                query->append("$D,", *itr);
            }
            query->trim(1); // remove last comma
            query->append(") ");

            if (request.getFlags().getMatchId())
            {
                query->append("and message_id=$U ", request.getMessageId());
            }
            else
            {
                if (request.getFlags().getMatchSource())
                {
                    query->append("and src_component=$u and src_type=$u and src_id=$D ",
                        request.getSource().type.component,
                        request.getSource().type.type,
                        request.getSource().id
                    );
                }

                if (request.getFlags().getMatchTypes())
                {
                    const MessageTypeList& messageTypeList = request.getTypeList();

                    if (!messageTypeList.empty())
                    {
                        query->append("and type in (");
                        for (MessageTypeList::const_iterator i = messageTypeList.begin(), e = messageTypeList.end(); i != e; ++i)
                        {
                            query->append("$u,",*i);
                        }
                        query->trim(1); // remove last comma
                        query->append(") ");
                    }
                }
                else if (request.getFlags().getMatchType())
                {
                    query->append("and type=$u ", request.getType());
                }
                else if (request.getFlags().getNotMatchTypes())
                {
                    const MessageTypeList& messageTypeList = request.getTypeList();

                    if (!messageTypeList.empty())
                    {
                        query->append("and type not in (");
                        for (MessageTypeList::const_iterator i = messageTypeList.begin(), e = messageTypeList.end(); i != e; ++i)
                        {
                            query->append("$u,",*i);
                        }
                        query->trim(1); // remove last comma
                        query->append(") ");
                    }
                }

                if (request.getFlags().getMatchStatus())
                {
                    query->append("and status&$u=$u ", request.getStatusMask(), request.getStatusMask() & request.getStatus());
                }
            }
            
            switch(request.getOrderBy())
            {
            case ORDER_TIME_ASC:
                query->append("order by timestamp asc ");
                break;
            case ORDER_TIME_DESC:
                query->append("order by timestamp desc ");
                break;
            default:
                break;
            }
            
            // apply limit(if any)
            if (request.getPageSize() > 0)
            {
                const uint32_t messageIndex = request.getPageIndex()*request.getPageSize();
                const uint32_t messageCount = request.getPageSize();
                query->append("limit $u, $u ", messageIndex, messageCount);
            }

            DbResultPtr dbResult;
            BlazeRpcError dbError = dbConn->executeQuery(query, dbResult);
            if (dbError == DB_ERR_OK)
            {
                if (!dbResult->empty())
                {
                    rc = Blaze::ERR_OK;
                    // messaging_inbox db table
                    // columns used by the messaging component
                    enum MessageColumnEnum
                    {
                        MSG_COL_MESSAGE_ID = 0,
                        MSG_COL_SRC_COMPONENT_ID,
                        MSG_COL_SRC_ENTITY_TYPE,
                        MSG_COL_SRC_ENTITY_ID,
                        MSG_COL_TGT_COMPONENT_ID,
                        MSG_COL_TGT_ENTITY_TYPE,
                        MSG_COL_TGT_ENTITY_ID,
                        MSG_COL_FLAGS,
                        MSG_COL_TYPE,
                        MSG_COL_TAG,
                        MSG_COL_STATUS,
                        MSG_COL_TIMESTAMP,
                        MSG_COL_ATTR_KEY0,
                        MSG_COL_ATTR_STR0
                    };

                    messages->reserve(dbResult->size());

                    const uint32_t locale = gUserSessionManager->getSessionLocale(userSessionId);
                    const uint32_t attrLimit = mPersistentMessageAttributeLimit;
                    for (DbResult::const_iterator i = dbResult->begin(), e = dbResult->end(); i != e; ++i)
                    {
                        const DbRow* row = *i;

                        ServerMessage* fetchedMessage = messages->pull_back();

                        // Populate the message object
                        fetchedMessage->setMessageId(row->getUInt64(MSG_COL_MESSAGE_ID));
                        fetchedMessage->setSource(
                            EA::TDF::ObjectId(
                                row->getUShort(MSG_COL_SRC_COMPONENT_ID),
                                row->getUShort(MSG_COL_SRC_ENTITY_TYPE),
                                row->getInt64(MSG_COL_SRC_ENTITY_ID)
                            )
                        );
                        fetchedMessage->getPayload().setTargetType(
                            EA::TDF::ObjectType(
                                row->getUShort(MSG_COL_TGT_COMPONENT_ID),
                                row->getUShort(MSG_COL_TGT_ENTITY_TYPE)
                            )
                        );
                        fetchedMessage->getPayload().getTargetIds().push_back(row->getInt64(MSG_COL_TGT_ENTITY_ID));
                        fetchedMessage->getPayload().getFlags().setBits(row->getUInt(MSG_COL_FLAGS));
                        fetchedMessage->getPayload().setType(row->getUInt(MSG_COL_TYPE));
                        fetchedMessage->getPayload().setTag(row->getUInt(MSG_COL_TAG));
                        fetchedMessage->getPayload().setStatus(row->getUInt(MSG_COL_STATUS));
                        fetchedMessage->setTimestamp(row->getUInt(MSG_COL_TIMESTAMP));
                        fetchedMessage->getFlags().setFetched(); // mark message as explicitly fetched on client's request
                        for (uint32_t j = 0; j < attrLimit; ++j)
                        {
                            const char8_t* str = row->getString(MSG_COL_ATTR_STR0 + 2*j);
                            if (str != nullptr)
                            {
                                const AttrKey key = row->getUInt(MSG_COL_ATTR_KEY0 + 2*j);
                                if (!fetchedMessage->getPayload().getAttrMap().insert(eastl::make_pair(key, str)).second)
                                {
                                    WARN_LOG("[MessagingSlaveImpl].getMessages - Failed to insert attribute: "
                                        "<" << key << ",'" << str << "'> into map");
                                }
                            }
                        }
                        if (fetchedMessage->getPayload().getFlags().getLocalize())
                        {
                            // localize the strings in the message attribute map using the localizer
                            MessageLocalizer localizer(fetchedMessage->getPayload().getAttrMap());
                            // NOTE: Localizer can be safely destroyed after the localization has been performed
                            // because the generated localized strings will be owned by the AttrMap.
                            localizer.localize(locale);
                        }

                        if (!isMessageSourceOmitted(fetchedMessage->getSource()))
                        {
                            rc = fillSourceName(*fetchedMessage);
                            if (rc != Blaze::ERR_OK)
                            {
                                WARN_LOG(
                                    "[MessagingSlaveImpl].retrieveMessagesFromDb - identity system "
                                    "failed to resolve source name for (" << fetchedMessage->getSource().toString().c_str()
                                    << ") reason: " << (ErrorHelp::getErrorName(rc)));
                                // possible session disconnect/timeout error, exit immediately (GOS-6064 fix)
                                break;
                            }
                        }
                    }
                    mFetchedMessages.increment(dbResult->size());
                    if (request.getFlags().getMatchTarget() && owner != request.getTarget())
                    {
                        // log scenario when a user fetches messages that were not sent to him
                        TRACE_LOG("[MessagingSlaveImpl].retrieveMessagesFromDb: Retrieved " 
                            << dbResult->size() << " messages sent to different target: " 
                            << request.getTarget().toString().c_str());
                    }
                }
                else if(request.getFlags().getMatchId())
                {
                    // result set is empty, but we were searching for specific messageIds, so return no match
                    rc = Blaze::MESSAGING_ERR_MATCH_NOT_FOUND;
                }
            }
            else
            {
                // query failed
                ERR_LOG("[MessagingSlaveImpl].retrieveMessagesFromDb: "
                    "Failed to retrieve message (err=" << getDbErrorString(dbError) << ")");
                rc = Blaze::MESSAGING_ERR_DATABASE;
            }
        }
        else
        {
            // failed to create query
            ERR_LOG("[MessagingSlaveImpl].retrieveMessagesFromDb: Failed to create query");
            rc = Blaze::MESSAGING_ERR_DATABASE;
        }
    }
    else
    {
        // failed to obtain connection
        ERR_LOG("[MessagingSlaveImpl].retrieveMessagesFromDb: Failed to obtain connection");
        rc = Blaze::MESSAGING_ERR_DATABASE;
    }

    return rc;
}

void MessagingSlaveImpl::onScheduledTask(const EA::TDF::Tdf* tdf, TaskId taskId, const char8_t* taskName) 
{
    if (blaze_strcmp(taskName, MESSAGING_SWEEP_TASK_NAME) == 0)
        mSweepTaskId = taskId; 
} 


Blaze::BlazeRpcError MessagingSlaveImpl::purgeMessages(UserSessionId userSessionId, const PurgeMessageRequest& request, uint32_t* count)
{
    BlazeRpcError rc = ERR_OK;
    if (!getConfig().getPersistent().getEnabled())
    {
        return MESSAGING_ERR_FEATURE_DISABLED;       
    }

    // Query the DB
    DbConnPtr dbConn = gDbScheduler->getConnPtr(getDbId());
    if (dbConn != nullptr)
    {
        const EA::TDF::ObjectId owner(ENTITY_TYPE_USER, gUserSessionManager->getBlazeId(userSessionId));
        QueryPtr query = DB_NEW_QUERY_PTR(dbConn);
        if (query != nullptr)
        {
            query->append("delete from messaging_inbox where tgt_component=$u and tgt_type=$u and tgt_id=$D ",
                owner.type.component, 
                owner.type.type, 
                owner.id
            );
            if (request.getFlags().getMatchId())
            {
                query->append("and message_id=$U ", request.getMessageId());
            }
            else
            {
                if (request.getFlags().getMatchSource())
                {
                    query->append("and src_component=$u and src_type=$u and src_id=$D ", 
                        request.getSource().type.component, 
                        request.getSource().type.type, 
                        request.getSource().id
                    );
                }
                if (request.getFlags().getMatchType())
                {
                    query->append("and type=$u ", request.getType());
                }
                if (request.getFlags().getMatchStatus())
                {
                    query->append("and status&$u=$u ", request.getStatusMask(), request.getStatusMask() & request.getStatus());
                }
            }

            DbResultPtr dbResult;
            BlazeRpcError dbError = dbConn->executeQuery(query, dbResult);
            if (dbError == DB_ERR_OK)
            {
                const uint32_t affected = dbResult->getAffectedRowCount();
                TRACE_LOG("[MessagingSlaveImpl].purgeMessages: Messages purged(" << affected << ")");
                if (affected > 0)
                {
                    *count = affected;
                    mPurgedMessages.increment(affected);
                    rc = Blaze::ERR_OK;
                }
                else if(request.getFlags().getMatchId())
                {
                    // result set is empty, but we were searching for specific messageIds, so return no match
                    rc = Blaze::MESSAGING_ERR_MATCH_NOT_FOUND;
                }
            }
            else
            {
                // query failed
                ERR_LOG("[MessagingSlaveImpl].purgeMessages: Failed to purge messages from message inbox (err=" 
                        << getDbErrorString(dbError) << ")");
                rc = Blaze::MESSAGING_ERR_DATABASE;
            }
        }
        else
        {
            // failed to create query
            ERR_LOG("[MessagingSlaveImpl].purgeMessages: Failed to create query");
            rc = Blaze::MESSAGING_ERR_DATABASE;
        }
    }
    else
    {
        // failed to obtain connection
        ERR_LOG("[MessagingSlaveImpl].purgeMessages: Failed to obtain connection");
        rc = Blaze::MESSAGING_ERR_DATABASE;
    }
    return rc;
}

Blaze::BlazeRpcError MessagingSlaveImpl::touchMessages(UserSessionId userSessionId, const TouchMessageRequest& request, uint32_t* count)
{
    BlazeRpcError rc;
    if (!getConfig().getPersistent().getEnabled())
    {
        return MESSAGING_ERR_FEATURE_DISABLED;       
    }
    if (request.getFlags().getMatchSource() && request.getFlags().getMatchTarget())
    {
        WARN_LOG("[FetchMessagesCommand].touchMessages - Messages cannot be touched by specifying both source and target.");
        return MESSAGING_ERR_INVALID_PARAM;
    }

    // Query the DB
    DbConnPtr dbConn = gDbScheduler->getConnPtr(getDbId());
    if (dbConn != nullptr)
    {
        QueryPtr query = DB_NEW_QUERY_PTR(dbConn);
        if (query != nullptr)
        {
            const EA::TDF::ObjectId user(ENTITY_TYPE_USER, gUserSessionManager->getBlazeId(userSessionId));
            query->append("update messaging_inbox set status=(status&$u)|$u where ",
                ~(request.getTouchStatusMask()), // negate the mask to pull in status bits unaffected by it
                request.getTouchStatusMask() & request.getTouchStatus()
            );
            if (request.getFlags().getMatchId())
            {
                // if id specified, then we can only touch message if we are
                // the sender OR the recepient!
                query->append(
                    "((tgt_component=$u and tgt_type=$u and tgt_id=$D) ",
                    user.type.component, 
                    user.type.type, 
                    user.id
                );
                query->append(
                    "or (src_component=$u and src_type=$u and src_id=$D)) ",
                    user.type.component,
                    user.type.type,
                    user.id
                );
                query->append("and message_id=$U ", request.getMessageId());
            }
            else
            {
                if (request.getFlags().getMatchSource())
                {
                    query->append(
                        "tgt_component=$u and tgt_type=$u and tgt_id=$D ",
                        user.type.component, 
                        user.type.type, 
                        user.id
                    );
                    query->append("and src_component=$u and src_type=$u and src_id=$D ", 
                        request.getSource().type.component, 
                        request.getSource().type.type, 
                        request.getSource().id
                    );
                }
                else if (request.getFlags().getMatchTarget())
                {
                    query->append(
                        "tgt_component=$u and tgt_type=$u and tgt_id=$D ",
                        request.getTarget().type.component, 
                        request.getTarget().type.type, 
                        request.getTarget().id
                    );
                    query->append("and src_component=$u and src_type=$u and src_id=$D ", 
                        user.type.component, 
                        user.type.type, 
                        user.id
                    );
                }
                else
                {
                    query->append(
                        "tgt_component=$u and tgt_type=$u and tgt_id=$D ",
                        user.type.component, 
                        user.type.type, 
                        user.id
                    );
                }
                if (request.getFlags().getMatchType())
                {
                    query->append("and type=$u ", request.getType());
                }
                if (request.getFlags().getMatchStatus())
                {
                    query->append("and (status&$u)=$u ",
                        request.getStatusMask(),
                        request.getStatusMask() & request.getStatus()
                    );
                }
            }
            DbResultPtr dbResult;
            BlazeRpcError dbError = dbConn->executeQuery(query, dbResult);
            if (dbError == DB_ERR_OK)
            {
                const uint32_t affected = dbResult->getAffectedRowCount();
                TRACE_LOG("[MessagingSlaveImpl].touchMessages: Messages touched(" << affected << ")");
                *count = affected;
                mTouchedMessages.increment(affected);
                rc = Blaze::ERR_OK;
            }
            else
            {
                // query failed
                ERR_LOG("[MessagingSlaveImpl].touchMessages: Failed to update message inbox (err=" << getDbErrorString(dbError) << ")");
                rc = Blaze::MESSAGING_ERR_DATABASE;
            }
        }
        else
        {
            // failed to create query
            ERR_LOG("[MessagingSlaveImpl].touchMessages: Failed to create query");
            rc = Blaze::MESSAGING_ERR_DATABASE;
        }
    }
    else
    {
        // failed to obtain connection
        ERR_LOG("[MessagingSlaveImpl].touchMessages: Failed to obtain connection");
        rc = Blaze::MESSAGING_ERR_DATABASE;
    }
    return rc;
}

bool MessagingSlaveImpl::setAttrParam(ClientMessage& message, AttrKey attrKey, uint32_t paramIndex, const char8_t* param)
{
    if (paramIndex < PARAM_COUNT_LIMIT)
    {
        message.getAttrMap().insert(eastl::make_pair(PARAM_ATTR_MIN + attrKey*PARAM_COUNT_LIMIT + paramIndex, param));
        return true;
    }
    return false;
}

const char8_t* MessagingSlaveImpl::getAttrParam(const ClientMessage& message, AttrKey attrKey, uint32_t paramIndex)
{
    if (paramIndex < PARAM_COUNT_LIMIT)
    {
        MessageAttrMap::const_iterator it = message.getAttrMap().find(PARAM_ATTR_MIN + attrKey*PARAM_COUNT_LIMIT + paramIndex);
        if (it != message.getAttrMap().end())
        {
            return it->second.c_str();
        }
    }
    return nullptr;
}

void MessagingSlaveImpl::scheduleSweep()
{
    const PersistentData& persistent = getConfig().getPersistent();
    if (persistent.getEnabled())
    {
        if (persistent.getMessageSweepInterval() != 0LL)
        {
            if (mSweepTaskId == INVALID_TASK_ID)
            {
                TaskSchedulerSlaveImpl *sched = static_cast<TaskSchedulerSlaveImpl*>
                    (gController->getComponent(TaskSchedulerSlave::COMPONENT_ID, true, true, nullptr));
                if (sched != nullptr)
                {
                    sched->createTask(MESSAGING_SWEEP_TASK_NAME, COMPONENT_ID, nullptr, 
                        static_cast<uint32_t>(TimeValue::getTimeOfDay().getSec()), 0, 
                        static_cast<uint32_t>(persistent.getMessageSweepInterval().getSec()));
                }
            }
        }
    }
}

void MessagingSlaveImpl::cancelSweep()
{
    if (mSweepTaskId != INVALID_TASK_ID)
    {
        TaskSchedulerSlaveImpl *sched = static_cast<TaskSchedulerSlaveImpl*>
            (gController->getComponent(TaskSchedulerSlave::COMPONENT_ID, true, true, nullptr));
        if (sched != nullptr)
        {
            sched->cancelTask(mSweepTaskId);
        }
    }
}

void MessagingSlaveImpl::doSweep()
{
    INFO_LOG("[MessagingSlaveImpl].dbSweep: Sweeping...");

    DbConnPtr dbConn = gDbScheduler->getConnPtr(getDbId());
    mMessageDbSweeps.increment();
    if (dbConn != nullptr)
    {
        QueryPtr query = DB_NEW_QUERY_PTR(dbConn);
        if (query != nullptr)
        {
            const TimeValue cutoffTime
                (TimeValue::getTimeOfDay() - getConfig().getPersistent().getMessageExpiryInterval());
            // delete messages that occur earlier than mMessageExpiryInterval before 'now'
            // NOTE: Corresponding message_inbox rows will be deleted by a trigger
            query->append("delete from messaging_inbox where timestamp < $u", 
                static_cast<uint32_t>(cutoffTime.getSec()));

            if (!mSkipSweepTypeList.empty())
            {
                query->append(" and type not in (");
                for (MessageTypeList::const_iterator i = mSkipSweepTypeList.begin(), e = mSkipSweepTypeList.end(); i != e; ++i)
                {
                    query->append("$u,",*i);
                }
                query->trim(1); // remove last comma
                query->append(") ");
            }

            DbResultPtr dbResult;
            BlazeRpcError dbError = dbConn->executeQuery(query, dbResult);
            if (dbError == DB_ERR_OK)
            {
                const uint32_t affected = dbResult->getAffectedRowCount();
                if (affected > 0)
                {
                    TRACE_LOG("[MessagingSlaveImpl].dbSweep: Sweep cleaned " << affected << " expired messages.");
                    mSweptStaleMessages.increment(affected);
                }
                else
                {
                    TRACE_LOG("[MessagingSlaveImpl].dbSweep: Sweep found no expired messages.");
                    mEmptyMessageDbSweeps.increment();
                }
            }
            else
            {
                // query failed
                WARN_LOG("[MessagingSlaveImpl].dbSweep: Failed to sweep expired messages (err=" << getDbErrorString(dbError) << ")");
                mFailedMessageDbSweeps.increment();
            }
        }
        else
        {
            // failed to create query
            WARN_LOG("[MessagingSlaveImpl].dbSweep: Failed to create query");
            mFailedMessageDbSweeps.increment();
        }
    }
    else
    {
        // failed to obtain connection
        WARN_LOG("[MessagingSlaveImpl].dbSweep: Failed to obtain connection");
        mFailedMessageDbSweeps.increment();
    }
}

} // Messaging
} // Blaze
