// Configuration file for the stress tester
//
// Define the connection and protocol parameters
connection-info = {
    protocol = fire2
    encoder = heat2
    decoder = heat2

    // Total number of connections to use
    num-connections = #NUM_CONNECTIONS#

    // Control whether SSL is used or not
    secure = true
}

//
//This following block controls how instances are started up.
//
startup = {
    //Number of instances to start up in a given pass
    //A block size of 0 will start all instances simultaneously
    
    // parser does not allow expressions in variable value 
    #define SERVER_NUCLEUS_POOL_SIZE_TIMES_INT #SERVER_NUCLEUS_POOL_SIZE# * 4
    block-size = #SERVER_NUCLEUS_POOL_SIZE_TIMES_INT#

    //Delay between starting instances in milliseconds
    instance-delay = #CONN_INSTANCE_DELAY#

    //Delay between starting blocks in milliseconds
    // parser does not allow expressions in variable value 
    #define SERVER_NUCLEUS_POOL_SIZE_INT #SERVER_NUCLEUS_POOL_SIZE# * 4 * #CONN_INSTANCE_DELAY#
    block-delay = #SERVER_NUCLEUS_POOL_SIZE_INT#
}

// 
// Define the account/authentication parameters used for account creation and authentication
// 
account = {
    // Specify the starting integer value to use when generating email addresses.  This value
    // should be adjusted when multiple stress tester instances are running in parallel against the
    // same blaze server to avoid overlap of account names.  For example, if each stress tester
    // instance was configurated for 1000 connections, then the first config file would set this
    // to 0 and the second instance would set this to 1000.
    start-index = #START_INDEX#

    // Define the email address and persona pattern used for stressLogin
    email-format = "blaze-stress%05x@ea.com"
    persona-format = "s%05x"
    
    platformToServiceNameMap = {
        "common"    = "#SERVICE_NAME_PREFIX#-common"
        "pc"        = "#SERVICE_NAME_PREFIX#-pc"
        "ps4"       = "#SERVICE_NAME_PREFIX#-ps4"
        "xone"      = "#SERVICE_NAME_PREFIX#-xone"
        "nx"        = "#SERVICE_NAME_PREFIX#-nx"
        "ios"       = "#SERVICE_NAME_PREFIX#-ios"
        "android"   = "#SERVICE_NAME_PREFIX#-android"
    }
}

// 
// Define the list of stress modules that will be instantiated
// 
modules = [ matchmaker ]

// 
// Define how the available instances/connections are distributed amongst the different modules
// 
distribution = {
    matchmaker = 1.0
}

//
// define the distribution of platform types for available instances/connections
//
#if PLATFORM == "common"
platform-distribution = {
    pc = 1.0
}
#endif

#define MM_CLUB_BASE_FACTOR 30
#define MM_CLUB_BASE_RATE 1000
#define MM_CLUB_DELAY MM_CLUB_BASE_RATE*MM_CLUB_BASE_FACTOR
#define MM_CLUB_GM_LIFESPAN 1800*MM_CLUB_BASE_RATE
#define MM_CLUB_GM_LIFECPAN_CYCLES MM_CLUB_GM_LIFESPAN/MM_CLUB_DELAY

// 
// Configuration data specific to the dummy module
// 
matchmaker = {
    useScenarios = false

    // Define the number of milliseconds between RPC calls
    delay= #MM_CLUB_DELAY#
    login = true
    logout = false
    opt_in_chance = 100
    delay_per_trial = 0
    num_execs_per_trial = 1000


    // define the delay before starting matchmaking
    matchmakerDelay= #MM_CLUB_BASE_RATE#
    legacyReports = false
    // legacyGameTypeId = 9 // club type
    
    // the chance that a user will log out during execute
    logoutChance = 0
    
    // Define which action to execute
    // action = noop
    action = findOrCreateGameSession

    // matchmaking session timeout in MS. For Dawngate players may wait up to 20 minutes on occassion.
    matchmakingTimeout = 1200000
    // game state durations in MS
    initStateDurationMs = 1000
    preGameStateDurationMs = 5000
    inGameStateDurationMs = #MM_CLUB_GM_LIFESPAN#
    inGameStateDeviationMs = 1000
    
    minPlayersForInGameTransition = 10 // minimum number of players before host transitions to IN_GAME

    // game protocol version rule
    // disabling game protocol version rule is part of the game manager configuration
    useRandomizedGameProtocolVersionString = false
    // if false, use this game protocol version string for matchmaking
    gameProtocolVersionString = DAWNGATE_1.00
    //todo: switch to CLIENT_SERVER_DEDICATED once that is working
    gameNetworkTopology = CLIENT_SERVER_PEER_HOSTED

    //
    // Teams based matchmaking configuration
    //

    joiningTeamIdPossibleValues = [ANY_TEAM_ID]    
    requestedTeamIdPossibleValues = [ANY_TEAM_ID]
    teamCount = 2

    // Game size rule type to use new slot based rules
    sizeRule = TEAM_SIZE_AND_PLAYER_SLOT_RULES

    // team composition rule
    // possible values
    // teamCompositionRuleName: competitiveMode (5v5)
    // requireExactMatch = [0:EXACT_MATCH_REQUIRED]
    // veryQuickMatch = [0:EXACT_MATCH_REQUIRED, 3:0.0]
    // quickMatch = [0:EXACT_MATCH_REQUIRED, 5:.8, 10:.7, 30:.6]
    // matchAny = [0:0]
    // decayLimited = [0:EXACT_MATCH_REQUIRED, 120:.6]
    //teamCompositionRuleName = "competitiveMode"
    //teamCompositionRuleMinFitListName = "decayLimited"

    // team ued balance rule
    // possible values
    // teamUEDBalanceRuleName: teamSkillSumBalanceRule, or teamSkillAvgBalanceRule
    // veryQuickMatch = [0:offset=100, 2:offset=500, 3:offset=INF]
    // quickDecay = [0:offset=100, 5:offset=200, 10:offset=700]
    // noDecay = [0:offset=100]
    // matchAny = [0:offset=INF]
    // Dawngate's decayPlus0 = [0:offset=20, 120:offset=40, 240:offset=60, 360:offset=80, 480:offset=100, 600:offset=150, 780:offset=200, 960:offset=250, 1200:offset=300]
    teamUEDBalanceRuleName = "teamSkillAvgBalanceRule"
    teamUEDBalanceRuleRangeListName = "decayPlus0"

    // team ued position parity rule
    // possible values
    // teamUEDPositionParityRuleName: topAndBottomPlayersRule
    // quickDecay = [0:offset=50, 10:offset=100, 120:offset=200, 240:offset=INF]
    // noDecay = [0:offset=100]
    teamUEDPositionParityRuleName = "topAndBottomPlayersRule"
    teamUEDPositionParityRuleRangeListName = "quickDecay"

    // UED values for each user, used in TeamUEDBalanceRule tests
    // Values map to UED specified  in usersessions.cfg
    clientUED = [
        // 'teamSkill'
        {
            clientUEDKey = 1, 
            clientUEDMinValue = 0,
            clientUEDMaxValue = 1800,
            // for more realistic skill distribution
            clientUEDEliteLevelMin = 1500,
            clientUEDEliteLevelChance = 10,
            clientUEDAdvancedLevelMin = 1100,
            clientUEDAdvancedLevelChance = 80
        }
    ]

    // team min size rule (disabled and unneeded for titles using TeamCompositionRule. Needed if testing TeamUEDBalanceRule alone.)
    // Note this rule would typically not be used if team compostion rule is used in client request.
    //teamMinSizeRangeListName = "requireExactMatch"
    //minTeamSize = 5

    // team balance rule
    // Note this rule would typically not be used if team compostion rule is used in client request.
    //teamBalanceRangeListName = "testDecay"
    //maxTeamSizeDifference = 0

    //
    // Other matchmaking configuration
    //

    // total player slots rule (disabled and unneeded for titles using TeamCompositionRule. Needed if testing TeamUEDBalanceRule alone.)
    //totalPlayerSlotsRuleRangeList = OSDK_matchExact
    //minTotalPlayerSlotsLowerBound = 10
    //minTotalPlayerSlotsSeed = 0
    //maxTotalPlayerSlotsLowerBound = 10
    //maxTotalPlayerSlotsSeed = 0
    //sDesiredTotalPlayerSlotsPercent = 100
    
    // player count rule (disabled and unneeded for titles using TeamCompositionRule)
    //playerCountRuleRangeList = ILT_4v4_matchRelax
    //minValuePlayerCountRuleLowerBound = 5 // for 4v4, we only want to match a game that will have 4 players + someone else
    //minValuePlayerCountRuleSeed = 1
    //maxValuePlayerCountRuleLowerBound = 10
    //maxValuePlayerCountRuleSeed = 0
    // this is the percentage of the difference between min & max player count to use as the desired player count
    //desiredValuePlayerCountRulePercent = 100
    
    // ranked game rule
    // possible values
    // OSDK_matchExact = [0:1.0]
    // OSDK_matchAny = [0:0.0]
    //rankedGameFitThresholdName = OSDK_matchExact
    //unrankedFrequency = 0
    //rankedFrequency = 100
    //randomFrequency = 0
    //abstainFrequency = 0
    
    // skill rule. For Dawngate may be used to clamp overall skill ranges, outside of team based rules.
    //skillRuleName = dawngate_skill_Rule
    //skillRuleFitThresholdName = decayPlus0
    //userSkillValueOverrride = false
    //minimumSkill = 1
    //maximumSkill = 99

    // dnf rule
    // the maximum acceptable DNF value
    maxDNFValue = 101

    // host balancing rule
    // comment out threshold name to disable rule
    // possible values
    // matchAny = [ 0:HOSTS_UNBALANCED ]
    hostBalancingFitThresholdName = matchAny
    
    // host viability rule
    // comment out threshold name to disable rule
    // possible values
    // OSDK_connAssured = [0:CONNECTION_ASSURED]
    // OSDK_connLikely = [0:CONNECTION_LIKELY]
    // OSDK_connUnlikely = [0:CONNECTION_UNLIKELY]
    hostViabilityFitThresholdName = OSDK_connUnlikely
    
    // expanded ping site rule
    // comment out range offset list name to disable rule
    // possible values
    // OSDK_matchExact    = [{ t=0, offset=["EXACT_MATCH_REQUIRED"] }]
    // OSDK_matchAny      = [{ t=0, offset=["INF"]}]
    // OSDK_matchRelax    = [{ t=0, offset=[100]}, { t=5, offset=[200]}]
    // pingSiteRangeOffsetListName = quickMatch

    //
    // Game Manager utility configuration
    //
    
    // percent chance of a settings update on the ame
    gmGameSettingsRandomUpdates = 0.1
    // Number of cycles a game should last
    gmGameLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#
    // Number of cycles a player should last
    gmGamePlayerLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#
    // Max number of players for a game (random number from min to this)
    gmGamePlayerSeed = 10
    // Minimum number of player in a game.
    gmGamePlayerLowerLimit = 10
    
    // game groups configuration
    // chance a stress instance will be a gg leader
    ggLeaderFreq = 25
    // chance a stress instance will be a gg follower
    ggJoinerFreq = 75
    // Control the fraction of instances that create game groups for the test.  The remaining fraction execute the test action RPCs
    ggGamegroupsFreq = 0.00909
    ggCapacity = 5
    // Control the how long the group remains alive - a scalar to delay (so time = grouptimescalar * delay) 
    ggLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#
    ggMemberLifespan = #MM_CLUB_GM_LIFECPAN_CYCLES#


    //
    // Game Reporting utility configuration
    //
    
    // the game types to use to send reports
    // NOTE: currently we only have a single H2H report creator registered for gameType0 with the CustomGameReporterFactory,
    // before adding more report types here you'll need to register more report creators/handlers
    //onlineReportGameTypes = [ 
    //    { typeName = "gameType0",  weight = 100 }
    //]

    // NOTE: currently we only have a single Solo report creator registered for gameType7 with the CustomGameReporterFactory,
    // before adding more report types here you'll need to register more report creators/handlers
    //offlineReportGameTypes = [ 
    //    { typeName = "gameType7", weight = 100 }
    //]

    //grSubmitReports = true
}

